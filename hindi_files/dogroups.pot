msgid ""
msgstr ""
"Project-Id-Version: dogroups 0.0\n"
"POT-Creation-Date: 2024-10-10 22:46+0100\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: dogroups.c:85
msgid "env is not an environment"
msgstr ""

#: dogroups.c:132
msgid "row.names attribute of .SD not found"
msgstr ""

#: dogroups.c:134
#, c-format
msgid ""
"row.names of .SD isn't integer length 2 with NA as first item; i.e., ."
"set_row_names(). [%s %d %d]"
msgstr ""

#: dogroups.c:165
#, c-format
msgid "length(iSD)[%d] != length(jiscols)[%d]"
msgstr ""

#: dogroups.c:166
#, c-format
msgid "length(xSD)[%d] != length(xjiscols)[%d]"
msgstr ""

#: dogroups.c:277
#, c-format
msgid "j evaluates to type '%s'. Must evaluate to atomic vector or list."
msgstr ""

#: dogroups.c:286
#, c-format
msgid ""
"Entry %d for group %d in j=list(...) should be atomic vector or list. If you "
"are trying something like j=list(.SD,newcol=mean(colA)) then use := by group "
"instead (much quicker), or cbind or merge afterwards."
msgstr ""

#: dogroups.c:293
#, c-format
msgid ""
"Entry %d for group %d in j=list(...) is an array with %d dimensions > 1, "
"which is disallowed. \"Break\" the array yourself with c() or as.vector() if "
"that is intentional."
msgstr ""

#: dogroups.c:303
msgid ""
"RHS of := is NULL during grouped assignment, but it's not possible to delete "
"parts of a column."
msgstr ""

#: dogroups.c:307
#, c-format
msgid ""
"Supplied %d items to be assigned to group %d of size %d in column '%s'. The "
"RHS length must either be 1 (single values are ok) or match the LHS length "
"exactly. If you wish to 'recycle' the RHS please use rep() explicitly to "
"make this intent clear to readers of your code."
msgstr ""

#: dogroups.c:339
#, c-format
msgid "Group %d column '%s': %s"
msgstr ""

#: dogroups.c:346
msgid "j doesn't evaluate to the same number of columns for each group"
msgstr ""

#: dogroups.c:380
#, c-format
msgid ""
"Column %d of j's result for the first group is NULL. We rely on the column "
"types of the first result to decide the type expected for the remaining "
"groups (and require consistency). NULL columns are acceptable for later "
"groups (and those are replaced with NA of appropriate type and recycled) but "
"not for the first. Please use a typed empty vector instead, such as "
"integer() or numeric()."
msgstr ""

#: dogroups.c:383
msgid ""
"j appears to be a named vector. The same names will likely be created over "
"and over again for each group and slow things down. Try and pass a named "
"list (which data.table optimizes) or an unnamed list() instead.\n"
msgstr ""

#: dogroups.c:385
#, c-format
msgid ""
"Column %d of j is a named vector (each item down the rows is named, "
"somehow). Please remove those names for efficiency (to save creating them "
"over and over for each group). They are ignored anyway.\n"
msgstr ""

#: dogroups.c:393
msgid ""
"The result of j is a named list. It's very inefficient to create the same "
"names over and over again for each group. When j=list(...), any names are "
"detected, removed and put back after grouping has completed, for efficiency. "
"Using j=transform(), for example, prevents that speedup (consider changing "
"to :=). This message may be upgraded to warning in future.\n"
msgstr ""

#: dogroups.c:405
#, c-format
msgid "dogroups: growing from %d to %d rows\n"
msgstr ""

#: dogroups.c:425
#, c-format
msgid ""
"Item %d of j's result for group %d is zero length. This will be filled with "
"%d NAs to match the longest column in this result. Later groups may have a "
"similar problem but only the first is reported to save filling the warning "
"buffer."
msgstr ""

#: dogroups.c:432
#, c-format
msgid ""
"Column %d of result for group %d is type '%s' but expecting type '%s'. "
"Column types must be consistent for each group."
msgstr ""

#: dogroups.c:434
#, c-format
msgid ""
"Supplied %d items for column %d of group %d which has %d rows. The RHS "
"length must either be 1 (single values are ok) or match the LHS length "
"exactly. If you wish to 'recycle' the RHS please use rep() explicitly to "
"make this intent clear to readers of your code."
msgstr ""

#: dogroups.c:452
msgid "\n"
msgstr ""

#: dogroups.c:453 dogroups.c:467
#, c-format
msgid ""
"\rProcessed %d groups out of %d. %.0f%% done. Time elapsed: %ds. ETA: %ds."
msgstr ""

#: dogroups.c:472
#, c-format
msgid "Wrote less rows (%d) than allocated (%d).\n"
msgstr ""

#: dogroups.c:496
#, c-format
msgid ""
"\n"
"  collecting discontiguous groups took %.3fs for %d groups\n"
msgstr ""

#: dogroups.c:497
#, c-format
msgid ""
"\n"
"  memcpy contiguous groups took %.3fs for %d groups\n"
msgstr ""

#: dogroups.c:499
#, c-format
msgid "  eval(j) took %.3fs for %d calls\n"
msgstr ""

#: dogroups.c:528
msgid "growVector passed NULL"
msgstr ""
