
R version 4.3.3 (2024-02-29) -- "Angel Food Cake"
Copyright (C) 2024 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

  Natural language support but running in an English locale

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> pkgname <- "data.table"
> source(file.path(R.home("share"), "R", "examples-header.R"))
> options(warn = 1)
> library('data.table')
> 
> base::assign(".oldSearch", base::search(), pos = 'CheckExEnv')
> base::assign(".old_wd", base::getwd(), pos = 'CheckExEnv')
> cleanEx()
> nameEx("IDateTime")
> ### * IDateTime
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: IDateTime
> ### Title: Integer based date class
> ### Aliases: IDate as.IDate ITime as.ITime IDateTime as.character.ITime
> ###   as.Date.IDate as.IDate.Date as.IDate.default as.ITime.character
> ###   as.ITime.default as.ITime.POSIXlt as.ITime.times as.list.IDate
> ###   as.POSIXct.IDate as.POSIXct.ITime as.POSIXlt.ITime c.IDate c.ITime
> ###   format.ITime IDateTime.default mean.IDate mean.ITime print.ITime
> ###   rep.IDate rep.ITime round.IDate round.ITime trunc.ITime seq.IDate
> ###   seq.ITime second minute hour yday wday mday week isoweek month
> ###   quarter year yearmon yearqtr IDate-class ITime-class
> ### Keywords: utilities
> 
> ### ** Examples
> 
> 
> # create IDate:
> (d <- as.IDate("2001-01-01"))
[1] "2001-01-01"
> 
> # S4 coercion also works
> identical(as.IDate("2001-01-01"), methods::as("2001-01-01", "IDate"))
[1] TRUE
> 
> # create ITime:
> (t <- as.ITime("10:45"))
[1] "10:45:00"
> 
> # S4 coercion also works
> identical(as.ITime("10:45"), methods::as("10:45", "ITime"))
[1] TRUE
> 
> (t <- as.ITime("10:45:04"))
[1] "10:45:04"
> 
> (t <- as.ITime("10:45:04", format = "%H:%M:%S"))
[1] "10:45:04"
> 
> as.POSIXct("2001-01-01") + as.ITime("10:45")
[1] "2001-01-01 10:45:00 IST"
> 
> datetime <- seq(as.POSIXct("2001-01-01"), as.POSIXct("2001-01-03"), by = "5 hour")
> (af <- data.table(IDateTime(datetime), a = rep(1:2, 5), key = c("a", "idate", "itime")))
Key: <a, idate, itime>
         idate    itime     a
        <IDat>  <ITime> <int>
 1: 2001-01-01 00:00:00     1
 2: 2001-01-01 10:00:00     1
 3: 2001-01-01 20:00:00     1
 4: 2001-01-02 06:00:00     1
 5: 2001-01-02 16:00:00     1
 6: 2001-01-01 05:00:00     2
 7: 2001-01-01 15:00:00     2
 8: 2001-01-02 01:00:00     2
 9: 2001-01-02 11:00:00     2
10: 2001-01-02 21:00:00     2
> 
> af[, mean(a), by = "itime"]
       itime    V1
     <ITime> <num>
 1: 00:00:00     1
 2: 10:00:00     1
 3: 20:00:00     1
 4: 06:00:00     1
 5: 16:00:00     1
 6: 05:00:00     2
 7: 15:00:00     2
 8: 01:00:00     2
 9: 11:00:00     2
10: 21:00:00     2
> af[, mean(a), by = list(hour = hour(itime))]
     hour    V1
    <int> <num>
 1:     0     1
 2:    10     1
 3:    20     1
 4:     6     1
 5:    16     1
 6:     5     2
 7:    15     2
 8:     1     2
 9:    11     2
10:    21     2
> af[, mean(a), by = list(wday = factor(weekdays(idate)))]
      wday    V1
    <fctr> <num>
1:  Monday   1.4
2: Tuesday   1.6
> af[, mean(a), by = list(wday = wday(idate))]
    wday    V1
   <int> <num>
1:     2   1.4
2:     3   1.6
> 
> as.POSIXct(af$idate)
 [1] "2001-01-01 UTC" "2001-01-01 UTC" "2001-01-01 UTC" "2001-01-02 UTC"
 [5] "2001-01-02 UTC" "2001-01-01 UTC" "2001-01-01 UTC" "2001-01-02 UTC"
 [9] "2001-01-02 UTC" "2001-01-02 UTC"
> as.POSIXct(af$idate, time = af$itime)
 [1] "2001-01-01 00:00:00 UTC" "2001-01-01 10:00:00 UTC"
 [3] "2001-01-01 20:00:00 UTC" "2001-01-02 06:00:00 UTC"
 [5] "2001-01-02 16:00:00 UTC" "2001-01-01 05:00:00 UTC"
 [7] "2001-01-01 15:00:00 UTC" "2001-01-02 01:00:00 UTC"
 [9] "2001-01-02 11:00:00 UTC" "2001-01-02 21:00:00 UTC"
> as.POSIXct(af$idate, af$itime)
 [1] "2001-01-01 00:00:00 UTC" "2001-01-01 10:00:00 UTC"
 [3] "2001-01-01 20:00:00 UTC" "2001-01-02 06:00:00 UTC"
 [5] "2001-01-02 16:00:00 UTC" "2001-01-01 05:00:00 UTC"
 [7] "2001-01-01 15:00:00 UTC" "2001-01-02 01:00:00 UTC"
 [9] "2001-01-02 11:00:00 UTC" "2001-01-02 21:00:00 UTC"
> as.POSIXct(af$idate, time = af$itime, tz = "GMT")
 [1] "2001-01-01 00:00:00 GMT" "2001-01-01 10:00:00 GMT"
 [3] "2001-01-01 20:00:00 GMT" "2001-01-02 06:00:00 GMT"
 [5] "2001-01-02 16:00:00 GMT" "2001-01-01 05:00:00 GMT"
 [7] "2001-01-01 15:00:00 GMT" "2001-01-02 01:00:00 GMT"
 [9] "2001-01-02 11:00:00 GMT" "2001-01-02 21:00:00 GMT"
> 
> as.POSIXct(af$itime, af$idate)
 [1] "2001-01-01 00:00:00 UTC" "2001-01-01 10:00:00 UTC"
 [3] "2001-01-01 20:00:00 UTC" "2001-01-02 06:00:00 UTC"
 [5] "2001-01-02 16:00:00 UTC" "2001-01-01 05:00:00 UTC"
 [7] "2001-01-01 15:00:00 UTC" "2001-01-02 01:00:00 UTC"
 [9] "2001-01-02 11:00:00 UTC" "2001-01-02 21:00:00 UTC"
> as.POSIXct(af$itime) # uses today's date
 [1] "2024-12-23 00:00:00 UTC" "2024-12-23 10:00:00 UTC"
 [3] "2024-12-23 20:00:00 UTC" "2024-12-23 06:00:00 UTC"
 [5] "2024-12-23 16:00:00 UTC" "2024-12-23 05:00:00 UTC"
 [7] "2024-12-23 15:00:00 UTC" "2024-12-23 01:00:00 UTC"
 [9] "2024-12-23 11:00:00 UTC" "2024-12-23 21:00:00 UTC"
> 
> (seqdates <- seq(as.IDate("2001-01-01"), as.IDate("2001-08-03"), by = "3 weeks"))
 [1] "2001-01-01" "2001-01-22" "2001-02-12" "2001-03-05" "2001-03-26"
 [6] "2001-04-16" "2001-05-07" "2001-05-28" "2001-06-18" "2001-07-09"
[11] "2001-07-30"
> round(seqdates, "months")
 [1] "2001-01-01" "2001-01-01" "2001-02-01" "2001-03-01" "2001-03-01"
 [6] "2001-04-01" "2001-05-01" "2001-05-01" "2001-06-01" "2001-07-01"
[11] "2001-07-01"
> 
> (seqtimes <- seq(as.ITime("07:00"), as.ITime("08:00"), by = 20))
  [1] "07:00:00" "07:00:20" "07:00:40" "07:01:00" "07:01:20" "07:01:40"
  [7] "07:02:00" "07:02:20" "07:02:40" "07:03:00" "07:03:20" "07:03:40"
 [13] "07:04:00" "07:04:20" "07:04:40" "07:05:00" "07:05:20" "07:05:40"
 [19] "07:06:00" "07:06:20" "07:06:40" "07:07:00" "07:07:20" "07:07:40"
 [25] "07:08:00" "07:08:20" "07:08:40" "07:09:00" "07:09:20" "07:09:40"
 [31] "07:10:00" "07:10:20" "07:10:40" "07:11:00" "07:11:20" "07:11:40"
 [37] "07:12:00" "07:12:20" "07:12:40" "07:13:00" "07:13:20" "07:13:40"
 [43] "07:14:00" "07:14:20" "07:14:40" "07:15:00" "07:15:20" "07:15:40"
 [49] "07:16:00" "07:16:20" "07:16:40" "07:17:00" "07:17:20" "07:17:40"
 [55] "07:18:00" "07:18:20" "07:18:40" "07:19:00" "07:19:20" "07:19:40"
 [61] "07:20:00" "07:20:20" "07:20:40" "07:21:00" "07:21:20" "07:21:40"
 [67] "07:22:00" "07:22:20" "07:22:40" "07:23:00" "07:23:20" "07:23:40"
 [73] "07:24:00" "07:24:20" "07:24:40" "07:25:00" "07:25:20" "07:25:40"
 [79] "07:26:00" "07:26:20" "07:26:40" "07:27:00" "07:27:20" "07:27:40"
 [85] "07:28:00" "07:28:20" "07:28:40" "07:29:00" "07:29:20" "07:29:40"
 [91] "07:30:00" "07:30:20" "07:30:40" "07:31:00" "07:31:20" "07:31:40"
 [97] "07:32:00" "07:32:20" "07:32:40" "07:33:00" "07:33:20" "07:33:40"
[103] "07:34:00" "07:34:20" "07:34:40" "07:35:00" "07:35:20" "07:35:40"
[109] "07:36:00" "07:36:20" "07:36:40" "07:37:00" "07:37:20" "07:37:40"
[115] "07:38:00" "07:38:20" "07:38:40" "07:39:00" "07:39:20" "07:39:40"
[121] "07:40:00" "07:40:20" "07:40:40" "07:41:00" "07:41:20" "07:41:40"
[127] "07:42:00" "07:42:20" "07:42:40" "07:43:00" "07:43:20" "07:43:40"
[133] "07:44:00" "07:44:20" "07:44:40" "07:45:00" "07:45:20" "07:45:40"
[139] "07:46:00" "07:46:20" "07:46:40" "07:47:00" "07:47:20" "07:47:40"
[145] "07:48:00" "07:48:20" "07:48:40" "07:49:00" "07:49:20" "07:49:40"
[151] "07:50:00" "07:50:20" "07:50:40" "07:51:00" "07:51:20" "07:51:40"
[157] "07:52:00" "07:52:20" "07:52:40" "07:53:00" "07:53:20" "07:53:40"
[163] "07:54:00" "07:54:20" "07:54:40" "07:55:00" "07:55:20" "07:55:40"
[169] "07:56:00" "07:56:20" "07:56:40" "07:57:00" "07:57:20" "07:57:40"
[175] "07:58:00" "07:58:20" "07:58:40" "07:59:00" "07:59:20" "07:59:40"
[181] "08:00:00"
> round(seqtimes, "hours")
  [1] "07:00:00" "07:00:00" "07:00:00" "07:00:00" "07:00:00" "07:00:00"
  [7] "07:00:00" "07:00:00" "07:00:00" "07:00:00" "07:00:00" "07:00:00"
 [13] "07:00:00" "07:00:00" "07:00:00" "07:00:00" "07:00:00" "07:00:00"
 [19] "07:00:00" "07:00:00" "07:00:00" "07:00:00" "07:00:00" "07:00:00"
 [25] "07:00:00" "07:00:00" "07:00:00" "07:00:00" "07:00:00" "07:00:00"
 [31] "07:00:00" "07:00:00" "07:00:00" "07:00:00" "07:00:00" "07:00:00"
 [37] "07:00:00" "07:00:00" "07:00:00" "07:00:00" "07:00:00" "07:00:00"
 [43] "07:00:00" "07:00:00" "07:00:00" "07:00:00" "07:00:00" "07:00:00"
 [49] "07:00:00" "07:00:00" "07:00:00" "07:00:00" "07:00:00" "07:00:00"
 [55] "07:00:00" "07:00:00" "07:00:00" "07:00:00" "07:00:00" "07:00:00"
 [61] "07:00:00" "07:00:00" "07:00:00" "07:00:00" "07:00:00" "07:00:00"
 [67] "07:00:00" "07:00:00" "07:00:00" "07:00:00" "07:00:00" "07:00:00"
 [73] "07:00:00" "07:00:00" "07:00:00" "07:00:00" "07:00:00" "07:00:00"
 [79] "07:00:00" "07:00:00" "07:00:00" "07:00:00" "07:00:00" "07:00:00"
 [85] "07:00:00" "07:00:00" "07:00:00" "07:00:00" "07:00:00" "07:00:00"
 [91] "08:00:00" "08:00:00" "08:00:00" "08:00:00" "08:00:00" "08:00:00"
 [97] "08:00:00" "08:00:00" "08:00:00" "08:00:00" "08:00:00" "08:00:00"
[103] "08:00:00" "08:00:00" "08:00:00" "08:00:00" "08:00:00" "08:00:00"
[109] "08:00:00" "08:00:00" "08:00:00" "08:00:00" "08:00:00" "08:00:00"
[115] "08:00:00" "08:00:00" "08:00:00" "08:00:00" "08:00:00" "08:00:00"
[121] "08:00:00" "08:00:00" "08:00:00" "08:00:00" "08:00:00" "08:00:00"
[127] "08:00:00" "08:00:00" "08:00:00" "08:00:00" "08:00:00" "08:00:00"
[133] "08:00:00" "08:00:00" "08:00:00" "08:00:00" "08:00:00" "08:00:00"
[139] "08:00:00" "08:00:00" "08:00:00" "08:00:00" "08:00:00" "08:00:00"
[145] "08:00:00" "08:00:00" "08:00:00" "08:00:00" "08:00:00" "08:00:00"
[151] "08:00:00" "08:00:00" "08:00:00" "08:00:00" "08:00:00" "08:00:00"
[157] "08:00:00" "08:00:00" "08:00:00" "08:00:00" "08:00:00" "08:00:00"
[163] "08:00:00" "08:00:00" "08:00:00" "08:00:00" "08:00:00" "08:00:00"
[169] "08:00:00" "08:00:00" "08:00:00" "08:00:00" "08:00:00" "08:00:00"
[175] "08:00:00" "08:00:00" "08:00:00" "08:00:00" "08:00:00" "08:00:00"
[181] "08:00:00"
> trunc(seqtimes, "hours")
  [1] "07:00:00" "07:00:00" "07:00:00" "07:00:00" "07:00:00" "07:00:00"
  [7] "07:00:00" "07:00:00" "07:00:00" "07:00:00" "07:00:00" "07:00:00"
 [13] "07:00:00" "07:00:00" "07:00:00" "07:00:00" "07:00:00" "07:00:00"
 [19] "07:00:00" "07:00:00" "07:00:00" "07:00:00" "07:00:00" "07:00:00"
 [25] "07:00:00" "07:00:00" "07:00:00" "07:00:00" "07:00:00" "07:00:00"
 [31] "07:00:00" "07:00:00" "07:00:00" "07:00:00" "07:00:00" "07:00:00"
 [37] "07:00:00" "07:00:00" "07:00:00" "07:00:00" "07:00:00" "07:00:00"
 [43] "07:00:00" "07:00:00" "07:00:00" "07:00:00" "07:00:00" "07:00:00"
 [49] "07:00:00" "07:00:00" "07:00:00" "07:00:00" "07:00:00" "07:00:00"
 [55] "07:00:00" "07:00:00" "07:00:00" "07:00:00" "07:00:00" "07:00:00"
 [61] "07:00:00" "07:00:00" "07:00:00" "07:00:00" "07:00:00" "07:00:00"
 [67] "07:00:00" "07:00:00" "07:00:00" "07:00:00" "07:00:00" "07:00:00"
 [73] "07:00:00" "07:00:00" "07:00:00" "07:00:00" "07:00:00" "07:00:00"
 [79] "07:00:00" "07:00:00" "07:00:00" "07:00:00" "07:00:00" "07:00:00"
 [85] "07:00:00" "07:00:00" "07:00:00" "07:00:00" "07:00:00" "07:00:00"
 [91] "07:00:00" "07:00:00" "07:00:00" "07:00:00" "07:00:00" "07:00:00"
 [97] "07:00:00" "07:00:00" "07:00:00" "07:00:00" "07:00:00" "07:00:00"
[103] "07:00:00" "07:00:00" "07:00:00" "07:00:00" "07:00:00" "07:00:00"
[109] "07:00:00" "07:00:00" "07:00:00" "07:00:00" "07:00:00" "07:00:00"
[115] "07:00:00" "07:00:00" "07:00:00" "07:00:00" "07:00:00" "07:00:00"
[121] "07:00:00" "07:00:00" "07:00:00" "07:00:00" "07:00:00" "07:00:00"
[127] "07:00:00" "07:00:00" "07:00:00" "07:00:00" "07:00:00" "07:00:00"
[133] "07:00:00" "07:00:00" "07:00:00" "07:00:00" "07:00:00" "07:00:00"
[139] "07:00:00" "07:00:00" "07:00:00" "07:00:00" "07:00:00" "07:00:00"
[145] "07:00:00" "07:00:00" "07:00:00" "07:00:00" "07:00:00" "07:00:00"
[151] "07:00:00" "07:00:00" "07:00:00" "07:00:00" "07:00:00" "07:00:00"
[157] "07:00:00" "07:00:00" "07:00:00" "07:00:00" "07:00:00" "07:00:00"
[163] "07:00:00" "07:00:00" "07:00:00" "07:00:00" "07:00:00" "07:00:00"
[169] "07:00:00" "07:00:00" "07:00:00" "07:00:00" "07:00:00" "07:00:00"
[175] "07:00:00" "07:00:00" "07:00:00" "07:00:00" "07:00:00" "07:00:00"
[181] "08:00:00"
> 
> 
> 
> 
> cleanEx()
> nameEx("J")
> ### * J
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: J
> ### Title: Creates a join 'data.table'
> ### Aliases: J CJ SJ
> ### Keywords: data
> 
> ### ** Examples
> 
> DT = data.table(A=5:1, B=letters[5:1])
> setkey(DT, B)   # reorders table and marks it sorted
> DT[J("b")]      # returns the 2nd row
Key: <B>
       A      B
   <int> <char>
1:     2      b
> DT[list("b")]   # same
Key: <B>
       A      B
   <int> <char>
1:     2      b
> DT[.("b")]      # same using the dot alias for list
Key: <B>
       A      B
   <int> <char>
1:     2      b
> 
> # CJ usage examples
> CJ(c(5, NA, 1), c(1, 3, 2))                 # sorted and keyed data.table
Key: <V1, V2>
      V1    V2
   <num> <num>
1:    NA     1
2:    NA     2
3:    NA     3
4:     1     1
5:     1     2
6:     1     3
7:     5     1
8:     5     2
9:     5     3
> do.call(CJ, list(c(5, NA, 1), c(1, 3, 2)))  # same as above
Key: <V1, V2>
      V1    V2
   <num> <num>
1:    NA     1
2:    NA     2
3:    NA     3
4:     1     1
5:     1     2
6:     1     3
7:     5     1
8:     5     2
9:     5     3
> CJ(c(5, NA, 1), c(1, 3, 2), sorted=FALSE)   # same order as input, unkeyed
      V1    V2
   <num> <num>
1:     5     1
2:     5     3
3:     5     2
4:    NA     1
5:    NA     3
6:    NA     2
7:     1     1
8:     1     3
9:     1     2
> # use for 'unique=' argument
> x = c(1, 1, 2)
> y = c(4, 6, 4)
> CJ(x, y)              # output columns are automatically named 'x' and 'y'
Key: <x, y>
       x     y
   <num> <num>
1:     1     4
2:     1     4
3:     1     4
4:     1     4
5:     1     6
6:     1     6
7:     2     4
8:     2     4
9:     2     6
> CJ(x, y, unique=TRUE) # unique(x) and unique(y) are computed automatically
Key: <x, y>
       x     y
   <num> <num>
1:     1     4
2:     1     6
3:     2     4
4:     2     6
> CJ(x, y, sorted = FALSE) # retain input order for y
       x     y
   <num> <num>
1:     1     4
2:     1     6
3:     1     4
4:     1     4
5:     1     6
6:     1     4
7:     2     4
8:     2     6
9:     2     4
> 
> 
> 
> cleanEx()
> nameEx("address")
> ### * address
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: address
> ### Title: Address in RAM of a variable
> ### Aliases: address
> ### Keywords: data
> 
> ### ** Examples
> 
> x=1
> address(x)
[1] "0x630862b1c888"
> 
> 
> 
> cleanEx()
> nameEx("all.equal.data.table")
> ### * all.equal.data.table
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: all.equal
> ### Title: Equality Test Between Two Data Tables
> ### Aliases: all.equal all.equal.data.table
> 
> ### ** Examples
> 
> dt1 <- data.table(A = letters[1:10], X = 1:10, key = "A")
> dt2 <- data.table(A = letters[5:14], Y = 1:10, key = "A")
> isTRUE(all.equal(dt1, dt1))
[1] TRUE
> is.character(all.equal(dt1, dt2))
[1] TRUE
> 
> # ignore.col.order
> x <- copy(dt1)
> y <- dt1[, .(X, A)]
> all.equal(x, y)
[1] "Different column order"
> all.equal(x, y, ignore.col.order = TRUE)
[1] TRUE
> 
> # ignore.row.order
> x <- setkeyv(copy(dt1), NULL)
> y <- dt1[sample(nrow(dt1))]
> all.equal(x, y)
[1] "Column 'A': 10 string mismatches"
> all.equal(x, y, ignore.row.order = TRUE)
[1] TRUE
> 
> # check.attributes
> x = copy(dt1)
> y = setkeyv(copy(dt1), NULL)
> all.equal(x, y)
[1] "Datasets have different keys. 'target': [A]. 'current': has no key."
> all.equal(x, y, check.attributes = FALSE)
[1] TRUE
> x = data.table(1L)
> y = 1L
> all.equal(x, y)
[1] "target is data.table, current is numeric"
> all.equal(x, y, check.attributes = FALSE)
[1] TRUE
> 
> # trim.levels
> x <- data.table(A = factor(letters[1:10])[1:4]) # 10 levels
> y <- data.table(A = factor(letters[1:5])[1:4]) # 5 levels
> all.equal(x, y, trim.levels = FALSE)
[1] "Column 'A': Levels not identical. No attempt to refactor because trim.levels is FALSE"
> all.equal(x, y, trim.levels = FALSE, check.attributes = FALSE)
[1] "Column 'A': Levels not identical. No attempt to refactor because trim.levels is FALSE"
> all.equal(x, y)
[1] TRUE
> 
> 
> 
> cleanEx()
> nameEx("as.data.table")
> ### * as.data.table
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: as.data.table
> ### Title: Coerce to data.table
> ### Aliases: as.data.table as.data.table.array as.data.table.matrix
> ###   as.data.table.list as.data.table.data.frame as.data.table.data.table
> ###   as.data.table.factor as.data.table.ordered as.data.table.integer
> ###   as.data.table.numeric as.data.table.logical as.data.table.character
> ###   as.data.table.Date is.data.table
> ### Keywords: data
> 
> ### ** Examples
> 
> nn = c(a=0.1, b=0.2, c=0.3, d=0.4)
> as.data.table(nn)
      nn
   <num>
1:   0.1
2:   0.2
3:   0.3
4:   0.4
> as.data.table(nn, keep.rownames=TRUE)
       rn    nn
   <char> <num>
1:      a   0.1
2:      b   0.2
3:      c   0.3
4:      d   0.4
> as.data.table(nn, keep.rownames="rownames")
   rownames    nn
     <char> <num>
1:        a   0.1
2:        b   0.2
3:        c   0.3
4:        d   0.4
> 
> # char object not converted to factor
> cc = c(X="a", Y="b", Z="c")
> as.data.table(cc)
       cc
   <char>
1:      a
2:      b
3:      c
> as.data.table(cc, keep.rownames=TRUE)
       rn     cc
   <char> <char>
1:      X      a
2:      Y      b
3:      Z      c
> as.data.table(cc, keep.rownames="rownames")
   rownames     cc
     <char> <char>
1:        X      a
2:        Y      b
3:        Z      c
> 
> mm = matrix(1:4, ncol=2, dimnames=list(c("r1", "r2"), c("c1", "c2")))
> as.data.table(mm)
      c1    c2
   <int> <int>
1:     1     3
2:     2     4
> as.data.table(mm, keep.rownames=TRUE)
       rn    c1    c2
   <char> <int> <int>
1:     r1     1     3
2:     r2     2     4
> as.data.table(mm, keep.rownames="rownames")
   rownames    c1    c2
     <char> <int> <int>
1:       r1     1     3
2:       r2     2     4
> as.data.table(mm, key="c1")
Key: <c1>
      c1    c2
   <int> <int>
1:     1     3
2:     2     4
> 
> ll = list(a=1:2, b=3:4)
> as.data.table(ll)
       a     b
   <int> <int>
1:     1     3
2:     2     4
> as.data.table(ll, keep.rownames=TRUE)
       a     b
   <int> <int>
1:     1     3
2:     2     4
> as.data.table(ll, keep.rownames="rownames")
       a     b
   <int> <int>
1:     1     3
2:     2     4
> 
> DF = data.frame(x=rep(c("x","y","z"),each=2), y=c(1,3,6), row.names=LETTERS[1:6])
> as.data.table(DF)
        x     y
   <char> <num>
1:      x     1
2:      x     3
3:      y     6
4:      y     1
5:      z     3
6:      z     6
> as.data.table(DF, keep.rownames=TRUE)
       rn      x     y
   <char> <char> <num>
1:      A      x     1
2:      B      x     3
3:      C      y     6
4:      D      y     1
5:      E      z     3
6:      F      z     6
> as.data.table(DF, keep.rownames="rownames")
   rownames      x     y
     <char> <char> <num>
1:        A      x     1
2:        B      x     3
3:        C      y     6
4:        D      y     1
5:        E      z     3
6:        F      z     6
> 
> DT = data.table(x=rep(c("x","y","z"),each=2), y=c(1:6))
> as.data.table(DT)
        x     y
   <char> <int>
1:      x     1
2:      x     2
3:      y     3
4:      y     4
5:      z     5
6:      z     6
> as.data.table(DT, key='x')
        x     y
   <char> <int>
1:      x     1
2:      x     2
3:      y     3
4:      y     4
5:      z     5
6:      z     6
> 
> ar = rnorm(27)
> ar[sample(27, 15)] = NA
> dim(ar) = c(3L,3L,3L)
> as.data.table(ar)
Key: <V1, V2, V3>
       V1    V2    V3       value
    <int> <int> <int>       <num>
 1:     1     1     1 -0.62645381
 2:     1     2     1  1.59528080
 3:     1     3     2 -0.04493361
 4:     2     1     2  1.51178117
 5:     2     2     1  0.32950777
 6:     2     3     1  0.73832471
 7:     2     3     2 -0.01619026
 8:     2     3     3 -0.05612874
 9:     3     1     1 -0.83562861
10:     3     1     2  0.38984324
11:     3     1     3  0.91897737
12:     3     3     1  0.57578135
> 
> 
> 
> cleanEx()
> nameEx("as.data.table.xts")
> ### * as.data.table.xts
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: as.data.table.xts
> ### Title: Efficient xts to as.data.table conversion
> ### Aliases: as.data.table.xts
> 
> ### ** Examples
> 
> if (requireNamespace("xts", quietly = TRUE)) {
+   data(sample_matrix, package = "xts")
+   sample.xts <- xts::as.xts(sample_matrix) # xts might not be attached on search path
+   # print head of xts
+   print(head(sample.xts))
+   # print data.table
+   print(as.data.table(sample.xts))
+ }
               Open     High      Low    Close
2007-01-02 50.03978 50.11778 49.95041 50.11778
2007-01-03 50.23050 50.42188 50.23050 50.39767
2007-01-04 50.42096 50.42096 50.26414 50.33236
2007-01-05 50.37347 50.37347 50.22103 50.33459
2007-01-06 50.24433 50.24433 50.11121 50.18112
2007-01-07 50.13211 50.21561 49.99185 49.99185
          index     Open     High      Low    Close
         <POSc>    <num>    <num>    <num>    <num>
  1: 2007-01-02 50.03978 50.11778 49.95041 50.11778
  2: 2007-01-03 50.23050 50.42188 50.23050 50.39767
  3: 2007-01-04 50.42096 50.42096 50.26414 50.33236
  4: 2007-01-05 50.37347 50.37347 50.22103 50.33459
  5: 2007-01-06 50.24433 50.24433 50.11121 50.18112
 ---                                               
176: 2007-06-26 47.44300 47.61611 47.44300 47.61611
177: 2007-06-27 47.62323 47.71673 47.60015 47.62769
178: 2007-06-28 47.67604 47.70460 47.57241 47.60716
179: 2007-06-29 47.63629 47.77563 47.61733 47.66471
180: 2007-06-30 47.67468 47.94127 47.67468 47.76719
> 
> 
> 
> cleanEx()
> nameEx("as.matrix")
> ### * as.matrix
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: as.matrix
> ### Title: Convert a data.table to a matrix
> ### Aliases: as.matrix as.matrix.data.table
> ### Keywords: array
> 
> ### ** Examples
> 
> DT <- data.table(A = letters[1:10], X = 1:10, Y = 11:20)
> as.matrix(DT) # character matrix
      A   X    Y   
 [1,] "a" " 1" "11"
 [2,] "b" " 2" "12"
 [3,] "c" " 3" "13"
 [4,] "d" " 4" "14"
 [5,] "e" " 5" "15"
 [6,] "f" " 6" "16"
 [7,] "g" " 7" "17"
 [8,] "h" " 8" "18"
 [9,] "i" " 9" "19"
[10,] "j" "10" "20"
> as.matrix(DT, rownames = "A")
   X  Y
a  1 11
b  2 12
c  3 13
d  4 14
e  5 15
f  6 16
g  7 17
h  8 18
i  9 19
j 10 20
> as.matrix(DT, rownames = 1)
   X  Y
a  1 11
b  2 12
c  3 13
d  4 14
e  5 15
f  6 16
g  7 17
h  8 18
i  9 19
j 10 20
> as.matrix(DT, rownames = TRUE)
   X  Y
a  1 11
b  2 12
c  3 13
d  4 14
e  5 15
f  6 16
g  7 17
h  8 18
i  9 19
j 10 20
> 
> setkey(DT, A)
> as.matrix(DT, rownames = TRUE)
   X  Y
a  1 11
b  2 12
c  3 13
d  4 14
e  5 15
f  6 16
g  7 17
h  8 18
i  9 19
j 10 20
> 
> 
> 
> cleanEx()
> nameEx("as.xts.data.table")
> ### * as.xts.data.table
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: as.xts.data.table
> ### Title: Efficient data.table to xts conversion
> ### Aliases: as.xts.data.table
> 
> ### ** Examples
> 
> if (requireNamespace("xts", quietly = TRUE)) {
+   sample.dt <- data.table(date = as.Date((Sys.Date()-999):Sys.Date(),origin="1970-01-01"),
+                           quantity = sample(10:50,1000,TRUE),
+                           value = sample(100:1000,1000,TRUE))
+   # print data.table
+   print(sample.dt)
+   # print head of xts
+   print(head(as.xts.data.table(sample.dt))) # xts might not be attached on search path
+ }
            date quantity value
          <Date>    <int> <int>
   1: 2022-03-30       13   757
   2: 2022-03-31       48   370
   3: 2022-04-01       10   422
   4: 2022-04-02       43   374
   5: 2022-04-03       32   922
  ---                          
 996: 2024-12-19       40   767
 997: 2024-12-20       22   267
 998: 2024-12-21       50   919
 999: 2024-12-22       12   557
1000: 2024-12-23       20   332
           quantity value
2022-03-30       13   757
2022-03-31       48   370
2022-04-01       10   422
2022-04-02       43   374
2022-04-03       32   922
2022-04-04       23   903
> 
> 
> 
> cleanEx()
> nameEx("assign")
> ### * assign
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: :=
> ### Title: Assignment by reference
> ### Aliases: := set let
> ### Keywords: data
> 
> ### ** Examples
> 
> DT = data.table(a = LETTERS[c(3L,1:3)], b = 4:7)
> DT[, c := 8]                # add a numeric column, 8 for all rows
> DT[, d := 9L]               # add an integer column, 9L for all rows
> DT[, c := NULL]             # remove column c
> DT[2, d := -8L]             # subassign by reference to d; 2nd row is -8L now
> DT                          # DT changed by reference
        a     b     d
   <char> <int> <int>
1:      C     4     9
2:      A     5    -8
3:      B     6     9
4:      C     7     9
> DT[2, d := 10L][]           # shorthand for update and print
        a     b     d
   <char> <int> <int>
1:      C     4     9
2:      A     5    10
3:      B     6     9
4:      C     7     9
> 
> DT[b > 4, b := d * 2L]      # subassign to b with d*2L on those rows where b > 4 is TRUE
> DT[b > 4][, b := d * 2L]    # different from above. [, := ] is performed on the subset
>                             # which is an new (ephemeral) data.table. Result needs to be
>                             # assigned to a variable (using `<-`).
> 
> DT[, e := mean(d), by = a]  # add new column by group by reference
> DT["A", b := 0L, on = "a"]  # ad-hoc update of column b for group "A" using
> 			    # joins-as-subsets with binary search and 'on='
> # same as above but using keys
> setkey(DT, a)
> DT["A", b := 0L]            # binary search for group "A" and set column b using keys
> DT["B", f := mean(d)]       # subassign to new column, NA initialized
> 
> # Adding multiple columns
> ## by name
> DT[ , c('sin_d', 'log_e', 'cos_d') :=
+    .(sin(d), log(e), cos(d))]
> ## by patterned name
> DT[ , paste(c('sin', 'cos'), 'b', sep = '_') :=
+    .(sin(b), cos(b))]
> ## using lapply & .SD
> DT[ , paste0('tan_', c('b', 'd', 'e')) :=
+    lapply(.SD, tan), .SDcols = c('b', 'd', 'e')]
> ## using forced evaluation to disambiguate a vector of names
> ##   and overwrite existing columns with their squares
> sq_cols = c('b', 'd', 'e')
> DT[ , (sq_cols) := lapply(.SD, `^`, 2L), .SDcols = sq_cols]
> ## by integer (NB: for robustness, it is not recommended
> ##   to use explicit integers to update/define columns)
> DT[ , c(2L, 3L, 4L) := .(sqrt(b), sqrt(d), sqrt(e))]
> ## by implicit integer
> DT[ , grep('a$', names(DT)) := tolower(a)]
> ## by implicit integer, using forced evaluation
> sq_col_idx = grep('d$', names(DT))
> DT[ , (sq_col_idx) := lapply(.SD, dnorm),
+    .SDcols = sq_col_idx]
> 
> # Examples using `set` function
> ## Set value for single cell
> set(DT, 1L, "b", 10L)
> ## Set values for multiple columns in a specific row
> set(DT, 2L, c("b", "d"), list(20L, 30L))
> ## Set values by column indices
> set(DT, 3L, c(2L, 4L), list(40L, 50L))
> ## Set value for an entire column without specifying rows
> set(DT, j = "b", value = 100L)
> set(DT, NULL, "b", 100L) # equivalent
> ## Set values for multiple columns without specifying rows
> set(DT, j = c("b", "d"), value = list(200L, 300L))
> ## Set values for multiple columns with multiple specified rows.
> set(DT, c(1L, 3L), c("b", "d"), value = list(500L, 800L))
> 
> ## Not run: 
> ##D # Speed example:
> ##D 
> ##D m = matrix(1, nrow = 2e6L, ncol = 100L)
> ##D DF = as.data.frame(m)
> ##D DT = as.data.table(m)
> ##D 
> ##D system.time(for (i in 1:1000) DF[i, 1] = i)
> ##D # 15.856 seconds
> ##D system.time(for (i in 1:1000) DT[i, V1 := i])
> ##D # 0.279 seconds  (57 times faster)
> ##D system.time(for (i in 1:1000) set(DT, i, 1L, i))
> ##D # 0.002 seconds  (7930 times faster, overhead of [.data.table is avoided)
> ##D 
> ##D # However, normally, we call [.data.table *once* on *large* data, not many times on small data.
> ##D # The above is to demonstrate overhead, not to recommend looping in this way. But the option
> ##D # of set() is there if you need it.
> ## End(Not run)
> 
> 
> 
> 
> cleanEx()
> nameEx("between")
> ### * between
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: between
> ### Title: Convenience functions for range subsets.
> ### Aliases: between %between% inrange %inrange%
> ### Keywords: data
> 
> ### ** Examples
> 
> X = data.table(a=1:5, b=6:10, c=c(5:1))
> X[b %between% c(7,9)]
       a     b     c
   <int> <int> <int>
1:     2     7     4
2:     3     8     3
3:     4     9     2
> X[between(b, 7, 9)] # same as above
       a     b     c
   <int> <int> <int>
1:     2     7     4
2:     3     8     3
3:     4     9     2
> # NEW feature in v1.9.8, vectorised between
> X[c %between% list(a,b)]
       a     b     c
   <int> <int> <int>
1:     1     6     5
2:     2     7     4
3:     3     8     3
> X[between(c, a, b)] # same as above
       a     b     c
   <int> <int> <int>
1:     1     6     5
2:     2     7     4
3:     3     8     3
> X[between(c, a, b, incbounds=FALSE)] # open interval
       a     b     c
   <int> <int> <int>
1:     1     6     5
2:     2     7     4
> 
> # inrange()
> Y = data.table(a=c(8,3,10,7,-10), val=runif(5))
> range = data.table(start = 1:5, end = 6:10)
> Y[a %inrange% range]
       a       val
   <num>     <num>
1:     8 0.2655087
2:     3 0.3721239
3:    10 0.5728534
4:     7 0.9082078
> Y[inrange(a, range$start, range$end)] # same as above
       a       val
   <num>     <num>
1:     8 0.2655087
2:     3 0.3721239
3:    10 0.5728534
4:     7 0.9082078
> Y[inrange(a, range$start, range$end, incbounds=FALSE)] # open interval
       a       val
   <num>     <num>
1:     8 0.2655087
2:     3 0.3721239
3:     7 0.9082078
> 
> 
> 
> cleanEx()
> nameEx("chmatch")
> ### * chmatch
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: chmatch
> ### Title: Faster match of character vectors
> ### Aliases: chmatch %chin% chorder chgroup
> ### Keywords: data
> 
> ### ** Examples
> 
> # Please type 'example(chmatch)' to run this and see timings on your machine
> 
> N = 1e5
> # N is set small here (1e5) to reduce runtime because every day CRAN runs and checks
> # all documentation examples in addition to the package's test suite.
> # The comments here apply when N has been changed to 1e8 and were run on 2018-05-13
> # with R 3.5.0 and data.table 1.11.2.
> 
> u = as.character(as.hexmode(1:10000))
> y = sample(u,N,replace=TRUE)
> x = sample(u)
>                                            #  With N=1e8 ...
> system.time(a <- match(x,y))               #  4.6s
   user  system elapsed 
  0.003   0.001   0.004 
> system.time(b <- chmatch(x,y))             #  1.8s
   user  system elapsed 
  0.001   0.000   0.000 
> identical(a,b)
[1] TRUE
> 
> system.time(a <- x %in% y)               #  4.5s
   user  system elapsed 
  0.004   0.000   0.005 
> system.time(b <- x %chin% y)             #  1.7s
   user  system elapsed 
  0.000   0.000   0.001 
> identical(a,b)
[1] TRUE
> 
> # Different example with more unique strings ...
> u = as.character(as.hexmode(1:(N/10)))
> y = sample(u,N,replace=TRUE)
> x = sample(u,N,replace=TRUE)
> system.time(a <- match(x,y))               # 46s
   user  system elapsed 
  0.004   0.001   0.005 
> system.time(b <- chmatch(x,y))             # 16s
   user  system elapsed 
  0.002   0.000   0.002 
> identical(a,b)
[1] TRUE
> 
> 
> 
> cleanEx()
> nameEx("coalesce")
> ### * coalesce
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: fcoalesce
> ### Title: Coalescing missing values
> ### Aliases: fcoalesce setcoalesce
> ### Keywords: data
> 
> ### ** Examples
> 
> x = c(11L, NA, 13L, NA, 15L, NA)
> y = c(NA, 12L, 5L, NA, NA, NA)
> z = c(11L, NA, 1L, 14L, NA, NA)
> fcoalesce(x, y, z)
[1] 11 12 13 14 15 NA
> fcoalesce(list(x,y,z))   # same
[1] 11 12 13 14 15 NA
> fcoalesce(x, list(y,z))  # same
[1] 11 12 13 14 15 NA
> 
> 
> 
> cleanEx()
> nameEx("copy")
> ### * copy
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: copy
> ### Title: Copy an entire object
> ### Aliases: copy
> ### Keywords: data
> 
> ### ** Examples
> 
> # Type 'example(copy)' to run these at prompt and browse output
> 
> DT = data.table(A=5:1,B=letters[5:1])
> DT2 = copy(DT)        # explicit copy() needed to copy a data.table
> setkey(DT2,B)         # now just changes DT2
> identical(DT,DT2)     # FALSE. DT and DT2 are now different tables
[1] FALSE
> 
> DT = data.table(A=5:1, B=letters[5:1])
> nm1 = names(DT)
> nm2 = copy(names(DT))
> DT[, C := 1L]
> identical(nm1, names(DT)) # TRUE, nm1 is also changed by reference
[1] TRUE
> identical(nm2, names(DT)) # FALSE, nm2 is a copy, different from names(DT)
[1] FALSE
> 
> 
> 
> cleanEx()
> nameEx("data.table-class")
> ### * data.table-class
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: data.table-class
> ### Title: S4 Definition for data.table
> ### Aliases: class:data.table data.table-class
> ### Keywords: classes methods
> 
> ### ** Examples
> 
> ## Used in inheritance.
> setClass('SuperDataTable', contains='data.table')
> 
> ## Used in a slot
> setClass('Something', representation(x='character', dt='data.table'))
> x <- new("Something", x='check', dt=data.table(a=1:10, b=11:20))
> 
> 
> 
> cleanEx()
> nameEx("data.table")
> ### * data.table
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: data.table-package
> ### Title: Enhanced data.frame
> ### Aliases: data.table-package data.table Ops.data.table is.na.data.table
> ###   [.data.table . .( .() ..
> ### Keywords: data
> 
> ### ** Examples
> 
> ## Not run: 
> ##D example(data.table)  # to run these examples yourself
> ## End(Not run)
> DF = data.frame(x=rep(c("b","a","c"),each=3), y=c(1,3,6), v=1:9)
> DT = data.table(x=rep(c("b","a","c"),each=3), y=c(1,3,6), v=1:9)
> DF
  x y v
1 b 1 1
2 b 3 2
3 b 6 3
4 a 1 4
5 a 3 5
6 a 6 6
7 c 1 7
8 c 3 8
9 c 6 9
> DT
        x     y     v
   <char> <num> <int>
1:      b     1     1
2:      b     3     2
3:      b     6     3
4:      a     1     4
5:      a     3     5
6:      a     6     6
7:      c     1     7
8:      c     3     8
9:      c     6     9
> identical(dim(DT), dim(DF))    # TRUE
[1] TRUE
> identical(DF$a, DT$a)          # TRUE
[1] TRUE
> is.list(DF)                    # TRUE
[1] TRUE
> is.list(DT)                    # TRUE
[1] TRUE
> 
> is.data.frame(DT)              # TRUE
[1] TRUE
> 
> tables()
   NAME NROW NCOL MB  COLS    KEY
1:   DT    9    3  0 x,y,v [NULL]
Total: 0MB using type_size
> 
> # basic row subset operations
> DT[2]                          # 2nd row
        x     y     v
   <char> <num> <int>
1:      b     3     2
> DT[3:2]                        # 3rd and 2nd row
        x     y     v
   <char> <num> <int>
1:      b     6     3
2:      b     3     2
> DT[order(x)]                   # no need for order(DT$x)
        x     y     v
   <char> <num> <int>
1:      a     1     4
2:      a     3     5
3:      a     6     6
4:      b     1     1
5:      b     3     2
6:      b     6     3
7:      c     1     7
8:      c     3     8
9:      c     6     9
> DT[order(x), ]                 # same as above. The ',' is optional
        x     y     v
   <char> <num> <int>
1:      a     1     4
2:      a     3     5
3:      a     6     6
4:      b     1     1
5:      b     3     2
6:      b     6     3
7:      c     1     7
8:      c     3     8
9:      c     6     9
> DT[y>2]                        # all rows where DT$y > 2
        x     y     v
   <char> <num> <int>
1:      b     3     2
2:      b     6     3
3:      a     3     5
4:      a     6     6
5:      c     3     8
6:      c     6     9
> DT[y>2 & v>5]                  # compound logical expressions
        x     y     v
   <char> <num> <int>
1:      a     6     6
2:      c     3     8
3:      c     6     9
> DT[!2:4]                       # all rows other than 2:4
        x     y     v
   <char> <num> <int>
1:      b     1     1
2:      a     3     5
3:      a     6     6
4:      c     1     7
5:      c     3     8
6:      c     6     9
> DT[-(2:4)]                     # same
        x     y     v
   <char> <num> <int>
1:      b     1     1
2:      a     3     5
3:      a     6     6
4:      c     1     7
5:      c     3     8
6:      c     6     9
> 
> # select|compute columns data.table way
> DT[, v]                        # v column (as vector)
[1] 1 2 3 4 5 6 7 8 9
> DT[, list(v)]                  # v column (as data.table)
       v
   <int>
1:     1
2:     2
3:     3
4:     4
5:     5
6:     6
7:     7
8:     8
9:     9
> DT[, .(v)]                     # same as above, .() is a shorthand alias to list()
       v
   <int>
1:     1
2:     2
3:     3
4:     4
5:     5
6:     6
7:     7
8:     8
9:     9
> DT[, sum(v)]                   # sum of column v, returned as vector
[1] 45
> DT[, .(sum(v))]                # same, but return data.table (column autonamed V1)
      V1
   <int>
1:    45
> DT[, .(sv=sum(v))]             # same, but column named "sv"
      sv
   <int>
1:    45
> DT[, .(v, v*2)]                # return two column data.table, v and v*2
       v    V2
   <int> <num>
1:     1     2
2:     2     4
3:     3     6
4:     4     8
5:     5    10
6:     6    12
7:     7    14
8:     8    16
9:     9    18
> 
> # subset rows and select|compute data.table way
> DT[2:3, sum(v)]                # sum(v) over rows 2 and 3, return vector
[1] 5
> DT[2:3, .(sum(v))]             # same, but return data.table with column V1
      V1
   <int>
1:     5
> DT[2:3, .(sv=sum(v))]          # same, but return data.table with column sv
      sv
   <int>
1:     5
> DT[2:5, cat(v, "\n")]          # just for j's side effect
2 3 4 5 
NULL
> 
> # select columns the data.frame way
> DT[, 2]                        # 2nd column, returns a data.table always
       y
   <num>
1:     1
2:     3
3:     6
4:     1
5:     3
6:     6
7:     1
8:     3
9:     6
> colNum = 2
> DT[, ..colNum]                 # same, .. prefix conveys one-level-up in calling scope
       y
   <num>
1:     1
2:     3
3:     6
4:     1
5:     3
6:     6
7:     1
8:     3
9:     6
> DT[["v"]]                      # same as DT[, v] but faster if called in a loop
[1] 1 2 3 4 5 6 7 8 9
> 
> # grouping operations - j and by
> DT[, sum(v), by=x]             # ad hoc by, order of groups preserved in result
        x    V1
   <char> <int>
1:      b     6
2:      a    15
3:      c    24
> DT[, sum(v), keyby=x]          # same, but order the result on by cols
Key: <x>
        x    V1
   <char> <int>
1:      a    15
2:      b     6
3:      c    24
> DT[, sum(v), by=x, keyby=TRUE] # same, but using sorting flag
Key: <x>
        x    V1
   <char> <int>
1:      a    15
2:      b     6
3:      c    24
> DT[, sum(v), by=x][order(x)]   # same but by chaining expressions together
        x    V1
   <char> <int>
1:      a    15
2:      b     6
3:      c    24
> 
> # fast ad hoc row subsets (subsets as joins)
> DT["a", on="x"]                # same as x == "a" but uses binary search (fast)
        x     y     v
   <char> <num> <int>
1:      a     1     4
2:      a     3     5
3:      a     6     6
> DT["a", on=.(x)]               # same, for convenience, no need to quote every column
        x     y     v
   <char> <num> <int>
1:      a     1     4
2:      a     3     5
3:      a     6     6
> DT[.("a"), on="x"]             # same
        x     y     v
   <char> <num> <int>
1:      a     1     4
2:      a     3     5
3:      a     6     6
> DT[x=="a"]                     # same, single "==" internally optimised to use binary search (fast)
        x     y     v
   <char> <num> <int>
1:      a     1     4
2:      a     3     5
3:      a     6     6
> DT[x!="b" | y!=3]              # not yet optimized, currently vector scan subset
        x     y     v
   <char> <num> <int>
1:      b     1     1
2:      b     6     3
3:      a     1     4
4:      a     3     5
5:      a     6     6
6:      c     1     7
7:      c     3     8
8:      c     6     9
> DT[.("b", 3), on=c("x", "y")]  # join on columns x,y of DT; uses binary search (fast)
        x     y     v
   <char> <num> <int>
1:      b     3     2
> DT[.("b", 3), on=.(x, y)]      # same, but using on=.()
        x     y     v
   <char> <num> <int>
1:      b     3     2
> DT[.("b", 1:2), on=c("x", "y")]             # no match returns NA
        x     y     v
   <char> <int> <int>
1:      b     1     1
2:      b     2    NA
> DT[.("b", 1:2), on=.(x, y), nomatch=NULL]   # no match row is not returned
        x     y     v
   <char> <int> <int>
1:      b     1     1
> DT[.("b", 1:2), on=c("x", "y"), roll=Inf]   # locf, nomatch row gets rolled by previous row
        x     y     v
   <char> <int> <int>
1:      b     1     1
2:      b     2     1
> DT[.("b", 1:2), on=.(x, y), roll=-Inf]      # nocb, nomatch row gets rolled by next row
        x     y     v
   <char> <int> <int>
1:      b     1     1
2:      b     2     2
> DT["b", sum(v*y), on="x"]                   # on rows where DT$x=="b", calculate sum(v*y)
[1] 25
> 
> # all together now
> DT[x!="a", sum(v), by=x]                    # get sum(v) by "x" for each i != "a"
        x    V1
   <char> <int>
1:      b     6
2:      c    24
> DT[!"a", sum(v), by=.EACHI, on="x"]         # same, but using subsets-as-joins
        x    V1
   <char> <int>
1:      b     6
2:      c    24
> DT[c("b","c"), sum(v), by=.EACHI, on="x"]   # same
        x    V1
   <char> <int>
1:      b     6
2:      c    24
> DT[c("b","c"), sum(v), by=.EACHI, on=.(x)]  # same, using on=.()
        x    V1
   <char> <int>
1:      b     6
2:      c    24
> 
> # joins as subsets
> X = data.table(x=c("c","b"), v=8:7, foo=c(4,2))
> X
        x     v   foo
   <char> <int> <num>
1:      c     8     4
2:      b     7     2
> 
> DT[X, on="x"]                         # right join
        x     y     v   i.v   foo
   <char> <num> <int> <int> <num>
1:      c     1     7     8     4
2:      c     3     8     8     4
3:      c     6     9     8     4
4:      b     1     1     7     2
5:      b     3     2     7     2
6:      b     6     3     7     2
> X[DT, on="x"]                         # left join
        x     v   foo     y   i.v
   <char> <int> <num> <num> <int>
1:      b     7     2     1     1
2:      b     7     2     3     2
3:      b     7     2     6     3
4:      a    NA    NA     1     4
5:      a    NA    NA     3     5
6:      a    NA    NA     6     6
7:      c     8     4     1     7
8:      c     8     4     3     8
9:      c     8     4     6     9
> DT[X, on="x", nomatch=NULL]           # inner join
        x     y     v   i.v   foo
   <char> <num> <int> <int> <num>
1:      c     1     7     8     4
2:      c     3     8     8     4
3:      c     6     9     8     4
4:      b     1     1     7     2
5:      b     3     2     7     2
6:      b     6     3     7     2
> DT[!X, on="x"]                        # not join
        x     y     v
   <char> <num> <int>
1:      a     1     4
2:      a     3     5
3:      a     6     6
> DT[X, on=c(y="v")]                    # join using column "y" of DT with column "v" of X
        x     y     v    i.x   foo
   <char> <int> <int> <char> <num>
1:   <NA>     8    NA      c     4
2:   <NA>     7    NA      b     2
> DT[X, on="y==v"]                      # same as above (v1.9.8+)
        x     y     v    i.x   foo
   <char> <int> <int> <char> <num>
1:   <NA>     8    NA      c     4
2:   <NA>     7    NA      b     2
> 
> DT[X, on=.(y<=foo)]                   # NEW non-equi join (v1.9.8+)
        x     y     v    i.x   i.v
   <char> <num> <int> <char> <int>
1:      b     4     1      c     8
2:      b     4     2      c     8
3:      a     4     4      c     8
4:      a     4     5      c     8
5:      c     4     7      c     8
6:      c     4     8      c     8
7:      b     2     1      b     7
8:      a     2     4      b     7
9:      c     2     7      b     7
> DT[X, on="y<=foo"]                    # same as above
        x     y     v    i.x   i.v
   <char> <num> <int> <char> <int>
1:      b     4     1      c     8
2:      b     4     2      c     8
3:      a     4     4      c     8
4:      a     4     5      c     8
5:      c     4     7      c     8
6:      c     4     8      c     8
7:      b     2     1      b     7
8:      a     2     4      b     7
9:      c     2     7      b     7
> DT[X, on=c("y<=foo")]                 # same as above
        x     y     v    i.x   i.v
   <char> <num> <int> <char> <int>
1:      b     4     1      c     8
2:      b     4     2      c     8
3:      a     4     4      c     8
4:      a     4     5      c     8
5:      c     4     7      c     8
6:      c     4     8      c     8
7:      b     2     1      b     7
8:      a     2     4      b     7
9:      c     2     7      b     7
> DT[X, on=.(y>=foo)]                   # NEW non-equi join (v1.9.8+)
        x     y     v    i.x   i.v
   <char> <num> <int> <char> <int>
1:      b     4     3      c     8
2:      a     4     6      c     8
3:      c     4     9      c     8
4:      b     2     2      b     7
5:      b     2     3      b     7
6:      a     2     5      b     7
7:      a     2     6      b     7
8:      c     2     8      b     7
9:      c     2     9      b     7
> DT[X, on=.(x, y<=foo)]                # NEW non-equi join (v1.9.8+)
        x     y     v   i.v
   <char> <num> <int> <int>
1:      c     4     7     8
2:      c     4     8     8
3:      b     2     1     7
> DT[X, .(x,y,x.y,v), on=.(x, y>=foo)]  # Select x's join columns as well
        x     y   x.y     v
   <char> <num> <num> <int>
1:      c     4     6     9
2:      b     2     3     2
3:      b     2     6     3
> 
> DT[X, on="x", mult="first"]           # first row of each group
        x     y     v   i.v   foo
   <char> <num> <int> <int> <num>
1:      c     1     7     8     4
2:      b     1     1     7     2
> DT[X, on="x", mult="last"]            # last row of each group
        x     y     v   i.v   foo
   <char> <num> <int> <int> <num>
1:      c     6     9     8     4
2:      b     6     3     7     2
> DT[X, sum(v), by=.EACHI, on="x"]      # join and eval j for each row in i
        x    V1
   <char> <int>
1:      c    24
2:      b     6
> DT[X, sum(v)*foo, by=.EACHI, on="x"]  # join inherited scope
        x    V1
   <char> <num>
1:      c    96
2:      b    12
> DT[X, sum(v)*i.v, by=.EACHI, on="x"]  # 'i,v' refers to X's v column
        x    V1
   <char> <int>
1:      c   192
2:      b    42
> DT[X, on=.(x, v>=v), sum(y)*foo, by=.EACHI] # NEW non-equi join with by=.EACHI (v1.9.8+)
        x     v    V1
   <char> <int> <num>
1:      c     8    36
2:      b     7    NA
> 
> # setting keys
> kDT = copy(DT)                        # (deep) copy DT to kDT to work with it.
> setkey(kDT,x)                         # set a 1-column key. No quotes, for convenience.
> setkeyv(kDT,"x")                      # same (v in setkeyv stands for vector)
> v="x"
> setkeyv(kDT,v)                        # same
> haskey(kDT)                           # TRUE
[1] TRUE
> key(kDT)                              # "x"
[1] "x"
> 
> # fast *keyed* subsets
> kDT["a"]                              # subset-as-join on *key* column 'x'
Key: <x>
        x     y     v
   <char> <num> <int>
1:      a     1     4
2:      a     3     5
3:      a     6     6
> kDT["a", on="x"]                      # same, being explicit using 'on=' (preferred)
Key: <x>
        x     y     v
   <char> <num> <int>
1:      a     1     4
2:      a     3     5
3:      a     6     6
> 
> # all together
> kDT[!"a", sum(v), by=.EACHI]          # get sum(v) for each i != "a"
Key: <x>
        x    V1
   <char> <int>
1:      b     6
2:      c    24
> 
> # multi-column key
> setkey(kDT,x,y)                       # 2-column key
> setkeyv(kDT,c("x","y"))               # same
> 
> # fast *keyed* subsets on multi-column key
> kDT["a"]                              # join to 1st column of key
Key: <x, y>
        x     y     v
   <char> <num> <int>
1:      a     1     4
2:      a     3     5
3:      a     6     6
> kDT["a", on="x"]                      # on= is optional, but is preferred
Key: <x, y>
        x     y     v
   <char> <num> <int>
1:      a     1     4
2:      a     3     5
3:      a     6     6
> kDT[.("a")]                           # same, .() is an alias for list()
Key: <x, y>
        x     y     v
   <char> <num> <int>
1:      a     1     4
2:      a     3     5
3:      a     6     6
> kDT[list("a")]                        # same
Key: <x, y>
        x     y     v
   <char> <num> <int>
1:      a     1     4
2:      a     3     5
3:      a     6     6
> kDT[.("a", 3)]                        # join to 2 columns
Key: <x, y>
        x     y     v
   <char> <num> <int>
1:      a     3     5
> kDT[.("a", 3:6)]                      # join 4 rows (2 missing)
        x     y     v
   <char> <int> <int>
1:      a     3     5
2:      a     4    NA
3:      a     5    NA
4:      a     6     6
> kDT[.("a", 3:6), nomatch=NULL]        # remove missing
Key: <x, y>
        x     y     v
   <char> <int> <int>
1:      a     3     5
2:      a     6     6
> kDT[.("a", 3:6), roll=TRUE]           # locf rolling join
        x     y     v
   <char> <int> <int>
1:      a     3     5
2:      a     4     5
3:      a     5     5
4:      a     6     6
> kDT[.("a", 3:6), roll=Inf]            # same as above
        x     y     v
   <char> <int> <int>
1:      a     3     5
2:      a     4     5
3:      a     5     5
4:      a     6     6
> kDT[.("a", 3:6), roll=-Inf]           # nocb rolling join
        x     y     v
   <char> <int> <int>
1:      a     3     5
2:      a     4     6
3:      a     5     6
4:      a     6     6
> kDT[!.("a")]                          # not join
Key: <x, y>
        x     y     v
   <char> <num> <int>
1:      b     1     1
2:      b     3     2
3:      b     6     3
4:      c     1     7
5:      c     3     8
6:      c     6     9
> kDT[!"a"]                             # same
Key: <x, y>
        x     y     v
   <char> <num> <int>
1:      b     1     1
2:      b     3     2
3:      b     6     3
4:      c     1     7
5:      c     3     8
6:      c     6     9
> 
> # more on special symbols, see also ?"special-symbols"
> DT[.N]                                  # last row
        x     y     v
   <char> <num> <int>
1:      c     6     9
> DT[, .N]                                # total number of rows in DT
[1] 9
> DT[, .N, by=x]                          # number of rows in each group
        x     N
   <char> <int>
1:      b     3
2:      a     3
3:      c     3
> DT[, .SD, .SDcols=x:y]                  # select columns 'x' through 'y'
Index: <x>
        x     y
   <char> <num>
1:      b     1
2:      b     3
3:      b     6
4:      a     1
5:      a     3
6:      a     6
7:      c     1
8:      c     3
9:      c     6
> DT[ , .SD, .SDcols = !x:y]              # drop columns 'x' through 'y'
       v
   <int>
1:     1
2:     2
3:     3
4:     4
5:     5
6:     6
7:     7
8:     8
9:     9
> DT[ , .SD, .SDcols = patterns('^[xv]')] # select columns matching '^x' or '^v'
Index: <x>
        x     v
   <char> <int>
1:      b     1
2:      b     2
3:      b     3
4:      a     4
5:      a     5
6:      a     6
7:      c     7
8:      c     8
9:      c     9
> DT[, .SD[1]]                            # first row of all columns
        x     y     v
   <char> <num> <int>
1:      b     1     1
> DT[, .SD[1], by=x]                      # first row of 'y' and 'v' for each group in 'x'
        x     y     v
   <char> <num> <int>
1:      b     1     1
2:      a     1     4
3:      c     1     7
> DT[, c(.N, lapply(.SD, sum)), by=x]     # get rows *and* sum columns 'v' and 'y' by group
        x     N     y     v
   <char> <int> <num> <int>
1:      b     3    10     6
2:      a     3    10    15
3:      c     3    10    24
> DT[, .I[1], by=x]                       # row number in DT corresponding to each group
        x    V1
   <char> <int>
1:      b     1
2:      a     4
3:      c     7
> DT[, grp := .GRP, by=x]                 # add a group counter column
> DT[ , dput(.BY), by=.(x,y)]             # .BY is a list of singletons for each group
list(x = "b", y = 1)
list(x = "b", y = 3)
list(x = "b", y = 6)
list(x = "a", y = 1)
list(x = "a", y = 3)
list(x = "a", y = 6)
list(x = "c", y = 1)
list(x = "c", y = 3)
list(x = "c", y = 6)
        x     y      x     y
   <char> <num> <char> <num>
1:      b     1      b     1
2:      b     3      b     3
3:      b     6      b     6
4:      a     1      a     1
5:      a     3      a     3
6:      a     6      a     6
7:      c     1      c     1
8:      c     3      c     3
9:      c     6      c     6
> X[, DT[.BY, y, on="x"], by=x]           # join within each group
        x    V1
   <char> <num>
1:      c     1
2:      c     3
3:      c     6
4:      b     1
5:      b     3
6:      b     6
> DT[, {
+   # write each group to a different file
+   fwrite(.SD, file.path(tempdir(), paste0('x=', .BY$x, '.csv')))
+ }, by=x]
Empty data.table (0 rows and 1 cols): x
> dir(tempdir())
[1] "x=a.csv" "x=b.csv" "x=c.csv"
> 
> # add/update/delete by reference (see ?assign)
> print(DT[, z:=42L])                   # add new column by reference
Index: <x>
        x     y     v   grp     z
   <char> <num> <int> <int> <int>
1:      b     1     1     1    42
2:      b     3     2     1    42
3:      b     6     3     1    42
4:      a     1     4     2    42
5:      a     3     5     2    42
6:      a     6     6     2    42
7:      c     1     7     3    42
8:      c     3     8     3    42
9:      c     6     9     3    42
> print(DT[, z:=NULL])                  # remove column by reference
Index: <x>
        x     y     v   grp
   <char> <num> <int> <int>
1:      b     1     1     1
2:      b     3     2     1
3:      b     6     3     1
4:      a     1     4     2
5:      a     3     5     2
6:      a     6     6     2
7:      c     1     7     3
8:      c     3     8     3
9:      c     6     9     3
> print(DT["a", v:=42L, on="x"])        # subassign to existing v column by reference
Index: <x>
        x     y     v   grp
   <char> <num> <int> <int>
1:      b     1     1     1
2:      b     3     2     1
3:      b     6     3     1
4:      a     1    42     2
5:      a     3    42     2
6:      a     6    42     2
7:      c     1     7     3
8:      c     3     8     3
9:      c     6     9     3
> print(DT["b", v2:=84L, on="x"])       # subassign to new column by reference (NA padded)
Index: <x>
        x     y     v   grp    v2
   <char> <num> <int> <int> <int>
1:      b     1     1     1    84
2:      b     3     2     1    84
3:      b     6     3     1    84
4:      a     1    42     2    NA
5:      a     3    42     2    NA
6:      a     6    42     2    NA
7:      c     1     7     3    NA
8:      c     3     8     3    NA
9:      c     6     9     3    NA
> 
> DT[, m:=mean(v), by=x][]              # add new column by reference by group
Index: <x>
        x     y     v   grp    v2     m
   <char> <num> <int> <int> <int> <num>
1:      b     1     1     1    84     2
2:      b     3     2     1    84     2
3:      b     6     3     1    84     2
4:      a     1    42     2    NA    42
5:      a     3    42     2    NA    42
6:      a     6    42     2    NA    42
7:      c     1     7     3    NA     8
8:      c     3     8     3    NA     8
9:      c     6     9     3    NA     8
>                                       # NB: postfix [] is shortcut to print()
> # advanced usage
> DT = data.table(x=rep(c("b","a","c"),each=3), v=c(1,1,1,2,2,1,1,2,2), y=c(1,3,6), a=1:9, b=9:1)
> 
> DT[, sum(v), by=.(y%%2)]              # expressions in by
       y    V1
   <num> <num>
1:     1     9
2:     0     4
> DT[, sum(v), by=.(bool = y%%2)]       # same, using a named list to change by column name
    bool    V1
   <num> <num>
1:     1     9
2:     0     4
> DT[, .SD[2], by=x]                    # get 2nd row of each group
        x     v     y     a     b
   <char> <num> <num> <int> <int>
1:      b     1     3     2     8
2:      a     2     3     5     5
3:      c     2     3     8     2
> DT[, tail(.SD,2), by=x]               # last 2 rows of each group
        x     v     y     a     b
   <char> <num> <num> <int> <int>
1:      b     1     3     2     8
2:      b     1     6     3     7
3:      a     2     3     5     5
4:      a     1     6     6     4
5:      c     2     3     8     2
6:      c     2     6     9     1
> DT[, lapply(.SD, sum), by=x]          # sum of all (other) columns for each group
        x     v     y     a     b
   <char> <num> <num> <int> <int>
1:      b     3    10     6    24
2:      a     5    10    15    15
3:      c     5    10    24     6
> DT[, .SD[which.min(v)], by=x]         # nested query by group
        x     v     y     a     b
   <char> <num> <num> <int> <int>
1:      b     1     1     1     9
2:      a     1     6     6     4
3:      c     1     1     7     3
> 
> DT[, list(MySum=sum(v),
+           MyMin=min(v),
+           MyMax=max(v)),
+     by=.(x, y%%2)]                    # by 2 expressions
        x     y MySum MyMin MyMax
   <char> <num> <num> <num> <num>
1:      b     1     2     1     1
2:      b     0     1     1     1
3:      a     1     4     2     2
4:      a     0     1     1     1
5:      c     1     3     1     2
6:      c     0     2     2     2
> 
> DT[, .(a = .(a), b = .(b)), by=x]     # list columns
        x      a      b
   <char> <list> <list>
1:      b  1,2,3  9,8,7
2:      a  4,5,6  6,5,4
3:      c  7,8,9  3,2,1
> DT[, .(seq = min(a):max(b)), by=x]    # j is not limited to just aggregations
         x   seq
    <char> <int>
 1:      b     1
 2:      b     2
 3:      b     3
 4:      b     4
 5:      b     5
 6:      b     6
 7:      b     7
 8:      b     8
 9:      b     9
10:      a     4
11:      a     5
12:      a     6
13:      c     7
14:      c     6
15:      c     5
16:      c     4
17:      c     3
> DT[, sum(v), by=x][V1<20]             # compound query
        x    V1
   <char> <num>
1:      b     3
2:      a     5
3:      c     5
> DT[, sum(v), by=x][order(-V1)]        # ordering results
        x    V1
   <char> <num>
1:      a     5
2:      c     5
3:      b     3
> DT[, c(.N, lapply(.SD,sum)), by=x]    # get number of observations and sum per group
        x     N     v     y     a     b
   <char> <int> <num> <num> <int> <int>
1:      b     3     3    10     6    24
2:      a     3     5    10    15    15
3:      c     3     5    10    24     6
> DT[, {tmp <- mean(y);
+       .(a = a-tmp, b = b-tmp)
+       }, by=x]                        # anonymous lambda in 'j', j accepts any valid
        x          a          b
   <char>      <num>      <num>
1:      b -2.3333333  5.6666667
2:      b -1.3333333  4.6666667
3:      b -0.3333333  3.6666667
4:      a  0.6666667  2.6666667
5:      a  1.6666667  1.6666667
6:      a  2.6666667  0.6666667
7:      c  3.6666667 -0.3333333
8:      c  4.6666667 -1.3333333
9:      c  5.6666667 -2.3333333
>                                       # expression. TO REMEMBER: every element of
>                                       # the list becomes a column in result.
> pdf("new.pdf")
> DT[, plot(a,b), by=x]                 # can also plot in 'j'
Empty data.table (0 rows and 1 cols): x
> dev.off()
pdf 
  2 
> ## Don't show: 
> file.remove("new.pdf")
[1] TRUE
> ## End(Don't show)
> 
> # using rleid, get max(y) and min of all cols in .SDcols for each consecutive run of 'v'
> DT[, c(.(y=max(y)), lapply(.SD, min)), by=rleid(v), .SDcols=v:b]
   rleid     y     v     y     a     b
   <int> <num> <num> <num> <int> <int>
1:     1     6     1     1     1     7
2:     2     3     2     1     4     5
3:     3     6     1     1     6     3
4:     4     6     2     3     8     1
> 
> # Support guide and links:
> # https://github.com/Rdatatable/data.table/wiki/Support
> 
> ## Not run: 
> ##D if (interactive()) {
> ##D   vignette(package="data.table")  # 9 vignettes
> ##D 
> ##D   test.data.table()               # 6,000 tests
> ##D 
> ##D   # keep up to date with latest stable version on CRAN
> ##D   update.packages()
> ##D 
> ##D   # get the latest devel version that has passed all tests
> ##D   update_dev_pkg()
> ##D   # read more at:
> ##D   # https://github.com/Rdatatable/data.table/wiki/Installation
> ##D }
> ## End(Not run)
> 
> 
> cleanEx()
> nameEx("datatable-optimize")
> ### * datatable-optimize
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: datatable.optimize
> ### Title: Optimisations in data.table
> ### Aliases: datatable-optimize datatable.optimize data.table-optimize
> ###   data.table.optimize gforce GForce autoindex autoindexing auto-index
> ###   auto-indexing rounding
> ### Keywords: data
> 
> ### ** Examples
> 
> ## Not run: 
> ##D old = options(datatable.optimize = Inf)
> ##D 
> ##D # Generate a big data.table with a relatively many columns
> ##D set.seed(1L)
> ##D DT = lapply(1:20, function(x) sample(c(-100:100), 5e6L, TRUE))
> ##D setDT(DT)[, id := sample(1e5, 5e6, TRUE)]
> ##D print(object.size(DT), units="Mb") # 400MB, not huge, but will do
> ##D 
> ##D # 'order' optimisation
> ##D options(datatable.optimize = 1L) # optimisation 'on'
> ##D system.time(ans1 <- DT[order(id)])
> ##D options(datatable.optimize = 0L) # optimisation 'off'
> ##D system.time(ans2 <- DT[order(id)])
> ##D identical(ans1, ans2)
> ##D 
> ##D # optimisation of 'lapply(.SD, fun)'
> ##D options(datatable.optimize = 1L) # optimisation 'on'
> ##D system.time(ans1 <- DT[, lapply(.SD, min), by=id])
> ##D options(datatable.optimize = 0L) # optimisation 'off'
> ##D system.time(ans2 <- DT[, lapply(.SD, min), by=id])
> ##D identical(ans1, ans2)
> ##D 
> ##D # optimisation of 'mean'
> ##D options(datatable.optimize = 1L) # optimisation 'on'
> ##D system.time(ans1 <- DT[, lapply(.SD, mean), by=id])
> ##D system.time(ans2 <- DT[, lapply(.SD, base::mean), by=id])
> ##D identical(ans1, ans2)
> ##D 
> ##D # optimisation of 'c(.N, lapply(.SD, ))'
> ##D options(datatable.optimize = 1L) # optimisation 'on'
> ##D system.time(ans1 <- DT[, c(.N, lapply(.SD, min)), by=id])
> ##D options(datatable.optimize = 0L) # optimisation 'off'
> ##D system.time(ans2 <- DT[, c(N=.N, lapply(.SD, min)), by=id])
> ##D identical(ans1, ans2)
> ##D 
> ##D # GForce
> ##D options(datatable.optimize = 2L) # optimisation 'on'
> ##D system.time(ans1 <- DT[, lapply(.SD, median), by=id])
> ##D system.time(ans2 <- DT[, lapply(.SD, function(x) as.numeric(stats::median(x))), by=id])
> ##D identical(ans1, ans2)
> ##D 
> ##D # optimized subsets
> ##D options(datatable.optimize = 2L)
> ##D system.time(ans1 <- DT[id == 100L]) # vector scan
> ##D system.time(ans2 <- DT[id == 100L]) # vector scan
> ##D system.time(DT[id %in% 100:500])    # vector scan
> ##D 
> ##D options(datatable.optimize = 3L)
> ##D system.time(ans1 <- DT[id == 100L]) # index + binary search subset
> ##D system.time(ans2 <- DT[id == 100L]) # only binary search subset
> ##D system.time(DT[id %in% 100:500])    # only binary search subset again
> ##D 
> ##D # sensitivity to collate order
> ##D old_lc_collate = Sys.getlocale("LC_COLLATE")
> ##D 
> ##D if (old_lc_collate == "C") {
> ##D   Sys.setlocale("LC_COLLATE", "")
> ##D }
> ##D DT = data.table(
> ##D   grp = rep(1:2, each = 4L),
> ##D   var = c("A", "a", "0", "1", "B", "b", "0", "1")
> ##D )
> ##D options(datatable.optimize = Inf)
> ##D DT[, .(max(var), min(var)), by=grp]
> ##D # GForce is deactivated because of the ad-hoc column 'tolower(var)',
> ##D #   through which the result for 'max(var)' may also change
> ##D DT[, .(max(var), min(tolower(var))), by=grp]
> ##D 
> ##D Sys.setlocale("LC_COLLATE", old_lc_collate)
> ##D options(old)
> ## End(Not run)
> 
> 
> cleanEx()
> nameEx("dcast.data.table")
> ### * dcast.data.table
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: dcast.data.table
> ### Title: Fast dcast for data.table
> ### Aliases: dcast.data.table dcast
> ### Keywords: data
> 
> ### ** Examples
> 
> ChickWeight = as.data.table(ChickWeight)
> setnames(ChickWeight, tolower(names(ChickWeight)))
> DT <- melt(as.data.table(ChickWeight), id.vars=2:4) # calls melt.data.table
> 
> # dcast is an S3 method in data.table from v1.9.6
> dcast(DT, time ~ variable, fun.aggregate=mean)
Key: <time>
     time    weight
    <num>     <num>
 1:     0  41.06000
 2:     2  49.22000
 3:     4  59.95918
 4:     6  74.30612
 5:     8  91.24490
 6:    10 107.83673
 7:    12 129.24490
 8:    14 143.81250
 9:    16 168.08511
10:    18 190.19149
11:    20 209.71739
12:    21 218.68889
> dcast(DT, diet ~ variable, fun.aggregate=mean)
Key: <diet>
     diet   weight
   <fctr>    <num>
1:      1 102.6455
2:      2 122.6167
3:      3 142.9500
4:      4 135.2627
> dcast(DT, diet+chick ~ time, drop=FALSE)
Key: <diet, chick>
       diet chick     0     2     4     6     8    10    12    14    16    18
     <fctr> <ord> <num> <num> <num> <num> <num> <num> <num> <num> <num> <num>
  1:      1    18    39    35    NA    NA    NA    NA    NA    NA    NA    NA
  2:      1    16    41    45    49    51    57    51    54    NA    NA    NA
  3:      1    15    41    49    56    64    68    68    67    68    NA    NA
  4:      1    13    41    48    53    60    65    67    71    70    71    81
  5:      1     9    42    51    59    68    85    96    90    92    93   100
 ---                                                                         
196:      4    49    40    53    64    85   108   128   152   166   184   203
197:      4    46    40    52    62    82   101   120   144   156   173   210
198:      4    50    41    54    67    84   105   122   155   175   205   234
199:      4    42    42    49    63    84   103   126   160   174   204   234
200:      4    48    39    50    62    80   104   125   154   170   222   261
        20    21
     <num> <num>
  1:    NA    NA
  2:    NA    NA
  3:    NA    NA
  4:    91    96
  5:   100    98
 ---            
196:   233   237
197:   231   238
198:   264   264
199:   269   281
200:   303   322
> dcast(DT, diet+chick ~ time, drop=FALSE, fill=0)
Key: <diet, chick>
       diet chick     0     2     4     6     8    10    12    14    16    18
     <fctr> <ord> <num> <num> <num> <num> <num> <num> <num> <num> <num> <num>
  1:      1    18    39    35     0     0     0     0     0     0     0     0
  2:      1    16    41    45    49    51    57    51    54     0     0     0
  3:      1    15    41    49    56    64    68    68    67    68     0     0
  4:      1    13    41    48    53    60    65    67    71    70    71    81
  5:      1     9    42    51    59    68    85    96    90    92    93   100
 ---                                                                         
196:      4    49    40    53    64    85   108   128   152   166   184   203
197:      4    46    40    52    62    82   101   120   144   156   173   210
198:      4    50    41    54    67    84   105   122   155   175   205   234
199:      4    42    42    49    63    84   103   126   160   174   204   234
200:      4    48    39    50    62    80   104   125   154   170   222   261
        20    21
     <num> <num>
  1:     0     0
  2:     0     0
  3:     0     0
  4:    91    96
  5:   100    98
 ---            
196:   233   237
197:   231   238
198:   264   264
199:   269   281
200:   303   322
> 
> # using subset
> dcast(DT, chick ~ time, fun.aggregate=mean, subset=.(time < 10 & chick < 20))
Key: <chick>
   chick     0     2     4     6     8
   <ord> <num> <num> <num> <num> <num>
1:    18    39    35   NaN   NaN   NaN
2:    16    41    45    49    51    57
3:    15    41    49    56    64    68
4:    13    41    48    53    60    65
5:     9    42    51    59    68    85
> 
> # drop argument, #1512
> DT <- data.table(v1 = c(1.1, 1.1, 1.1, 2.2, 2.2, 2.2),
+                  v2 = factor(c(1L, 1L, 1L, 3L, 3L, 3L), levels=1:3),
+                  v3 = factor(c(2L, 3L, 5L, 1L, 2L, 6L), levels=1:6),
+                  v4 = c(3L, 2L, 2L, 5L, 4L, 3L))
> # drop=TRUE
> dcast(DT, v1+v2~v3, value.var='v4')                      # default is drop=TRUE
Key: <v1, v2>
      v1     v2     1     2     3     5     6
   <num> <fctr> <int> <int> <int> <int> <int>
1:   1.1      1    NA     3     2     2    NA
2:   2.2      3     5     4    NA    NA     3
> dcast(DT, v1+v2~v3, value.var='v4', drop=FALSE)          # all missing combinations of LHS and RHS
Key: <v1, v2>
      v1     v2     1     2     3     4     5     6
   <num> <fctr> <int> <int> <int> <int> <int> <int>
1:   1.1      1    NA     3     2    NA     2    NA
2:   1.1      2    NA    NA    NA    NA    NA    NA
3:   1.1      3    NA    NA    NA    NA    NA    NA
4:   2.2      1    NA    NA    NA    NA    NA    NA
5:   2.2      2    NA    NA    NA    NA    NA    NA
6:   2.2      3     5     4    NA    NA    NA     3
> dcast(DT, v1+v2~v3, value.var='v4', drop=c(FALSE, TRUE)) # all missing combinations of LHS only
Key: <v1, v2>
      v1     v2     1     2     3     5     6
   <num> <fctr> <int> <int> <int> <int> <int>
1:   1.1      1    NA     3     2     2    NA
2:   1.1      2    NA    NA    NA    NA    NA
3:   1.1      3    NA    NA    NA    NA    NA
4:   2.2      1    NA    NA    NA    NA    NA
5:   2.2      2    NA    NA    NA    NA    NA
6:   2.2      3     5     4    NA    NA     3
> dcast(DT, v1+v2~v3, value.var='v4', drop=c(TRUE, FALSE)) # all missing combinations of RHS only
Key: <v1, v2>
      v1     v2     1     2     3     4     5     6
   <num> <fctr> <int> <int> <int> <int> <int> <int>
1:   1.1      1    NA     3     2    NA     2    NA
2:   2.2      3     5     4    NA    NA    NA     3
> 
> # using . and ...
> DT <- data.table(v1 = rep(1:2, each = 6),
+                  v2 = rep(rep(1:3, 2), each = 2),
+                  v3 = rep(1:2, 6),
+                  v4 = rnorm(6))
> dcast(DT, ... ~ v3, value.var="v4") # same as v1+v2 ~ v3, value.var="v4"
Key: <v1, v2>
      v1    v2          1          2
   <int> <int>      <num>      <num>
1:     1     1 -0.6264538  0.1836433
2:     1     2 -0.8356286  1.5952808
3:     1     3  0.3295078 -0.8204684
4:     2     1 -0.6264538  0.1836433
5:     2     2 -0.8356286  1.5952808
6:     2     3  0.3295078 -0.8204684
> dcast(DT, ... ~ v3, value.var="v4", value.var.in.dots=TRUE) # same as v1+v2+v4~v3, value.var="v4"
Key: <v1, v2, v4>
       v1    v2         v4          1          2
    <int> <int>      <num>      <num>      <num>
 1:     1     1 -0.6264538 -0.6264538         NA
 2:     1     1  0.1836433         NA  0.1836433
 3:     1     2 -0.8356286 -0.8356286         NA
 4:     1     2  1.5952808         NA  1.5952808
 5:     1     3 -0.8204684         NA -0.8204684
 6:     1     3  0.3295078  0.3295078         NA
 7:     2     1 -0.6264538 -0.6264538         NA
 8:     2     1  0.1836433         NA  0.1836433
 9:     2     2 -0.8356286 -0.8356286         NA
10:     2     2  1.5952808         NA  1.5952808
11:     2     3 -0.8204684         NA -0.8204684
12:     2     3  0.3295078  0.3295078         NA
> dcast(DT, v1+v2+v3 ~ ., value.var="v4")
Key: <v1, v2, v3>
       v1    v2    v3          .
    <int> <int> <int>      <num>
 1:     1     1     1 -0.6264538
 2:     1     1     2  0.1836433
 3:     1     2     1 -0.8356286
 4:     1     2     2  1.5952808
 5:     1     3     1  0.3295078
 6:     1     3     2 -0.8204684
 7:     2     1     1 -0.6264538
 8:     2     1     2  0.1836433
 9:     2     2     1 -0.8356286
10:     2     2     2  1.5952808
11:     2     3     1  0.3295078
12:     2     3     2 -0.8204684
> 
> ## for each combination of (v1, v2), add up all values of v4
> dcast(DT, v1+v2 ~ ., value.var="v4", fun.aggregate=sum)
Key: <v1, v2>
      v1    v2          .
   <int> <int>      <num>
1:     1     1 -0.4428105
2:     1     2  0.7596522
3:     1     3 -0.4909606
4:     2     1 -0.4428105
5:     2     2  0.7596522
6:     2     3 -0.4909606
> 
> # fill and types
> dcast(DT, v2~v3, value.var='v1', fun.aggregate=length, fill=0L)  #  0L --> 0
Key: <v2>
      v2     1     2
   <int> <int> <int>
1:     1     2     2
2:     2     2     2
3:     3     2     2
> dcast(DT, v2~v3, value.var='v4', fun.aggregate=length, fill=1.1) # 1.1 --> 1L
Key: <v2>
      v2     1     2
   <int> <int> <int>
1:     1     2     2
2:     2     2     2
3:     3     2     2
> 
> # multiple value.var and multiple fun.aggregate
> DT = data.table(x=sample(5,20,TRUE), y=sample(2,20,TRUE),
+                 z=sample(letters[1:2], 20,TRUE), d1=runif(20), d2=1L)
> # multiple value.var
> dcast(DT, x+y ~ z, fun.aggregate=sum, value.var=c("d1","d2"))
Key: <x, y>
       x     y      d1_a      d1_b  d2_a  d2_b
   <int> <int>     <num>     <num> <int> <int>
1:     1     1 0.7789147 0.3887929     1     2
2:     1     2 0.4346595 0.6579667     1     2
3:     2     1 0.0000000 0.6049333     0     1
4:     2     2 1.5185575 1.0824393     2     2
5:     3     2 0.8108702 0.0000000     1     0
6:     4     1 0.0000000 0.7973088     0     1
7:     4     2 0.4100841 0.0000000     1     0
8:     5     1 0.0000000 0.4589287     0     2
9:     5     2 0.1216919 1.6632653     1     3
> # multiple fun.aggregate
> dcast(DT, x+y ~ z, fun.aggregate=list(sum, mean), value.var="d1")
Key: <x, y>
       x     y  d1_sum_a  d1_sum_b d1_mean_a d1_mean_b
   <int> <int>     <num>     <num>     <num>     <num>
1:     1     1 0.7789147 0.3887929 0.7789147 0.1943964
2:     1     2 0.4346595 0.6579667 0.4346595 0.3289834
3:     2     1 0.0000000 0.6049333       NaN 0.6049333
4:     2     2 1.5185575 1.0824393 0.7592787 0.5412196
5:     3     2 0.8108702 0.0000000 0.8108702       NaN
6:     4     1 0.0000000 0.7973088       NaN 0.7973088
7:     4     2 0.4100841 0.0000000 0.4100841       NaN
8:     5     1 0.0000000 0.4589287       NaN 0.2294644
9:     5     2 0.1216919 1.6632653 0.1216919 0.5544218
> # multiple fun.agg and value.var (all combinations)
> dcast(DT, x+y ~ z, fun.aggregate=list(sum, mean), value.var=c("d1", "d2"))
Key: <x, y>
       x     y  d1_sum_a  d1_sum_b d2_sum_a d2_sum_b d1_mean_a d1_mean_b
   <int> <int>     <num>     <num>    <int>    <int>     <num>     <num>
1:     1     1 0.7789147 0.3887929        1        2 0.7789147 0.1943964
2:     1     2 0.4346595 0.6579667        1        2 0.4346595 0.3289834
3:     2     1 0.0000000 0.6049333        0        1       NaN 0.6049333
4:     2     2 1.5185575 1.0824393        2        2 0.7592787 0.5412196
5:     3     2 0.8108702 0.0000000        1        0 0.8108702       NaN
6:     4     1 0.0000000 0.7973088        0        1       NaN 0.7973088
7:     4     2 0.4100841 0.0000000        1        0 0.4100841       NaN
8:     5     1 0.0000000 0.4589287        0        2       NaN 0.2294644
9:     5     2 0.1216919 1.6632653        1        3 0.1216919 0.5544218
   d2_mean_a d2_mean_b
       <num>     <num>
1:         1         1
2:         1         1
3:       NaN         1
4:         1         1
5:         1       NaN
6:       NaN         1
7:         1       NaN
8:       NaN         1
9:         1         1
> # multiple fun.agg and value.var (one-to-one)
> dcast(DT, x+y ~ z, fun.aggregate=list(sum, mean), value.var=list("d1", "d2"))
Key: <x, y>
       x     y  d1_sum_a  d1_sum_b d2_mean_a d2_mean_b
   <int> <int>     <num>     <num>     <num>     <num>
1:     1     1 0.7789147 0.3887929         1         1
2:     1     2 0.4346595 0.6579667         1         1
3:     2     1 0.0000000 0.6049333       NaN         1
4:     2     2 1.5185575 1.0824393         1         1
5:     3     2 0.8108702 0.0000000         1       NaN
6:     4     1 0.0000000 0.7973088       NaN         1
7:     4     2 0.4100841 0.0000000         1       NaN
8:     5     1 0.0000000 0.4589287       NaN         1
9:     5     2 0.1216919 1.6632653         1         1
> 
> 
> 
> cleanEx()
> nameEx("deprecated")
> ### * deprecated
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: key<-
> ### Title: Deprecated.
> ### Aliases: key<-
> ### Keywords: internal
> 
> ### ** Examples
> 
> # dummy example section to pass release check that all .Rd files have examples
> 
> 
> 
> cleanEx()
> nameEx("duplicated")
> ### * duplicated
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: duplicated
> ### Title: Determine Duplicate Rows
> ### Aliases: duplicated duplicated.data.table unique unique.data.table
> ###   anyDuplicated anyDuplicated.data.table uniqueN
> ### Keywords: data
> 
> ### ** Examples
> 
> DT <- data.table(A = rep(1:3, each=4), B = rep(1:4, each=3),
+                   C = rep(1:2, 6), key = c("A", "B"))
> duplicated(DT)
 [1] FALSE FALSE  TRUE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE  TRUE
> unique(DT)
Key: <A, B>
        A     B     C
    <int> <int> <int>
 1:     1     1     1
 2:     1     1     2
 3:     1     2     2
 4:     2     2     1
 5:     2     2     2
 6:     2     3     1
 7:     2     3     2
 8:     3     3     1
 9:     3     4     2
10:     3     4     1
> 
> duplicated(DT, by="B")
 [1] FALSE  TRUE  TRUE FALSE  TRUE  TRUE FALSE  TRUE  TRUE FALSE  TRUE  TRUE
> unique(DT, by="B")
Key: <A, B>
       A     B     C
   <int> <int> <int>
1:     1     1     1
2:     1     2     2
3:     2     3     1
4:     3     4     2
> 
> duplicated(DT, by=c("A", "C"))
 [1] FALSE FALSE  TRUE  TRUE FALSE FALSE  TRUE  TRUE FALSE FALSE  TRUE  TRUE
> unique(DT, by=c("A", "C"))
Key: <A, B>
       A     B     C
   <int> <int> <int>
1:     1     1     1
2:     1     1     2
3:     2     2     1
4:     2     2     2
5:     3     3     1
6:     3     4     2
> 
> DT = data.table(a=c(2L,1L,2L), b=c(1L,2L,1L))   # no key
> unique(DT)                   # rows 1 and 2 (row 3 is a duplicate of row 1)
       a     b
   <int> <int>
1:     2     1
2:     1     2
> 
> DT = data.table(a=c(3.142, 4.2, 4.2, 3.142, 1.223, 1.223), b=rep(1,6))
> unique(DT)                   # rows 1,2 and 5
       a     b
   <num> <num>
1: 3.142     1
2: 4.200     1
3: 1.223     1
> 
> DT = data.table(a=tan(pi*(1/4 + 1:10)), b=rep(1,10))   # example from ?all.equal
> length(unique(DT$a))         # 10 strictly unique floating point values
[1] 10
> all.equal(DT$a,rep(1,10))    # TRUE, all within tolerance of 1.0
[1] TRUE
> DT[,which.min(a)]            # row 10, the strictly smallest floating point value
[1] 10
> identical(unique(DT),DT[1])  # TRUE, stable within tolerance
[1] FALSE
> identical(unique(DT),DT[10]) # FALSE
[1] FALSE
> 
> # fromLast = TRUE vs. FALSE
> DT <- data.table(A = c(1, 1, 2, 2, 3), B = c(1, 2, 1, 1, 2), C = c("a", "b", "a", "b", "a"))
> 
> duplicated(DT, by="B", fromLast=FALSE) # rows 3,4,5 are duplicates
[1] FALSE FALSE  TRUE  TRUE  TRUE
> unique(DT, by="B", fromLast=FALSE) # equivalent: DT[!duplicated(DT, by="B", fromLast=FALSE)]
       A     B      C
   <num> <num> <char>
1:     1     1      a
2:     1     2      b
> 
> duplicated(DT, by="B", fromLast=TRUE) # rows 1,2,3 are duplicates
[1]  TRUE  TRUE  TRUE FALSE FALSE
> unique(DT, by="B", fromLast=TRUE) # equivalent: DT[!duplicated(DT, by="B", fromLast=TRUE)]
       A     B      C
   <num> <num> <char>
1:     2     1      b
2:     3     2      a
> 
> # anyDuplicated
> anyDuplicated(DT, by=c("A", "B"))    # 3L
[1] 4
> any(duplicated(DT, by=c("A", "B")))  # TRUE
[1] TRUE
> 
> # uniqueN, unique rows on key columns
> uniqueN(DT, by = key(DT))
[1] 5
> # uniqueN, unique rows on all columns
> uniqueN(DT)
[1] 5
> # uniqueN while grouped by "A"
> DT[, .(uN=uniqueN(.SD)), by=A]
       A    uN
   <num> <int>
1:     1     2
2:     2     2
3:     3     1
> 
> # uniqueN's na.rm=TRUE
> x = sample(c(NA, NaN, runif(3)), 10, TRUE)
> uniqueN(x, na.rm = FALSE) # 5, default
[1] 4
> uniqueN(x, na.rm=TRUE) # 3
[1] 2
> 
> 
> 
> cleanEx()
> nameEx("fcase")
> ### * fcase
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: fcase
> ### Title: fcase
> ### Aliases: fcase
> ### Keywords: data
> 
> ### ** Examples
> 
> x = 1:10
> fcase(
+ 	x < 5L, 1L,
+ 	x > 5L, 3L
+ )
 [1]  1  1  1  1 NA  3  3  3  3  3
> 
> fcase(
+ 	x < 5L, 1L:10L,
+ 	x > 5L, 3L:12L
+ )
 [1]  1  2  3  4 NA  8  9 10 11 12
> 
> # Lazy evaluation example
> fcase(
+ 	x < 5L, 1L,
+ 	x >= 5L, 3L,
+ 	x == 5L, stop("provided value is an unexpected one!")
+ )
 [1] 1 1 1 1 3 3 3 3 3 3
> 
> # fcase preserves attributes, example with dates
> fcase(
+ 	x < 5L, as.Date("2019-10-11"),
+ 	x > 5L, as.Date("2019-10-14")
+ )
 [1] "2019-10-11" "2019-10-11" "2019-10-11" "2019-10-11" NA          
 [6] "2019-10-14" "2019-10-14" "2019-10-14" "2019-10-14" "2019-10-14"
> 
> # fcase example with factor; note the matching levels
> fcase(
+ 	x < 5L, factor("a", levels=letters[1:3]),
+ 	x > 5L, factor("b", levels=letters[1:3])
+ )
 [1] a    a    a    a    <NA> b    b    b    b    b   
Levels: a b c
> 
> # Example of using the 'default' argument
> fcase(
+ 	x < 5L, 1L,
+ 	x > 5L, 3L,
+ 	default = 5L
+ )
 [1] 1 1 1 1 5 3 3 3 3 3
> 
> # fcase can be used for recursion, unlike fifelse
> # Recursive function to calculate the Greatest Common Divisor
> gcd_dt = function(x,y) {
+   r = x%%y
+   fcase(!r, y, r, gcd_dt(x, y)) # Recursive call must be in the last when-value pair
+ }
> gcd_dt(10L, 1L)
[1] 1
> 
> 
> 
> cleanEx()
> nameEx("fdroplevels")
> ### * fdroplevels
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: fdroplevels
> ### Title: Fast droplevels
> ### Aliases: fdroplevels droplevels droplevels.data.table setdroplevels
> ### Keywords: data
> 
> ### ** Examples
> 
> # on vectors
> x = factor(letters[1:10])
> fdroplevels(x[1:5])
[1] a b c d e
Levels: a b c d e
> # exclude levels from drop
> fdroplevels(x[1:5], exclude = c("a", "c"))
[1] <NA> b    <NA> d    e   
Levels: b d e
> 
> # on data.table
> DT = data.table(a = factor(1:10), b = factor(letters[1:10]))
> droplevels(head(DT))[["b"]]
[1] a b c d e f
Levels: a b c d e f
> # exclude levels
> droplevels(head(DT), exclude = c("b", "c"))[["b"]]
[1] a    <NA> <NA> d    e    f   
Levels: a d e f
> # except columns from drop
> droplevels(head(DT), except = 2)[["b"]]
[1] a b c d e f
Levels: a b c d e f g h i j
> droplevels(head(DT), except = 1)[["b"]]
[1] a b c d e f
Levels: a b c d e f
> 
> 
> 
> cleanEx()
> nameEx("fifelse")
> ### * fifelse
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: fifelse
> ### Title: Fast ifelse
> ### Aliases: fifelse ifelse
> ### Keywords: data
> 
> ### ** Examples
> 
> x = c(1:4, 3:2, 1:4)
> fifelse(x > 2L, x, x - 1L)
 [1] 0 1 3 4 3 1 0 1 3 4
> 
> # unlike ifelse, fifelse preserves attributes, taken from the 'yes' argument
> dates = as.Date(c("2011-01-01","2011-01-02","2011-01-03","2011-01-04","2011-01-05"))
> ifelse(dates == "2011-01-01", dates - 1, dates)
[1] 14974 14976 14977 14978 14979
> fifelse(dates == "2011-01-01", dates - 1, dates)
[1] "2010-12-31" "2011-01-02" "2011-01-03" "2011-01-04" "2011-01-05"
> yes = factor(c("a","b","c"))
> no = yes[1L]
> ifelse(c(TRUE,FALSE,TRUE), yes, no)
[1] 1 1 3
> fifelse(c(TRUE,FALSE,TRUE), yes, no)
[1] a a c
Levels: a b c
> 
> # Example of using the 'na' argument
> fifelse(test = c(-5L:5L < 0L, NA), yes = 1L, no = 0L, na = 2L)
 [1] 1 1 1 1 1 0 0 0 0 0 0 2
> 
> # Example showing both 'yes' and 'no' arguments are evaluated, unlike ifelse
> fifelse(1 == 1, print("yes"), print("no"))
[1] "yes"
[1] "no"
[1] "yes"
> ifelse(1 == 1, print("yes"), print("no"))
[1] "yes"
[1] "yes"
> 
> 
> 
> cleanEx()
> nameEx("foverlaps")
> ### * foverlaps
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: foverlaps
> ### Title: Fast overlap joins
> ### Aliases: foverlaps
> ### Keywords: data
> 
> ### ** Examples
> 
> require(data.table)
> ## simple example:
> x = data.table(start=c(5,31,22,16), end=c(8,50,25,18), val2 = 7:10)
> y = data.table(start=c(10, 20, 30), end=c(15, 35, 45), val1 = 1:3)
> setkey(y, start, end)
> foverlaps(x, y, type="any", which=TRUE) ## return overlap indices
     xid   yid
   <int> <int>
1:     1    NA
2:     2     2
3:     2     3
4:     3     2
5:     4    NA
> foverlaps(x, y, type="any") ## return overlap join
   start   end  val1 i.start i.end  val2
   <num> <num> <int>   <num> <num> <int>
1:    NA    NA    NA       5     8     7
2:    20    35     2      31    50     8
3:    30    45     3      31    50     8
4:    20    35     2      22    25     9
5:    NA    NA    NA      16    18    10
> foverlaps(x, y, type="any", mult="first") ## returns only first match
   start   end  val1 i.start i.end  val2
   <num> <num> <int>   <num> <num> <int>
1:    NA    NA    NA       5     8     7
2:    20    35     2      31    50     8
3:    20    35     2      22    25     9
4:    NA    NA    NA      16    18    10
> foverlaps(x, y, type="within") ## matches iff 'x' is within 'y'
   start   end  val1 i.start i.end  val2
   <num> <num> <int>   <num> <num> <int>
1:    NA    NA    NA       5     8     7
2:    NA    NA    NA      31    50     8
3:    20    35     2      22    25     9
4:    NA    NA    NA      16    18    10
> 
> ## with extra identifiers (ex: in genomics)
> x = data.table(chr=c("Chr1", "Chr1", "Chr2", "Chr2", "Chr2"),
+                start=c(5,10, 1, 25, 50), end=c(11,20,4,52,60))
> y = data.table(chr=c("Chr1", "Chr1", "Chr2"), start=c(1, 15,1),
+                end=c(4, 18, 55), geneid=letters[1:3])
> setkey(y, chr, start, end)
> foverlaps(x, y, type="any", which=TRUE)
     xid   yid
   <int> <int>
1:     1    NA
2:     2     2
3:     3     3
4:     4     3
5:     5     3
> foverlaps(x, y, type="any")
      chr start   end geneid i.start i.end
   <char> <num> <num> <char>   <num> <num>
1:   Chr1    NA    NA   <NA>       5    11
2:   Chr1    15    18      b      10    20
3:   Chr2     1    55      c       1     4
4:   Chr2     1    55      c      25    52
5:   Chr2     1    55      c      50    60
> foverlaps(x, y, type="any", nomatch=NULL)
      chr start   end geneid i.start i.end
   <char> <num> <num> <char>   <num> <num>
1:   Chr1    15    18      b      10    20
2:   Chr2     1    55      c       1     4
3:   Chr2     1    55      c      25    52
4:   Chr2     1    55      c      50    60
> foverlaps(x, y, type="within", which=TRUE)
     xid   yid
   <int> <int>
1:     1    NA
2:     2    NA
3:     3     3
4:     4     3
5:     5    NA
> foverlaps(x, y, type="within")
      chr start   end geneid i.start i.end
   <char> <num> <num> <char>   <num> <num>
1:   Chr1    NA    NA   <NA>       5    11
2:   Chr1    NA    NA   <NA>      10    20
3:   Chr2     1    55      c       1     4
4:   Chr2     1    55      c      25    52
5:   Chr2    NA    NA   <NA>      50    60
> foverlaps(x, y, type="start")
      chr start   end geneid i.start i.end
   <char> <num> <num> <char>   <num> <num>
1:   Chr1    NA    NA   <NA>       5    11
2:   Chr1    NA    NA   <NA>      10    20
3:   Chr2     1    55      c       1     4
4:   Chr2    NA    NA   <NA>      25    52
5:   Chr2    NA    NA   <NA>      50    60
> 
> ## x and y have different column names - specify by.x
> x = data.table(seq=c("Chr1", "Chr1", "Chr2", "Chr2", "Chr2"),
+                start=c(5,10, 1, 25, 50), end=c(11,20,4,52,60))
> y = data.table(chr=c("Chr1", "Chr1", "Chr2"), start=c(1, 15,1),
+                end=c(4, 18, 55), geneid=letters[1:3])
> setkey(y, chr, start, end)
> foverlaps(x, y, by.x=c("seq", "start", "end"),
+             type="any", which=TRUE)
     xid   yid
   <int> <int>
1:     1    NA
2:     2     2
3:     3     3
4:     4     3
5:     5     3
> 
> 
> 
> cleanEx()
> nameEx("frank")
> ### * frank
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: frank
> ### Title: Fast rank
> ### Aliases: frank frankv rank
> ### Keywords: data
> 
> ### ** Examples
> 
> # on vectors
> x = c(4, 1, 4, NA, 1, NA, 4)
> # NAs are considered identical (unlike base R)
> # default is average
> frankv(x) # na.last=TRUE
[1] 4.0 1.5 4.0 6.5 1.5 6.5 4.0
> frankv(x, na.last=FALSE)
[1] 6.0 3.5 6.0 1.5 3.5 1.5 6.0
> 
> # ties.method = min
> frankv(x, ties.method="min")
[1] 3 1 3 6 1 6 3
> # ties.method = dense
> frankv(x, ties.method="dense")
[1] 2 1 2 3 1 3 2
> 
> # on data.table
> DT = data.table(x, y=c(1, 1, 1, 0, NA, 0, 2))
> frankv(DT, cols="x") # same as frankv(x) from before
[1] 4.0 1.5 4.0 6.5 1.5 6.5 4.0
> frankv(DT, cols="x", na.last="keep")
[1] 4.0 1.5 4.0  NA 1.5  NA 4.0
> frankv(DT, cols="x", ties.method="dense", na.last=NA)
[1] 2 1 2 1 2
> frank(DT, x, ties.method="dense", na.last=NA) # equivalent of above using frank
[1] 2 1 2 1 2
> # on both columns
> frankv(DT, ties.method="first", na.last="keep")
[1]  2  1  3 NA NA NA  4
> frank(DT, ties.method="first", na.last="keep") # equivalent of above using frank
[1]  2  1  3 NA NA NA  4
> 
> # order argument
> frank(DT, x, -y, ties.method="first")
[1] 4 1 5 6 2 7 3
> # equivalent of above using frankv
> frankv(DT, order=c(1L, -1L), ties.method="first")
[1] 4 1 5 6 2 7 3
> 
> 
> 
> cleanEx()
> nameEx("fread")
> ### * fread
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: fread
> ### Title: Fast and friendly file finagler
> ### Aliases: fread
> ### Keywords: data
> 
> ### ** Examples
> 
> # Reads text input directly :
> fread("A,B\n1,2\n3,4")
       A     B
   <int> <int>
1:     1     2
2:     3     4
> 
> # Reads pasted input directly :
> fread("A,B
+ 1,2
+ 3,4
+ ")
       A     B
   <int> <int>
1:     1     2
2:     3     4
> 
> # Finds the first data line automatically :
> fread("
+ This is perhaps a banner line or two or ten.
+ A,B
+ 1,2
+ 3,4
+ ")
       A     B
   <int> <int>
1:     1     2
2:     3     4
> 
> # Detects whether column names are present automatically :
> fread("
+ 1,2
+ 3,4
+ ")
      V1    V2
   <int> <int>
1:     1     2
2:     3     4
> 
> # Numerical precision :
> 
> DT = fread("A\n1.010203040506070809010203040506\n")
> # TODO: add numerals=c("allow.loss", "warn.loss", "no.loss") from base::read.table, +"use.Rmpfr"
> typeof(DT$A)=="double"   # currently "allow.loss" with no option
[1] TRUE
> 
> DT = fread("A\n1.46761e-313\n")   # read as 'numeric'
> DT[,sprintf("%.15E",A)]   # beyond what double precision can store accurately to 15 digits
[1] "1.467610000018072E-313"
> # For greater accuracy use colClasses to read as character, then package Rmpfr.
> 
> # colClasses
> data = "A,B,C,D\n1,3,5,7\n2,4,6,8\n"
> fread(data, colClasses=c(B="character",C="character",D="character"))  # as read.csv
       A      B      C      D
   <int> <char> <char> <char>
1:     1      3      5      7
2:     2      4      6      8
> fread(data, colClasses=list(character=c("B","C","D")))    # saves typing
       A      B      C      D
   <int> <char> <char> <char>
1:     1      3      5      7
2:     2      4      6      8
> fread(data, colClasses=list(character=2:4))     # same using column numbers
       A      B      C      D
   <int> <char> <char> <char>
1:     1      3      5      7
2:     2      4      6      8
> 
> # drop
> fread(data, colClasses=c("B"="NULL","C"="NULL"))   # as read.csv
       A     D
   <int> <int>
1:     1     7
2:     2     8
> fread(data, colClasses=list(NULL=c("B","C")))      #
       A     D
   <int> <int>
1:     1     7
2:     2     8
> fread(data, drop=c("B","C"))      # same but less typing, easier to read
       A     D
   <int> <int>
1:     1     7
2:     2     8
> fread(data, drop=2:3)             # same using column numbers
       A     D
   <int> <int>
1:     1     7
2:     2     8
> 
> # select
> # (in read.csv you need to work out which to drop)
> fread(data, select=c("A","D"))    # less typing, easier to read
       A     D
   <int> <int>
1:     1     7
2:     2     8
> fread(data, select=c(1,4))        # same using column numbers
       A     D
   <int> <int>
1:     1     7
2:     2     8
> 
> # select and types combined
> fread(data, select=c(A="numeric", D="character"))
       A      D
   <num> <char>
1:     1      7
2:     2      8
> fread(data, select=list(numeric="A", character="D"))
       A      D
   <num> <char>
1:     1      7
2:     2      8
> 
> # skip blank lines
> fread("a,b\n1,a\n2,b\n\n\n3,c\n", blank.lines.skip=TRUE)
       a      b
   <int> <char>
1:     1      a
2:     2      b
3:     3      c
> # fill
> fread("a,b\n1,a\n2\n3,c\n", fill=TRUE)
       a      b
   <int> <char>
1:     1      a
2:     2       
3:     3      c
> fread("a,b\n\n1,a\n2\n\n3,c\n\n", fill=TRUE)
       a      b
   <int> <char>
1:    NA       
2:     1      a
3:     2       
4:    NA       
5:     3      c
6:    NA       
> 
> # fill with skip blank lines
> fread("a,b\n\n1,a\n2\n\n3,c\n\n", fill=TRUE, blank.lines.skip=TRUE)
       a      b
   <int> <char>
1:     1      a
2:     2       
3:     3      c
> 
> # check.names usage
> fread("a b,a b\n1,2\n")
     a b   a b
   <int> <int>
1:     1     2
> fread("a b,a b\n1,2\n", check.names=TRUE) # no duplicates + syntactically valid names
     a.b a.b.1
   <int> <int>
1:     1     2
> 
> ## Not run: 
> ##D # Demo speed-up
> ##D n = 1e6
> ##D DT = data.table( a=sample(1:1000,n,replace=TRUE),
> ##D                  b=sample(1:1000,n,replace=TRUE),
> ##D                  c=rnorm(n),
> ##D                  d=sample(c("foo","bar","baz","qux","quux"),n,replace=TRUE),
> ##D                  e=rnorm(n),
> ##D                  f=sample(1:1000,n,replace=TRUE) )
> ##D DT[2,b:=NA_integer_]
> ##D DT[4,c:=NA_real_]
> ##D DT[3,d:=NA_character_]
> ##D DT[5,d:=""]
> ##D DT[2,e:=+Inf]
> ##D DT[3,e:=-Inf]
> ##D 
> ##D write.table(DT,"test.csv",sep=",",row.names=FALSE,quote=FALSE)
> ##D cat("File size (MB):", round(file.info("test.csv")$size/1024^2),"\n")
> ##D # 50 MB (1e6 rows x 6 columns)
> ##D 
> ##D system.time(DF1 <-read.csv("test.csv",stringsAsFactors=FALSE))
> ##D # 5.4 sec (first time in fresh R session)
> ##D 
> ##D system.time(DF1 <- read.csv("test.csv",stringsAsFactors=FALSE))
> ##D # 3.9 sec (immediate repeat is faster, varies)
> ##D 
> ##D system.time(DF2 <- read.table("test.csv",header=TRUE,sep=",",quote="",
> ##D     stringsAsFactors=FALSE,comment.char="",nrows=n,
> ##D     colClasses=c("integer","integer","numeric",
> ##D                  "character","numeric","integer")))
> ##D # 1.2 sec (consistently). All known tricks and known nrows, see references.
> ##D 
> ##D system.time(DT <- fread("test.csv"))
> ##D # 0.1 sec (faster and friendlier)
> ##D 
> ##D identical(DF1, DF2)
> ##D all.equal(as.data.table(DF1), DT)
> ##D 
> ##D # Scaling up ...
> ##D l = vector("list",10)
> ##D for (i in 1:10) l[[i]] = DT
> ##D DTbig = rbindlist(l)
> ##D tables()
> ##D write.table(DTbig,"testbig.csv",sep=",",row.names=FALSE,quote=FALSE)
> ##D # 500MB csv (10 million rows x 6 columns)
> ##D 
> ##D system.time(DF <- read.table("testbig.csv",header=TRUE,sep=",",
> ##D     quote="",stringsAsFactors=FALSE,comment.char="",nrows=1e7,
> ##D     colClasses=c("integer","integer","numeric",
> ##D                  "character","numeric","integer")))
> ##D # 17.0 sec (varies)
> ##D 
> ##D system.time(DT <- fread("testbig.csv"))
> ##D #  0.8 sec
> ##D 
> ##D all(mapply(all.equal, DF, DT))
> ##D 
> ##D # Reads URLs directly :
> ##D fread("https://www.stats.ox.ac.uk/pub/datasets/csb/ch11b.dat")
> ##D 
> ##D # Decompresses .gz and .bz2 automatically :
> ##D fread("https://github.com/Rdatatable/data.table/raw/1.14.0/inst/tests/ch11b.dat.bz2")
> ##D 
> ##D fread("https://github.com/Rdatatable/data.table/raw/1.14.0/inst/tests/issue_785_fread.txt.gz")
> ##D 
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("froll")
> ### * froll
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: roll
> ### Title: Rolling functions
> ### Aliases: roll froll rolling sliding moving rollmean frollmean rollsum
> ###   frollsum rollapply frollapply
> ### Keywords: data
> 
> ### ** Examples
> 
> d = as.data.table(list(1:6/2, 3:8/4))
> # rollmean of single vector and single window
> frollmean(d[, V1], 3)
[1]  NA  NA 1.0 1.5 2.0 2.5
> # multiple columns at once
> frollmean(d, 3)
[[1]]
[1]  NA  NA 1.0 1.5 2.0 2.5

[[2]]
[1]   NA   NA 1.00 1.25 1.50 1.75

> # multiple windows at once
> frollmean(d[, .(V1)], c(3, 4))
[[1]]
[1]  NA  NA 1.0 1.5 2.0 2.5

[[2]]
[1]   NA   NA   NA 1.25 1.75 2.25

> # multiple columns and multiple windows at once
> frollmean(d, c(3, 4))
[[1]]
[1]  NA  NA 1.0 1.5 2.0 2.5

[[2]]
[1]   NA   NA   NA 1.25 1.75 2.25

[[3]]
[1]   NA   NA 1.00 1.25 1.50 1.75

[[4]]
[1]    NA    NA    NA 1.125 1.375 1.625

> ## three calls above will use multiple cores when available
> 
> # partial window using adaptive rolling function
> an = function(n, len) c(seq.int(n), rep(n, len-n))
> n = an(3, nrow(d))
> frollmean(d, n, adaptive=TRUE)
[[1]]
[1] 0.50 0.75 1.00 1.50 2.00 2.50

[[2]]
[1] 0.750 0.875 1.000 1.250 1.500 1.750

> 
> # frollsum
> frollsum(d, 3:4)
[[1]]
[1]  NA  NA 3.0 4.5 6.0 7.5

[[2]]
[1] NA NA NA  5  7  9

[[3]]
[1]   NA   NA 3.00 3.75 4.50 5.25

[[4]]
[1]  NA  NA  NA 4.5 5.5 6.5

> 
> # frollapply
> frollapply(d, 3:4, sum)
[[1]]
[1]  NA  NA 3.0 4.5 6.0 7.5

[[2]]
[1] NA NA NA  5  7  9

[[3]]
[1]   NA   NA 3.00 3.75 4.50 5.25

[[4]]
[1]  NA  NA  NA 4.5 5.5 6.5

> f = function(x, ...) if (sum(x, ...)>5) min(x, ...) else max(x, ...)
> frollapply(d, 3:4, f, na.rm=TRUE)
[[1]]
[1]  NA  NA 1.5 2.0 1.5 2.0

[[2]]
[1]  NA  NA  NA 2.0 1.0 1.5

[[3]]
[1]   NA   NA 1.25 1.50 1.75 1.50

[[4]]
[1]   NA   NA   NA 1.50 1.00 1.25

> 
> # performance vs exactness
> set.seed(108)
> x = sample(c(rnorm(1e3, 1e6, 5e5), 5e9, 5e-9))
> n = 15
> ma = function(x, n, na.rm=FALSE) {
+   ans = rep(NA_real_, nx<-length(x))
+   for (i in n:nx) ans[i] = mean(x[(i-n+1):i], na.rm=na.rm)
+   ans
+ }
> fastma = function(x, n, na.rm) {
+   if (!missing(na.rm)) stop("NAs are unsupported, wrongly propagated by cumsum")
+   cs = cumsum(x)
+   scs = shift(cs, n)
+   scs[n] = 0
+   as.double((cs-scs)/n)
+ }
> system.time(ans1<-ma(x, n))
   user  system elapsed 
  0.007   0.000   0.007 
> system.time(ans2<-fastma(x, n))
   user  system elapsed 
      0       0       0 
> system.time(ans3<-frollmean(x, n))
   user  system elapsed 
      0       0       0 
> system.time(ans4<-frollmean(x, n, algo="exact"))
   user  system elapsed 
      0       0       0 
> system.time(ans5<-frollapply(x, n, mean))
   user  system elapsed 
  0.002   0.000   0.002 
> anserr = list(
+   fastma = ans2-ans1,
+   froll_fast = ans3-ans1,
+   froll_exact = ans4-ans1,
+   frollapply = ans5-ans1
+ )
> errs = sapply(lapply(anserr, abs), sum, na.rm=TRUE)
> sapply(errs, format, scientific=FALSE) # roundoff
            fastma         froll_fast        froll_exact         frollapply 
   "0.00001287466" "0.00000001833541"                "0"                "0" 
> 
> # frollapply corner cases
> f = function(x) head(x, 2)     ## FUN returns non length 1
> try(frollapply(1:5, 3, f))
Error in frollapply(1:5, 3, f) : 
  frollapply: results from provided FUN are not length 1
> f = function(x) {              ## FUN sometimes returns non length 1
+   n = length(x)
+   # length 1 will be returned only for first iteration where we check length
+   if (n==x[n]) x[1L] else range(x) # range(x)[2L] is silently ignored!
+ }
> frollapply(1:5, 3, f)
[1] NA NA  1  2  3
> options(datatable.verbose=TRUE)
> x = c(1,2,1,1,1,2,3,2)
> frollapply(x, 3, uniqueN)     ## FUN returns integer
frollapplyR: allocating memory for results 1x1
forderReuseSorting: opt not possible: is.data.table(DT)=0, sortGroups=1, all1(ascArg)=1
forder.c received 3 rows and 1 columns
forderReuseSorting: opt=0, took 0.000s
frollapply: results from provided FUN are not of type double, coercion from integer or logical will be applied on each iteration
forderReuseSorting: opt not possible: is.data.table(DT)=0, sortGroups=1, all1(ascArg)=1
forder.c received 3 rows and 1 columns
forderReuseSorting: opt=0, took 0.000s
forderReuseSorting: opt not possible: is.data.table(DT)=0, sortGroups=1, all1(ascArg)=1
forder.c received 3 rows and 1 columns
forderReuseSorting: opt=0, took 0.000s
forderReuseSorting: opt not possible: is.data.table(DT)=0, sortGroups=1, all1(ascArg)=1
forder.c received 3 rows and 1 columns
forderReuseSorting: opt=0, took 0.000s
forderReuseSorting: opt not possible: is.data.table(DT)=0, sortGroups=1, all1(ascArg)=1
forder.c received 3 rows and 1 columns
forderReuseSorting: opt=0, took 0.000s
forderReuseSorting: opt not possible: is.data.table(DT)=0, sortGroups=1, all1(ascArg)=1
forder.c received 3 rows and 1 columns
forderReuseSorting: opt=0, took 0.000s
frollapply: took 0.000s
frollapplyR: processing of 1 column(s) and 1 window(s) took 0.000s
[1] NA NA  2  2  1  2  3  2
> numUniqueN = function(x) as.numeric(uniqueN(x))
> frollapply(x, 3, numUniqueN)
frollapplyR: allocating memory for results 1x1
forderReuseSorting: opt not possible: is.data.table(DT)=0, sortGroups=1, all1(ascArg)=1
forder.c received 3 rows and 1 columns
forderReuseSorting: opt=0, took 0.000s
forderReuseSorting: opt not possible: is.data.table(DT)=0, sortGroups=1, all1(ascArg)=1
forder.c received 3 rows and 1 columns
forderReuseSorting: opt=0, took 0.000s
forderReuseSorting: opt not possible: is.data.table(DT)=0, sortGroups=1, all1(ascArg)=1
forder.c received 3 rows and 1 columns
forderReuseSorting: opt=0, took 0.000s
forderReuseSorting: opt not possible: is.data.table(DT)=0, sortGroups=1, all1(ascArg)=1
forder.c received 3 rows and 1 columns
forderReuseSorting: opt=0, took 0.000s
forderReuseSorting: opt not possible: is.data.table(DT)=0, sortGroups=1, all1(ascArg)=1
forder.c received 3 rows and 1 columns
forderReuseSorting: opt=0, took 0.000s
forderReuseSorting: opt not possible: is.data.table(DT)=0, sortGroups=1, all1(ascArg)=1
forder.c received 3 rows and 1 columns
forderReuseSorting: opt=0, took 0.000s
frollapply: took 0.001s
frollapplyR: processing of 1 column(s) and 1 window(s) took 0.001s
[1] NA NA  2  2  1  2  3  2
> x = c(1,2,1,1,NA,2,NA,2)
> frollapply(x, 3, anyNA)       ## FUN returns logical
frollapplyR: allocating memory for results 1x1
frollapply: results from provided FUN are not of type double, coercion from integer or logical will be applied on each iteration
frollapply: took 0.000s
frollapplyR: processing of 1 column(s) and 1 window(s) took 0.000s
[1] NA NA  0  0  1  1  1  1
> as.logical(frollapply(x, 3, anyNA))
frollapplyR: allocating memory for results 1x1
frollapply: results from provided FUN are not of type double, coercion from integer or logical will be applied on each iteration
frollapply: took 0.000s
frollapplyR: processing of 1 column(s) and 1 window(s) took 0.000s
[1]    NA    NA FALSE FALSE  TRUE  TRUE  TRUE  TRUE
> options(datatable.verbose=FALSE)
> f = function(x) {             ## FUN returns character
+   if (sum(x)>5) "big" else "small"
+ }
> try(frollapply(1:5, 3, f))
Error in frollapply(1:5, 3, f) : 
  frollapply: results from provided FUN are not of type double
> f = function(x) {             ## FUN is not type-stable
+   n = length(x)
+   # double type will be returned only for first iteration where we check type
+   if (n==x[n]) 1 else NA # NA logical turns into garbage without coercion to double
+ }
> try(frollapply(1:5, 3, f))
Error in frollapply(1:5, 3, f) : 
  REAL() can only be applied to a 'numeric', not a 'logical'
> 
> 
> 
> cleanEx()
> nameEx("fsort")
> ### * fsort
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: fsort
> ### Title: Fast parallel sort
> ### Aliases: fsort
> 
> ### ** Examples
> 
> x = runif(1e6)
> system.time(ans1 <- sort(x, method="quick"))
   user  system elapsed 
  0.080   0.005   0.085 
> system.time(ans2 <- fsort(x))
   user  system elapsed 
  0.097   0.009   0.020 
> identical(ans1, ans2)
[1] TRUE
> 
> 
> 
> cleanEx()
> nameEx("fwrite")
> ### * fwrite
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: fwrite
> ### Title: Fast CSV writer
> ### Aliases: fwrite
> ### Keywords: data
> 
> ### ** Examples
> 
> 
> DF = data.frame(A=1:3, B=c("foo","A,Name","baz"))
> fwrite(DF)
A,B
1,foo
2,"A,Name"
3,baz
> write.csv(DF, row.names=FALSE, quote=FALSE)  # same
A,B
1,foo
2,A,Name
3,baz
> 
> fwrite(DF, row.names=TRUE, quote=TRUE)
"","A","B"
"1",1,"foo"
"2",2,"A,Name"
"3",3,"baz"
> write.csv(DF)                                # same
"","A","B"
"1",1,"foo"
"2",2,"A,Name"
"3",3,"baz"
> 
> DF = data.frame(A=c(2.1,-1.234e-307,pi), B=c("foo","A,Name","bar"))
> fwrite(DF, quote='auto')        # Just DF[2,2] is auto quoted
A,B
2.1,foo
-1.234e-307,"A,Name"
3.14159265358979,bar
> write.csv(DF, row.names=FALSE)  # same numeric formatting
"A","B"
2.1,"foo"
-1.234e-307,"A,Name"
3.14159265358979,"bar"
> 
> DT = data.table(A=c(2,5.6,-3),B=list(1:3,c("foo","A,Name","bar"),round(pi*1:3,2)))
> fwrite(DT)
A,B
2,1|2|3
5.6,foo|"A,Name"|bar
-3,3.14|6.28|9.42
> fwrite(DT, sep="|", sep2=c("{",",","}"))
A|B
2|{1,2,3}
5.6|{foo,"A,Name",bar}
-3|{3.14,6.28,9.42}
> 
> ## Not run: 
> ##D 
> ##D set.seed(1)
> ##D DT = as.data.table( lapply(1:10, sample,
> ##D          x=as.numeric(1:5e7), size=5e6))                            #     382MB
> ##D system.time(fwrite(DT, "/dev/shm/tmp1.csv"))                        #      0.8s
> ##D system.time(write.csv(DT, "/dev/shm/tmp2.csv",                      #     60.6s
> ##D                       quote=FALSE, row.names=FALSE))
> ##D system("diff /dev/shm/tmp1.csv /dev/shm/tmp2.csv")                  # identical
> ##D 
> ##D set.seed(1)
> ##D N = 1e7
> ##D DT = data.table(
> ##D   str1=sample(sprintf("%010d",sample(N,1e5,replace=TRUE)), N, replace=TRUE),
> ##D   str2=sample(sprintf("%09d",sample(N,1e5,replace=TRUE)), N, replace=TRUE),
> ##D   str3=sample(sapply(sample(2:30, 100, TRUE), function(n)
> ##D      paste0(sample(LETTERS, n, TRUE), collapse="")), N, TRUE),
> ##D   str4=sprintf("%05d",sample(sample(1e5,50),N,TRUE)),
> ##D   num1=sample(round(rnorm(1e6,mean=6.5,sd=15),2), N, replace=TRUE),
> ##D   num2=sample(round(rnorm(1e6,mean=6.5,sd=15),10), N, replace=TRUE),
> ##D   str5=sample(c("Y","N"),N,TRUE),
> ##D   str6=sample(c("M","F"),N,TRUE),
> ##D   int1=sample(ceiling(rexp(1e6)), N, replace=TRUE),
> ##D   int2=sample(N,N,replace=TRUE)-N/2
> ##D )                                                                   #     774MB
> ##D system.time(fwrite(DT,"/dev/shm/tmp1.csv"))                         #      1.1s
> ##D system.time(write.csv(DT,"/dev/shm/tmp2.csv",                       #     63.2s
> ##D                       row.names=FALSE, quote=FALSE))
> ##D system("diff /dev/shm/tmp1.csv /dev/shm/tmp2.csv")                  # identical
> ##D 
> ##D unlink("/dev/shm/tmp1.csv")
> ##D unlink("/dev/shm/tmp2.csv")
> ## End(Not run)
> 
> 
> 
> 
> cleanEx()
> nameEx("groupingsets")
> ### * groupingsets
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: groupingsets
> ### Title: Grouping Set aggregation for data tables
> ### Aliases: rollup cube groupingsets rollup.data.table cube.data.table
> ###   groupingsets.data.table
> ### Keywords: data
> 
> ### ** Examples
> 
> n = 24L
> set.seed(25)
> DT <- data.table(
+     color = sample(c("green","yellow","red"), n, TRUE),
+     year = as.Date(sample(paste0(2011:2015,"-01-01"), n, TRUE)),
+     status = as.factor(sample(c("removed","active","inactive","archived"), n, TRUE)),
+     amount = sample(1:5, n, TRUE),
+     value = sample(c(3, 3.5, 2.5, 2), n, TRUE)
+ )
> 
> # rollup
> by_vars = c("color", "year", "status")
> rollup(DT, j=sum(value), by=by_vars) # default id=FALSE
     color       year   status    V1
    <char>     <Date>   <fctr> <num>
 1:    red 2015-01-01   active   3.5
 2:  green 2015-01-01 inactive   5.5
 3:  green 2014-01-01 archived   3.5
 4:  green 2015-01-01 archived   2.0
 5: yellow 2014-01-01   active   4.5
 6:    red 2013-01-01 inactive   2.0
 7:  green 2011-01-01   active   6.0
 8:    red 2014-01-01 inactive   2.5
 9:  green 2011-01-01 archived   2.5
10: yellow 2015-01-01   active   2.0
11:    red 2012-01-01 archived   2.0
12:    red 2011-01-01  removed   3.5
13:  green 2014-01-01 inactive   8.0
14:  green 2011-01-01  removed   2.0
15: yellow 2012-01-01 archived   2.5
16:    red 2013-01-01  removed   3.5
17:  green 2013-01-01   active   3.0
18:  green 2014-01-01  removed   2.5
19:    red 2011-01-01 archived   3.0
20:    red 2015-01-01     <NA>   3.5
21:  green 2015-01-01     <NA>   7.5
22:  green 2014-01-01     <NA>  14.0
23: yellow 2014-01-01     <NA>   4.5
24:    red 2013-01-01     <NA>   5.5
25:  green 2011-01-01     <NA>  10.5
26:    red 2014-01-01     <NA>   2.5
27: yellow 2015-01-01     <NA>   2.0
28:    red 2012-01-01     <NA>   2.0
29:    red 2011-01-01     <NA>   6.5
30: yellow 2012-01-01     <NA>   2.5
31:  green 2013-01-01     <NA>   3.0
32:    red       <NA>     <NA>  20.0
33:  green       <NA>     <NA>  35.0
34: yellow       <NA>     <NA>   9.0
35:   <NA>       <NA>     <NA>  64.0
     color       year   status    V1
> rollup(DT, j=sum(value), by=by_vars, id=TRUE)
    grouping  color       year   status    V1
       <int> <char>     <Date>   <fctr> <num>
 1:        0    red 2015-01-01   active   3.5
 2:        0  green 2015-01-01 inactive   5.5
 3:        0  green 2014-01-01 archived   3.5
 4:        0  green 2015-01-01 archived   2.0
 5:        0 yellow 2014-01-01   active   4.5
 6:        0    red 2013-01-01 inactive   2.0
 7:        0  green 2011-01-01   active   6.0
 8:        0    red 2014-01-01 inactive   2.5
 9:        0  green 2011-01-01 archived   2.5
10:        0 yellow 2015-01-01   active   2.0
11:        0    red 2012-01-01 archived   2.0
12:        0    red 2011-01-01  removed   3.5
13:        0  green 2014-01-01 inactive   8.0
14:        0  green 2011-01-01  removed   2.0
15:        0 yellow 2012-01-01 archived   2.5
16:        0    red 2013-01-01  removed   3.5
17:        0  green 2013-01-01   active   3.0
18:        0  green 2014-01-01  removed   2.5
19:        0    red 2011-01-01 archived   3.0
20:        1    red 2015-01-01     <NA>   3.5
21:        1  green 2015-01-01     <NA>   7.5
22:        1  green 2014-01-01     <NA>  14.0
23:        1 yellow 2014-01-01     <NA>   4.5
24:        1    red 2013-01-01     <NA>   5.5
25:        1  green 2011-01-01     <NA>  10.5
26:        1    red 2014-01-01     <NA>   2.5
27:        1 yellow 2015-01-01     <NA>   2.0
28:        1    red 2012-01-01     <NA>   2.0
29:        1    red 2011-01-01     <NA>   6.5
30:        1 yellow 2012-01-01     <NA>   2.5
31:        1  green 2013-01-01     <NA>   3.0
32:        3    red       <NA>     <NA>  20.0
33:        3  green       <NA>     <NA>  35.0
34:        3 yellow       <NA>     <NA>   9.0
35:        7   <NA>       <NA>     <NA>  64.0
    grouping  color       year   status    V1
> rollup(DT, j=lapply(.SD, sum), by=by_vars, id=TRUE, .SDcols="value")
    grouping  color       year   status value
       <int> <char>     <Date>   <fctr> <num>
 1:        0    red 2015-01-01   active   3.5
 2:        0  green 2015-01-01 inactive   5.5
 3:        0  green 2014-01-01 archived   3.5
 4:        0  green 2015-01-01 archived   2.0
 5:        0 yellow 2014-01-01   active   4.5
 6:        0    red 2013-01-01 inactive   2.0
 7:        0  green 2011-01-01   active   6.0
 8:        0    red 2014-01-01 inactive   2.5
 9:        0  green 2011-01-01 archived   2.5
10:        0 yellow 2015-01-01   active   2.0
11:        0    red 2012-01-01 archived   2.0
12:        0    red 2011-01-01  removed   3.5
13:        0  green 2014-01-01 inactive   8.0
14:        0  green 2011-01-01  removed   2.0
15:        0 yellow 2012-01-01 archived   2.5
16:        0    red 2013-01-01  removed   3.5
17:        0  green 2013-01-01   active   3.0
18:        0  green 2014-01-01  removed   2.5
19:        0    red 2011-01-01 archived   3.0
20:        1    red 2015-01-01     <NA>   3.5
21:        1  green 2015-01-01     <NA>   7.5
22:        1  green 2014-01-01     <NA>  14.0
23:        1 yellow 2014-01-01     <NA>   4.5
24:        1    red 2013-01-01     <NA>   5.5
25:        1  green 2011-01-01     <NA>  10.5
26:        1    red 2014-01-01     <NA>   2.5
27:        1 yellow 2015-01-01     <NA>   2.0
28:        1    red 2012-01-01     <NA>   2.0
29:        1    red 2011-01-01     <NA>   6.5
30:        1 yellow 2012-01-01     <NA>   2.5
31:        1  green 2013-01-01     <NA>   3.0
32:        3    red       <NA>     <NA>  20.0
33:        3  green       <NA>     <NA>  35.0
34:        3 yellow       <NA>     <NA>   9.0
35:        7   <NA>       <NA>     <NA>  64.0
    grouping  color       year   status value
> rollup(DT, j=c(list(count=.N), lapply(.SD, sum)), by=by_vars, id=TRUE)
    grouping  color       year   status count amount value
       <int> <char>     <Date>   <fctr> <int>  <int> <num>
 1:        0    red 2015-01-01   active     1      4   3.5
 2:        0  green 2015-01-01 inactive     2      5   5.5
 3:        0  green 2014-01-01 archived     1      3   3.5
 4:        0  green 2015-01-01 archived     1      4   2.0
 5:        0 yellow 2014-01-01   active     2      5   4.5
 6:        0    red 2013-01-01 inactive     1      1   2.0
 7:        0  green 2011-01-01   active     2      9   6.0
 8:        0    red 2014-01-01 inactive     1      5   2.5
 9:        0  green 2011-01-01 archived     1      4   2.5
10:        0 yellow 2015-01-01   active     1      4   2.0
11:        0    red 2012-01-01 archived     1      4   2.0
12:        0    red 2011-01-01  removed     1      1   3.5
13:        0  green 2014-01-01 inactive     3      7   8.0
14:        0  green 2011-01-01  removed     1      4   2.0
15:        0 yellow 2012-01-01 archived     1      1   2.5
16:        0    red 2013-01-01  removed     1      3   3.5
17:        0  green 2013-01-01   active     1      2   3.0
18:        0  green 2014-01-01  removed     1      5   2.5
19:        0    red 2011-01-01 archived     1      1   3.0
20:        1    red 2015-01-01     <NA>     1      4   3.5
21:        1  green 2015-01-01     <NA>     3      9   7.5
22:        1  green 2014-01-01     <NA>     5     15  14.0
23:        1 yellow 2014-01-01     <NA>     2      5   4.5
24:        1    red 2013-01-01     <NA>     2      4   5.5
25:        1  green 2011-01-01     <NA>     4     17  10.5
26:        1    red 2014-01-01     <NA>     1      5   2.5
27:        1 yellow 2015-01-01     <NA>     1      4   2.0
28:        1    red 2012-01-01     <NA>     1      4   2.0
29:        1    red 2011-01-01     <NA>     2      2   6.5
30:        1 yellow 2012-01-01     <NA>     1      1   2.5
31:        1  green 2013-01-01     <NA>     1      2   3.0
32:        3    red       <NA>     <NA>     7     19  20.0
33:        3  green       <NA>     <NA>    13     43  35.0
34:        3 yellow       <NA>     <NA>     4     10   9.0
35:        7   <NA>       <NA>     <NA>    24     72  64.0
    grouping  color       year   status count amount value
> rollup(DT, j=sum(value), by=by_vars,
+        # specify label by variable name
+        label=list(color="total", year=as.Date("3000-01-01"), status=factor("total")))
     color       year   status    V1
    <char>     <Date>   <fctr> <num>
 1:    red 2015-01-01   active   3.5
 2:  green 2015-01-01 inactive   5.5
 3:  green 2014-01-01 archived   3.5
 4:  green 2015-01-01 archived   2.0
 5: yellow 2014-01-01   active   4.5
 6:    red 2013-01-01 inactive   2.0
 7:  green 2011-01-01   active   6.0
 8:    red 2014-01-01 inactive   2.5
 9:  green 2011-01-01 archived   2.5
10: yellow 2015-01-01   active   2.0
11:    red 2012-01-01 archived   2.0
12:    red 2011-01-01  removed   3.5
13:  green 2014-01-01 inactive   8.0
14:  green 2011-01-01  removed   2.0
15: yellow 2012-01-01 archived   2.5
16:    red 2013-01-01  removed   3.5
17:  green 2013-01-01   active   3.0
18:  green 2014-01-01  removed   2.5
19:    red 2011-01-01 archived   3.0
20:    red 2015-01-01    total   3.5
21:  green 2015-01-01    total   7.5
22:  green 2014-01-01    total  14.0
23: yellow 2014-01-01    total   4.5
24:    red 2013-01-01    total   5.5
25:  green 2011-01-01    total  10.5
26:    red 2014-01-01    total   2.5
27: yellow 2015-01-01    total   2.0
28:    red 2012-01-01    total   2.0
29:    red 2011-01-01    total   6.5
30: yellow 2012-01-01    total   2.5
31:  green 2013-01-01    total   3.0
32:    red 3000-01-01    total  20.0
33:  green 3000-01-01    total  35.0
34: yellow 3000-01-01    total   9.0
35:  total 3000-01-01    total  64.0
     color       year   status    V1
> rollup(DT, j=sum(value), by=by_vars,
+        # specify label by variable name and first element of class
+        label=list(color="total", Date=as.Date("3000-01-01"), factor=factor("total")))
     color       year   status    V1
    <char>     <Date>   <fctr> <num>
 1:    red 2015-01-01   active   3.5
 2:  green 2015-01-01 inactive   5.5
 3:  green 2014-01-01 archived   3.5
 4:  green 2015-01-01 archived   2.0
 5: yellow 2014-01-01   active   4.5
 6:    red 2013-01-01 inactive   2.0
 7:  green 2011-01-01   active   6.0
 8:    red 2014-01-01 inactive   2.5
 9:  green 2011-01-01 archived   2.5
10: yellow 2015-01-01   active   2.0
11:    red 2012-01-01 archived   2.0
12:    red 2011-01-01  removed   3.5
13:  green 2014-01-01 inactive   8.0
14:  green 2011-01-01  removed   2.0
15: yellow 2012-01-01 archived   2.5
16:    red 2013-01-01  removed   3.5
17:  green 2013-01-01   active   3.0
18:  green 2014-01-01  removed   2.5
19:    red 2011-01-01 archived   3.0
20:    red 2015-01-01    total   3.5
21:  green 2015-01-01    total   7.5
22:  green 2014-01-01    total  14.0
23: yellow 2014-01-01    total   4.5
24:    red 2013-01-01    total   5.5
25:  green 2011-01-01    total  10.5
26:    red 2014-01-01    total   2.5
27: yellow 2015-01-01    total   2.0
28:    red 2012-01-01    total   2.0
29:    red 2011-01-01    total   6.5
30: yellow 2012-01-01    total   2.5
31:  green 2013-01-01    total   3.0
32:    red 3000-01-01    total  20.0
33:  green 3000-01-01    total  35.0
34: yellow 3000-01-01    total   9.0
35:  total 3000-01-01    total  64.0
     color       year   status    V1
> # label is character scalar so applies to color only
> rollup(DT, j=sum(value), by=by_vars, label="total")
     color       year   status    V1
    <char>     <Date>   <fctr> <num>
 1:    red 2015-01-01   active   3.5
 2:  green 2015-01-01 inactive   5.5
 3:  green 2014-01-01 archived   3.5
 4:  green 2015-01-01 archived   2.0
 5: yellow 2014-01-01   active   4.5
 6:    red 2013-01-01 inactive   2.0
 7:  green 2011-01-01   active   6.0
 8:    red 2014-01-01 inactive   2.5
 9:  green 2011-01-01 archived   2.5
10: yellow 2015-01-01   active   2.0
11:    red 2012-01-01 archived   2.0
12:    red 2011-01-01  removed   3.5
13:  green 2014-01-01 inactive   8.0
14:  green 2011-01-01  removed   2.0
15: yellow 2012-01-01 archived   2.5
16:    red 2013-01-01  removed   3.5
17:  green 2013-01-01   active   3.0
18:  green 2014-01-01  removed   2.5
19:    red 2011-01-01 archived   3.0
20:    red 2015-01-01     <NA>   3.5
21:  green 2015-01-01     <NA>   7.5
22:  green 2014-01-01     <NA>  14.0
23: yellow 2014-01-01     <NA>   4.5
24:    red 2013-01-01     <NA>   5.5
25:  green 2011-01-01     <NA>  10.5
26:    red 2014-01-01     <NA>   2.5
27: yellow 2015-01-01     <NA>   2.0
28:    red 2012-01-01     <NA>   2.0
29:    red 2011-01-01     <NA>   6.5
30: yellow 2012-01-01     <NA>   2.5
31:  green 2013-01-01     <NA>   3.0
32:    red       <NA>     <NA>  20.0
33:  green       <NA>     <NA>  35.0
34: yellow       <NA>     <NA>   9.0
35:  total       <NA>     <NA>  64.0
     color       year   status    V1
> rollup(DT, j=.N, by=c("color", "year", "status", "value"),
+        # label can be explicitly specified as NA or NaN
+        label = list(color=NA_character_, year=as.Date(NA), status=factor(NA), value=NaN))
     color       year   status value     N
    <char>     <Date>   <fctr> <num> <int>
 1:    red 2015-01-01   active   3.5     1
 2:  green 2015-01-01 inactive   3.5     1
 3:  green 2014-01-01 archived   3.5     1
 4:  green 2015-01-01 archived   2.0     1
 5:  green 2015-01-01 inactive   2.0     1
 6: yellow 2014-01-01   active   2.5     1
 7:    red 2013-01-01 inactive   2.0     1
 8: yellow 2014-01-01   active   2.0     1
 9:  green 2011-01-01   active   3.5     1
10:    red 2014-01-01 inactive   2.5     1
11:  green 2011-01-01 archived   2.5     1
12: yellow 2015-01-01   active   2.0     1
13:    red 2012-01-01 archived   2.0     1
14:    red 2011-01-01  removed   3.5     1
15:  green 2014-01-01 inactive   3.0     2
16:  green 2011-01-01  removed   2.0     1
17: yellow 2012-01-01 archived   2.5     1
18:  green 2011-01-01   active   2.5     1
19:    red 2013-01-01  removed   3.5     1
20:  green 2014-01-01 inactive   2.0     1
21:  green 2013-01-01   active   3.0     1
22:  green 2014-01-01  removed   2.5     1
23:    red 2011-01-01 archived   3.0     1
24:    red 2015-01-01   active   NaN     1
25:  green 2015-01-01 inactive   NaN     2
26:  green 2014-01-01 archived   NaN     1
27:  green 2015-01-01 archived   NaN     1
28: yellow 2014-01-01   active   NaN     2
29:    red 2013-01-01 inactive   NaN     1
30:  green 2011-01-01   active   NaN     2
31:    red 2014-01-01 inactive   NaN     1
32:  green 2011-01-01 archived   NaN     1
33: yellow 2015-01-01   active   NaN     1
34:    red 2012-01-01 archived   NaN     1
35:    red 2011-01-01  removed   NaN     1
36:  green 2014-01-01 inactive   NaN     3
37:  green 2011-01-01  removed   NaN     1
38: yellow 2012-01-01 archived   NaN     1
39:    red 2013-01-01  removed   NaN     1
40:  green 2013-01-01   active   NaN     1
41:  green 2014-01-01  removed   NaN     1
42:    red 2011-01-01 archived   NaN     1
43:    red 2015-01-01     <NA>   NaN     1
44:  green 2015-01-01     <NA>   NaN     3
45:  green 2014-01-01     <NA>   NaN     5
46: yellow 2014-01-01     <NA>   NaN     2
47:    red 2013-01-01     <NA>   NaN     2
48:  green 2011-01-01     <NA>   NaN     4
49:    red 2014-01-01     <NA>   NaN     1
50: yellow 2015-01-01     <NA>   NaN     1
51:    red 2012-01-01     <NA>   NaN     1
52:    red 2011-01-01     <NA>   NaN     2
53: yellow 2012-01-01     <NA>   NaN     1
54:  green 2013-01-01     <NA>   NaN     1
55:    red       <NA>     <NA>   NaN     7
56:  green       <NA>     <NA>   NaN    13
57: yellow       <NA>     <NA>   NaN     4
58:   <NA>       <NA>     <NA>   NaN    24
     color       year   status value     N
> 
> # cube
> cube(DT, j = sum(value), by = c("color","year","status"), id=TRUE)
    grouping  color       year   status    V1
       <int> <char>     <Date>   <fctr> <num>
 1:        0    red 2015-01-01   active   3.5
 2:        0  green 2015-01-01 inactive   5.5
 3:        0  green 2014-01-01 archived   3.5
 4:        0  green 2015-01-01 archived   2.0
 5:        0 yellow 2014-01-01   active   4.5
 6:        0    red 2013-01-01 inactive   2.0
 7:        0  green 2011-01-01   active   6.0
 8:        0    red 2014-01-01 inactive   2.5
 9:        0  green 2011-01-01 archived   2.5
10:        0 yellow 2015-01-01   active   2.0
11:        0    red 2012-01-01 archived   2.0
12:        0    red 2011-01-01  removed   3.5
13:        0  green 2014-01-01 inactive   8.0
14:        0  green 2011-01-01  removed   2.0
15:        0 yellow 2012-01-01 archived   2.5
16:        0    red 2013-01-01  removed   3.5
17:        0  green 2013-01-01   active   3.0
18:        0  green 2014-01-01  removed   2.5
19:        0    red 2011-01-01 archived   3.0
20:        1    red 2015-01-01     <NA>   3.5
21:        1  green 2015-01-01     <NA>   7.5
22:        1  green 2014-01-01     <NA>  14.0
23:        1 yellow 2014-01-01     <NA>   4.5
24:        1    red 2013-01-01     <NA>   5.5
25:        1  green 2011-01-01     <NA>  10.5
26:        1    red 2014-01-01     <NA>   2.5
27:        1 yellow 2015-01-01     <NA>   2.0
28:        1    red 2012-01-01     <NA>   2.0
29:        1    red 2011-01-01     <NA>   6.5
30:        1 yellow 2012-01-01     <NA>   2.5
31:        1  green 2013-01-01     <NA>   3.0
32:        2    red       <NA>   active   3.5
33:        2  green       <NA> inactive  13.5
34:        2  green       <NA> archived   8.0
35:        2 yellow       <NA>   active   6.5
36:        2    red       <NA> inactive   4.5
37:        2  green       <NA>   active   9.0
38:        2    red       <NA> archived   5.0
39:        2    red       <NA>  removed   7.0
40:        2  green       <NA>  removed   4.5
41:        2 yellow       <NA> archived   2.5
42:        3    red       <NA>     <NA>  20.0
43:        3  green       <NA>     <NA>  35.0
44:        3 yellow       <NA>     <NA>   9.0
45:        4   <NA> 2015-01-01   active   5.5
46:        4   <NA> 2015-01-01 inactive   5.5
47:        4   <NA> 2014-01-01 archived   3.5
48:        4   <NA> 2015-01-01 archived   2.0
49:        4   <NA> 2014-01-01   active   4.5
50:        4   <NA> 2013-01-01 inactive   2.0
51:        4   <NA> 2011-01-01   active   6.0
52:        4   <NA> 2014-01-01 inactive  10.5
53:        4   <NA> 2011-01-01 archived   5.5
54:        4   <NA> 2012-01-01 archived   4.5
55:        4   <NA> 2011-01-01  removed   5.5
56:        4   <NA> 2013-01-01  removed   3.5
57:        4   <NA> 2013-01-01   active   3.0
58:        4   <NA> 2014-01-01  removed   2.5
59:        5   <NA> 2015-01-01     <NA>  13.0
60:        5   <NA> 2014-01-01     <NA>  21.0
61:        5   <NA> 2013-01-01     <NA>   8.5
62:        5   <NA> 2011-01-01     <NA>  17.0
63:        5   <NA> 2012-01-01     <NA>   4.5
64:        6   <NA>       <NA>   active  19.0
65:        6   <NA>       <NA> inactive  18.0
66:        6   <NA>       <NA> archived  15.5
67:        6   <NA>       <NA>  removed  11.5
68:        7   <NA>       <NA>     <NA>  64.0
    grouping  color       year   status    V1
> cube(DT, j = lapply(.SD, sum), by = c("color","year","status"), id=TRUE, .SDcols="value")
    grouping  color       year   status value
       <int> <char>     <Date>   <fctr> <num>
 1:        0    red 2015-01-01   active   3.5
 2:        0  green 2015-01-01 inactive   5.5
 3:        0  green 2014-01-01 archived   3.5
 4:        0  green 2015-01-01 archived   2.0
 5:        0 yellow 2014-01-01   active   4.5
 6:        0    red 2013-01-01 inactive   2.0
 7:        0  green 2011-01-01   active   6.0
 8:        0    red 2014-01-01 inactive   2.5
 9:        0  green 2011-01-01 archived   2.5
10:        0 yellow 2015-01-01   active   2.0
11:        0    red 2012-01-01 archived   2.0
12:        0    red 2011-01-01  removed   3.5
13:        0  green 2014-01-01 inactive   8.0
14:        0  green 2011-01-01  removed   2.0
15:        0 yellow 2012-01-01 archived   2.5
16:        0    red 2013-01-01  removed   3.5
17:        0  green 2013-01-01   active   3.0
18:        0  green 2014-01-01  removed   2.5
19:        0    red 2011-01-01 archived   3.0
20:        1    red 2015-01-01     <NA>   3.5
21:        1  green 2015-01-01     <NA>   7.5
22:        1  green 2014-01-01     <NA>  14.0
23:        1 yellow 2014-01-01     <NA>   4.5
24:        1    red 2013-01-01     <NA>   5.5
25:        1  green 2011-01-01     <NA>  10.5
26:        1    red 2014-01-01     <NA>   2.5
27:        1 yellow 2015-01-01     <NA>   2.0
28:        1    red 2012-01-01     <NA>   2.0
29:        1    red 2011-01-01     <NA>   6.5
30:        1 yellow 2012-01-01     <NA>   2.5
31:        1  green 2013-01-01     <NA>   3.0
32:        2    red       <NA>   active   3.5
33:        2  green       <NA> inactive  13.5
34:        2  green       <NA> archived   8.0
35:        2 yellow       <NA>   active   6.5
36:        2    red       <NA> inactive   4.5
37:        2  green       <NA>   active   9.0
38:        2    red       <NA> archived   5.0
39:        2    red       <NA>  removed   7.0
40:        2  green       <NA>  removed   4.5
41:        2 yellow       <NA> archived   2.5
42:        3    red       <NA>     <NA>  20.0
43:        3  green       <NA>     <NA>  35.0
44:        3 yellow       <NA>     <NA>   9.0
45:        4   <NA> 2015-01-01   active   5.5
46:        4   <NA> 2015-01-01 inactive   5.5
47:        4   <NA> 2014-01-01 archived   3.5
48:        4   <NA> 2015-01-01 archived   2.0
49:        4   <NA> 2014-01-01   active   4.5
50:        4   <NA> 2013-01-01 inactive   2.0
51:        4   <NA> 2011-01-01   active   6.0
52:        4   <NA> 2014-01-01 inactive  10.5
53:        4   <NA> 2011-01-01 archived   5.5
54:        4   <NA> 2012-01-01 archived   4.5
55:        4   <NA> 2011-01-01  removed   5.5
56:        4   <NA> 2013-01-01  removed   3.5
57:        4   <NA> 2013-01-01   active   3.0
58:        4   <NA> 2014-01-01  removed   2.5
59:        5   <NA> 2015-01-01     <NA>  13.0
60:        5   <NA> 2014-01-01     <NA>  21.0
61:        5   <NA> 2013-01-01     <NA>   8.5
62:        5   <NA> 2011-01-01     <NA>  17.0
63:        5   <NA> 2012-01-01     <NA>   4.5
64:        6   <NA>       <NA>   active  19.0
65:        6   <NA>       <NA> inactive  18.0
66:        6   <NA>       <NA> archived  15.5
67:        6   <NA>       <NA>  removed  11.5
68:        7   <NA>       <NA>     <NA>  64.0
    grouping  color       year   status value
> cube(DT, j = c(list(count=.N), lapply(.SD, sum)), by = c("color","year","status"), id=TRUE)
    grouping  color       year   status count amount value
       <int> <char>     <Date>   <fctr> <int>  <int> <num>
 1:        0    red 2015-01-01   active     1      4   3.5
 2:        0  green 2015-01-01 inactive     2      5   5.5
 3:        0  green 2014-01-01 archived     1      3   3.5
 4:        0  green 2015-01-01 archived     1      4   2.0
 5:        0 yellow 2014-01-01   active     2      5   4.5
 6:        0    red 2013-01-01 inactive     1      1   2.0
 7:        0  green 2011-01-01   active     2      9   6.0
 8:        0    red 2014-01-01 inactive     1      5   2.5
 9:        0  green 2011-01-01 archived     1      4   2.5
10:        0 yellow 2015-01-01   active     1      4   2.0
11:        0    red 2012-01-01 archived     1      4   2.0
12:        0    red 2011-01-01  removed     1      1   3.5
13:        0  green 2014-01-01 inactive     3      7   8.0
14:        0  green 2011-01-01  removed     1      4   2.0
15:        0 yellow 2012-01-01 archived     1      1   2.5
16:        0    red 2013-01-01  removed     1      3   3.5
17:        0  green 2013-01-01   active     1      2   3.0
18:        0  green 2014-01-01  removed     1      5   2.5
19:        0    red 2011-01-01 archived     1      1   3.0
20:        1    red 2015-01-01     <NA>     1      4   3.5
21:        1  green 2015-01-01     <NA>     3      9   7.5
22:        1  green 2014-01-01     <NA>     5     15  14.0
23:        1 yellow 2014-01-01     <NA>     2      5   4.5
24:        1    red 2013-01-01     <NA>     2      4   5.5
25:        1  green 2011-01-01     <NA>     4     17  10.5
26:        1    red 2014-01-01     <NA>     1      5   2.5
27:        1 yellow 2015-01-01     <NA>     1      4   2.0
28:        1    red 2012-01-01     <NA>     1      4   2.0
29:        1    red 2011-01-01     <NA>     2      2   6.5
30:        1 yellow 2012-01-01     <NA>     1      1   2.5
31:        1  green 2013-01-01     <NA>     1      2   3.0
32:        2    red       <NA>   active     1      4   3.5
33:        2  green       <NA> inactive     5     12  13.5
34:        2  green       <NA> archived     3     11   8.0
35:        2 yellow       <NA>   active     3      9   6.5
36:        2    red       <NA> inactive     2      6   4.5
37:        2  green       <NA>   active     3     11   9.0
38:        2    red       <NA> archived     2      5   5.0
39:        2    red       <NA>  removed     2      4   7.0
40:        2  green       <NA>  removed     2      9   4.5
41:        2 yellow       <NA> archived     1      1   2.5
42:        3    red       <NA>     <NA>     7     19  20.0
43:        3  green       <NA>     <NA>    13     43  35.0
44:        3 yellow       <NA>     <NA>     4     10   9.0
45:        4   <NA> 2015-01-01   active     2      8   5.5
46:        4   <NA> 2015-01-01 inactive     2      5   5.5
47:        4   <NA> 2014-01-01 archived     1      3   3.5
48:        4   <NA> 2015-01-01 archived     1      4   2.0
49:        4   <NA> 2014-01-01   active     2      5   4.5
50:        4   <NA> 2013-01-01 inactive     1      1   2.0
51:        4   <NA> 2011-01-01   active     2      9   6.0
52:        4   <NA> 2014-01-01 inactive     4     12  10.5
53:        4   <NA> 2011-01-01 archived     2      5   5.5
54:        4   <NA> 2012-01-01 archived     2      5   4.5
55:        4   <NA> 2011-01-01  removed     2      5   5.5
56:        4   <NA> 2013-01-01  removed     1      3   3.5
57:        4   <NA> 2013-01-01   active     1      2   3.0
58:        4   <NA> 2014-01-01  removed     1      5   2.5
59:        5   <NA> 2015-01-01     <NA>     5     17  13.0
60:        5   <NA> 2014-01-01     <NA>     8     25  21.0
61:        5   <NA> 2013-01-01     <NA>     3      6   8.5
62:        5   <NA> 2011-01-01     <NA>     6     19  17.0
63:        5   <NA> 2012-01-01     <NA>     2      5   4.5
64:        6   <NA>       <NA>   active     7     24  19.0
65:        6   <NA>       <NA> inactive     7     18  18.0
66:        6   <NA>       <NA> archived     6     17  15.5
67:        6   <NA>       <NA>  removed     4     13  11.5
68:        7   <NA>       <NA>     <NA>    24     72  64.0
    grouping  color       year   status count amount value
> 
> # groupingsets
> groupingsets(DT, j = c(list(count=.N), lapply(.SD, sum)), by = c("color","year","status"),
+              sets = list("color", c("year","status"), character()), id=TRUE)
    grouping  color       year   status count amount value
       <int> <char>     <Date>   <fctr> <int>  <int> <num>
 1:        3    red       <NA>     <NA>     7     19  20.0
 2:        3  green       <NA>     <NA>    13     43  35.0
 3:        3 yellow       <NA>     <NA>     4     10   9.0
 4:        4   <NA> 2015-01-01   active     2      8   5.5
 5:        4   <NA> 2015-01-01 inactive     2      5   5.5
 6:        4   <NA> 2014-01-01 archived     1      3   3.5
 7:        4   <NA> 2015-01-01 archived     1      4   2.0
 8:        4   <NA> 2014-01-01   active     2      5   4.5
 9:        4   <NA> 2013-01-01 inactive     1      1   2.0
10:        4   <NA> 2011-01-01   active     2      9   6.0
11:        4   <NA> 2014-01-01 inactive     4     12  10.5
12:        4   <NA> 2011-01-01 archived     2      5   5.5
13:        4   <NA> 2012-01-01 archived     2      5   4.5
14:        4   <NA> 2011-01-01  removed     2      5   5.5
15:        4   <NA> 2013-01-01  removed     1      3   3.5
16:        4   <NA> 2013-01-01   active     1      2   3.0
17:        4   <NA> 2014-01-01  removed     1      5   2.5
18:        7   <NA>       <NA>     <NA>    24     72  64.0
> 
> 
> 
> cleanEx()
> nameEx("last")
> ### * last
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: last
> ### Title: First/last item of an object
> ### Aliases: first last
> ### Keywords: data
> 
> ### ** Examples
> 
> first(1:5) # [1] 1
[1] 1
> x = data.table(x=1:5, y=6:10)
> first(x) # same as head(x, 1)
       x     y
   <int> <int>
1:     1     6
> 
> last(1:5) # [1] 5
[1] 5
> x = data.table(x=1:5, y=6:10)
> last(x) # same as tail(x, 1)
       x     y
   <int> <int>
1:     5    10
> 
> 
> 
> cleanEx()
> nameEx("last.updated")
> ### * last.updated
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: .Last.updated
> ### Title: Number of rows affected by last update
> ### Aliases: .Last.updated Last.updated
> ### Keywords: data
> 
> ### ** Examples
> 
> d = data.table(a=1:4, b=2:5)
> d[2:3, z:=5L]
> .Last.updated
[1] 2
> 
> # updated count takes duplicates into account #2837
> DT = data.table(a = 1L)
> DT[c(1L, 1L), a := 2:3]
> .Last.updated
[1] 2
> 
> 
> 
> cleanEx()
> nameEx("like")
> ### * like
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: like
> ### Title: Convenience function for calling grep.
> ### Aliases: like %like% %ilike% %flike% %plike%
> ### Keywords: data
> 
> ### ** Examples
> 
> DT = data.table(Name=c("Mary","George","Martha"), Salary=c(2,3,4))
> DT[Name %like% "^Mar"]
     Name Salary
   <char>  <num>
1:   Mary      2
2: Martha      4
> DT[Name %ilike% "mar"]
     Name Salary
   <char>  <num>
1:   Mary      2
2: Martha      4
> DT[Name %flike% "Mar"]
     Name Salary
   <char>  <num>
1:   Mary      2
2: Martha      4
> DT[Name %plike% "(?=Ma)(?=.*y)"]
     Name Salary
   <char>  <num>
1:   Mary      2
> 
> 
> 
> cleanEx()
> nameEx("measure")
> ### * measure
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: measure
> ### Title: Specify measure.vars via regex or separator
> ### Aliases: measure measurev
> ### Keywords: data
> 
> ### ** Examples
> 
> (two.iris = data.table(datasets::iris)[c(1,150)])
   Sepal.Length Sepal.Width Petal.Length Petal.Width   Species
          <num>       <num>        <num>       <num>    <fctr>
1:          5.1         3.5          1.4         0.2    setosa
2:          5.9         3.0          5.1         1.8 virginica
> # melt into a single value column.
> melt(two.iris, measure.vars = measure(part, dim, sep="."))
     Species   part    dim value
      <fctr> <char> <char> <num>
1:    setosa  Sepal Length   5.1
2: virginica  Sepal Length   5.9
3:    setosa  Sepal  Width   3.5
4: virginica  Sepal  Width   3.0
5:    setosa  Petal Length   1.4
6: virginica  Petal Length   5.1
7:    setosa  Petal  Width   0.2
8: virginica  Petal  Width   1.8
> # do the same, programmatically with measurev
> my.list = list(part=NULL, dim=NULL)
> melt(two.iris, measure.vars=measurev(my.list, sep="."))
     Species   part    dim value
      <fctr> <char> <char> <num>
1:    setosa  Sepal Length   5.1
2: virginica  Sepal Length   5.9
3:    setosa  Sepal  Width   3.5
4: virginica  Sepal  Width   3.0
5:    setosa  Petal Length   1.4
6: virginica  Petal Length   5.1
7:    setosa  Petal  Width   0.2
8: virginica  Petal  Width   1.8
> # melt into two value columns, one for each part.
> melt(two.iris, measure.vars = measure(value.name, dim, sep="."))
     Species    dim Sepal Petal
      <fctr> <char> <num> <num>
1:    setosa Length   5.1   1.4
2: virginica Length   5.9   5.1
3:    setosa  Width   3.5   0.2
4: virginica  Width   3.0   1.8
> # melt into two value columns, one for each dim.
> melt(two.iris, measure.vars = measure(part, value.name, sep="."))
     Species   part Length Width
      <fctr> <char>  <num> <num>
1:    setosa  Sepal    5.1   3.5
2: virginica  Sepal    5.9   3.0
3:    setosa  Petal    1.4   0.2
4: virginica  Petal    5.1   1.8
> # melt using sep, converting child number to integer.
> (two.families = data.table(sex_child1="M", sex_child2="F", age_child1=10, age_child2=20))
   sex_child1 sex_child2 age_child1 age_child2
       <char>     <char>      <num>      <num>
1:          M          F         10         20
> print(melt(two.families, measure.vars = measure(
+   value.name, child=as.integer,
+   sep="_child"
+ )), class=TRUE)
   child    sex   age
   <int> <char> <num>
1:     1      M    10
2:     2      F    20
> # same melt using pattern.
> print(melt(two.families, measure.vars = measure(
+   value.name, child=as.integer,
+   pattern="(.*)_child(.)"
+ )), class=TRUE)
   child    sex   age
   <int> <char> <num>
1:     1      M    10
2:     2      F    20
> # same melt with pattern and measurev function list.
> print(melt(two.families, measure.vars = measurev(
+   list(value.name=NULL, child=as.integer),
+   pattern="(.*)_child(.)"
+ )), class=TRUE)
   child    sex   age
   <int> <char> <num>
1:     1      M    10
2:     2      F    20
> # inspired by data(who, package="tidyr")
> (who <- data.table(id=1, new_sp_m5564=2, newrel_f65=3))
      id new_sp_m5564 newrel_f65
   <num>        <num>      <num>
1:     1            2          3
> # melt to three variable columns, all character.
> melt(who, measure.vars = measure(diagnosis, gender, ages, pattern="new_?(.*)_(.)(.*)"))
      id diagnosis gender   ages value
   <num>    <char> <char> <char> <num>
1:     1        sp      m   5564     2
2:     1       rel      f     65     3
> # melt to five variable columns, two numeric (with custom conversion).
> print(melt(who, measure.vars = measure(
+   diagnosis, gender, ages,
+   ymin=as.numeric,
+   ymax=function(y)ifelse(y=="", Inf, as.numeric(y)),
+   pattern="new_?(.*)_(.)(([0-9]{2})([0-9]{0,2}))"
+ )), class=TRUE)
      id diagnosis gender   ages  ymin  ymax value
   <num>    <char> <char> <char> <num> <num> <num>
1:     1        sp      m   5564    55    64     2
2:     1       rel      f     65    65   Inf     3
> 
> 
> 
> cleanEx()
> nameEx("melt.data.table")
> ### * melt.data.table
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: melt.data.table
> ### Title: Fast melt for data.table
> ### Aliases: melt.data.table melt
> ### Keywords: data
> 
> ### ** Examples
> 
> set.seed(45)
> require(data.table)
> DT <- data.table(
+   i_1 = c(1:5, NA),
+   n_1 = c(NA, 6, 7, 8, 9, 10),
+   f_1 = factor(sample(c(letters[1:3], NA), 6L, TRUE)),
+   f_2 = factor(c("z", "a", "x", "c", "x", "x"), ordered=TRUE),
+   c_1 = sample(c(letters[1:3], NA), 6L, TRUE),
+   c_2 = sample(c(LETTERS[1:2], NA), 6L, TRUE),
+   d_1 = as.Date(c(1:3,NA,4:5), origin="2013-09-01"),
+   d_2 = as.Date(6:1, origin="2012-01-01")
+ )
> # add a couple of list cols
> DT[, l_1 := DT[, list(c=list(rep(i_1, sample(5, 1L)))), by = i_1]$c]
> DT[, l_2 := DT[, list(c=list(rep(c_1, sample(5, 1L)))), by = i_1]$c]
> 
> # id.vars, measure.vars as character/integer/numeric vectors
> melt(DT, id.vars=1:2, measure.vars="f_1")
     i_1   n_1 variable  value
   <int> <num>   <fctr> <char>
1:     1    NA      f_1      a
2:     2     6      f_1      c
3:     3     7      f_1      b
4:     4     8      f_1   <NA>
5:     5     9      f_1      c
6:    NA    10      f_1      b
> melt(DT, id.vars=c("i_1", "n_1"), measure.vars=3) # same as above
     i_1   n_1 variable  value
   <int> <num>   <fctr> <char>
1:     1    NA      f_1      a
2:     2     6      f_1      c
3:     3     7      f_1      b
4:     4     8      f_1   <NA>
5:     5     9      f_1      c
6:    NA    10      f_1      b
> melt(DT, id.vars=1:2, measure.vars=3L, value.factor=TRUE) # same, but 'value' is factor
     i_1   n_1 variable  value
   <int> <num>   <fctr> <fctr>
1:     1    NA      f_1      a
2:     2     6      f_1      c
3:     3     7      f_1      b
4:     4     8      f_1   <NA>
5:     5     9      f_1      c
6:    NA    10      f_1      b
> melt(DT, id.vars=1:2, measure.vars=3:4, value.factor=TRUE) # 'value' is *ordered* factor
      i_1   n_1 variable value
    <int> <num>   <fctr> <ord>
 1:     1    NA      f_1     a
 2:     2     6      f_1     c
 3:     3     7      f_1     b
 4:     4     8      f_1  <NA>
 5:     5     9      f_1     c
 6:    NA    10      f_1     b
 7:     1    NA      f_2     z
 8:     2     6      f_2     a
 9:     3     7      f_2     x
10:     4     8      f_2     c
11:     5     9      f_2     x
12:    NA    10      f_2     x
> 
> # preserves attribute when types are identical, ex: Date
> melt(DT, id.vars=3:4, measure.vars=c("d_1", "d_2"))
       f_1   f_2 variable      value
    <fctr> <ord>   <fctr>     <Date>
 1:      a     z      d_1 2013-09-02
 2:      c     a      d_1 2013-09-03
 3:      b     x      d_1 2013-09-04
 4:   <NA>     c      d_1       <NA>
 5:      c     x      d_1 2013-09-05
 6:      b     x      d_1 2013-09-06
 7:      a     z      d_2 2012-01-07
 8:      c     a      d_2 2012-01-06
 9:      b     x      d_2 2012-01-05
10:   <NA>     c      d_2 2012-01-04
11:      c     x      d_2 2012-01-03
12:      b     x      d_2 2012-01-02
> melt(DT, id.vars=3:4, measure.vars=c("n_1", "d_1")) # attribute not preserved
       f_1   f_2 variable value
    <fctr> <ord>   <fctr> <num>
 1:      a     z      n_1    NA
 2:      c     a      n_1     6
 3:      b     x      n_1     7
 4:   <NA>     c      n_1     8
 5:      c     x      n_1     9
 6:      b     x      n_1    10
 7:      a     z      d_1 15950
 8:      c     a      d_1 15951
 9:      b     x      d_1 15952
10:   <NA>     c      d_1    NA
11:      c     x      d_1 15953
12:      b     x      d_1 15954
> 
> # on list
> melt(DT, id.vars=1, measure.vars=c("l_1", "l_2")) # value is a list
      i_1 variable          value
    <int>   <fctr>         <list>
 1:     1      l_1      1,1,1,1,1
 2:     2      l_1              2
 3:     3      l_1            3,3
 4:     4      l_1      4,4,4,4,4
 5:     5      l_1          5,5,5
 6:    NA      l_1          NA,NA
 7:     1      l_2            c,c
 8:     2      l_2          c,c,c
 9:     3      l_2 NA,NA,NA,NA,NA
10:     4      l_2            c,c
11:     5      l_2 NA,NA,NA,NA,NA
12:    NA      l_2              c
> suppressWarnings(
+   melt(DT, id.vars=1, measure.vars=c("c_1", "l_1")) # c1 coerced to list, with warning
+ )
      i_1 variable     value
    <int>   <fctr>    <list>
 1:     1      c_1         c
 2:     2      c_1         c
 3:     3      c_1        NA
 4:     4      c_1         c
 5:     5      c_1        NA
 6:    NA      c_1         c
 7:     1      l_1 1,1,1,1,1
 8:     2      l_1         2
 9:     3      l_1       3,3
10:     4      l_1 4,4,4,4,4
11:     5      l_1     5,5,5
12:    NA      l_1     NA,NA
> 
> # on character
> melt(DT, id.vars=1, measure.vars=c("c_1", "f_1")) # value is char
      i_1 variable  value
    <int>   <fctr> <char>
 1:     1      c_1      c
 2:     2      c_1      c
 3:     3      c_1   <NA>
 4:     4      c_1      c
 5:     5      c_1   <NA>
 6:    NA      c_1      c
 7:     1      f_1      a
 8:     2      f_1      c
 9:     3      f_1      b
10:     4      f_1   <NA>
11:     5      f_1      c
12:    NA      f_1      b
> suppressWarnings(
+   melt(DT, id.vars=1, measure.vars=c("c_1", "n_1")) # n_1 coerced to char, with warning
+ )
      i_1 variable  value
    <int>   <fctr> <char>
 1:     1      c_1      c
 2:     2      c_1      c
 3:     3      c_1   <NA>
 4:     4      c_1      c
 5:     5      c_1   <NA>
 6:    NA      c_1      c
 7:     1      n_1   <NA>
 8:     2      n_1      6
 9:     3      n_1      7
10:     4      n_1      8
11:     5      n_1      9
12:    NA      n_1     10
> 
> # on na.rm=TRUE. NAs are removed efficiently, from within C
> melt(DT, id.vars=1, measure.vars=c("c_1", "c_2"), na.rm=TRUE) # remove NA
     i_1 variable  value
   <int>   <fctr> <char>
1:     1      c_1      c
2:     2      c_1      c
3:     4      c_1      c
4:    NA      c_1      c
5:     1      c_2      A
6:     2      c_2      B
7:     3      c_2      A
8:     4      c_2      A
> 
> # measure.vars can be also a list
> # melt "f_1,f_2" and "d_1,d_2" simultaneously, retain 'factor' attribute
> # convenient way using internal function patterns()
> melt(DT, id.vars=1:2, measure.vars=patterns("^f_", "^d_"), value.factor=TRUE)
      i_1   n_1 variable value1     value2
    <int> <num>   <fctr>  <ord>     <Date>
 1:     1    NA        1      a 2013-09-02
 2:     2     6        1      c 2013-09-03
 3:     3     7        1      b 2013-09-04
 4:     4     8        1   <NA>       <NA>
 5:     5     9        1      c 2013-09-05
 6:    NA    10        1      b 2013-09-06
 7:     1    NA        2      z 2012-01-07
 8:     2     6        2      a 2012-01-06
 9:     3     7        2      x 2012-01-05
10:     4     8        2      c 2012-01-04
11:     5     9        2      x 2012-01-03
12:    NA    10        2      x 2012-01-02
> # same as above, but provide list of columns directly by column names or indices
> melt(DT, id.vars=1:2, measure.vars=list(3:4, c("d_1", "d_2")), value.factor=TRUE)
      i_1   n_1 variable value1     value2
    <int> <num>   <fctr>  <ord>     <Date>
 1:     1    NA        1      a 2013-09-02
 2:     2     6        1      c 2013-09-03
 3:     3     7        1      b 2013-09-04
 4:     4     8        1   <NA>       <NA>
 5:     5     9        1      c 2013-09-05
 6:    NA    10        1      b 2013-09-06
 7:     1    NA        2      z 2012-01-07
 8:     2     6        2      a 2012-01-06
 9:     3     7        2      x 2012-01-05
10:     4     8        2      c 2012-01-04
11:     5     9        2      x 2012-01-03
12:    NA    10        2      x 2012-01-02
> # same as above, but provide names directly:
> melt(DT, id.vars=1:2, measure.vars=patterns(f="^f_", d="^d_"), value.factor=TRUE)
      i_1   n_1 variable     f          d
    <int> <num>   <fctr> <ord>     <Date>
 1:     1    NA        1     a 2013-09-02
 2:     2     6        1     c 2013-09-03
 3:     3     7        1     b 2013-09-04
 4:     4     8        1  <NA>       <NA>
 5:     5     9        1     c 2013-09-05
 6:    NA    10        1     b 2013-09-06
 7:     1    NA        2     z 2012-01-07
 8:     2     6        2     a 2012-01-06
 9:     3     7        2     x 2012-01-05
10:     4     8        2     c 2012-01-04
11:     5     9        2     x 2012-01-03
12:    NA    10        2     x 2012-01-02
> 
> # na.rm=TRUE removes rows with NAs in any 'value' columns
> melt(DT, id.vars=1:2, measure.vars=patterns("f_", "d_"), value.factor=TRUE, na.rm=TRUE)
      i_1   n_1 variable value1     value2
    <int> <num>   <fctr>  <ord>     <Date>
 1:     1    NA        1      a 2013-09-02
 2:     2     6        1      c 2013-09-03
 3:     3     7        1      b 2013-09-04
 4:     5     9        1      c 2013-09-05
 5:    NA    10        1      b 2013-09-06
 6:     1    NA        2      z 2012-01-07
 7:     2     6        2      a 2012-01-06
 8:     3     7        2      x 2012-01-05
 9:     4     8        2      c 2012-01-04
10:     5     9        2      x 2012-01-03
11:    NA    10        2      x 2012-01-02
> 
> # 'na.rm=TRUE' also works with list column, but note that is.na only
> # returns TRUE if the list element is a length=1 vector with an NA.
> is.na(list(one.NA=NA, two.NA=c(NA,NA)))
one.NA two.NA 
  TRUE  FALSE 
> melt(DT, id.vars=1:2, measure.vars=patterns("l_", "d_"), na.rm=FALSE)
      i_1   n_1 variable         value1     value2
    <int> <num>   <fctr>         <list>     <Date>
 1:     1    NA        1      1,1,1,1,1 2013-09-02
 2:     2     6        1              2 2013-09-03
 3:     3     7        1            3,3 2013-09-04
 4:     4     8        1      4,4,4,4,4       <NA>
 5:     5     9        1          5,5,5 2013-09-05
 6:    NA    10        1          NA,NA 2013-09-06
 7:     1    NA        2            c,c 2012-01-07
 8:     2     6        2          c,c,c 2012-01-06
 9:     3     7        2 NA,NA,NA,NA,NA 2012-01-05
10:     4     8        2            c,c 2012-01-04
11:     5     9        2 NA,NA,NA,NA,NA 2012-01-03
12:    NA    10        2              c 2012-01-02
> melt(DT, id.vars=1:2, measure.vars=patterns("l_", "d_"), na.rm=TRUE)
      i_1   n_1 variable         value1     value2
    <int> <num>   <fctr>         <list>     <Date>
 1:     1    NA        1      1,1,1,1,1 2013-09-02
 2:     2     6        1              2 2013-09-03
 3:     3     7        1            3,3 2013-09-04
 4:     5     9        1          5,5,5 2013-09-05
 5:    NA    10        1          NA,NA 2013-09-06
 6:     1    NA        2            c,c 2012-01-07
 7:     2     6        2          c,c,c 2012-01-06
 8:     3     7        2 NA,NA,NA,NA,NA 2012-01-05
 9:     4     8        2            c,c 2012-01-04
10:     5     9        2 NA,NA,NA,NA,NA 2012-01-03
11:    NA    10        2              c 2012-01-02
> 
> # measure list with missing/short entries results in output with runs of NA
> DT.missing.cols <- DT[, .(d_1, d_2, c_1, f_2)]
> melt(DT.missing.cols, measure.vars=list(d=1:2, c="c_1", f=c(NA, "f_2")))
    variable          d      c      f
      <fctr>     <Date> <char> <char>
 1:        1 2013-09-02      c   <NA>
 2:        1 2013-09-03      c   <NA>
 3:        1 2013-09-04   <NA>   <NA>
 4:        1       <NA>      c   <NA>
 5:        1 2013-09-05   <NA>   <NA>
 6:        1 2013-09-06      c   <NA>
 7:        2 2012-01-07   <NA>      z
 8:        2 2012-01-06   <NA>      a
 9:        2 2012-01-05   <NA>      x
10:        2 2012-01-04   <NA>      c
11:        2 2012-01-03   <NA>      x
12:        2 2012-01-02   <NA>      x
> 
> # specifying columns to melt via separator.
> melt(DT.missing.cols, measure.vars=measure(value.name, number=as.integer, sep="_"))
    number          d      c      f
     <int>     <Date> <char> <char>
 1:      1 2013-09-02      c   <NA>
 2:      1 2013-09-03      c   <NA>
 3:      1 2013-09-04   <NA>   <NA>
 4:      1       <NA>      c   <NA>
 5:      1 2013-09-05   <NA>   <NA>
 6:      1 2013-09-06      c   <NA>
 7:      2 2012-01-07   <NA>      z
 8:      2 2012-01-06   <NA>      a
 9:      2 2012-01-05   <NA>      x
10:      2 2012-01-04   <NA>      c
11:      2 2012-01-03   <NA>      x
12:      2 2012-01-02   <NA>      x
> 
> # specifying columns to melt via regex.
> melt(DT.missing.cols, measure.vars=measure(value.name, number=as.integer, pattern="(.)_(.)"))
    number          d      c      f
     <int>     <Date> <char> <char>
 1:      1 2013-09-02      c   <NA>
 2:      1 2013-09-03      c   <NA>
 3:      1 2013-09-04   <NA>   <NA>
 4:      1       <NA>      c   <NA>
 5:      1 2013-09-05   <NA>   <NA>
 6:      1 2013-09-06      c   <NA>
 7:      2 2012-01-07   <NA>      z
 8:      2 2012-01-06   <NA>      a
 9:      2 2012-01-05   <NA>      x
10:      2 2012-01-04   <NA>      c
11:      2 2012-01-03   <NA>      x
12:      2 2012-01-02   <NA>      x
> melt(DT.missing.cols, measure.vars=measure(value.name, number=as.integer, pattern="([dc])_(.)"))
      f_2 number          d      c
    <ord>  <int>     <Date> <char>
 1:     z      1 2013-09-02      c
 2:     a      1 2013-09-03      c
 3:     x      1 2013-09-04   <NA>
 4:     c      1       <NA>      c
 5:     x      1 2013-09-05   <NA>
 6:     x      1 2013-09-06      c
 7:     z      2 2012-01-07   <NA>
 8:     a      2 2012-01-06   <NA>
 9:     x      2 2012-01-05   <NA>
10:     c      2 2012-01-04   <NA>
11:     x      2 2012-01-03   <NA>
12:     x      2 2012-01-02   <NA>
> 
> # cols arg of measure can be used if you do not want to use regex
> melt(DT.missing.cols, measure.vars=measure(
+   value.name, number=as.integer, sep="_", cols=c("d_1","d_2","c_1")))
      f_2 number          d      c
    <ord>  <int>     <Date> <char>
 1:     z      1 2013-09-02      c
 2:     a      1 2013-09-03      c
 3:     x      1 2013-09-04   <NA>
 4:     c      1       <NA>      c
 5:     x      1 2013-09-05   <NA>
 6:     x      1 2013-09-06      c
 7:     z      2 2012-01-07   <NA>
 8:     a      2 2012-01-06   <NA>
 9:     x      2 2012-01-05   <NA>
10:     c      2 2012-01-04   <NA>
11:     x      2 2012-01-03   <NA>
12:     x      2 2012-01-02   <NA>
> 
> 
> 
> cleanEx()
> nameEx("merge")
> ### * merge
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: merge
> ### Title: Merge two data.tables
> ### Aliases: merge merge.data.table
> ### Keywords: data
> 
> ### ** Examples
> 
> (dt1 <- data.table(A = letters[1:10], X = 1:10, key = "A"))
Key: <A>
         A     X
    <char> <int>
 1:      a     1
 2:      b     2
 3:      c     3
 4:      d     4
 5:      e     5
 6:      f     6
 7:      g     7
 8:      h     8
 9:      i     9
10:      j    10
> (dt2 <- data.table(A = letters[5:14], Y = 1:10, key = "A"))
Key: <A>
         A     Y
    <char> <int>
 1:      e     1
 2:      f     2
 3:      g     3
 4:      h     4
 5:      i     5
 6:      j     6
 7:      k     7
 8:      l     8
 9:      m     9
10:      n    10
> merge(dt1, dt2)
Key: <A>
        A     X     Y
   <char> <int> <int>
1:      e     5     1
2:      f     6     2
3:      g     7     3
4:      h     8     4
5:      i     9     5
6:      j    10     6
> merge(dt1, dt2, all = TRUE)
Key: <A>
         A     X     Y
    <char> <int> <int>
 1:      a     1    NA
 2:      b     2    NA
 3:      c     3    NA
 4:      d     4    NA
 5:      e     5     1
 6:      f     6     2
 7:      g     7     3
 8:      h     8     4
 9:      i     9     5
10:      j    10     6
11:      k    NA     7
12:      l    NA     8
13:      m    NA     9
14:      n    NA    10
> 
> (dt1 <- data.table(A = letters[rep(1:3, 2)], X = 1:6, key = "A"))
Key: <A>
        A     X
   <char> <int>
1:      a     1
2:      a     4
3:      b     2
4:      b     5
5:      c     3
6:      c     6
> (dt2 <- data.table(A = letters[rep(2:4, 2)], Y = 6:1, key = "A"))
Key: <A>
        A     Y
   <char> <int>
1:      b     6
2:      b     3
3:      c     5
4:      c     2
5:      d     4
6:      d     1
> merge(dt1, dt2, allow.cartesian=TRUE)
Key: <A>
        A     X     Y
   <char> <int> <int>
1:      b     2     6
2:      b     2     3
3:      b     5     6
4:      b     5     3
5:      c     3     5
6:      c     3     2
7:      c     6     5
8:      c     6     2
> 
> (dt1 <- data.table(A = c(rep(1L, 5), 2L), B = letters[rep(1:3, 2)], X = 1:6, key = c("A", "B")))
Key: <A, B>
       A      B     X
   <int> <char> <int>
1:     1      a     1
2:     1      a     4
3:     1      b     2
4:     1      b     5
5:     1      c     3
6:     2      c     6
> (dt2 <- data.table(A = c(rep(1L, 5), 2L), B = letters[rep(2:4, 2)], Y = 6:1, key = c("A", "B")))
Key: <A, B>
       A      B     Y
   <int> <char> <int>
1:     1      b     6
2:     1      b     3
3:     1      c     5
4:     1      c     2
5:     1      d     4
6:     2      d     1
> merge(dt1, dt2)
Key: <A, B>
       A      B     X     Y
   <int> <char> <int> <int>
1:     1      b     2     6
2:     1      b     2     3
3:     1      b     5     6
4:     1      b     5     3
5:     1      c     3     5
6:     1      c     3     2
> merge(dt1, dt2, by="B", allow.cartesian=TRUE)
Key: <B>
        B   A.x     X   A.y     Y
   <char> <int> <int> <int> <int>
1:      b     1     2     1     6
2:      b     1     2     1     3
3:      b     1     5     1     6
4:      b     1     5     1     3
5:      c     1     3     1     5
6:      c     1     3     1     2
7:      c     2     6     1     5
8:      c     2     6     1     2
> 
> # test it more:
> d1 <- data.table(a=rep(1:2,each=3), b=1:6, key=c("a", "b"))
> d2 <- data.table(a=0:1, bb=10:11, key="a")
> d3 <- data.table(a=0:1, key="a")
> d4 <- data.table(a=0:1, b=0:1, key=c("a", "b"))
> 
> merge(d1, d2)
Key: <a>
       a     b    bb
   <int> <int> <int>
1:     1     1    11
2:     1     2    11
3:     1     3    11
> merge(d2, d1)
Key: <a>
       a    bb     b
   <int> <int> <int>
1:     1    11     1
2:     1    11     2
3:     1    11     3
> merge(d1, d2, all=TRUE)
Key: <a>
       a     b    bb
   <int> <int> <int>
1:     0    NA    10
2:     1     1    11
3:     1     2    11
4:     1     3    11
5:     2     4    NA
6:     2     5    NA
7:     2     6    NA
> merge(d2, d1, all=TRUE)
Key: <a>
       a    bb     b
   <int> <int> <int>
1:     0    10    NA
2:     1    11     1
3:     1    11     2
4:     1    11     3
5:     2    NA     4
6:     2    NA     5
7:     2    NA     6
> 
> merge(d3, d1)
Key: <a>
       a     b
   <int> <int>
1:     1     1
2:     1     2
3:     1     3
> merge(d1, d3)
Key: <a>
       a     b
   <int> <int>
1:     1     1
2:     1     2
3:     1     3
> merge(d1, d3, all=TRUE)
Key: <a>
       a     b
   <int> <int>
1:     0    NA
2:     1     1
3:     1     2
4:     1     3
5:     2     4
6:     2     5
7:     2     6
> merge(d3, d1, all=TRUE)
Key: <a>
       a     b
   <int> <int>
1:     0    NA
2:     1     1
3:     1     2
4:     1     3
5:     2     4
6:     2     5
7:     2     6
> 
> merge(d1, d4)
Key: <a, b>
       a     b
   <int> <int>
1:     1     1
> merge(d1, d4, by="a", suffixes=c(".d1", ".d4"))
Key: <a>
       a  b.d1  b.d4
   <int> <int> <int>
1:     1     1     1
2:     1     2     1
3:     1     3     1
> merge(d4, d1)
Key: <a, b>
       a     b
   <int> <int>
1:     1     1
> merge(d1, d4, all=TRUE)
Key: <a, b>
       a     b
   <int> <int>
1:     0     0
2:     1     1
3:     1     2
4:     1     3
5:     2     4
6:     2     5
7:     2     6
> merge(d4, d1, all=TRUE)
Key: <a, b>
       a     b
   <int> <int>
1:     0     0
2:     1     1
3:     1     2
4:     1     3
5:     2     4
6:     2     5
7:     2     6
> 
> # setkey is automatic by default
> set.seed(1L)
> d1 <- data.table(a=sample(rep(1:3,each=2)), z=1:6)
> d2 <- data.table(a=2:0, z=10:12)
> merge(d1, d2, by="a")
Key: <a>
       a   z.x   z.y
   <int> <int> <int>
1:     1     1    11
2:     1     5    11
3:     2     2    10
4:     2     3    10
> merge(d1, d2, by="a", all=TRUE)
Key: <a>
       a   z.x   z.y
   <int> <int> <int>
1:     0    NA    12
2:     1     1    11
3:     1     5    11
4:     2     2    10
5:     2     3    10
6:     3     4    NA
7:     3     6    NA
> 
> # using by.x and by.y
> setnames(d2, "a", "b")
> merge(d1, d2, by.x="a", by.y="b")
Key: <a>
       a   z.x   z.y
   <int> <int> <int>
1:     1     1    11
2:     1     5    11
3:     2     2    10
4:     2     3    10
> merge(d1, d2, by.x="a", by.y="b", all=TRUE)
Key: <a>
       a   z.x   z.y
   <int> <int> <int>
1:     0    NA    12
2:     1     1    11
3:     1     5    11
4:     2     2    10
5:     2     3    10
6:     3     4    NA
7:     3     6    NA
> merge(d2, d1, by.x="b", by.y="a")
Key: <b>
       b   z.x   z.y
   <int> <int> <int>
1:     1    11     1
2:     1    11     5
3:     2    10     2
4:     2    10     3
> 
> # using incomparables values
> d1 <- data.table(a=c(1,2,NA,NA,3,1), z=1:6)
> d2 <- data.table(a=c(1,2,NA), z=10:12)
> merge(d1, d2, by="a")
Key: <a>
       a   z.x   z.y
   <num> <int> <int>
1:    NA     3    12
2:    NA     4    12
3:     1     1    10
4:     1     6    10
5:     2     2    11
> merge(d1, d2, by="a", incomparables=NA)
Key: <a>
       a   z.x   z.y
   <num> <int> <int>
1:     1     1    10
2:     1     6    10
3:     2     2    11
> 
> 
> 
> cleanEx()
> nameEx("na.omit.data.table")
> ### * na.omit.data.table
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: na.omit.data.table
> ### Title: Remove rows with missing values on columns specified
> ### Aliases: na.omit.data.table na.omit
> ### Keywords: data
> 
> ### ** Examples
> 
> DT = data.table(x=c(1,NaN,NA,3), y=c(NA_integer_, 1:3), z=c("a", NA_character_, "b", "c"))
> # default behaviour
> na.omit(DT)
       x     y      z
   <num> <int> <char>
1:     3     3      c
> # omit rows where 'x' has a missing value
> na.omit(DT, cols="x")
       x     y      z
   <num> <int> <char>
1:     1    NA      a
2:     3     3      c
> # omit rows where either 'x' or 'y' have missing values
> na.omit(DT, cols=c("x", "y"))
       x     y      z
   <num> <int> <char>
1:     3     3      c
> 
> ## Not run: 
> ##D # Timings on relatively large data
> ##D set.seed(1L)
> ##D DT = data.table(x = sample(c(1:100, NA_integer_), 5e7L, TRUE),
> ##D                 y = sample(c(rnorm(100), NA), 5e7L, TRUE))
> ##D system.time(ans1 <- na.omit(DT)) ## 2.6 seconds
> ##D system.time(ans2 <- stats:::na.omit.data.frame(DT)) ## 29 seconds
> ##D # identical? check each column separately, as ans2 will have additional attribute
> ##D all(sapply(1:2, function(i) identical(ans1[[i]], ans2[[i]]))) ## TRUE
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("nafill")
> ### * nafill
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: nafill
> ### Title: Fill missing values
> ### Aliases: nafill fill setnafill locf nocb na.fill
> ### Keywords: data
> 
> ### ** Examples
> 
> x = 1:10
> x[c(1:2, 5:6, 9:10)] = NA
> nafill(x, "locf")
 [1] NA NA  3  4  4  4  7  8  8  8
> 
> dt = data.table(v1=x, v2=shift(x)/2, v3=shift(x, -1L)/2)
> nafill(dt, "nocb")
$v1
 [1]  3  3  3  4  7  7  7  8 NA NA

$v2
 [1] 1.5 1.5 1.5 1.5 2.0 3.5 3.5 3.5 4.0  NA

$v3
 [1] 1.5 1.5 2.0 3.5 3.5 3.5 4.0  NA  NA  NA

> 
> setnafill(dt, "locf", cols=c("v2","v3"))
> dt
       v1    v2    v3
    <int> <num> <num>
 1:    NA    NA    NA
 2:    NA    NA   1.5
 3:     3    NA   2.0
 4:     4   1.5   2.0
 5:    NA   2.0   2.0
 6:    NA   2.0   3.5
 7:     7   2.0   4.0
 8:     8   3.5   4.0
 9:    NA   4.0   4.0
10:    NA   4.0   4.0
> 
> 
> 
> cleanEx()
> nameEx("notin")
> ### * notin
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: notin
> ### Title: Convenience operator for checking if an example is not in a set
> ###   of elements
> ### Aliases: %notin%
> 
> ### ** Examples
> 
>   11 %notin% 1:10 # TRUE
[1] TRUE
>   "a" %notin% c("a", "b") # FALSE
[1] FALSE
> 
>   ## NAs on the LHS
>   NA %in% 1:2
[1] FALSE
>   NA %notin% 1:2
[1] TRUE
>   ## NAs on the RHS
>   NA %in% c(1:2,NA)
[1] TRUE
>   NA %notin% c(1:2,NA)
[1] FALSE
> 
> 
> 
> cleanEx()
> nameEx("openmp-utils")
> ### * openmp-utils
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: setDTthreads
> ### Title: Set or get number of threads that data.table should use
> ### Aliases: setDTthreads getDTthreads openMP openmp
> 
> ### ** Examples
> 
>   getDTthreads(verbose=TRUE)
  OpenMP version (_OPENMP)       201511
  omp_get_num_procs()            12
  R_DATATABLE_NUM_PROCS_PERCENT  unset (default 50)
  R_DATATABLE_NUM_THREADS        unset
  R_DATATABLE_THROTTLE           unset (default 1024)
  omp_get_thread_limit()         2147483647
  omp_get_max_threads()          12
  OMP_THREAD_LIMIT               unset
  OMP_NUM_THREADS                unset
  RestoreAfterFork               true
  data.table is using 6 threads with throttle==1024. See ?setDTthreads.
[1] 6
> 
> 
> 
> cleanEx()
> nameEx("patterns")
> ### * patterns
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: patterns
> ### Title: Obtain matching indices corresponding to patterns
> ### Aliases: patterns
> ### Keywords: data
> 
> ### ** Examples
> 
> DT = data.table(x1 = 1:5, x2 = 6:10, y1 = letters[1:5], y2 = letters[6:10])
> # melt all columns that begin with 'x' & 'y', respectively, into separate columns
> melt(DT, measure.vars = patterns("^x", "^y", cols=names(DT)))
    variable value1 value2
      <fctr>  <int> <char>
 1:        1      1      a
 2:        1      2      b
 3:        1      3      c
 4:        1      4      d
 5:        1      5      e
 6:        2      6      f
 7:        2      7      g
 8:        2      8      h
 9:        2      9      i
10:        2     10      j
> # when used with melt, 'cols' is implicitly assumed to be names of input
> # data.table, if not provided.
> melt(DT, measure.vars = patterns("^x", "^y"))
    variable value1 value2
      <fctr>  <int> <char>
 1:        1      1      a
 2:        1      2      b
 3:        1      3      c
 4:        1      4      d
 5:        1      5      e
 6:        2      6      f
 7:        2      7      g
 8:        2      8      h
 9:        2      9      i
10:        2     10      j
> 
> 
> 
> cleanEx()
> nameEx("print.data.table")
> ### * print.data.table
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: print.data.table
> ### Title: data.table Printing Options
> ### Aliases: print.data.table format_col format_col.default
> ###   format_col.POSIXct format_col.expression format_list_item
> ###   format_list_item.default
> 
> ### ** Examples
> 
>   #output compression
>   DT <- data.table(a = 1:1000)
>   print(DT, nrows = 100, topn = 4)
          a
      <int>
   1:     1
   2:     2
   3:     3
   4:     4
  ---      
 997:   997
 998:   998
 999:   999
1000:  1000
> 
>   #`quote` can be used to identify whitespace
>   DT <- data.table(blanks = c(" 12", " 34"),
+                    noblanks = c("12", "34"))
>   print(DT, quote = TRUE)
   "blanks" "noblanks"
   "<char>"   "<char>"
1:    " 12"       "12"
2:    " 34"       "34"
> 
>   #`class` provides handy column type summaries at a glance
>   DT <- data.table(a = vector("integer", 3),
+                    b = vector("complex", 3),
+                    c = as.IDate(paste0("2016-02-0", 1:3)))
>   print(DT, class = TRUE)
       a      b          c
   <int> <cplx>     <IDat>
1:     0   0+0i 2016-02-01
2:     0   0+0i 2016-02-02
3:     0   0+0i 2016-02-03
> 
>   #`row.names` can be eliminated to save space
>   DT <- data.table(a = 1:3)
>   print(DT, row.names = FALSE)
     a
 <int>
     1
     2
     3
> 
>   #`print.keys` can alert which columns are currently keys
>   DT <- data.table(a=1:3, b=4:6, c=7:9, key=c("b", "a"))
>   setindexv(DT, c("a", "b"))
>   setindexv(DT, "a")
>   print(DT, print.keys=TRUE)
Key: <b, a>
Indices: <a__b>, <a>
       a     b     c
   <int> <int> <int>
1:     1     4     7
2:     2     5     8
3:     3     6     9
> 
>   # `trunc.cols` will make it so only columns that fit in console will be printed
>   #    with a message that states the variables not shown
>   old_width = options("width" = 40)
>   DT <- data.table(thing_11 = vector("integer", 3),
+                    thing_21 = vector("complex", 3),
+                    thing_31 = as.IDate(paste0("2016-02-0", 1:3)),
+                    thing_41 = "aasdfasdfasdfasdfasdfasdfasdfasdfasdfasdf",
+                    thing_51 = vector("integer", 3),
+                    thing_61 = vector("complex", 3))
>   print(DT, trunc.cols=TRUE)
   thing_11 thing_21   thing_31
      <int>   <cplx>     <IDat>
1:        0     0+0i 2016-02-01
2:        0     0+0i 2016-02-02
3:        0     0+0i 2016-02-03
3 variables not shown: [thing_41 <char>, thing_51 <int>, thing_61 <cplx>]
>   options(old_width)
> 
>   # `char.trunc` will truncate the strings,
>   # if their lengths exceed the given limit: `datatable.prettyprint.char`
>   # For example:
> 
>   old = options(datatable.prettyprint.char=5L)
>   DT = data.table(x=1:2, y=c("abcdefghij", "klmnopqrstuv"))
>   DT
       x        y
   <int>   <char>
1:     1 abcde...
2:     2 klmno...
>   options(old)
> 
>   # Formatting customization
>   format_col.complex = function(x, ...) sprintf('(%.1f, %.1fi)', Re(x), Im(x))
>   x = data.table(z = c(1 + 3i, 2 - 1i, pi + 2.718i))
>   print(x)
              z
         <cplx>
1:  (1.0, 3.0i)
2: (2.0, -1.0i)
3:  (3.1, 2.7i)
> 
>   old = options(datatable.show.indices=TRUE)
>   NN = 200
>   set.seed(2024)
>   DT = data.table(
+     grp1 = sample(100, NN, TRUE),
+     grp2 = sample(90, NN, TRUE),
+     grp3 = sample(80, NN, TRUE)
+   )
>   setkey(DT, grp1, grp2)
>   setindex(DT, grp1, grp3)
>   print(DT)
Key: <grp1, grp2>
Index: <grp1__grp3>
Warning in rbind(abbs, toprint) :
  number of columns of result is not a multiple of vector length (arg 1)
      grp1  grp2  grp3 index:grp1__grp3
     <int> <int> <int>            <int>
  1:     1     9    11                2
  2:     1    10     5                1
  3:     1    60    47                3
  4:     2    44     6                4
  5:     2    80    36                5
 ---                                   
196:    97    59    65              196
197:    98    32    59              198
198:    98    52    36              197
199:    99     2    19              199
200:    99    72    80              200
>   options(old)
> 
>   iris = as.data.table(iris)
>   iris_agg = iris[ , .(reg = list(lm(Sepal.Length ~ Petal.Length))), by = Species]
>   format_list_item.lm = function(x, ...) sprintf('<lm:%s>', format(x$call$formula))
>   print(iris_agg)
      Species                              reg
       <fctr>                           <list>
1:     setosa <lm:Sepal.Length ~ Petal.Length>
2: versicolor <lm:Sepal.Length ~ Petal.Length>
3:  virginica <lm:Sepal.Length ~ Petal.Length>
> 
> 
> 
> cleanEx()
> nameEx("rbindlist")
> ### * rbindlist
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: rbindlist
> ### Title: Makes one data.table from a list of many
> ### Aliases: rbindlist rbind.data.table rbind
> ### Keywords: data
> 
> ### ** Examples
> 
> # default case
> DT1 = data.table(A=1:3,B=letters[1:3])
> DT2 = data.table(A=4:5,B=letters[4:5])
> l = list(DT1,DT2)
> rbindlist(l)
       A      B
   <int> <char>
1:     1      a
2:     2      b
3:     3      c
4:     4      d
5:     5      e
> 
> # bind correctly by names
> DT1 = data.table(A=1:3,B=letters[1:3])
> DT2 = data.table(B=letters[4:5],A=4:5)
> l = list(DT1,DT2)
> rbindlist(l, use.names=TRUE)
       A      B
   <int> <char>
1:     1      a
2:     2      b
3:     3      c
4:     4      d
5:     5      e
> 
> # fill missing columns, and match by col names
> DT1 = data.table(A=1:3,B=letters[1:3])
> DT2 = data.table(B=letters[4:5],C=factor(1:2))
> l = list(DT1,DT2)
> rbindlist(l, use.names=TRUE, fill=TRUE)
       A      B      C
   <int> <char> <fctr>
1:     1      a   <NA>
2:     2      b   <NA>
3:     3      c   <NA>
4:    NA      d      1
5:    NA      e      2
> 
> # generate index column, auto generates indices
> rbindlist(l, use.names=TRUE, fill=TRUE, idcol=TRUE)
     .id     A      B      C
   <int> <int> <char> <fctr>
1:     1     1      a   <NA>
2:     1     2      b   <NA>
3:     1     3      c   <NA>
4:     2    NA      d      1
5:     2    NA      e      2
> # let's name the list
> setattr(l, 'names', c("a", "b"))
> rbindlist(l, use.names=TRUE, fill=TRUE, idcol="ID")
       ID     A      B      C
   <char> <int> <char> <fctr>
1:      a     1      a   <NA>
2:      a     2      b   <NA>
3:      a     3      c   <NA>
4:      b    NA      d      1
5:      b    NA      e      2
> 
> # bind different classes
> DT1 = data.table(A=1:3,B=letters[1:3])
> DT2 = data.table(A=4:5,B=letters[4:5])
> setattr(DT1[["A"]], "class", c("a", "integer"))
> rbind(DT1, DT2, ignore.attr=TRUE)
     A      B
   <a> <char>
1:   1      a
2:   2      b
3:   3      c
4:   4      d
5:   5      e
> 
> 
> 
> cleanEx()
> nameEx("rleid")
> ### * rleid
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: rleid
> ### Title: Generate run-length type group id
> ### Aliases: rleid rleidv
> ### Keywords: data
> 
> ### ** Examples
> 
> DT = data.table(grp=rep(c("A", "B", "C", "A", "B"), c(2,2,3,1,2)), value=1:10)
> rleid(DT$grp) # get run-length ids
 [1] 1 1 2 2 3 3 3 4 5 5
> rleidv(DT, "grp") # same as above
 [1] 1 1 2 2 3 3 3 4 5 5
> 
> rleid(DT$grp, prefix="grp") # prefix with 'grp'
 [1] "grp1" "grp1" "grp2" "grp2" "grp3" "grp3" "grp3" "grp4" "grp5" "grp5"
> 
> # get sum of value over run-length groups
> DT[, sum(value), by=.(grp, rleid(grp))]
      grp rleid    V1
   <char> <int> <int>
1:      A     1     3
2:      B     2     7
3:      C     3    18
4:      A     4     8
5:      B     5    19
> DT[, sum(value), by=.(grp, rleid(grp, prefix="grp"))]
      grp  rleid    V1
   <char> <char> <int>
1:      A   grp1     3
2:      B   grp2     7
3:      C   grp3    18
4:      A   grp4     8
5:      B   grp5    19
> 
> 
> 
> 
> cleanEx()
> nameEx("rowid")
> ### * rowid
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: rowid
> ### Title: Generate unique row ids within each group
> ### Aliases: rowid rowidv
> ### Keywords: data
> 
> ### ** Examples
> 
> DT = data.table(x=c(20,10,10,30,30,20), y=c("a", "a", "a", "b", "b", "b"), z=1:6)
> 
> rowid(DT$x) # 1,1,2,1,2,2
[1] 1 1 2 1 2 2
> rowidv(DT, cols="x") # same as above
[1] 1 1 2 1 2 2
> 
> rowid(DT$x, prefix="group") # prefixed with 'group'
[1] "group1" "group1" "group2" "group1" "group2" "group2"
> 
> rowid(DT$x, DT$y) # 1,1,2,1,2,1
[1] 1 1 2 1 2 1
> rowidv(DT, cols=c("x","y")) # same as above
[1] 1 1 2 1 2 1
> DT[, .(N=seq_len(.N)), by=.(x,y)]$N # same as above
[1] 1 1 2 1 2 1
> 
> # convenient usage with dcast
> dcast(DT, x ~ rowid(x, prefix="group"), value.var="z")
Key: <x>
       x group1 group2
   <num>  <int>  <int>
1:    10      2      3
2:    20      1      6
3:    30      4      5
> #     x group1 group2
> # 1: 10      2      3
> # 2: 20      1      6
> # 3: 30      4      5
> 
> 
> 
> cleanEx()
> nameEx("rowwiseDT")
> ### * rowwiseDT
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: rowwiseDT
> ### Title: Create a data.table row-wise
> ### Aliases: rowwiseDT
> 
> ### ** Examples
> 
> rowwiseDT(
+   A=,B=, C=,
+   1, "a",2:3,
+   2, "b",list(5)
+ )
       A      B      C
   <num> <char> <list>
1:     1      a    2,3
2:     2      b      5
> 
> 
> 
> cleanEx()
> nameEx("setDF")
> ### * setDF
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: setDF
> ### Title: Coerce a data.table to data.frame by reference
> ### Aliases: setDF
> ### Keywords: data
> 
> ### ** Examples
> 
> X = data.table(x=1:5, y=6:10)
> ## convert 'X' to data.frame, without any copy.
> setDF(X)
> 
> X = data.table(x=1:5, y=6:10)
> ## idem, assigning row names
> setDF(X, rownames = LETTERS[1:5])
> 
> X = list(x=1:5, y=6:10)
> # X is converted to a data.frame without any copy.
> setDF(X)
> 
> 
> 
> cleanEx()
> nameEx("setDT")
> ### * setDT
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: setDT
> ### Title: Coerce lists and data.frames to data.table by reference
> ### Aliases: setDT
> ### Keywords: data
> 
> ### ** Examples
> 
> 
> set.seed(45L)
> X = data.frame(A=sample(3, 10, TRUE),
+          B=sample(letters[1:3], 10, TRUE),
+          C=sample(10), stringsAsFactors=FALSE)
> 
> # Convert X to data.table by reference and
> # get the frequency of each "A,B" combination
> setDT(X)[, .N, by=.(A,B)]
       A      B     N
   <int> <char> <int>
1:     1      b     1
2:     3      a     3
3:     2      a     1
4:     3      c     1
5:     2      c     1
6:     3      b     2
7:     1      c     1
> 
> # convert list to data.table
> # autofill names
> X = list(1:4, letters[1:4])
> setDT(X)
> # don't provide names
> X = list(a=1:4, letters[1:4])
> setDT(X, FALSE)
> 
> # setkey directly
> X = list(a = 4:1, b=runif(4))
> setDT(X, key="a")[]
Key: <a>
       a         b
   <int>     <num>
1:     1 0.3396133
2:     2 0.5762478
3:     3 0.4272740
4:     4 0.5409554
> 
> # check.names argument
> X = list(a=1:5, a=6:10)
> setDT(X, check.names=TRUE)[]
       a   a.1
   <int> <int>
1:     1     6
2:     2     7
3:     3     8
4:     4     9
5:     5    10
> 
> 
> 
> 
> cleanEx()
> nameEx("setNumericRounding")
> ### * setNumericRounding
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: setNumericRounding
> ### Title: Change or turn off numeric rounding
> ### Aliases: setNumericRounding getNumericRounding
> ### Keywords: data
> 
> ### ** Examples
> 
> DT = data.table(a=seq(0,1,by=0.2),b=1:2, key="a")
> DT
Key: <a>
       a     b
   <num> <int>
1:   0.0     1
2:   0.2     2
3:   0.4     1
4:   0.6     2
5:   0.8     1
6:   1.0     2
> setNumericRounding(0)   # By default, rounding is turned off
> DT[.(0.4)]   # works
Key: <a>
       a     b
   <num> <int>
1:   0.4     1
> DT[.(0.6)]   # no match, can be confusing since 0.6 is clearly there in DT
Key: <a>
       a     b
   <num> <int>
1:   0.6    NA
>              # happens due to floating point representation limitations
> 
> setNumericRounding(2)   # round off last 2 bytes
> DT[.(0.6)]   # works
Key: <a>
       a     b
   <num> <int>
1:   0.6     2
> 
> # using type 'numeric' for integers > 2^31 (typically ids)
> DT = data.table(id = c(1234567890123, 1234567890124, 1234567890125), val=1:3)
> print(DT, digits=15)
              id   val
           <num> <int>
1: 1234567890123     1
2: 1234567890124     2
3: 1234567890125     3
> DT[,.N,by=id]   # 1 row, (last 2 bytes rounded)
             id     N
          <num> <int>
1: 1.234568e+12     3
> setNumericRounding(0)
> DT[,.N,by=id]   # 3 rows, (no rounding, default)
             id     N
          <num> <int>
1: 1.234568e+12     1
2: 1.234568e+12     1
3: 1.234568e+12     1
> # better to use bit64::integer64 for such ids
> 
> 
> 
> cleanEx()
> nameEx("setattr")
> ### * setattr
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: setattr
> ### Title: Set attributes of objects by reference
> ### Aliases: setattr setnames
> ### Keywords: data
> 
> ### ** Examples
> 
> 
> DT <- data.table(a = 1, b = 2, d = 3)
> 
> old <- c("a", "b", "c", "d")
> new <- c("A", "B", "C", "D")
> 
> setnames(DT, old, new, skip_absent = TRUE) # skips old[3] because "c" is not a column name of DT
> 
> DF = data.frame(a=1:2,b=3:4)       # base data.frame to demo copies and syntax
> if (capabilities()["profmem"])     # usually memory profiling is available but just in case
+   tracemem(DF)
[1] "<0x630865677128>"
> colnames(DF)[1] <- "A"             # 4 shallow copies (R >= 3.1, was 4 deep copies before)
tracemem[0x630865677128 -> 0x63086579dcf8]: colnames<- 
> names(DF)[1] <- "A"                # 3 shallow copies
> names(DF) <- c("A", "b")           # 1 shallow copy
> `names<-`(DF,c("A","b"))           # 1 shallow copy
tracemem[0x63086579dcf8 -> 0x63086579e138]: 
  A b
1 1 3
2 2 4
> 
> DT = data.table(a=1:2,b=3:4,c=5:6) # compare to data.table
> if (capabilities()["profmem"])
+   tracemem(DT)                     # by reference, no deep or shallow copies
[1] "<0x6308686ac5a0>"
> setnames(DT,"b","B")               # by name, no match() needed (warning if "b" is missing)
> setnames(DT,3,"C")                 # by position with warning if 3 > ncol(DT)
> setnames(DT,2:3,c("D","E"))        # multiple
> setnames(DT,c("a","E"),c("A","F")) # multiple by name (warning if either "a" or "E" is missing)
> setnames(DT,c("X","Y","Z"))        # replace all (length of names must be == ncol(DT))
> setnames(DT,tolower)               # replace all names with their lower case
> setnames(DT,2:3,toupper)           # replace the 2nd and 3rd names with their upper case
> 
> DT <- data.table(x = 1:3, y = 4:6, z = 7:9)
> setnames(DT, -2, c("a", "b"))      # NEW FR #1443, allows -ve indices in 'old' argument
> 
> DT = data.table(a=1:3, b=4:6)
> f = function(...) {
+     # ...
+     setattr(DT,"myFlag",TRUE)  # by reference
+     # ...
+     localDT = copy(DT)
+     setattr(localDT,"myFlag2",TRUE)
+     # ...
+     invisible()
+ }
> f()
> attr(DT,"myFlag")   # TRUE
[1] TRUE
> attr(DT,"myFlag2")  # NULL
NULL
> 
> 
> 
> 
> cleanEx()
> nameEx("setcolorder")
> ### * setcolorder
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: setcolorder
> ### Title: Fast column reordering of a data.table by reference
> ### Aliases: setcolorder
> ### Keywords: data
> 
> ### ** Examples
> 
> 
> set.seed(45L)
> DT = data.table(A=sample(3, 10, TRUE),
+          B=sample(letters[1:3], 10, TRUE), C=sample(10))
> 
> setcolorder(DT, c("C", "A", "B"))
> 
> #incomplete specification
> setcolorder(DT, "A")
> 
> # insert new column as first column
> set(DT, j="D", value=sample(10))
> setcolorder(DT, "D", before=1)
> 
> # move column to last column place
> setcolorder(DT, "A", after=ncol(DT))
> 
> 
> 
> cleanEx()
> nameEx("setkey")
> ### * setkey
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: setkey
> ### Title: Create key on a data.table
> ### Aliases: setkey setkeyv key haskey setindex setindexv indices
> ### Keywords: data
> 
> ### ** Examples
> 
> # Type 'example(setkey)' to run these at the prompt and browse output
> 
> DT = data.table(A=5:1,B=letters[5:1])
> DT # before
       A      B
   <int> <char>
1:     5      e
2:     4      d
3:     3      c
4:     2      b
5:     1      a
> setkey(DT,B)          # re-orders table and marks it sorted.
> DT # after
Key: <B>
       A      B
   <int> <char>
1:     1      a
2:     2      b
3:     3      c
4:     4      d
5:     5      e
> tables()              # KEY column reports the key'd columns
   NAME NROW NCOL MB COLS KEY
1:   DT    5    2  0  A,B   B
Total: 0MB using type_size
> key(DT)
[1] "B"
> keycols = c("A","B")
> setkeyv(DT,keycols)
> 
> DT = data.table(A=5:1,B=letters[5:1])
> DT2 = DT              # does not copy
> setkey(DT2,B)         # does not copy-on-write to DT2
> identical(DT,DT2)     # TRUE. DT and DT2 are two names for the same keyed table
[1] TRUE
> 
> DT = data.table(A=5:1,B=letters[5:1])
> DT2 = copy(DT)        # explicit copy() needed to copy a data.table
> setkey(DT2,B)         # now just changes DT2
> identical(DT,DT2)     # FALSE. DT and DT2 are now different tables
[1] FALSE
> 
> DT = data.table(A=5:1,B=letters[5:1])
> setindex(DT)          # set indices
> setindex(DT, A)
> setindex(DT, B)
> indices(DT)           # get indices single vector
[1] "A__B" "A"    "B"   
> indices(DT, vectors = TRUE) # get indices list
[[1]]
[1] "A" "B"

[[2]]
[1] "A"

[[3]]
[1] "B"

> 
> # Setting multiple indices at once
> DT = data.table(A = 5:1, B = letters[5:1], C = 10:6)
> setindexv(DT, list(c("A", "B"), c("B", "C")))
> print(DT, show.indices=TRUE)
Indices: <A__B>, <B__C>
Warning in rbind(abbs, toprint) :
  number of columns of result is not a multiple of vector length (arg 1)
       A      B     C index1:A__B index2:B__C
   <int> <char> <int>       <int>      <char>
1:     5      e    10           5           5
2:     4      d     9           4           4
3:     3      c     8           3           3
4:     2      b     7           2           2
5:     1      a     6           1           1
> 
> # Use the dot .(subset_value) syntax with integer keys:
> DT = data.table(id = 2:1)
> setkey(DT, id)
> subset_value <- 1
> DT[subset_value]  # treats subset_value as an row number
Key: <id>
      id
   <int>
1:     1
> DT[.(subset_value)]  # matches subset_value against key column (id)
Key: <id>
      id
   <int>
1:     1
> 
> 
> 
> 
> cleanEx()
> nameEx("setops")
> ### * setops
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: setops
> ### Title: Set operations for data tables
> ### Aliases: setops intersect fintersect setdiff fsetdiff except fexcept
> ###   union funion setequal fsetequal
> ### Keywords: data
> 
> ### ** Examples
> 
> x = data.table(c(1,2,2,2,3,4,4))
> x2 = data.table(c(1,2,3,4)) # same set of rows as x
> y = data.table(c(2,3,4,4,4,5))
> fintersect(x, y)            # intersect
      V1
   <num>
1:     2
2:     3
3:     4
> fintersect(x, y, all=TRUE)  # intersect all
      V1
   <num>
1:     2
2:     3
3:     4
4:     4
> fsetdiff(x, y)              # except
      V1
   <num>
1:     1
> fsetdiff(x, y, all=TRUE)    # except all
      V1
   <num>
1:     1
2:     2
3:     2
> funion(x, y)                # union
      V1
   <num>
1:     1
2:     2
3:     3
4:     4
5:     5
> funion(x, y, all=TRUE)      # union all
       V1
    <num>
 1:     1
 2:     2
 3:     2
 4:     2
 5:     3
 6:     4
 7:     4
 8:     2
 9:     3
10:     4
11:     4
12:     4
13:     5
> fsetequal(x, x2, all=FALSE) # setequal
[1] TRUE
> fsetequal(x, x2)            # setequal all
[1] FALSE
> 
> 
> 
> cleanEx()
> nameEx("setorder")
> ### * setorder
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: setorder
> ### Title: Fast row reordering of a data.table by reference
> ### Aliases: setorder setorderv order fastorder forder forderv
> ### Keywords: data
> 
> ### ** Examples
> 
> 
> set.seed(45L)
> DT = data.table(A=sample(3, 10, TRUE),
+          B=sample(letters[1:3], 10, TRUE), C=sample(10))
> 
> # setorder
> setorder(DT, A, -B)
> 
> # same as above, but using setorderv
> setorderv(DT, c("A", "B"), c(1, -1))
> 
> 
> 
> cleanEx()
> nameEx("shift")
> ### * shift
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: shift
> ### Title: Fast lead/lag for vectors and lists
> ### Aliases: shift lead lag
> ### Keywords: data
> 
> ### ** Examples
> 
> # on vectors, returns a vector as long as length(n) == 1, #1127
> x = 1:5
> # lag with n=1 and pad with NA (returns vector)
> shift(x, n=1, fill=NA, type="lag")
[1] NA  1  2  3  4
> # lag with n=1 and 2, and pad with 0 (returns list)
> shift(x, n=1:2, fill=0, type="lag")
[[1]]
[1] 0 1 2 3 4

[[2]]
[1] 0 0 1 2 3

> # getting a window by using positive and negative n:
> shift(x, n = -1:1)
[[1]]
[1]  2  3  4  5 NA

[[2]]
[1] 1 2 3 4 5

[[3]]
[1] NA  1  2  3  4

> shift(x, n = -1:1, type = "shift", give.names = TRUE)
$`x_shift_-1`
[1]  2  3  4  5 NA

$x_shift_0
[1] 1 2 3 4 5

$x_shift_1
[1] NA  1  2  3  4

> # cyclic shift where pad uses pushed out values
> shift(x, n = -1:1, type = "cyclic")
[[1]]
[1] 2 3 4 5 1

[[2]]
[1] 1 2 3 4 5

[[3]]
[1] 5 1 2 3 4

> 
> # on data.tables
> DT = data.table(year=2010:2014, v1=runif(5), v2=1:5, v3=letters[1:5])
> # lag columns 'v1,v2,v3' DT by 1 and fill with 0
> cols = c("v1","v2","v3")
> anscols = paste("lead", cols, sep="_")
> DT[, (anscols) := shift(.SD, 1, 0, "lead"), .SDcols=cols]
> 
> # return a new data.table instead of updating
> # with names automatically set
> DT = data.table(year=2010:2014, v1=runif(5), v2=1:5, v3=letters[1:5])
> DT[, shift(.SD, 1:2, NA, "lead", TRUE), .SDcols=2:4]
    v1_lead_1  v1_lead_2 v2_lead_1 v2_lead_2 v3_lead_1 v3_lead_2
        <num>      <num>     <int>     <int>    <char>    <char>
1: 0.94467527 0.66079779         2         3         b         c
2: 0.66079779 0.62911404         3         4         c         d
3: 0.62911404 0.06178627         4         5         d         e
4: 0.06178627         NA         5        NA         e      <NA>
5:         NA         NA        NA        NA      <NA>      <NA>
> 
> # lag/lead in the right order
> DT = data.table(year=2010:2014, v1=runif(5), v2=1:5, v3=letters[1:5])
> DT = DT[sample(nrow(DT))]
> # add lag=1 for columns 'v1,v2,v3' in increasing order of 'year'
> cols = c("v1","v2","v3")
> anscols = paste("lag", cols, sep="_")
> DT[order(year), (cols) := shift(.SD, 1, type="lag"), .SDcols=cols]
> DT[order(year)]
    year        v1    v2     v3
   <int>     <num> <int> <char>
1:  2010        NA    NA   <NA>
2:  2011 0.2059746     1      a
3:  2012 0.1765568     2      b
4:  2013 0.6870228     3      c
5:  2014 0.3841037     4      d
> 
> # while grouping
> DT = data.table(year=rep(2010:2011, each=3), v1=1:6)
> DT[, c("lag1", "lag2") := shift(.SD, 1:2), by=year]
> 
> # on lists
> ll = list(1:3, letters[4:1], runif(2))
> shift(ll, 1, type="lead")
[[1]]
[1]  2  3 NA

[[2]]
[1] "c" "b" "a" NA 

[[3]]
[1] 0.2121425        NA

> shift(ll, 1, type="lead", give.names=TRUE)
$V1_lead_1
[1]  2  3 NA

$V2_lead_1
[1] "c" "b" "a" NA 

$V3_lead_1
[1] 0.2121425        NA

> shift(ll, 1:2, type="lead")
[[1]]
[1]  2  3 NA

[[2]]
[1]  3 NA NA

[[3]]
[1] "c" "b" "a" NA 

[[4]]
[1] "b" "a" NA  NA 

[[5]]
[1] 0.2121425        NA

[[6]]
[1] NA NA

> 
> # fill using first or last by group
> DT = data.table(x=1:6, g=rep(1:2, each=3))
> DT[ , shift(x, fill=x[1L]), by=g]
       g    V1
   <int> <int>
1:     1     1
2:     1     1
3:     1     2
4:     2     4
5:     2     4
6:     2     5
> DT[ , shift(x, fill=x[.N], type="lead"), by=g]
       g    V1
   <int> <int>
1:     1     2
2:     1     3
3:     1     3
4:     2     5
5:     2     6
6:     2     6
> 
> 
> 
> 
> cleanEx()
> nameEx("shouldPrint")
> ### * shouldPrint
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: shouldPrint
> ### Title: For use by packages that mimic/divert auto printing e.g.
> ###   IRkernel and knitr
> ### Aliases: shouldPrint
> 
> ### ** Examples
> 
> # dummy example section to pass release check that all .Rd files have examples
> 
> 
> 
> cleanEx()
> nameEx("special-symbols")
> ### * special-symbols
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: special-symbols
> ### Title: Special symbols
> ### Aliases: special-symbols datatable-symbols .SD .I .GRP .BY .N .EACHI
> ###   .NGRP .NATURAL
> ### Keywords: data
> 
> ### ** Examples
> 
> DT = data.table(x=rep(c("b","a","c"),each=3), v=c(1,1,1,2,2,1,1,2,2), y=c(1,3,6), a=1:9, b=9:1)
> DT
        x     v     y     a     b
   <char> <num> <num> <int> <int>
1:      b     1     1     1     9
2:      b     1     3     2     8
3:      b     1     6     3     7
4:      a     2     1     4     6
5:      a     2     3     5     5
6:      a     1     6     6     4
7:      c     1     1     7     3
8:      c     2     3     8     2
9:      c     2     6     9     1
> X = data.table(x=c("c","b"), v=8:7, foo=c(4,2))
> X
        x     v   foo
   <char> <int> <num>
1:      c     8     4
2:      b     7     2
> 
> DT[.N]                                 # last row, only special symbol allowed in 'i'
        x     v     y     a     b
   <char> <num> <num> <int> <int>
1:      c     2     6     9     1
> DT[, .N]                               # total number of rows in DT
[1] 9
> DT[, .N, by=x]                         # number of rows in each group
        x     N
   <char> <int>
1:      b     3
2:      a     3
3:      c     3
> DT[, .SD, .SDcols=x:y]                 # select columns 'x' through 'y'
        x     v     y
   <char> <num> <num>
1:      b     1     1
2:      b     1     3
3:      b     1     6
4:      a     2     1
5:      a     2     3
6:      a     1     6
7:      c     1     1
8:      c     2     3
9:      c     2     6
> DT[, .SD[1]]                           # first row of all columns
        x     v     y     a     b
   <char> <num> <num> <int> <int>
1:      b     1     1     1     9
> DT[, .SD[1], by=x]                     # first row of all columns for each group in 'x'
        x     v     y     a     b
   <char> <num> <num> <int> <int>
1:      b     1     1     1     9
2:      a     2     1     4     6
3:      c     1     1     7     3
> DT[, c(.N, lapply(.SD, sum)), by=x]    # get rows *and* sum all columns by group
        x     N     v     y     a     b
   <char> <int> <num> <num> <int> <int>
1:      b     3     3    10     6    24
2:      a     3     5    10    15    15
3:      c     3     5    10    24     6
> DT[, .I[1], by=x]                      # row number in DT corresponding to each group
        x    V1
   <char> <int>
1:      b     1
2:      a     4
3:      c     7
> DT[, .N, by=rleid(v)]                  # get count of consecutive runs of 'v'
   rleid     N
   <int> <int>
1:     1     3
2:     2     2
3:     3     2
4:     4     2
> DT[, c(.(y=max(y)), lapply(.SD, min)),
+         by=rleid(v), .SDcols=v:b]      # compute 'j' for each consecutive runs of 'v'
   rleid     y     v     y     a     b
   <int> <num> <num> <num> <int> <int>
1:     1     6     1     1     1     7
2:     2     3     2     1     4     5
3:     3     6     1     1     6     3
4:     4     6     2     3     8     1
> DT[, grp := .GRP, by=x]                # add a group counter
> DT[, grp_pct := .GRP/.NGRP, by=x]      # add a group "progress" counter
> X[, DT[.BY, y, on="x"], by=x]          # join within each group
        x    V1
   <char> <num>
1:      c     1
2:      c     3
3:      c     6
4:      b     1
5:      b     3
6:      b     6
> DT[X, on=.NATURAL]                     # join X and DT on common column similar to X[on=Y]
        x     v     y     a     b   grp grp_pct   foo
   <char> <int> <num> <int> <int> <int>   <num> <num>
1:      c     8    NA    NA    NA    NA      NA     4
2:      b     7    NA    NA    NA    NA      NA     2
> 
> # .N can be different in i and j
> DT[{cat(sprintf('in i, .N is %d\n', .N)); a < .N/2},
+    {cat(sprintf('in j, .N is %d\n', .N)); mean(a)}]
in i, .N is 9
in j, .N is 4
[1] 2.5
> 
> # .I can be different in j and by, enabling rowwise operations in by
> DT[, .(.I, min(.SD[,-1]))]
       I        V2
   <int>     <num>
1:     1 0.3333333
2:     2 0.3333333
3:     3 0.3333333
4:     4 0.3333333
5:     5 0.3333333
6:     6 0.3333333
7:     7 0.3333333
8:     8 0.3333333
9:     9 0.3333333
> DT[, .(min(.SD[,-1])), by=.I]
       I        V1
   <int>     <num>
1:     1 0.3333333
2:     2 0.3333333
3:     3 0.3333333
4:     4 0.6666667
5:     5 0.6666667
6:     6 0.6666667
7:     7 1.0000000
8:     8 1.0000000
9:     9 1.0000000
> 
> # Do not expect this to correctly append the value of .BY in each group; copy(.BY) will work.
> by_tracker = list()
> DT[, { append(by_tracker, .BY); sum(v) }, by=x]
        x    V1
   <char> <num>
1:      b     3
2:      a     5
3:      c     5
> 
> 
> 
> cleanEx()
> nameEx("split")
> ### * split
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: split
> ### Title: Split data.table into chunks in a list
> ### Aliases: split split.data.table
> ### Keywords: data
> 
> ### ** Examples
> 
> set.seed(123)
> DT = data.table(x1 = rep(letters[1:2], 6),
+                 x2 = rep(letters[3:5], 4),
+                 x3 = rep(letters[5:8], 3),
+                 y = rnorm(12))
> DT = DT[sample(.N)]
> DF = as.data.frame(DT)
> 
> # split consistency with data.frame: `x, f, drop`
> all.equal(
+     split(DT, list(DT$x1, DT$x2)),
+     lapply(split(DF, list(DF$x1, DF$x2)), setDT)
+ )
[1] TRUE
> 
> # nested list using `flatten` arguments
> split(DT, by=c("x1", "x2"))
$a.e
       x1     x2     x3          y
   <char> <char> <char>      <num>
1:      a      e      g  1.5587083
2:      a      e      e -0.6868529

$b.d
       x1     x2     x3          y
   <char> <char> <char>      <num>
1:      b      d      h -1.2650612
2:      b      d      f -0.2301775

$b.c
       x1     x2     x3           y
   <char> <char> <char>       <num>
1:      b      c      f -0.44566197
2:      b      c      h  0.07050839

$a.c
       x1     x2     x3          y
   <char> <char> <char>      <num>
1:      a      c      g  0.4609162
2:      a      c      e -0.5604756

$b.e
       x1     x2     x3         y
   <char> <char> <char>     <num>
1:      b      e      f 1.7150650
2:      b      e      h 0.3598138

$a.d
       x1     x2     x3         y
   <char> <char> <char>     <num>
1:      a      d      g 1.2240818
2:      a      d      e 0.1292877

> split(DT, by=c("x1", "x2"), flatten=FALSE)
$a
$a$e
       x1     x2     x3          y
   <char> <char> <char>      <num>
1:      a      e      g  1.5587083
2:      a      e      e -0.6868529

$a$c
       x1     x2     x3          y
   <char> <char> <char>      <num>
1:      a      c      g  0.4609162
2:      a      c      e -0.5604756

$a$d
       x1     x2     x3         y
   <char> <char> <char>     <num>
1:      a      d      g 1.2240818
2:      a      d      e 0.1292877


$b
$b$d
       x1     x2     x3          y
   <char> <char> <char>      <num>
1:      b      d      h -1.2650612
2:      b      d      f -0.2301775

$b$c
       x1     x2     x3           y
   <char> <char> <char>       <num>
1:      b      c      f -0.44566197
2:      b      c      h  0.07050839

$b$e
       x1     x2     x3         y
   <char> <char> <char>     <num>
1:      b      e      f 1.7150650
2:      b      e      h 0.3598138


> 
> # dealing with factors
> fdt = DT[, c(lapply(.SD, as.factor), list(y=y)), .SDcols=x1:x3]
> fdf = as.data.frame(fdt)
> sdf = split(fdf, list(fdf$x1, fdf$x2))
> all.equal(
+     split(fdt, by=c("x1", "x2"), sorted=TRUE),
+     lapply(sdf[sort(names(sdf))], setDT)
+ )
[1] TRUE
> 
> # factors having unused levels, drop FALSE, TRUE
> fdt = DT[, .(x1 = as.factor(c(as.character(x1), "c"))[-13L],
+              x2 = as.factor(c("a", as.character(x2)))[-1L],
+              x3 = as.factor(c("a", as.character(x3), "z"))[c(-1L,-14L)],
+              y = y)]
> fdf = as.data.frame(fdt)
> sdf = split(fdf, list(fdf$x1, fdf$x2))
> all.equal(
+     split(fdt, by=c("x1", "x2"), sorted=TRUE),
+     lapply(sdf[sort(names(sdf))], setDT)
+ )
[1] TRUE
> sdf = split(fdf, list(fdf$x1, fdf$x2), drop=TRUE)
> all.equal(
+     split(fdt, by=c("x1", "x2"), sorted=TRUE, drop=TRUE),
+     lapply(sdf[sort(names(sdf))], setDT)
+ )
[1] TRUE
> 
> 
> 
> cleanEx()
> nameEx("subset.data.table")
> ### * subset.data.table
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: subset.data.table
> ### Title: Subsetting data.tables
> ### Aliases: subset subset.data.table
> ### Keywords: data
> 
> ### ** Examples
> 
> 
> DT <- data.table(a=sample(c('a', 'b', 'c'), 20, replace=TRUE),
+                  b=sample(c('a', 'b', 'c'), 20, replace=TRUE),
+                  c=sample(20), key=c('a', 'b'))
> 
> sub <- subset(DT, a == 'a')
> all.equal(key(sub), key(DT))
[1] TRUE
> 
> 
> 
> cleanEx()
> nameEx("substitute2")
> ### * substitute2
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: substitute2
> ### Title: Substitute expression
> ### Aliases: substitute2 substitute I
> ### Keywords: data
> 
> ### ** Examples
> 
> ## base R substitute vs substitute2
> substitute(list(var1 = var2), list(var1 = "c1", var2 = 5L))
list(var1 = 5L)
> substitute2(list(var1 = var2), list(var1 = "c1", var2 = 5L)) ## works also on names
list(c1 = 5L)
> 
> substitute(var1, list(var1 = "c1"))
[1] "c1"
> substitute2(var1, list(var1 = I("c1"))) ## enforce character with I
[1] "c1"
> 
> substitute(var1, list(var1 = as.name("c1")))
c1
> substitute2(var1, list(var1 = "c1")) ## turn character into symbol, for convenience
c1
> 
> ## mix symbols and characters using 'I' function, both lines will yield same result
> substitute2(list(var1 = var2), list(var1 = "c1", var2 = I("some_character")))
list(c1 = "some_character")
> substitute2(list(var1 = var2), I(list(var1 = as.name("c1"), var2 = "some_character")))
list(c1 = "some_character")
> 
> ## list elements are enlist'ed into list calls
> (cl1 = substitute(f(lst), list(lst = list(1L, 2L))))
f(list(1L, 2L))
> (cl2 = substitute2(f(lst), I(list(lst = list(1L, 2L)))))
f(list(1L, 2L))
> (cl3 = substitute2(f(lst), list(lst = I(list(1L, 2L)))))
f(list(1L, 2L))
> (cl4 = substitute2(f(lst), list(lst = quote(list(1L, 2L)))))
f(list(1L, 2L))
> (cl5 = substitute2(f(lst), list(lst = list(1L, 2L))))
f(list(1L, 2L))
> cl1[[2L]] ## base R substitute with list element
[[1]]
[1] 1

[[2]]
[1] 2

> cl2[[2L]] ## same
[[1]]
[1] 1

[[2]]
[1] 2

> cl3[[2L]] ## same
[[1]]
[1] 1

[[2]]
[1] 2

> cl4[[2L]] ## desired
list(1L, 2L)
> cl5[[2L]] ## automatically
list(1L, 2L)
> 
> ## character to name and list into list calls works recursively
> (cl1 = substitute2(f(lst), list(lst = list(1L, list(2L)))))
f(list(1L, list(2L)))
> (cl2 = substitute2(f(lst), I(list(lst = list(1L, list(2L)))))) ## unless I() used
f(list(1L, list(2L)))
> last(cl1[[2L]]) ## enlisted recursively
list(2L)
> last(cl2[[2L]]) ## AsIs
[[1]]
[1] 2

> 
> ## using substitute2 from another function
> f = function(expr, env) {
+   eval(substitute(
+     substitute2(.expr, env),
+     list(.expr = substitute(expr))
+   ))
+ }
> f(list(var1 = var2), list(var1 = "c1", var2 = 5L))
list(c1 = 5L)
> 
> 
> 
> cleanEx()
> nameEx("tables")
> ### * tables
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: tables
> ### Title: Display 'data.table' metadata
> ### Aliases: tables
> ### Keywords: data
> 
> ### ** Examples
> 
> DT = data.table(A=1:10, B=letters[1:10])
> DT2 = data.table(A=1:10000, ColB=10000:1)
> setkey(DT,B)
> tables()
   NAME  NROW NCOL MB   COLS    KEY
1:   DT    10    2  0    A,B      B
2:  DT2 10000    2  0 A,ColB [NULL]
Total: 0MB using type_size
> 
> 
> 
> cleanEx()
> nameEx("test")
> ### * test
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: test
> ### Title: Test assertions for equality, exceptions and console output
> ### Aliases: test
> ### Keywords: data
> 
> ### ** Examples
> 
> test = data.table:::test
> test(1, x = sum(1:5), y = 15L)
> test(2, log(-1), NaN, warning="NaNs")
> test(3, sum("a"), error="invalid.*character")
> # test failure example
> stopifnot(
+   test(4, TRUE, FALSE) == FALSE
+ )
Test 4 ran without errors but failed check that x equals y:
> x = TRUE 
First 1 of 1 (type 'logical'): 
[1] TRUE
> y = FALSE 
First 1 of 1 (type 'logical'): 
[1] FALSE
1 element mismatch
> # NA_real_ vs NaN
> test(5.01, NA_real_, NaN)
> test(5.03, all.equal(NaN, NA_real_))
> test(5.02, identical(NaN, NA_real_), FALSE)
> 
> 
> 
> cleanEx()
> nameEx("test.data.table")
> ### * test.data.table
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: test.data.table
> ### Title: Runs a set of tests.
> ### Aliases: test.data.table
> ### Keywords: data
> 
> ### ** Examples
> 
>   ## Not run: 
> ##D   test.data.table()
> ##D   
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("timetaken")
> ### * timetaken
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: timetaken
> ### Title: Pretty print of time taken
> ### Aliases: timetaken
> ### Keywords: data
> 
> ### ** Examples
> 
> started.at=proc.time()
> Sys.sleep(1)
> cat("Finished in",timetaken(started.at),"\n")
Finished in 1.001s elapsed (0.000s cpu) 
> 
> 
> 
> cleanEx()
> nameEx("transform.data.table")
> ### * transform.data.table
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: transform.data.table
> ### Title: Data table utilities
> ### Aliases: transform transform.data.table within within.data.table
> ### Keywords: data internal
> 
> ### ** Examples
> 
> DT <- data.table(a=rep(1:3, each=2), b=1:6)
> 
> DT2 <- transform(DT, c = a^2)
> DT[, c:=a^2]
> identical(DT,DT2)
[1] TRUE
> 
> DT2 <- within(DT, {
+   b <- rev(b)
+   c <- a*2
+   rm(a)
+ })
> DT[,`:=`(b = rev(b),
+          c = a*2,
+          a = NULL)]
> identical(DT,DT2)
[1] TRUE
> 
> DT$d = ave(DT$b, DT$c, FUN=max)               # copies entire DT, even if it is 10GB in RAM
> DT = DT[, transform(.SD, d=max(b)), by="c"]   # same, but even worse as .SD is copied for each group
> DT[, d:=max(b), by="c"]                       # same result, but much faster, shorter and scales
> 
> # Multiple update by group. Convenient, fast, scales and easy to read.
> DT[, `:=`(minb = min(b),
+           meanb = mean(b),
+           bplusd = sum(b+d)),  by=c%/%5]
> DT
       c     b     d  minb meanb bplusd
   <num> <int> <int> <int> <num>  <int>
1:     2     6     6     3   4.5     38
2:     2     5     6     3   4.5     38
3:     4     4     4     3   4.5     38
4:     4     3     4     3   4.5     38
5:     6     2     2     1   1.5      7
6:     6     1     2     1   1.5      7
> 
> 
> 
> 
> cleanEx()
> nameEx("transpose")
> ### * transpose
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: transpose
> ### Title: Efficient transpose of list
> ### Aliases: transpose
> ### Keywords: data
> 
> ### ** Examples
> 
> ll = list(1:5, 6:8)
> transpose(ll)
[[1]]
[1] 1 6

[[2]]
[1] 2 7

[[3]]
[1] 3 8

[[4]]
[1]  4 NA

[[5]]
[1]  5 NA

> setDT(transpose(ll, fill=0))[]
      V1    V2    V3    V4    V5
   <int> <int> <int> <int> <int>
1:     1     2     3     4     5
2:     6     7     8     0     0
> 
> DT = data.table(x=1:5, y=6:10)
> transpose(DT)
      V1    V2    V3    V4    V5
   <int> <int> <int> <int> <int>
1:     1     2     3     4     5
2:     6     7     8     9    10
> 
> DT = data.table(x=1:3, y=c("a","b","c"))
> transpose(DT, list.cols=TRUE)
       V1     V2     V3
   <list> <list> <list>
1:      1      2      3
2:      a      b      c
> 
> # base R equivalent of transpose
> l = list(1:3, c("a", "b", "c"))
> lapply(seq(length(l[[1]])), function(x) lapply(l, `[[`, x))
[[1]]
[[1]][[1]]
[1] 1

[[1]][[2]]
[1] "a"


[[2]]
[[2]][[1]]
[1] 2

[[2]][[2]]
[1] "b"


[[3]]
[[3]][[1]]
[1] 3

[[3]][[2]]
[1] "c"


> transpose(l, list.cols=TRUE)
[[1]]
[[1]][[1]]
[1] 1

[[1]][[2]]
[1] "a"


[[2]]
[[2]][[1]]
[1] 2

[[2]][[2]]
[1] "b"


[[3]]
[[3]][[1]]
[1] 3

[[3]][[2]]
[1] "c"


> 
> ll = list(nm=c('x', 'y'), 1:2, 3:4)
> transpose(ll, make.names="nm")
$x
[1] 1 3

$y
[1] 2 4

> 
> 
> 
> cleanEx()
> nameEx("truelength")
> ### * truelength
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: truelength
> ### Title: Over-allocation access
> ### Aliases: truelength setalloccol alloc.col
> ### Keywords: data
> 
> ### ** Examples
> 
> DT = data.table(a=1:3,b=4:6)
> length(DT)                 # 2 column pointer slots used
[1] 2
> truelength(DT)             # 1026 column pointer slots allocated
[1] 1026
> setalloccol(DT, 2048)
       a     b
   <int> <int>
1:     1     4
2:     2     5
3:     3     6
> length(DT)                 # 2 used
[1] 2
> truelength(DT)             # 2050 allocated, 2048 free
[1] 2050
> DT[,c:=7L]                 # add new column by assigning to spare slot
> truelength(DT)-length(DT)  # 2047 slots spare
[1] 2047
> 
> 
> 
> cleanEx()
> nameEx("tstrsplit")
> ### * tstrsplit
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: tstrsplit
> ### Title: strsplit and transpose the resulting list efficiently
> ### Aliases: tstrsplit strsplit
> ### Keywords: data
> 
> ### ** Examples
> 
> x = c("abcde", "ghij", "klmnopq")
> strsplit(x, "", fixed=TRUE)
[[1]]
[1] "a" "b" "c" "d" "e"

[[2]]
[1] "g" "h" "i" "j"

[[3]]
[1] "k" "l" "m" "n" "o" "p" "q"

> tstrsplit(x, "", fixed=TRUE)
[[1]]
[1] "a" "g" "k"

[[2]]
[1] "b" "h" "l"

[[3]]
[1] "c" "i" "m"

[[4]]
[1] "d" "j" "n"

[[5]]
[1] "e" NA  "o"

[[6]]
[1] NA  NA  "p"

[[7]]
[1] NA  NA  "q"

> tstrsplit(x, "", fixed=TRUE, fill="<NA>")
[[1]]
[1] "a" "g" "k"

[[2]]
[1] "b" "h" "l"

[[3]]
[1] "c" "i" "m"

[[4]]
[1] "d" "j" "n"

[[5]]
[1] "e"    "<NA>" "o"   

[[6]]
[1] "<NA>" "<NA>" "p"   

[[7]]
[1] "<NA>" "<NA>" "q"   

> 
> # using keep to return just 1,3,5
> tstrsplit(x, "", fixed=TRUE, keep=c(1,3,5))
[[1]]
[1] "a" "g" "k"

[[2]]
[1] "c" "i" "m"

[[3]]
[1] "e" NA  "o"

> 
> # names argument
> tstrsplit(x, "", fixed=TRUE, keep=c(1,3,5), names=LETTERS[1:3])
$A
[1] "a" "g" "k"

$B
[1] "c" "i" "m"

$C
[1] "e" NA  "o"

> 
> DT = data.table(x=c("A/B", "A", "B"), y=1:3)
> DT[, c("c1") := tstrsplit(x, "/", fixed=TRUE, keep=1L)][]
        x     y     c1
   <char> <int> <char>
1:    A/B     1      A
2:      A     2      A
3:      B     3      B
> DT[, c("c1", "c2") := tstrsplit(x, "/", fixed=TRUE)][]
        x     y     c1     c2
   <char> <int> <char> <char>
1:    A/B     1      A      B
2:      A     2      A   <NA>
3:      B     3      B   <NA>
> 
> # type.convert argument
> DT = data.table(
+   w = c("Yes/F", "No/M"),
+   x = c("Yes 2000-03-01 A/T", "No 2000-04-01 E/R"),
+   y = c("1/1/2", "2/5/2.5"),
+   z = c("Yes/1/2", "No/5/3.5"),
+   v = c("Yes 10 30.5 2000-03-01 A/T", "No 20 10.2 2000-04-01 E/R"))
> 
> # convert each element in the transpose list to type factor
> DT[, tstrsplit(w, "/", type.convert=as.factor)]
       V1     V2
   <fctr> <fctr>
1:    Yes      F
2:     No      M
> 
> # convert part and leave any others
> DT[, tstrsplit(z, "/", type.convert=list(as.numeric=2:3))]
       V1    V2    V3
   <char> <num> <num>
1:    Yes     1   2.0
2:     No     5   3.5
> 
> # convert part with one function and any others with another
> DT[, tstrsplit(z, "/", type.convert=list(as.factor=1L, as.numeric))]
       V1    V2    V3
   <fctr> <num> <num>
1:    Yes     1   2.0
2:     No     5   3.5
> 
> # convert the remaining using 'type.convert(x, as.is=TRUE)' (i.e. what type.convert=TRUE does)
> DT[, tstrsplit(v, " ", type.convert=list(as.IDate=4L, function(x) type.convert(x, as.is=TRUE)))]
       V1    V2    V3         V4     V5
   <char> <int> <num>     <IDat> <char>
1:    Yes    10  30.5 2000-03-01    A/T
2:     No    20  10.2 2000-04-01    E/R
> 
> 
> 
> cleanEx()
> nameEx("update_dev_pkg")
> ### * update_dev_pkg
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: update_dev_pkg
> ### Title: Perform update of development version of a package
> ### Aliases: update_dev_pkg
> ### Keywords: data
> 
> ### ** Examples
> 
> ## Don't show: 
>  # using if(FALSE) because \dontrun could still be run by  --run-dontrun; #5421 
> ## End(Don't show)
>   if (FALSE) data.table::update_dev_pkg()
> 
> 
> 
> ### * <FOOTER>
> ###
> cleanEx()
> options(digits = 7L)
> base::cat("Time elapsed: ", proc.time() - base::get("ptime", pos = 'CheckExEnv'),"\n")
Time elapsed:  2.042 0.124 2.798 0 0 
> grDevices::dev.off()
null device 
          1 
> ###
> ### Local variables: ***
> ### mode: outline-minor ***
> ### outline-regexp: "\\(> \\)?### [*]+" ***
> ### End: ***
> quit('no')
