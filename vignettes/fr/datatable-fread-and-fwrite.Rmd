---
title: "Lecture et écriture rapides"
date: "`r Sys.Date()`"
output: 
  markdown::html_format
vignette: >
  %\VignetteIndexEntry{Importing data.table}
  %\VignetteEngine{knitr::knitr}
  \usepackage[utf8]{inputenc}
---

```{r echo=FALSE, file='../_translation_links.R'}
```
`r .write.translation.links("Une traduction de ce document est disponible en : %s")`

```{r, echo = FALSE, message = FALSE}
require(data.table)
knitr::opts_chunk$set(
  comment = "#",
    error = FALSE,
     tidy = FALSE,
    cache = FALSE,
 collapse = TRUE)
.old.th = setDTthreads(1)
```

Les fonctions `fread()` et `fwrite()` du paquet R `data.table` ne sont pas uniquement optimisées pour améliorer les performances avec de gros fichiers, mais elles offrent également des fonctionnalités puissantes et pratiques si voius utilisez de petits ensembles de données. Cette vignette montre leur utilisation, leur adaptabilité, et les performances pour importer et exporter des données.

***

## 1. fread()

### **1.1 Utilisation directe des outils en mode ligne de commande**
La fonction `fread()` de `data.table` peut lire des données redirigées à partir des commandes du shell, ce qui vous donne la possibilité de filtrer ou de pré-traiter les données avant même qu'elles soient soumises à R.

```{r}
# Créer un simple fichier avec quelques lignes non souhaitées
writeLines(
'HEADER: quelques méta-données
HEADER: méta-données supplémentaires 
1 2.0 3.0
2 4.5 6.7
HEADER: encore d'autres
3 8.9 0.1
4 1.2 3.4',
"example_data.txt")

library(data.table)
fread("grep -v HEADER example_data.txt")
```

L'option `-v` fait que la commande `grep` va renvoyer toutes les lignes sauf celles qui contiennent la chaîne 'HEADER'.

> "Etant donné le nombre d'ingénieurs hautement qualifiés qui se sont penché sur l'outil de commande grep durant ces années, il edst très probable qu'elle soit aussi rapide que possible, tout en étant correcte, pratique, bien documentée en ligne, facile à apprendre et à rechercher des solutions pour les tâches spécifiques. Si vous devez faire un filtrage sur des chaînes plus complexes (comme par exemple trouver des chaînes en début ou en fin de ligne), la syntaxe de grep est très puissante. En l'apprenant, vous pourrez réutiliser vos connaissances avec d'autres langages et environnements."
>
> — Matt Dowle  

Voir cet [exemple](https://stackoverflow.com/questions/36256706/fread-together-with-grepl/36270543#36270543) pour d'autres détails.

Sous Wndows, les outils en mode ligne de commande tels que `grep` sont disponibles dans divers environnements, tels que Rtools, Cygwin, ou Windows Subsystem for Linux (WSL). Sous Linux et macOS, ces outils sont typiquement inclus dans le système d'exploitation.

#### 1.1.1  Lecture directe à partir d'une chaîne textuelle

`fread()` peut lire les données directement à partir d'une chaîne de caractères dans R en utilisant l'argument `text`. Ceci est particulièrement pratique pour créer des exemples reproductibles, pour tester quelques lignes de code, ou pour travailler avec des données générées par un programme à l'intérieur d'une session R. Chaque ligne de la chaîne doit être séparée avec le caractère de passage à la ligne `\n`.

```{r}
my_data_string = "colA,colB,colC\n1,apple,TRUE\n2,banana,FALSE\n3,orange,TRUE"
dt_from_text = fread(text = my_data_string)
print(dt_from_text)
```

#### 1.1.2 Lecture à partir d'URLs

`fread()` peut lire les données directement à partir d'URLs web en passant l'URL en tant que chaîne de caractères dans l'argument `file`. Cela vous permet de télécharger et de lire les données à partir d'internet en une seule passe.

  ```{r}
  # dt = fread("https://people.sc.fsu.edu/~jburkardt/data/csv/airtravel.csv")
  # print(dt)
  ```

#### 1.1.3 Décompression automatique des fichiers compressés


Dans beaucoup de cas, `fread()` peut automatiquement détecter et décompresser les fichiers directement en utilisant les extensions de compression communes et sans avoir besoin d'un objet de connexion explicite ou de commandes du shell. Il se base sur l'extension du fichier.

**Les extensions reconnues incluent typiquement :**
- `.gz` / `.bz2` (gzip / bzip2) : acceptés et fonctionnent de manière indépendante.
- `.zip` / `.tar`  (archives ZIP ou tar, fichier unique) : acceptées — `fread()` lira le premier fichier de l'archive si elle n'encontient qu'un seul.

> Note : si l'archive contient plusieurs fichiers, `fread()` échouera avec une erreur.

### 1.2 Séparateur automatique et détection des sauts de lignes

`fread` automatise la détection du délimiteur et de l'entête, en élminant le besoin  de le spécifier manuellement dans la plupart des cas. Il suffit de fournir le nom de fichier — `fread` détectera intelligemment la structure :

**Détection des séparateurs**

`fread` teste les séparateurs usuels (`,`,`\t`, `|`, espace, `:`, `;`) et sélectionne celui qui fournit le nombre le plus cohérent de champs tout au long les lignes analysées. Dans le cas des délimiteurs non standard, vous pouvez rédéfinir ceci en utilisant le paramètre `sep=` .

**Détection de l'entête**

Après avoir appliqué les éventuelles valeurs de `skip` ou de `nrows` (si spécifiées), la première ligne qui comporte un nombre cohérent de champs est analysée :

Si on peut interpréter tous les champs de cette ligne comme des caractères et que les valeurs ne ressemblent pas trop à une ligne de données (par exemple une ligne de valeurs purement numériques pourrait encore être considérée comme des données), alors il s'agit typiquement d'une ligne d'entête (le nom des colonnes).

Sinon (c'est à dire si la ligne contient des types numériques reconnus, ou des chaînes de caractères qui ressemblent fortement à des nombres et qui pourraient être des données), elle est traitée comme une ligne de données et reçoit les noms de colonnnes par défaut (`V1`, `V2`, …).

Vous pouvez dire explicitement à fread si une entête existe en utilisant `header = TRUE` ou `header = FALSE`.

**Détection des sauts de lignes**

Par défaut (`skip="auto"`), `fread` va automatiquement sauter les lignes vides ainsi que les lignes de commentaires (celles qui commencent par `#`) avant l'entête des données. Pour forcer manuellement un nombre donné de lignes, utilisez use `skip=n`.

### 1.3 Détection avancée et automatique du type de colonne

Dans le monde réel, beaucoup d'ensembles de données contiennent des colonnes qui sont vides au départ, remplies par des zéros, ou qui apparaissent numériques mais qui contiendront des caractères ultérieurement. Pour gérer de telles incohérences, `fread()` de `data.table` utilise une stratégie robuste de détection du type de colonne.

Depuis la v1.10.5, `fread()` échantillonne les lignes en lisant des blocs de lignes contigües à partir de plusieurs points espacés régulièrement dans l'ensemble du fichier, y compris le début, le milieu et la fin. Le nombre de lignes échantillonnées est choisi dynamiquement en fonction de la taille et de la structure du fichier et vaut typiquement aux environs de 10 000, mais il peut être plus petit ou légèrement supérieur. Ce grand échantillonnage aide à détecter les changements de type qui se produisent ultérieurement dans les données (par exemple `001` qui devient `0A0` ou des blancs qui deviennent des valeurs).

**Accès aux fichier performant avec mmap**

Pour implémenter efficacement cet échantillonnage, `fread()` utilise le mappage en mémoire de l'accès aux fichiers du système d'exploitation (`mmap`), ce qui permet de sauter à des positions arbitraires dans le fichier sans le parcourir séquentiellement. Cette stratégie paresseuse à la demande rend l'échantillonnnage presque instantané même avec des fichiers très gros.

Si la destination du saut se trouve dans un champ entre guillemets comprenant des passages à la ligne, `fread()` teste les lignes qui suivent jusqu'à trouver 5 lignes consécutives avec le nombre attendu de champs, pour permettre une analyse correcte même avec des fichiers complexes.

**Détection précise et optimisée du type**

Le type de chaque colonne est déduit en se basant sur le type le plus bas nécessaire de la liste ordonnée suivante :

`booléen` < `entier` < `entier 64` < `double` < `caractère`

Ce qui permet :

- d'allouer la mémoire de manière unique à l'avance en utilisant le type correct
- d'éviter la relecture du fichier ou de définir les colClasses manuellement 
- d'améliorer la vitesse et efficacité de la mémoire

**Exceptions sur le type dans les valeurs non échantillonnées**

Si le type est modifié dans les lignes qui ne sont pas échantillonnées, `fread()` détecte cela automatiquement et relit le fichier pour rétablir l'assignation correcte du type, sans nécessiter l'intervention de l'utilisateur. Par exemple une colonne échantillonnée comme entier pourrait ultérieurement contenir `00A` — ce qui déclenchera une relecture automatique en tant que caractère.

En activant `verbose=TRUE` vous pourrez voir toute la logique de détection ainsi que les relectures.

### 1.4 Détection des erreurs au plus tôt à la fin du fichier

Parce qu'un grand nombre d'échantillons signifie que l'on se rapproche de la fin du fichier, les problèmes critiques tels qu'un nombre incohérent de colonnes, un bas de page mal formaté, ou des guillemets ouvrants qui ne sont pas fermés — peuvent être détectés et rapportés presque instantanément. Cette détection d'erreurs au plus tôt évite la surcharge d'un nouveau traitement du fichier complet ou l'allocation excessive de la mémoire, simplement pour trouver une erreur à la fin. Cela permet une réaction plus rapide et une utilisation plus efficace des ressources, particulièrement lorsque vous travaillez avec de gros ensembles de données.

### 1.5 Prise en charge de `integer64`

Par défaut, `fread` détecte les entiers plus grands que 2<sup>31</sup> et les lit en tant que `bit64::integer64` pour préserver la précision complète. Ce comportement peut être redéfini de trois manières :

- par colonne : utiliser l'argument `colClasses` pour spécifier le type des colonnes individuelles.

- par appel : utiliser l'argument `integer64` dans `fread()` pour définir la manière dont toutes les colonnes `integer64` détectées seront lues.

- globalement : définir l'option `datatable.integer64` de votre session R ou du fichier `.Rprofile` pour modifier le comportement par défaut pour tous les appels de fread.

L'argument integer64 et l'option correspondante acceptent les valeurs suivantes :

- `"integer64"` (par défaut) : lit les entiers longs en tant que `bit64::integer64` avec la précision complète.

- `"double"` ou `"numeric"`: lit les entiers longs en tant que nombres à double précision, éventuellement en perdant discrètement la précision (similaire à `utils::read.csv` en base R).

- `"character"` : lit les entiers longs en tant que chaînes de caractères.

Pour vérifier ou définit le comportement global par default, utilisez :

```{r}
# le comportement par défaut de fread est de traiter les entiers longs comme "integer64"; mais ce paramètre global peut être modifié :
options(datatable.integer64 = "double")   # Exemple : définir globalement à "double"
getOption("datatable.integer64") 
```

### 1.6 Ignorer ou sélectionner les colonnes par nom ou par position

To save memory and improve performance, use `fread()`'s `select` or `drop` arguments to read only the columns you need.

- If you need only a few columns, use `select`.
- If you want to exclude just a few, use `drop`—this avoids listing everything you want to keep.

Key points:
- `select`: Vector of column names/positions to keep (discards others).
- `drop`: Vector of column names/positions to discard (keeps others).
- Do not use `select` and `drop` together—they are mutually exclusive.
- `fread()` will warn you if any specified column is missing in the file.

For details, see the manual page by running `?fread` in R.

### 1.7 Skip to a Sub-Table’s Header Row Using a Column Name Substring

Use `skip="string"` in `fread` to search for a line containing a substring (typically from the column names, e.g., `skip="Date"`). Reading begins at the first matching line. This is useful for skipping metadata or selecting sub-tables in multi-table files. This feature is inspired by the `read.xls` function in the gdata package.

### 1.8 Automatic Quote Escape Detection (Including No-Escape)

`fread` automatically detects how quotes are escaped—including doubled ("") or backslash-escaped (\") quotes—without requiring user input. This is determined using a large sample of the data (see point 3), and validated against the entire file.

Supported Scenarios:
- Unescaped quotes inside quoted fields
e.g., `"This "quote" is invalid"` — supported as long as column count remains consistent.

- Unquoted fields that begin with quotes
e.g., `Invalid"Field,10,20` — recognized correctly as not a quoted field.

Requirements & Limitations:
- Escaping rules and column counts must be consistent throughout the file.

- Not supported when `fill=TRUE` — in that case, the file must follow RFC4180-compliant quoting/escaping.

Version-Specific Robustness:
From v1.10.6, `fread` resolves ambiguities more reliably across the entire file using full-column-count consistency (default is `fill=FALSE`). Warnings are issued if parsing fails due to ambiguity.

## 2. fwrite()

`fwrite()` is the fast file writer companion to `fread()`. It’s designed for speed, sensible defaults, and ease of use, mirroring many of the conveniences found in fread`.

### 2.1 Intelligent and Minimalist Quoting (quote="auto")

When data is written as strings (either inherently, like character columns, or by choice, like `dateTimeAs="ISO"`), `quote="auto"` (default) intelligently quotes fields:

**Contextual Quoting**:Fields are quoted only when necessary. This happens if they contain the delimiter `(sep)`, a double quote `(")`, a newline `(\n)`, a carriage return `(\r)`, or if the field is an empty string `("")`. Quoting the empty string is done to distinguish it from an NA value when the file is read.

**Bypassed for Direct Numeric Output**: If specific columns are written as their underlying numeric types (e.g., via `dateTimeAs="epoch"` for `POSIXct`, or if a user pre-converts Date to integer), then quoting logic is naturally bypassed for those numeric fields, contributing to efficiency.

```{r}
dt_quoting_scenario = data.table(
  text_field = c("Contains,a,comma", "Contains \"a quote\"", "Clean_text", "", NA),
  numeric_field = 1:5
)
temp_quote_adv = tempfile(fileext = ".csv")

fwrite(dt_quoting_scenario, temp_quote_adv)
# Note the output: the empty string is quoted (""), but the NA is not.
cat(readLines(temp_quote_adv), sep = "\n")
```

### 2.2 Fine-Grained Date/Time Serialization (dateTimeAs)

Offers precise control for POSIXct/Date types:

- `dateTimeAs="ISO"` (Default for POSIXct): ISO 8601 format (e.g., YYYY-MM-DDTHH:MM:SS.ffffffZ), preserving sub-second precision for unambiguous interchange.

- `dateTimeAs="epoch"`: POSIXct as seconds since epoch (numeric).

```{r}
dt_timestamps = data.table(
  ts = as.POSIXct("2023-10-26 14:35:45.123456", tz = "GMT"),
  dt = as.Date("2023-11-15")
)
temp_dt_iso = tempfile(fileext = ".csv")
fwrite(dt_timestamps, temp_dt_iso, dateTimeAs = "ISO")
cat(readLines(temp_dt_iso), sep = "\n")
unlink(temp_dt_iso)
```

### 2.3 Handling of bit64::integer64

**Full Precision for Large Integers**: `fwrite` writes `bit64::integer64` columns by converting them to strings with full precision. This prevents data loss or silent conversion to double that might occur with less specialized writers. This is crucial for IDs or measurements requiring more than R's standard `32-bit` integer range or `53-bit` double precision.

**Direct Handling**: This direct and careful handling of specialized numerics ensures data integrity and efficient I/O, without unnecessary intermediate conversions to less precise types.

```{r}
if (requireNamespace("bit64", quietly = TRUE)) {
  dt_i64 = data.table(uid = bit64::as.integer64("1234567890123456789"), val = 100)
  temp_i64_out = tempfile(fileext = ".csv")
  fwrite(dt_i64, temp_i64_out)
  cat(readLines(temp_i64_out), sep = "\n")

  unlink(temp_i64_out)
}
```

### 2.4 Column Order and Subset Control

To control the order and subset of columns written to file, subset the data.table before calling `fwrite()`. The `col.names` argument in `fwrite()` is a logical (TRUE/FALSE) that controls whether the header row is written, not which columns are written.

```{r}
dt = data.table(A = 1:3, B = 4:6, C = 7:9)

# Write only columns C and A, in that order
fwrite(dt[, .(C, A)], "out.csv")
cat(readLines("out.csv"), sep = "\n")
file.remove("out.csv")
```

## 3. A Note on Performance

While this vignette focuses on features and usability, the primary motivation for `fread` and `fwrite` is speed. The performance of `data.table`'s I/O is a topic of continuous benchmarking.

For users interested in detailed, up-to-date performance comparisons, we recommend these external blog posts which use the `atime` package for rigorous analysis:

- **[data.table asymptotic timings](https://tdhock.github.io/blog/2023/dt-atime-figures/)**: Compares `fread` and `fwrite` performance against other popular R packages like `readr` and `arrow`.
- **[Benchmarking data.table with polars, duckdb, and pandas](https://tdhock.github.io/blog/2024/pandas-dt/)**: Compares `data.table` I/O and grouping performance against leading Python libraries.

These benchmarks consistently show that `fread` and `fwrite` are highly competitive and often state-of-the-art for performance in the R ecosystem.

***
