---
title: "Lecture et écriture rapides"
date: "`r Sys.Date()`"
output: 
  markdown::html_format
vignette: >
  %\VignetteIndexEntry{Importing data.table}
  %\VignetteEngine{knitr::knitr}
  \usepackage[utf8]{inputenc}
---

```{r echo=FALSE, file='_translation_links.R'}
```
`r .write.translation.links("Une traduction de ce document est disponible en : %s")`

```{r, echo = FALSE, message = FALSE}
require(data.table)
knitr::opts_chunk$set(
  comment = "#",
    error = FALSE,
     tidy = FALSE,
    cache = FALSE,
 collapse = TRUE)
.old.th = setDTthreads(1)
```

Les fonctions `fread()` et `fwrite()` du paquet R `data.table` ne sont pas uniquement optimisées pour améliorer les performances avec de gros fichiers, mais elles offrent également des fonctionnalités puissantes et pratiques si voius utilisez de petits ensembles de données. Cette vignette montre leur utilisation, leur adaptabilité, et les performances pour importer et exporter des données.

***

## 1. fread()

### **1.1 Utilisation directe des outils en mode ligne de commande**
La fonction `fread()` de `data.table` peut lire des données redirigées à partir des commandes du shell, ce qui vous donne la possibilité de filtrer ou de pré-traiter les données avant même qu'elles soient soumises à R.

```{r}
# Créer un simple fichier avec quelques lignes non souhaitées
writeLines(
'HEADER: quelques méta-données
HEADER: méta-données supplémentaires 
1 2.0 3.0
2 4.5 6.7
HEADER: encore d'autres
3 8.9 0.1
4 1.2 3.4',
"example_data.txt")

library(data.table)
fread("grep -v HEADER example_data.txt")
```

L'option `-v` fait que la commande `grep` va renvoyer toutes les lignes sauf celles qui contiennent la chaîne 'HEADER'.

> "Etant donné le nombre d'ingénieurs hautement qualifiés qui se sont penché sur l'outil de commande grep durant ces années, il edst très probable qu'elle soit aussi rapide que possible, tout en étant correcte, pratique, bien documentée en ligne, facile à apprendre et à rechercher des solutions pour les tâches spécifiques. Si vous devez faire un filtrage sur des chaînes plus complexes (comme par exemple trouver des chaînes en début ou en fin de ligne), la syntaxe de grep est très puissante. En l'apprenant, vous pourrez réutiliser vos connaissances avec d'autres langages et environnements."
>
> — Matt Dowle  

Voir cet [exemple](https://stackoverflow.com/questions/36256706/fread-together-with-grepl/36270543#36270543) pour d'autres détails.

Sous Wndows, les outils en mode ligne de commande tels que `grep` sont disponibles dans divers environnements, tels que Rtools, Cygwin, ou Windows Subsystem for Linux (WSL). Sous Linux et macOS, ces outils sont typiquement inclus dans le système opératoire.

#### 1.1.1  Lecture directe à partir d'une chaîne textuelle

`fread()` peut lire les données directement à partir d'une chaîne de caractères dans R en utilisant l'argument `text`. Ceci est particulièrement pratique pour créer des exemples reproductibles, pour tester quelques lignes de code, ou pour travailler avec des données générées par un programme à l'intérieur d'une session R. Chaque ligne de la chaîne doit être séparée avec le caractère de passage à la ligne `\n`.

```{r}
my_data_string = "colA,colB,colC\n1,apple,TRUE\n2,banana,FALSE\n3,orange,TRUE"
dt_from_text = fread(text = my_data_string)
print(dt_from_text)
```

#### 1.1.2 Lecture à partir d'URLs

`fread()` peut lire les données directement à partir d'URLs web en passant l'URL en tant que chaîne de caractères dans l'argument `file`. Cela vous permet de télécharger et de lire les données à partir d'internet en une seule passe.

  ```{r}
  # dt = fread("https://people.sc.fsu.edu/~jburkardt/data/csv/airtravel.csv")
  # print(dt)
  ```

#### 1.1.3 Décompression automatique des fichiers compressés


Dans beaucoup de cas, `fread()` peut automatiquement détecter et décompresser les fichiers directement en utilisant les extensions de compression communes et sans avoir besoin d'un objet de connexion explicite ou de commandes du shell. Il se base sur l'extension du fichier.

**Les extensions reconnues incluent typiquement :**
- `.gz` / `.bz2` (gzip / bzip2) : acceptés et fonctionnent de manière indépendante.
- `.zip` / `.tar`  (archives ZIP ou tar, fichier unique) : acceptées — `fread()` lira le premier fichier de l'archive si elle n'encontient qu'un seul.

> Note : si l'archive contient plusieurs fichiers, `fread()` échouera avec une erreur.

### 1.2 Séparateur automatique et détection des sauts

`fread` automatise la détection du délimiteur et de l'entête, en élminant le besoin  de le spécifier manuellement dans la plupart des cas. Il suffit de fournir le nom de fichier — `fread` détectera intelligemment la structure :

**Détection des séparateurs**

`fread` teste les séparateurs usuels (`,`,`\t`, `|`, espace, `:`, `;`) et sélectionne celui qui fournit le nombre le plus cohérent de champs tout au long les lignes analysées. Dans le cas des délimiteurs non standard, vous pouvez rédéfinir ceci en utilisant le paramètre `sep=` .

**Détection de l'entête**

Après avoir appliqué les éventuelles valeurs de `skip` ou de `nrows` (si spécifiées), la première ligne qui comporte un nombre cohérent de champs cohérent est analysée :

Si on peut interpréter tous les champs de cette ligne comme des caractères et que les valeurs ne ressemblent pas trop à une ligne de données (par exemple une ligne de valeurs purement numériques pourrait encore être considérée comme des données), alors il s'agit typiquement d'une ligne d'entête (le nom des colonnes).

Sinon (c'est à dire si la ligne contient des types numériques reconnus, ou des chaînes de caractères qui ressemblent fortement à des nombres et qui pourraient être des données), elle est traitée comme une ligne de données et reçoit les noms de colonnnes par défaut (`V1`, `V2`, …).

Vous pouvez dire explicitement à fread si une entête existe en utilisant `header = TRUE` ou `header = FALSE`.

**Détection des sauts**

Par défaut (`skip="auto"`), `fread` va automatiquement sauter les lignes vides ainsi que les lignes de commentaires (celles qui commencent par `#`) avant l'entête des données. Pour forcer manuellement un nombre donné de lignes, utilisez use `skip=n`.

### 1.3 Détection avancée et automatique du type de colonne

Many real-world datasets contain columns that are initially blank, zero-filled, or appear numeric but later contain characters. To handle such inconsistencies, `fread()` in `data.table` employs a robust column type detection strategy.

Since v1.10.5, `fread()` samples rows by reading blocks of contiguous rows from multiple equally spaced points across the file, including the start, middle, and end. The total number of rows sampled is chosen dynamically based on the file size and structure, and is typically around 10,000, but can be smaller or slightly larger. This wide sampling helps detect type changes that occur later in the data (e.g., `001` to `0A0` or blanks becoming populated).

**Efficient File Access with mmap**

To implement this sampling efficiently, `fread()` uses the operating system's memory-mapped file access (`mmap`), allowing it to jump to arbitrary positions in the file without sequential scanning. This lazy, on-demand strategy makes sampling nearly instantaneous, even for very large files.

If a jump lands within a quoted field that includes newlines, `fread()` tests subsequent lines until it finds 5 consecutive rows with the expected number of fields, ensuring correct parsing even in complex files.

**Accurate and Optimized Type Detection**

The type for each column is inferred based on the lowest required type from the following ordered list:

`logical` < `integer` < `integer64` < `double` < `character`

This ensures:

- Single up-front allocation of memory using the correct type
- Avoidance of rereading the file or manually setting colClasses
- Improved speed and memory efficiency

**Out-of-Sample Type Exceptions**

If a type change occurs outside the sampled rows, `fread()` automatically detects it and rereads the file to ensure correct type assignment, without requiring user intervention. For example, a column sampled as integer might later contain `00A` — triggering an automatic reread as character.

All detection logic and any rereads are detailed when `verbose=TRUE` is enabled.

### 1.4 Early Error Detection at End-of-File

Because the large sample explicitly includes the very end of the file, critical issues—such as an inconsistent number of columns, a malformed footer, or an opening quote without a matching closing quote—can be detected and reported almost instantly. This early error detection avoids the unnecessary overhead of processing the entire file or allocating excessive memory, only to encounter a failure at the final step. It ensures faster feedback and more efficient resource usage, especially when working with large datasets.

### 1.5 `integer64` Support

By default, `fread` detects integers larger than 2<sup>31</sup> and reads them as `bit64::integer64` to preserve full precision. This behavior can be overridden in three ways:

- Per-column: Use the `colClasses` argument to specify the type for individual columns.

- Per-call: Use the `integer64` argument in `fread()` to set how all detected `integer64` columns are read.

- Globally: Set the option `datatable.integer64` in your R session or `.Rprofile` file to change the default behavior for all fread calls.

The integer64 argument (and corresponding option) accepts the following values:

- `"integer64"` (default): Reads large integers as `bit64::integer64` with full precision.

- `"double"` or `"numeric"`: Reads large integers as double-precision numbers, potentially losing precision silently (similar to `utils::read.csv` in base R).

- `"character"`: Reads large integers as character strings.

To check or set the global default, use:

```{r}
# fread's default behavior is to treat large integers as "integer64"; however, this global setting can be changed:
options(datatable.integer64 = "double")   # Example: set globally to "double"
getOption("datatable.integer64") 
```

### 1.6 Drop or Select Columns by Name or Position

To save memory and improve performance, use `fread()`'s `select` or `drop` arguments to read only the columns you need.

- If you need only a few columns, use `select`.
- If you want to exclude just a few, use `drop`—this avoids listing everything you want to keep.

Key points:
- `select`: Vector of column names/positions to keep (discards others).
- `drop`: Vector of column names/positions to discard (keeps others).
- Do not use `select` and `drop` together—they are mutually exclusive.
- `fread()` will warn you if any specified column is missing in the file.

For details, see the manual page by running `?fread` in R.

### 1.7 Skip to a Sub-Table’s Header Row Using a Column Name Substring

Use `skip="string"` in `fread` to search for a line containing a substring (typically from the column names, e.g., `skip="Date"`). Reading begins at the first matching line. This is useful for skipping metadata or selecting sub-tables in multi-table files. This feature is inspired by the `read.xls` function in the gdata package.

### 1.8 Automatic Quote Escape Detection (Including No-Escape)

`fread` automatically detects how quotes are escaped—including doubled ("") or backslash-escaped (\") quotes—without requiring user input. This is determined using a large sample of the data (see point 3), and validated against the entire file.

Supported Scenarios:
- Unescaped quotes inside quoted fields
e.g., `"This "quote" is invalid"` — supported as long as column count remains consistent.

- Unquoted fields that begin with quotes
e.g., `Invalid"Field,10,20` — recognized correctly as not a quoted field.

Requirements & Limitations:
- Escaping rules and column counts must be consistent throughout the file.

- Not supported when `fill=TRUE` — in that case, the file must follow RFC4180-compliant quoting/escaping.

Version-Specific Robustness:
From v1.10.6, `fread` resolves ambiguities more reliably across the entire file using full-column-count consistency (default is `fill=FALSE`). Warnings are issued if parsing fails due to ambiguity.

## 2. fwrite()

`fwrite()` is the fast file writer companion to `fread()`. It’s designed for speed, sensible defaults, and ease of use, mirroring many of the conveniences found in fread`.

### 2.1 Intelligent and Minimalist Quoting (quote="auto")

When data is written as strings (either inherently, like character columns, or by choice, like `dateTimeAs="ISO"`), `quote="auto"` (default) intelligently quotes fields:

**Contextual Quoting**:Fields are quoted only when necessary. This happens if they contain the delimiter `(sep)`, a double quote `(")`, a newline `(\n)`, a carriage return `(\r)`, or if the field is an empty string `("")`. Quoting the empty string is done to distinguish it from an NA value when the file is read.

**Bypassed for Direct Numeric Output**: If specific columns are written as their underlying numeric types (e.g., via `dateTimeAs="epoch"` for `POSIXct`, or if a user pre-converts Date to integer), then quoting logic is naturally bypassed for those numeric fields, contributing to efficiency.

```{r}
dt_quoting_scenario = data.table(
  text_field = c("Contains,a,comma", "Contains \"a quote\"", "Clean_text", "", NA),
  numeric_field = 1:5
)
temp_quote_adv = tempfile(fileext = ".csv")

fwrite(dt_quoting_scenario, temp_quote_adv)
# Note the output: the empty string is quoted (""), but the NA is not.
cat(readLines(temp_quote_adv), sep = "\n")
```

### 2.2 Fine-Grained Date/Time Serialization (dateTimeAs)

Offers precise control for POSIXct/Date types:

- `dateTimeAs="ISO"` (Default for POSIXct): ISO 8601 format (e.g., YYYY-MM-DDTHH:MM:SS.ffffffZ), preserving sub-second precision for unambiguous interchange.

- `dateTimeAs="epoch"`: POSIXct as seconds since epoch (numeric).

```{r}
dt_timestamps = data.table(
  ts = as.POSIXct("2023-10-26 14:35:45.123456", tz = "GMT"),
  dt = as.Date("2023-11-15")
)
temp_dt_iso = tempfile(fileext = ".csv")
fwrite(dt_timestamps, temp_dt_iso, dateTimeAs = "ISO")
cat(readLines(temp_dt_iso), sep = "\n")
unlink(temp_dt_iso)
```

### 2.3 Handling of bit64::integer64

**Full Precision for Large Integers**: `fwrite` writes `bit64::integer64` columns by converting them to strings with full precision. This prevents data loss or silent conversion to double that might occur with less specialized writers. This is crucial for IDs or measurements requiring more than R's standard `32-bit` integer range or `53-bit` double precision.

**Direct Handling**: This direct and careful handling of specialized numerics ensures data integrity and efficient I/O, without unnecessary intermediate conversions to less precise types.

```{r}
if (requireNamespace("bit64", quietly = TRUE)) {
  dt_i64 = data.table(uid = bit64::as.integer64("1234567890123456789"), val = 100)
  temp_i64_out = tempfile(fileext = ".csv")
  fwrite(dt_i64, temp_i64_out)
  cat(readLines(temp_i64_out), sep = "\n")

  unlink(temp_i64_out)
}
```

### 2.4 Column Order and Subset Control

To control the order and subset of columns written to file, subset the data.table before calling `fwrite()`. The `col.names` argument in `fwrite()` is a logical (TRUE/FALSE) that controls whether the header row is written, not which columns are written.

```{r}
dt = data.table(A = 1:3, B = 4:6, C = 7:9)

# Write only columns C and A, in that order
fwrite(dt[, .(C, A)], "out.csv")
cat(readLines("out.csv"), sep = "\n")
file.remove("out.csv")
```

## 3. A Note on Performance

While this vignette focuses on features and usability, the primary motivation for `fread` and `fwrite` is speed. The performance of `data.table`'s I/O is a topic of continuous benchmarking.

For users interested in detailed, up-to-date performance comparisons, we recommend these external blog posts which use the `atime` package for rigorous analysis:

- **[data.table asymptotic timings](https://tdhock.github.io/blog/2023/dt-atime-figures/)**: Compares `fread` and `fwrite` performance against other popular R packages like `readr` and `arrow`.
- **[Benchmarking data.table with polars, duckdb, and pandas](https://tdhock.github.io/blog/2024/pandas-dt/)**: Compares `data.table` I/O and grouping performance against leading Python libraries.

These benchmarks consistently show that `fread` and `fwrite` are highly competitive and often state-of-the-art for performance in the R ecosystem.

***
