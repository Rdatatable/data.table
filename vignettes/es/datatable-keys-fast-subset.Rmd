---
title: "Claves y filtrado rápido con búsqueda binaria"
date: "`{r} Sys.Date()`"
output:
  litedown::html_format
vignette: >
  %\VignetteIndexEntry{Keys and fast binary search based subset}
  %\VignetteEngine{litedown::vignette}
  \usepackage[utf8]{inputenc}
---

```{r, echo=FALSE, file='../_translation_links.R'}
```

`{r} .write.translation.links("Las traducciones de este documento están disponibles en: %s")`

```{r, echo = FALSE, message = FALSE}
library(data.table)
litedown::reactor(comment = "# ")
.old.th = setDTthreads(1)
```

Esta viñeta está dirigida a quienes ya están familiarizados con la sintaxis de *data.table*, su forma general, cómo filtrar [N. del T.: *subset*] filas en `i`, seleccionar y calcular columnas, agregar, modificar y eliminar columnas *por referencia* en `j` y agrupar mediante `by`. Si no está familiarizado con estos conceptos, lea primero las viñetas [`vignette("datatable-intro", package="data.table")`](datatable-intro.html) y [`vignette("datatable-reference-semantics", package="data.table")`](datatable-reference-semantics.html).

***

## Datos {#data}

Usaremos los mismos datos de `flights` que en la viñeta [`vignette("datatable-intro", package="data.table")`](datatable-intro.html).

```{r, echo = FALSE}
options(width = 100L)
```

```{r}
flights <- fread("../flights14.csv")
head(flights)
dim(flights)
```

## Introducción

En esta viñeta,

* primero introduciremos el concepto de *clave* en *data.table*, y estableceremos y usaremos claves para efectuar un filtro en `i` basado en  *búsquedas binarias rápidas*,

* ver que podemos combinar filtros basados ​​en clave junto con `j` y `by` exactamente de la misma manera que antes,

* ver otros argumentos útiles adicionales: `mult` y `nomatch`,

* y finalmente concluir mirando la ventaja de establecer claves: realizar *filtros basados ​​en búsquedas binarias rápidas* y comparar con el enfoque de escaneo vectorial tradicional.

## 1. Claves

### a) ¿Qué es una *clave*?

En la viñeta [`vignette("datatable-intro", package="data.table")`](datatable-intro.html), vimos cómo aplicar filtros en `i` usando expresiones lógicas, números de fila y el uso de `order()`. En esta sección, veremos otra forma de crear filtros increíblemente rápido: usando *claves*

Pero primero, veamos los *data.frames*. Todos los *data.frames* tienen un atributo de nombre de fila. Considere el *data.frame* `DF` a continuación.

```{r}
set.seed(1L)
DF = data.frame(ID1 = sample(letters[1:2], 10, TRUE),
                ID2 = sample(1:3, 10, TRUE),
                val = sample(10),
                stringsAsFactors = FALSE,
                row.names = sample(LETTERS[1:10]))
DF

rownames(DF)
```

Podemos filtrar una fila particular usando su nombre de fila como se muestra a continuación:

```{r}
DF["C", ]
```

Es decir, los nombres de fila son más o menos *un índice* de las filas de un *data.frame*. Sin embargo,

1. Cada fila está limitada a *exactamente un* nombre de fila.

    But, a person (for example) has at least two names - a *first* and a *second* name. It is useful to organise a telephone directory by *surname* then *first name*.

2. Y los nombres de las filas deben ser *únicos*.

    ```r
    rownames(DF) = sample(LETTERS[1:5], 10, TRUE)
    # Warning: non-unique values when setting 'row.names': 'C', 'D'
    # Error in `.rowNamesDF<-`(x, value = value): duplicate 'row.names' are not allowed
    ```

Ahora vamos a convertirlo en una *data.table*.

```{r}
DT = as.data.table(DF)
DT

rownames(DT)
```

* Tenga en cuenta que los nombres de las filas se han restablecido.

* *data.tables* nunca usa nombres de fila. Dado que *data.tables* **hereda** de *data.frames*, aún conserva el atributo de nombres de fila. Pero nunca los usa. Veremos por qué en breve.

    If you would like to preserve the row names, use `keep.rownames = TRUE` in `as.data.table()` - this will create a new column called `rn` and assign row names to this column.

En cambio, en *data.tables*, establecemos y usamos `keys` (claves). Piense en una `key` (clave) como **nombres de fila supercargados**.

#### Claves y sus propiedades {#key-properties}

1. Podemos establecer claves en *varias columnas* y la columna puede ser de *diferentes tipos*: *entero*, *numérico*, *carácter*, *factor*, *integer64*, etc. Los tipos *lista* y *complejos* aún no son compatibles.

2. No se exige unicidad, es decir, se permiten valores de clave duplicados. Dado que las filas se ordenan por clave, cualquier valor duplicado en las columnas de clave aparecerá consecutivamente.

3. Establecer una clave hace *dos* cosas:

    a. physically reorders the rows of the *data.table* by the column(s) provided *by reference*, always in *increasing* order.
    
    b. marks those columns as *key* columns by setting an attribute called `sorted` to the *data.table*.
    
    Since the rows are reordered, a *data.table* can have at most one key because it can not be sorted in more than one way.

Para el resto de la viñeta, trabajaremos con el conjunto de datos `flights`.

### b) Establecer, obtener y usar claves en una *data.table*

#### -- ¿Cómo podemos establecer la columna `origen` como clave en la *data.table* `flights`?

```{r}
setkey(flights, origin)
head(flights)

## alternatively we can provide character vectors to the function 'setkeyv()'
# setkeyv(flights, "origin") # useful to program with
```

* Puede usar la función `setkey()` y proporcionar los nombres de las columnas (sin comillas). Esto es útil durante el uso interactivo.

* También puede pasar un vector de caracteres de nombres de columnas a la función `setkeyv()`. Esto es especialmente útil al diseñar funciones que pasan columnas a las que se les asigna una clave como argumentos.

* Tenga en cuenta que no tuvimos que asignar el resultado a una variable. Esto se debe a que, al igual que la función `:=` que vimos en la viñeta [`vignette("datatable-reference-semantics", package="data.table")`](datatable-reference-semantics.html), `setkey()` y `setkeyv()` modifican la entrada *data.table* *por referencia*. Devuelven el resultado de forma invisible.

* La *data.table* ahora se reordena según la columna proporcionada: `origin`. Al reordenar por referencia, solo necesitamos memoria adicional de una columna con una longitud igual al número de filas de la *data.table*, lo que la hace muy eficiente en el uso de memoria.

* También puede establecer claves directamente al crear *data.tables* mediante la función `data.table()` con el argumento `key`. Esta función acepta un vector de caracteres de nombres de columna.

#### set* y `:=`:

En *data.table*, el operador `:=` y todas las funciones `set*` (por ejemplo, `setkey`, `setorder`, `setnames`, etc.) son las únicas que modifican el objeto de entrada *por referencia*

Una vez que se *clasifica* una *data.table* por ciertas columnas, se puede filtrar consultando esas columnas clave usando la notación `.()` en `i`. Recuerde que `.()` es un *alias* de `list()`.

#### -- Usar la columna clave `origin` para filtrar por todas las filas donde el aeropuerto de origen coincida con *"JFK"*

```{r}
flights[.("JFK")]

## alternatively
# flights[J("JFK")] (or)
# flights[list("JFK")]
```

* La columna *key* ya está configurada como `origin`. Por lo tanto, basta con proporcionar el valor, en este caso *"JFK"*, directamente. La sintaxis `.()` ayuda a identificar que la tarea requiere buscar el valor *"JFK"* en la columna key de *data.table* (en este caso, la columna `origin` de `flights` *data.table*).

* Primero se obtienen los *índices de fila* correspondientes al valor *"JFK"* en `origin`. Y como no hay expresión en `j`, se devuelven todas las columnas correspondientes a esos índices de fila.

* En una clave de columna única de tipo *carácter*, puede eliminar la notación `.()` y usar los valores directamente al filtrar, como filtrar usando nombres de filas en *data.frames*.

    ```r
    flights["JFK"]              ## same as flights[.("JFK")]
    ```

* Podemos filtrar cualquier cantidad de valores que sea necesaria

    ```r
    flights[c("JFK", "LGA")]    ## same as flights[.(c("JFK", "LGA"))]
    ```
    
    This returns all columns corresponding to those rows where `origin` column matches either *"JFK"* or *"LGA"*.

#### -- ¿Cómo podemos obtener las columnas por las que se codifica una *data.table*?

Usando la función `key()`.

```{r}
key(flights)
```

* Devuelve un vector de caracteres de todas las columnas clave.

* Si no se establece ninguna clave, devuelve `NULL`.

### c) Claves y columnas múltiples

Para refrescar, las *claves* son como nombres de fila *sobrecargados*. Podemos establecer claves en varias columnas y pueden ser de varios tipos.

#### -- ¿Cómo puedo configurar claves en las columnas `origin` *y* `dest`?

```{r}
setkey(flights, origin, dest)
head(flights)

## or alternatively
# setkeyv(flights, c("origin", "dest")) # provide a character vector of column names

key(flights)
```

* Ordena la *data.table* primero por la columna `origen` y luego por `dest` *por referencia*.

#### -- Filtrar todas las filas utilizando columnas clave donde la primera columna clave `origin` coincide con *"JFK"* y la segunda columna clave `dest` coincide con *"MIA"*

```{r}
flights[.("JFK", "MIA")]
```

#### ¿Cómo funciona el filtrado aquí? {#multiple-key-point}

* Es importante comprender cómo funciona esto internamente. *"JFK"* se compara primero con la primera columna clave `origin`. Y *dentro de esas filas coincidentes*, *"MIA"* se compara con la segunda columna clave `dest` para obtener *índices de fila* donde tanto `origin` como `dest` coinciden con los valores dados.

* Dado que no se proporciona `j`, simplemente devolvemos *todas las columnas* correspondientes a esos índices de fila.

#### -- Filtrar todas las filas donde solo la primera columna de clave `origin` coincide con *"JFK"*

```{r}
key(flights)

flights[.("JFK")] ## or in this case simply flights["JFK"], for convenience
```

* Dado que no proporcionamos ningún valor para la segunda columna de clave `dest`, simplemente compara *"JFK"* con la primera columna de clave `origin` y devuelve todas las filas coincidentes.

#### -- Filtrar todas las filas donde sólo la segunda columna clave `dest` coincide con *"MIA"*

```{r}
flights[.(unique(origin), "MIA")]
```

#### ¿Qué está pasando aquí?

* Lea [esto](#multiple-key-point) de nuevo. El valor proporcionado para la segunda columna de clave *"MIA"* tiene que encontrar los valores coincidentes en la columna de clave `dest` *en las filas coincidentes proporcionadas por la primera columna de clave `origin`*. No podemos omitir los valores de las columnas de clave *anteriores*. Por lo tanto, proporcionamos *todos* los valores únicos de la columna de clave `origin`.

* *"MIA"* se recicla automáticamente para ajustarse a la longitud de `unique(origin)` que es *3*.

## 2. Combinar claves con `j` y `by`

Hasta ahora, todo lo que hemos visto es el mismo concepto: obtener *índices de fila* en `i`, pero con un método diferente: usar `keys`. No debería sorprender que podamos hacer exactamente lo mismo en `j` y `by`, como se vio en los ejemplos anteriores. Lo ilustraremos con algunos ejemplos.

### a) Seleccionar en `j`

#### -- Devuelve la columna `arr_delay` como una *data.table* correspondiente a `origin = "LGA"` y `dest = "TPA"`.

```{r}
key(flights)
flights[.("LGA", "TPA"), .(arr_delay)]
```

* Los *índices de fila* correspondientes a `origin == "LGA"` y `dest == "TPA"` se obtienen utilizando un *filtro basado en clave*.

* Una vez que tenemos los índices de fila, revisamos `j`, que solo requiere la columna `arr_delay`. Así que simplemente seleccionamos la columna `arr_delay` para esos *índices de fila* de la misma manera que vimos en la viñeta [`vignette("datatable-intro", package="data.table")`](datatable-intro.html).

* Podríamos haber devuelto el resultado usando `with = FALSE` también.

    ```r
    flights[.("LGA", "TPA"), "arr_delay", with = FALSE]
    ```

### b) Encadenamiento

#### -- Con el resultado obtenido anteriormente, utilizar encadenamiento para ordenar la columna en orden decreciente

```{r}
flights[.("LGA", "TPA"), .(arr_delay)][order(-arr_delay)]
```

### c) Calcular o *hacer* en `j`

#### -- Encontrar el retraso máximo de llegada correspondiente a `origin = "LGA"` y `dest = "TPA"`.

```{r}
flights[.("LGA", "TPA"), max(arr_delay)]
```

*Podemos verificar que el resultado es idéntico al primer valor (486) del ejemplo anterior.

### d) *sub-asignar* por referencia usando `:=` en `j`

Ya vimos este ejemplo en la viñeta [`vignette("datatable-reference-semantics", package="data.table")`](datatable-reference-semantics.html). Veamos todas las `horas` disponibles en la *data.table* `flights`:

```{r}
# get all 'hours' in flights
flights[, sort(unique(hour))]
```

Observamos que hay un total de 25 valores únicos en los datos. Parece que hay tanto *0* como *24* horas. Reemplacemos *24* por *0*, pero esta vez usando *key*.

```{r}
setkey(flights, hour)
key(flights)
flights[.(24), hour := 0L]
key(flights)
```

* Primero configuramos `key` como `hour`. Esto reordena los `flights` según la columna `hour` y marca esa columna como `key`.

* Ahora podemos filtrar en `hour` usando la notación `.()`. Filtramos para el valor *24* y obtenemos los *índices de fila* correspondientes.

* Y en esos índices de fila, reemplazamos la columna `key` con el valor `0`.

* Dado que reemplazamos los valores en la columna *key*, la tabla de datos `flights` ya no se ordena por `hour`. Por lo tanto, la clave se ha eliminado automáticamente al establecerla en NULL.

Ahora, no debería haber ningún *24* en la columna "hora".

```{r}
flights[, sort(unique(hour))]
```

### e) Agregación utilizando `by`

Primero, establezcamos nuevamente la clave en `origin, dest`.

```{r}
setkey(flights, origin, dest)
key(flights)
```

#### Obtener el retraso máximo de salida para cada mes correspondiente a `origin = "JFK"`. Ordenar el resultado por mes.

```{r}
ans <- flights["JFK", max(dep_delay), keyby = month]
head(ans)
key(ans)
```

* Filtramos en la columna `clave` *origen* para obtener los *índices de fila* correspondientes a *"JFK"*.

* Una vez que obtenemos los índices de fila, solo necesitamos dos columnas: `month` para agrupar y `dep_delay` para obtener `max()` para cada grupo. Por lo tanto, la optimización de consulta de *data.table* filtra solo aquellas dos columnas correspondientes a los *índices de fila* obtenidos en `i`, para mayor velocidad y eficiencia de memoria.

* Y en ese filtro, agrupamos por *mes* y calculamos `max(dep_delay)`.

* Usamos `keyby` para clasificar automáticamente ese resultado por *mes*. Ahora entendemos lo que significa. Además de ordenar, también establece *mes* como la columna `key`.

## 3. Argumentos adicionales: `mult` y `nomatch`

### a) El argumento *mult*

Podemos elegir, para cada consulta, si se deben devolver *todas* ("all") las filas coincidentes, o solo la *primera* ("first") o la *última* ("last") mediante el argumento `mult`. El valor predeterminado es *"all"*, el que hemos visto hasta ahora.

#### -- Obtener solo la primera fila coincidente de todas las filas donde `origin` coincide con *"JFK"* y `dest` coincide con *"MIA"*

```{r}
flights[.("JFK", "MIA"), mult = "first"]
```

#### -- Filtrar solo la última fila coincidente de todas las filas donde `origin` coincide con *"LGA", "JFK", "EWR"* y `dest` coincide con *"XNA"*

```{r}
flights[.(c("LGA", "JFK", "EWR"), "XNA"), mult = "last"]
```

* La consulta *"JFK", "XNA"* no coincide con ninguna fila en `flights` y, por lo tanto, devuelve `NA`.

* Una vez más, la consulta para la segunda columna de clave `dest`, *"XNA"*, se recicla para ajustarse a la longitud de la consulta para la primera columna de clave `origin`, que tiene una longitud 3.

### b) El argumento *nomatch*

Podemos elegir si las consultas que no coinciden deben devolver "NA" o ignorarse por completo utilizando el argumento "nomatch".

#### -- Del ejemplo anterior, filtrar de todas las filas solo si hay una coincidencia

```{r}
flights[.(c("LGA", "JFK", "EWR"), "XNA"), mult = "last", nomatch = NULL]
```

* El valor predeterminado para `nomatch` es `NA`. Si se establece `nomatch = NULL`, se omiten las consultas sin coincidencias.

* La consulta “JFK”, “XNA” no coincide con ninguna fila en vuelos y, por lo tanto, se omite.

## 4. Búsqueda binaria vs. escaneo vectorial

Hemos visto hasta ahora cómo podemos establecer y usar claves para crear filtros. Pero ¿cuál es la ventaja? Por ejemplo, en lugar de hacer:

```r
# key by origin,dest columns
flights[.("JFK", "MIA")]
```

Podríamos haber hecho:

```r
flights[origin == "JFK" & dest == "MIA"]
```

Una de las ventajas más probables es su sintaxis más corta. Pero aún más, los *filtros basados ​​en búsqueda binaria* son **increíblemente rápidos**.

Con el tiempo, `data.table` se optimiza y actualmente la última llamada se optimiza automáticamente para usar la búsqueda binaria. Para usar el escaneo vectorial lento, es necesario eliminar la clave.

```r
setkey(flights, NULL)
flights[origin == "JFK" & dest == "MIA"]
```

### a) Rendimiento del enfoque de búsqueda binaria

Para ilustrarlo, creemos una *data.table* de muestra con 20 millones de filas y tres columnas y clasifiquémosla por las columnas `x` e `y`.

```{r}
set.seed(2L)
N = 2e7L
DT = data.table(x = sample(letters, N, TRUE),
                y = sample(1000L, N, TRUE),
                val = runif(N))
print(object.size(DT), units = "MiB")
```

`DT` ocupa unos 380 MiB. No es un tamaño enorme, pero basta con esto para ilustrar el punto.

De lo que hemos visto en la sección Introducción a data.table, podemos filtrar aquellas filas donde las columnas `x = "g"` e `y = 877` de la siguiente manera:

```{r}
key(DT)
## (1) Usual way of subsetting - vector scan approach
t1 <- system.time(ans1 <- DT[x == "g" & y == 877L])
t1
head(ans1)
dim(ans1)
```

Ahora vamos a intentar crear filtros usando claves.

```{r}
setkeyv(DT, c("x", "y"))
key(DT)
## (2) Subsetting using keys
t2 <- system.time(ans2 <- DT[.("g", 877L)])
t2
head(ans2)
dim(ans2)

identical(ans1$val, ans2$val)
```

* La mejora en velocidad es **~`{r} round(t1[3]/max(t2[3], .001))`x**!

### b) ¿Por qué al introducir una clave en una *data.table* se obtienen filtros increíblemente rápidos?

Para entender esto, veamos primero qué hace el *enfoque de escaneo vectorial* (método 1).

#### Enfoque de escaneo vectorial

* Se busca en la columna `x` el valor *"g"* fila por fila, en los 20 millones de filas. Esto da como resultado un *vector lógico* de tamaño 20 millones, con valores `TRUE, FALSE o NA` correspondientes al valor de `x`.

* De manera similar, se busca `877` en la columna `y` en las 20 millones de filas una por una, y se almacena en otro vector lógico.

* Las operaciones `&` elemento por elemento se realizan en los vectores lógicos intermedios y se devuelven todas las filas donde la expresión se evalúa como `VERDADERO`.

Esto es lo que llamamos un *enfoque de escaneo vectorial*. Es bastante ineficiente, especialmente en tablas grandes y cuando se necesita crear filtros repetidamente, ya que tiene que escanear todas las filas cada vez.

Ahora veamos el método de búsqueda binaria (método 2). Recordemos de [Propiedades de la clave](#key-properties): *establecer claves reordena la tabla data.table por columnas clave*. Como los datos están ordenados, ¡no tenemos que *explorar toda la longitud de la columna*! En su lugar, podemos usar la *búsqueda binaria* para buscar un valor en `O(log n)`, en lugar de `O(n)`, como en el caso del *enfoque de escaneo vectorial*, donde `n` es el número de filas en la tabla data.table*.

#### Enfoque de búsqueda binaria

Aquí hay una ilustración muy simple. Consideremos los números (ordenados) que se muestran a continuación:

```
1, 5, 10, 19, 22, 23, 30
```

Supongamos que queremos encontrar la posición coincidente del valor *1*, usando la búsqueda binaria, así es como procederíamos, porque sabemos que los datos están *ordenados*.

* Comienza con el valor del medio = 19. ¿Es 1 == 19? N.° 1 < 19.

* Dado que el valor que buscamos es menor que 19, debería estar en algún lugar antes de 19. Por lo tanto, podemos descartar el resto de la mitad que sea >= 19.

* Nuestro conjunto se reduce a *1, 5, 10*. Toma el valor medio una vez más = 5. ¿Es 1 == 5? No. 1 < 5.

* Nuestro conjunto se reduce a *1*. ¿Es 1 == 1? Sí. El índice correspondiente también es 1. Y esa es la única coincidencia.

Por otro lado, un enfoque de escaneo vectorial tendría que escanear todos los valores (aquí, 7).

Se puede observar que con cada búsqueda reducimos el número de búsquedas a la mitad. Por eso, los filtros basados ​​en *búsquedas binarias* son **increíblemente rápidos**. Dado que las filas de cada columna de *data.tables* tienen ubicaciones contiguas en memoria, las operaciones se realizan con gran eficiencia de caché (lo que también contribuye a la *velocidad*).

Además, dado que obtenemos los índices de fila coincidentes directamente sin tener que crear esos enormes vectores lógicos (iguales al número de filas en una *data.table*), también es bastante **eficiente en términos de memoria**.

## Resumen

En esta viñeta, hemos aprendido otro método para crear filtros de filas en `i` mediante la introducción de claves en una *data.table*. La introducción de claves nos permite realizar filtros increíblemente rápidos mediante la búsqueda binaria. En particular, hemos visto cómo

* establecer clave y filtrar usando la clave en una *data.table*.

* filtrar utilizando claves que obtienen *índices de fila* en `i`, pero mucho más rápido.

* Combina filtros basados ​​en claves con `j` y `by`. Ten en cuenta que las operaciones `j` y `by` son exactamente las mismas que antes.

Los filtros basados ​​en claves son **increíblemente rápidos** y resultan especialmente útiles cuando la tarea implica la aplicación repetida de filtros. Sin embargo, no siempre es recomendable establecer la clave y reordenar físicamente la *data.table*. En la siguiente viñeta (`vignette("datatable-secondary-indices-and-auto-indexing", package="data.table")`)](datatable-secondary-indices-and-auto-indexing.html), abordaremos este problema mediante una nueva función: los índices secundarios.

```{r, echo=FALSE}
setDTthreads(.old.th)
```
