---
title: "Programación en data.table"
date: "`{r} Sys.Date()`"
output:
  litedown::html_format
vignette: >
  %\VignetteIndexEntry{Programming on data.table}
  %\VignetteEngine{litedown::vignette}
  \usepackage[utf8]{inputenc}
---

```{r, echo=FALSE, file='../_translation_links.R'}
```

`{r} .write.translation.links("Las traducciones de este documento están disponibles en: %s")`

```{r init, include = FALSE}
require(data.table)
litedown::reactor(comment = "# ")
```

## Introducción

Desde sus primeras versiones, `data.table` habilitó el uso de las funciones `subset` y `with` (o `within`) mediante la definición del método `[.data.table`. `subset` y `with` son funciones básicas de R útiles para reducir la repetición en el código, mejorar la legibilidad y reducir la cantidad de caracteres que el usuario debe escribir. Esta funcionalidad es posible en R gracias a una característica única llamada *evaluación diferida*. Esta característica permite que una función capture sus argumentos antes de que se evalúen y los evalúe en un ámbito diferente al que se invocó. Recapitulemos el uso de la función `subset`.

```{r df_print, echo=FALSE}
registerS3method("print", "data.frame", function(x, ...) {
  base::print.data.frame(head(x, 2L), ...)
  cat("...\n")
  invisible(x)
})
.opts = options(
  datatable.print.topn=2L,
  datatable.print.nrows=20L
)
```

```{r subset}
subset(iris, Species == "setosa")
```

Aquí, `subset` toma el segundo argumento y lo evalúa dentro del alcance del `data.frame` dado como primer argumento. Esto elimina la necesidad de repetir variables, lo que lo hace menos propenso a errores y hace que el código sea más legible.

## Descripción del problema

El problema con este tipo de interfaz es que no es fácil parametrizar el código que la utiliza. Esto se debe a que las expresiones pasadas a esas funciones se sustituyen antes de ser evaluadas.

### Ejemplo

```{r subset_error, error=TRUE, purl=FALSE}
my_subset = function(data, col, val) {
  subset(data, col == val)
}
my_subset(iris, Species, "setosa")
```

### Aproximaciones al problema

Hay varias formas de solucionar este problema.

#### Evitar la *evaluación perezosa*

La solución más sencilla es evitar la *evaluación perezosa* en primer lugar y recurrir a enfoques menos intuitivos y más propensos a errores, como `df[["variable"]]`, etc.

```{r subset_nolazy}
my_subset = function(data, col, val) {
  data[data[[col]] == val & !is.na(data[[col]]), ]
}
my_subset(iris, col = "Species", val = "setosa")
```

Aquí, calculamos un vector lógico de longitud `nrow(iris)`, que se introduce en el argumento `i` de `[.data.frame` para realizar subconjuntos basados ​​en vectores lógicos. Para alinearlo con `subset()`, que también omite NA, necesitamos incluir un uso adicional de `data[[col]]` para capturarlo. Funciona bien para este ejemplo sencillo, pero carece de flexibilidad, introduce repetición de variables y requiere que el usuario modifique la interfaz de la función para pasar el nombre de la columna como un carácter en lugar de un símbolo sin comillas. Cuanto más compleja sea la expresión que necesitamos parametrizar, menos práctico resulta este enfoque.

#### Uso de `parse` / `eval`

Este método suele ser el preferido por quienes se inician en R, ya que es, quizás, el más sencillo conceptualmente. Requiere generar la expresión requerida mediante concatenación de cadenas, analizarla y evaluarla.

```{r subset_parse}
my_subset = function(data, col, val) {
  data = deparse(substitute(data))
  col  = deparse(substitute(col))
  val  = paste0("'", val, "'")
  text = paste0("subset(", data, ", ", col, " == ", val, ")")
  eval(parse(text = text)[[1L]])
}
my_subset(iris, Species, "setosa")
```

Debemos usar `deparse(substitute(...))` para capturar los nombres reales de los objetos pasados ​​a la función, de modo que podamos construir la llamada a la función `subset` usando esos nombres originales. Si bien esto ofrece una flexibilidad ilimitada con una complejidad relativamente baja, **se debe evitar el uso de `eval(parse(...))`**. Las principales razones son:

- falta de validación de sintaxis
- [vulnerabilidad a la inyección de código](https://github.com/Rdatatable/data.table/issues/2655#issuecomment-376781159)
- la existencia de mejores alternativas

Martin Machler, desarrollador principal del proyecto R, [dijo una vez](https://stackoverflow.com/a/40164111/2490497):

> Lo siento, pero no entiendo por qué tanta gente piensa siquiera que una cadena es algo que se puede evaluar. Debes cambiar de mentalidad, de verdad. Olvídense de todas las conexiones entre cadenas por un lado y expresiones, llamadas y evaluación por el otro. La (posiblemente) única conexión es mediante `parse(text = ....)`, y todo buen programador de R debería saber que esto rara vez es un método eficiente o seguro para construir expresiones (o llamadas). Mejor aprenda más sobre `substitute()`, `quote()` y, posiblemente, el poder de usar `do.call(substitute, ......)`.

#### Computación sobre el lenguaje

Las funciones mencionadas anteriormente, junto con algunas otras (incluidas `as.call`, `as.name`/`as.symbol`, `bquote` y `eval`), se pueden categorizar como funciones para *calcular en el lenguaje*, ya que operan en objetos del *lenguaje* (por ejemplo, `call`, `name`/`symbol`).

```{r subset_substitute}
my_subset = function(data, col, val) {
  eval(substitute(subset(data, col == val)))
}
my_subset(iris, Species, "setosa")
```

Aquí, usamos la función base R `substitute` para transformar la llamada `subset(data, col == val)` en `subset(iris, Species == "setosa")` sustituyendo `data`, `col` y `val` por sus nombres (o valores) originales de su entorno padre. Las ventajas de este enfoque con respecto a los anteriores son evidentes. Cabe destacar que, dado que operamos a nivel de objetos del lenguaje y no es necesario manipular cadenas, lo denominamos *computación en el lenguaje*. El [manual del lenguaje R](https://cran.r-project.org/doc/manuals/r-release/R-lang.html) incluye un capítulo dedicado a *computación en el lenguaje*. Aunque no es necesario para *programar en data.table*, recomendamos leer este capítulo para comprender mejor esta potente y única característica del lenguaje R.

#### Utilizar paquetes de terceros

Hay paquetes de terceros que pueden lograr lo que la computación R basa en las rutinas del lenguaje (`pryr`, `lazyeval` y `rlang`, por nombrar algunos).

Si bien estos pueden ser útiles, aquí discutiremos un enfoque exclusivo de `data.table`.

## Programación en data.table

Ahora que hemos establecido la forma correcta de parametrizar el código que utiliza *evaluación perezosa*, podemos pasar al tema principal de esta viñeta, *programación en data.table*.

A partir de la versión 1.15.0, data.table proporciona un mecanismo robusto para parametrizar expresiones pasadas a los argumentos `i`, `j` y `by` (o `keyby`) de `[.data.table`. Se basa en la función `substitute` de R e imita su interfaz. Aquí presentamos `substitute2` como una versión más robusta y fácil de usar de `substitute` de R. Para obtener una lista completa de las diferencias entre `base::substitute` y `data.table::substitute2`, consulte el [manual de `substitute2`](https://rdatatable.gitlab.io/data.table/library/data.table/html/substitute2.html).

### Sustituir variables y nombres

Supongamos que queremos una función general que aplique una función a la suma de dos argumentos a los que se les ha aplicado otra función. Como ejemplo concreto, a continuación tenemos una función para calcular la longitud de la hipotenusa en un triángulo rectángulo, conociendo la longitud de sus catetos.

${\displaystyle c = \sqrt{a^2 + b^2}}$

```{r hypotenuse}
square = function(x) x^2
quote(
  sqrt(square(a) + square(b))
)
```

El objetivo es hacer que cada nombre en la llamada anterior pueda pasarse como parámetro.

```{r hypotenuse_substitute2}
substitute2(
  outer(inner(var1) + inner(var2)),
  env = list(
    outer = "sqrt",
    inner = "square",
    var1 = "a",
    var2 = "b"
  )
)
```

Podemos ver en la salida que se han reemplazado tanto los nombres de las funciones como los de las variables pasadas a ellas. Usamos `substitute2` por comodidad. En este caso simple, también se podría haber usado `substitute` de R base, aunque habría requerido el uso de `lapply(env, as.name)`.

Ahora, para usar la sustitución dentro de `[.data.table`, no necesitamos llamar a la función `substitute2`. Como ahora se usa internamente, solo tenemos que proporcionar el argumento `env`, de la misma manera que lo hicimos con la función `substitute2` en el ejemplo anterior. La sustitución se puede aplicar a los argumentos `i`, `j` y `by` (o `keyby`) del método `[.data.table`. Tenga en cuenta que establecer el argumento `verbose` como `TRUE` permite imprimir expresiones después de aplicar la sustitución. Esto es muy útil para la depuración.

Usemos el conjunto de datos "iris" como demostración. A modo de ejemplo, imaginemos que queremos calcular la "Hipotenusa del Sépalo", considerando el ancho y la longitud del sépalo como si fueran los catetos de un triángulo rectángulo.

```{r hypotenuse_datatable}
DT = as.data.table(iris)

str(
  DT[, outer(inner(var1) + inner(var2)),
     env = list(
       outer = "sqrt",
       inner = "square",
       var1 = "Sepal.Length",
       var2 = "Sepal.Width"
    )]
)

# return as a data.table
DT[, .(Species, var1, var2, out = outer(inner(var1) + inner(var2))),
   env = list(
     outer = "sqrt",
     inner = "square",
     var1 = "Sepal.Length",
     var2 = "Sepal.Width",
     out = "Sepal.Hypotenuse"
  )]
```

En la última llamada, añadimos otro parámetro, `out = "Sepal.Hypotenuse"`, que indica el nombre de la columna de salida. A diferencia del `substitute` de R base, `substitute2` también gestionará la sustitución de los nombres de los argumentos de la llamada.

La sustitución también funciona en `i` y `by` (o `keyby`).

```{r hypotenuse_datatable_i_j_by}
DT[filter_col %in% filter_val,
   .(var1, var2, out = outer(inner(var1) + inner(var2))),
   by = by_col,
   env = list(
     outer = "sqrt",
     inner = "square",
     var1 = "Sepal.Length",
     var2 = "Sepal.Width",
     out = "Sepal.Hypotenuse",
     filter_col = "Species",
     filter_val = I(c("versicolor", "virginica")),
     by_col =  "Species"
  )]
```

### Sustituir funciones

Una pequeña aclaración puede ser útil sobre cómo sustituir el nombre de una función en una expresión. Tenga en cuenta que proporcionar `outer="sqrt"` (cadena) y `outer=sqrt` (símbolo) es muy diferente:

```{r substitute_fun1, result='hide'}
DT[, outer(Sepal.Length), env = list(outer="sqrt"), verbose=TRUE]
#Argument 'j' after substitute: sqrt(Sepal.Length)
## DT[, sqrt(Sepal.Length)]

DT[, outer(Sepal.Length), env = list(outer=sqrt), verbose=TRUE]
#Argument 'j' after substitute: .Primitive("sqrt")(Sepal.Length)
## DT[, .Primitive("sqrt")(Sepal.Length)]
```

Y aunque `.Primitive("sqrt")(Sepal.Length)` todavía funciona, casi nunca es la forma deseada.

Más importante aún, si se pretende utilizar la forma del símbolo, entonces se puede y se debe utilizar directamente en la expresión, ya que no hay necesidad de sustitución.

```{r substitute_fun2, result='hide'}
DT[, sqrt(Sepal.Length)]
```

Si el nombre de la función que se va a sustituir necesita estar calificado por el espacio de nombres, entonces el espacio de nombres y el nombre de la función se pueden sustituir por cualquier otro símbolo en la expresión:

```r
DT[, ns::fun(Sepal.Length), env = list(ns="base", fun="sqrt"), verbose=TRUE]
#Argument 'j' after substitute: base::sqrt(Sepal.Length)
## DT[, base::sqrt(Sepal.Length)]
```

### Sustituir variables y valores de caracteres

En el ejemplo anterior, hemos visto una característica útil de `substitute2`: la conversión automática de cadenas a nombres/símbolos. Surge una pregunta obvia: ¿qué ocurre si realmente queremos sustituir un parámetro con un valor de *carácter* para obtener el comportamiento `substitute` de R base? Proporcionamos un mecanismo para evitar la conversión automática envolviendo los elementos en la llamada `I()` de R base. La función `I` marca un objeto como *AsIs*, lo que impide la conversión automática de sus argumentos de carácter a símbolo. (Consulte la documentación de `?AsIs` para más detalles). Si se desea el comportamiento de R base para todo el argumento `env`, lo mejor es envolverlo en `I()`. Alternativamente, cada elemento de la lista puede envolverse en `I()` individualmente. Analicemos ambos casos a continuación.

```{r rank}
substitute(    # base R behaviour
  rank(input, ties.method = ties),
  env = list(input = as.name("Sepal.Width"), ties = "first")
)

substitute2(   # mimicking base R's "substitute" using "I"
  rank(input, ties.method = ties),
  env = I(list(input = as.name("Sepal.Width"), ties = "first"))
)

substitute2(   # only particular elements of env are used "AsIs"
  rank(input, ties.method = ties),
  env = list(input = "Sepal.Width", ties = I("first"))
)
```

Tenga en cuenta que la conversión funciona de forma recursiva en cada elemento de la lista, incluido el mecanismo de escape, por supuesto.

```{r substitute2_recursive}
substitute2(   # all are symbols
  f(v1, v2),
  list(v1 = "a", v2 = list("b", list("c", "d")))
)
substitute2(   # 'a' and 'd' should stay as character
  f(v1, v2),
  list(v1 = I("a"), v2 = list("b", list("c", I("d"))))
)
```

### Sustitución de listas de longitud arbitraria

El ejemplo anterior ilustra una forma sencilla y eficaz de dinamizar el código. Sin embargo, existen muchos otros casos mucho más complejos con los que un desarrollador podría tener que lidiar. Un problema común es el manejo de una lista de argumentos de longitud arbitraria.

Un caso de uso obvio podría ser imitar la funcionalidad de `.SD` inyectando una llamada `list` en el argumento `j`.

```{r splice_sd}
cols = c("Sepal.Length", "Sepal.Width")
DT[, .SD, .SDcols = cols]
```

Teniendo el parámetro `cols`, nos gustaría unirlo en una llamada `list`, haciendo que el argumento `j` se vea como en el código a continuación.

```{r splice_tobe}
DT[, list(Sepal.Length, Sepal.Width)]
```

*Splicing* es una operación que consiste en insertar una lista de objetos en una expresión como una secuencia de argumentos para llamar. En R base, empalmar `cols` en una `list` se puede lograr usando `as.call(c(quote(list), lapply(cols, as.name)))`. Además, a partir de R 4.0.0, existe una nueva interfaz para esta operación en la función `bquote`.

En data.table, lo simplificamos al incluir automáticamente una lista de objetos en una llamada de lista con esos objetos. Esto significa que cualquier objeto `list` dentro del argumento `env` se convertirá en una `call` de lista, simplificando así la API para ese caso de uso, como se muestra a continuación.

```{r splice_datatable}
# this works
DT[, j,
   env = list(j = as.list(cols)),
   verbose = TRUE]

# this will not work
#DT[, list(cols),
#   env = list(cols = cols)]
```

Es importante proporcionar una llamada a `as.list`, en lugar de simplemente una lista, dentro del argumento de lista `env`, como se muestra en el ejemplo anterior.

Exploremos el *alistamiento* con más detalle.

```{r splice_enlist}
DT[, j,  # data.table automatically enlists nested lists into list calls
   env = list(j = as.list(cols)),
   verbose = TRUE]

DT[, j,  # turning the above 'j' list into a list call
   env = list(j = quote(list(Sepal.Length, Sepal.Width))),
   verbose = TRUE]

DT[, j,  # the same as above but accepts character vector
   env = list(j = as.call(c(quote(list), lapply(cols, as.name)))),
   verbose = TRUE]
```

Ahora, intentemos pasar una lista de símbolos, en lugar de llamarlos. Usaremos `I()` para evitar la conversión automática de *enlist*, pero como esto también desactivará la conversión de caracteres a símbolos, también debemos usar `as.name`.

```{r splice_not, error=TRUE, purl=FALSE}
DT[, j,  # list of symbols
   env = I(list(j = lapply(cols, as.name))),
   verbose = TRUE]

DT[, j,  # again the proper way, enlist list to list call automatically
   env = list(j = as.list(cols)),
   verbose = TRUE]
```

Téngase en cuenta que ambas expresiones, aunque visualmente parezcan iguales, no son idénticas.

```{r splice_substitute2_not}
str(substitute2(j, env = I(list(j = lapply(cols, as.name)))))

str(substitute2(j, env = list(j = as.list(cols))))
```

Para obtener una explicación más detallada sobre este asunto, consulte los ejemplos en la [documentación de `substitute2`](https://rdatatable.gitlab.io/data.table/library/data.table/html/substitute2.html).

### Sustitución de una consulta compleja

Tomemos, como ejemplo de una función más compleja, el cálculo de la raíz cuadrada media.

${\displaystyle x_{\text{RMS}}={\sqrt{{\frac{1}{n}}\left(x_{1}^{2}+x_{2}^{2}+\cdots +x_{n}^{2}\right)}}}$

Acepta un número arbitrario de variables como entrada, pero ahora no podemos simplemente "unir" una lista de argumentos en una llamada de lista, ya que cada uno de ellos debe estar encapsulado en una llamada "cuadrada". En este caso, debemos "unir" manualmente en lugar de depender del "enlistado" automático de data.table.

Primero, debemos construir llamadas a la función `square` para cada variable (ver `inner_calls`). Luego, debemos reducir la lista de llamadas a una sola, con una secuencia anidada de llamadas `+` (ver `add_calls`). Finalmente, debemos sustituir la llamada construida en la expresión circundante (ver `rms`).

```{r complex}
outer = "sqrt"
inner = "square"
vars = c("Sepal.Length", "Sepal.Width", "Petal.Length", "Petal.Width")

syms = lapply(vars, as.name)
to_inner_call = function(var, fun) call(fun, var)
inner_calls = lapply(syms, to_inner_call, inner)
print(inner_calls)

to_add_call = function(x, y) call("+", x, y)
add_calls = Reduce(to_add_call, inner_calls)
print(add_calls)

rms = substitute2(
  expr = outer((add_calls) / len),
  env = list(
    outer = outer,
    add_calls = add_calls,
    len = length(vars)
  )
)
print(rms)

str(
  DT[, j, env = list(j = rms)]
)

# same, but skipping last substitute2 call and using add_calls directly
str(
  DT[, outer((add_calls) / len),
     env = list(
       outer = outer,
       add_calls = add_calls,
       len = length(vars)
    )]
)

# return as data.table
j = substitute2(j, list(j = as.list(setNames(nm = c(vars, "Species", "rms")))))
j[["rms"]] = rms
print(j)
DT[, j, env = list(j = j)]

# alternatively
j = as.call(c(
  quote(list),
  lapply(setNames(nm = vars), as.name),
  list(Species = as.name("Species")),
  list(rms = rms)
))
print(j)
DT[, j, env = list(j = j)]
```

### Errores comunes

Es importante comprender la diferencia entre pasar un objeto y un nombre que apunta a un objeto. Vea la salida detallada de los siguientes ejemplos.

```{r obj_vs_objname}
DT[, fun(Petal.Width), env = list(fun = mean), verbose=TRUE]
DT[, fun(Petal.Width), env = list(fun = "mean"), verbose=TRUE]
```

Los usuarios suelen preferir sustituir el nombre de la función en lugar de insertar el cuerpo de la misma. Por lo tanto, suele preferirse el segundo enfoque (pasar una cadena de caracteres).

En caso de dudas sobre el funcionamiento de la interfaz `env`, establezca `verbose = TRUE` para inspeccionar cómo se resuelven las expresiones internamente.

### Utilice el argumento `env` desde dentro de otra función

Se decidió por diseño que el argumento `env` siga las reglas de *Evaluación Estándar* (SE), es decir, los valores pasados ​​a `env` se evalúan en su ámbito original tal cual. Para más información sobre el tema, consulte el [Manual del lenguaje R: Computación en el lenguaje](https://cran.r-project.org/doc/manuals/r-release/R-lang.html#Computing-on-the-language)). Por lo tanto, **usar el argumento `env` desde una función no requiere ningún manejo especial**. Esto también significa que el alias `.()` para una `list()`, *como* `env = .(.col="Petal.Length")`, no funcionará; utilice `env = list(.col="Petal.Length")` ​​en su lugar.

```{r env_se}
fun = function(x, col.mean) {
  stopifnot(is.character(col.mean), is.data.table(x))
  x[, .(col_avg = mean(.col)), env = list(.col = col.mean)]
}
fun(DT, col.mean="Petal.Length")
```

Si la función externa en sí sigue las reglas NSE (evaluación no estándar), entonces tiene que resolver los objetos del lenguaje de la misma manera que cuando pasa sus argumentos a cualquier otra función SE.

```{r env_nse}
fun = function(x, col.mean) {
  col.mean = substitute(col.mean)
  stopifnot(is.name(col.mean), is.data.table(x))
  x[, .(col_avg = mean(.col)), env = list(.col = col.mean)]
}
fun(DT, col.mean=Petal.Length)
```

## Interfaces retiradas

En `[.data.table`, también es posible usar otros mecanismos para la sustitución de variables o para pasar expresiones entre comillas. Estos incluyen `get` y `mget` para la inyección en línea de variables proporcionando sus nombres como cadenas, y `eval`, que indica a `[.data.table` que la expresión pasada a un argumento está entre comillas y que debe gestionarse de forma diferente. Estas interfaces deben considerarse retiradas y recomendamos usar el nuevo argumento `env` en su lugar.

### `get`

```{r old_get}
v1 = "Petal.Width"
v2 = "Sepal.Width"

DT[, .(total = sum(get(v1), get(v2)))]

DT[, .(total = sum(v1, v2)),
   env = list(v1 = v1, v2 = v2)]
```

### `mget`

```{r old_mget}
v = c("Petal.Width", "Sepal.Width")

DT[, lapply(mget(v), mean)]

DT[, lapply(v, mean),
   env = list(v = as.list(v))]

DT[, lapply(v, mean),
   env = list(v = as.list(setNames(nm = v)))]
```

### `eval`

En lugar de utilizar la función `eval`, podemos proporcionar una expresión entre comillas en el elemento del argumento `env`, por lo que no se necesita una llamada `eval` adicional.

```{r old_eval}
cl = quote(
  .(Petal.Width = mean(Petal.Width), Sepal.Width = mean(Sepal.Width))
)

DT[, eval(cl)]

DT[, cl, env = list(cl = cl)]
```

```{r cleanup, echo=FALSE}
options(.opts)
registerS3method("print", "data.frame", base::print.data.frame)
```
