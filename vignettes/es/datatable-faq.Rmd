---
title: "Preguntas frecuentes sobre data.table"
date: "`{r} Sys.Date()`"
output:
  litedown::html_format:
    options:
      toc: true
      number_sections: true
vignette: >
  %\VignetteIndexEntry{Frequently Asked Questions about data.table}
  %\VignetteEngine{litedown::vignette}
  \usepackage[utf8]{inputenc}
---

<style>
h2 {
    font-size: 20px;
}

#TOC {
  border: 1px solid #ccc;
  border-radius: 5px;
  padding-left: 1em;
  background: #f6f6f6;
  width: 100%;
}
</style>

```{r, echo=FALSE, file='../_translation_links.R'}
```

`{r} .write.translation.links("Las traducciones de este documento están disponibles en: %s")`

```{r, echo = FALSE, message = FALSE}
library(data.table)
litedown::reactor(comment = "# ")
.old.th = setDTthreads(1)
```

La primera sección, Preguntas frecuentes para principiantes, está diseñada para leerse en orden, de principio a fin. Simplemente está escrita en estilo FAQ para facilitar su comprensión. No se trata de las preguntas más frecuentes. Una mejor manera de comprobarlo es consultar Stack Overflow.

Estas preguntas frecuentes son de lectura obligatoria y se consideran documentación esencial. No haga preguntas en Stack Overflow ni plantee problemas en GitHub hasta que las haya leído. Todos sabemos que no las ha leído cuando pregunta. Así que, si pregunta y no las ha leído, no use su nombre real.

Este documento se ha revisado rápidamente debido a los cambios en la versión 1.9.8, publicada en noviembre de 2016. Por favor, envíe solicitudes de incorporación de cambios para corregir errores o realizar mejoras. Si alguien sabe por qué la tabla de contenido aparece tan estrecha y compacta al ser mostrada por CRAN, por favor, infórmenos. Este documento solía estar en formato PDF y recientemente lo cambiamos a HTML.

# Preguntas frecuentes para principiantes

## ¿Por qué `DT[ , 5]` y `DT[2, 5]` devuelven un data.table de 1 columna en lugar de vectores como `data.frame`? {#j-num}

Para mantener la coherencia, al usar data.table en funciones que aceptan entradas variables, se puede confiar en que `DT[...]` devolverá un data.table. No es necesario recordar incluir `drop=FALSE` como en data.frame. data.table se lanzó por primera vez en 2006 y esta diferencia con data.frame ha sido una característica desde el principio.

Quizás haya oído que, en general, es una mala práctica referirse a las columnas por número en lugar de nombre. Si su colega lee tu código más tarde, puede que tenga que buscar por todas partes para encontrar la columna número 5. Si usted o él cambian el orden de las columnas en los niveles superiores de tu programa R, podría obtener resultados erróneos sin previo aviso ni error si se olvida modificar todos los lugares del código que hacen referencia a la columna número 5. La culpa es suya, no de R ni de data.table. Es realmente malo. Por favor, no lo haga. Es el mismo mantra de los desarrolladores profesionales de SQL: nunca uses `select *`, selecciona siempre explícitamente por nombre de columna para, al menos, intentar ser robusto ante futuros cambios.

Supongamos que la columna 5 se llama `"region"` y debe extraerla como un vector, no como un data.table. Es más robusto usar el nombre de la columna y escribir `DT$region` o `DT[["region"]]`; es decir, lo mismo que la base R. Se recomienda usar `$` y `[[` de la base R en data.table. No se recomienda su uso cuando se combina con `<-` para asignar (use `:=` en su lugar), sino simplemente para seleccionar una sola columna por nombre. Sin embargo, una diferencia clave es que DT$col y DT[['col']] pueden devolver una referencia, mientras que DT[, col] siempre devuelve una copia. Esto puede tener consecuencias importantes y se explica en `vignette("datatable-reference-semantics", package="data.table")`.

Hay circunstancias en las que referirse a una columna por número parece ser la única opción, como en el caso de una secuencia de columnas. En estas situaciones, al igual que en data.frame, puede escribir `DT[, 5:10]` y `DT[,c(1,4,10)]`. Sin embargo, es más robusto (ante futuros cambios en el número y orden de las columnas de sus datos) usar un rango con nombre como `DT[,columnRed:columnViolet]` o nombrar cada una `DT[,c("columnRed","columnOrange","columnYellow")]`. Al principio es más laborioso, pero probablemente se lo agradecerá a sí mismo y sus colegas podrían agradecérselo en el futuro. Al menos podrá decir que se esforzó al máximo por escribir código robusto si algo sale mal.

Sin embargo, lo que realmente queremos que hagas es `DT[,.(columnRed,columnOrange,columnYellow)]`; es decir, usar los nombres de columna como si fueran variables directamente dentro de `DT[...]`. No tiene que prefijar cada columna con `DT$` como lo hace en data.frame. La parte `.()` es solo un alias para `list()` y puede usar `list()` en su lugar si lo prefiere. Puede colocar cualquier expresión R de nombres de columna, usando cualquier paquete R, que devuelva diferentes tipos de diferentes longitudes, justo ahí. Queríamos alentarle a hacer eso tan fuertemente en el pasado que deliberadamente no hicimos que `DT[,5]` funcionara en absoluto. Antes de v1.9.8 lanzado en noviembre de 2016, `DT[,5]` solía devolver solo `5`. La idea era que podíamos enseñar más simplemente un hecho de que las partes dentro de `DT[...]` se evalúan dentro del marco de DT siempre (ven los nombres de columna como si fueran variables). Y `5` evalúa a `5`, por lo que el comportamiento fue consistente con la regla única. Les solicitamos que superaran un obstáculo adicional deliberado `DT[,5,with=FALSE]` si realmente deseaban seleccionar una columna por nombre o número. A partir de noviembre de 2016, ya no es necesario usar `with=FALSE` y veremos cómo una mayor consistencia con data.frame en este sentido ayudará o perjudicará tanto a los usuarios nuevos como a los antiguos. Los nuevos usuarios que no lean estas preguntas frecuentes, ni siquiera esta primera entrada, esperamos que no se tropiecen tan pronto con data.table como antes si esperaban que funcionara como data.frame. Esperamos que no se pierdan nuestra intención y recomendación de colocar expresiones de columnas dentro de `DT[i, j, by]`. Si usan data.table como data.frame, no obtendrán ningún beneficio. Si conocen a alguien en esa situación, por favor, anímenle a leer este documento como ustedes.

Recordatorio: puede colocar *cualquier* expresión de R dentro de `DT[...]` usando los nombres de columna como si fueran variables; por ejemplo, pruebe `DT[, colA*colB/2]`. Esto devuelve un vector porque usó los nombres de columna como si fueran variables. Envuélvalo en `.()` para devolver una data.table; es decir, `DT[,.(colA*colB/2)]`. Asígnele un nombre: `DT[,.(myResult = colA*colB/2)]`. Dejamos que adivine cómo devolver dos valores de esta consulta. También es bastante común realizar varias acciones dentro de un cuerpo anónimo: `DT[, { x<-colA+10; x*x/2 }]` o llamar a la función de otro paquete: `DT[ , fitdistr(columnA, "normal")]`.

## ¿Por qué `DT[,"region"]` devuelve un data.table de 1 columna en lugar de un vector?

Consulte la [respuesta anterior](#j-num). Prueba con `DT$region` o `DT[["region"]]`.

## ¿Por qué `DT[, región]` devuelve un vector para la columna "región"? Me gustaría una tabla data.table de una sola columna.

Pruebe `DT[ , .(region)]` en su lugar. `.()` es un alias para `list()` y garantiza que se devuelva una data.table.

Continúe leyendo y consulte las preguntas frecuentes a continuación. Revise los documentos completos antes de atascarse en una parte.

## ¿Por qué no funciona `DT[, x, y, z]`? Quería las tres columnas `x`, `y` y `z`.

La expresión `j` es el segundo argumento. Pruebe `DT[ , c("x","y","z")]` o `DT[ , .(x,y,z)]`.

## Asigné la variable `mycol="x"`, pero `DT[, mycol]` devuelve un error. ¿Cómo puedo hacer que busque el nombre de la columna contenida en la variable `mycol`?

El error es que no se puede encontrar la columna denominada `"mycol"`, y este error es correcto. El alcance de `data.table` es diferente al de `data.frame` en el sentido de que puede usar los nombres de las columnas como si fueran variables directamente dentro de `DT[...]` sin anteponer `DT$` a cada nombre de columna; consulte la pregunta frecuente 1.1 anterior.

Para usar `mycol` para seleccionar la columna `x` de `DT`, hay algunas opciones:

```r
DT[, ..mycol]            # .. prefix conveys to look for the mycol one level up in calling scope
DT[, mycol, with=FALSE]  # revert to data.frame behavior
DT[[mycol]]               # treat DT as a list and use [[ from base R
```

Consulte `?data.table` para obtener más detalles sobre el prefijo `..`.

El argumento `with` toma su nombre de la función `base` `with()`. Cuando `with=TRUE` (predeterminado), `data.table` funciona de forma similar a `with()`, es decir, `DT[, mycol]` se comporta como `with(DT, mycol)`. Cuando `with=FALSE`, las reglas de evaluación estándar de `data.frame` se aplican a todas las variables en `j` y ya no se pueden usar nombres de columna directamente.

## ¿Cuáles son los beneficios de poder utilizar nombres de columnas como si fueran variables dentro de 'DT[...]'?

`j` no tiene por qué ser solo nombres de columnas. Puede escribir cualquier *expresión* de R de nombres de columnas directamente en `j`, *p. ej.*, `DT[ , media(x*y/z)]`. Lo mismo aplica para `i`, *p. ej.*, `DT[x>1000, suma(y*z)]`.

Esto ejecuta la expresión `j` en el conjunto de filas donde la expresión `i` es verdadera. Ni siquiera necesita devolver datos, *p. ej.*, `DT[x>1000, plot(y, z)]`. Puede hacer `j` por grupo simplemente agregando `by = `; p. ej., `DT[x>1000, sum(y*z), by = w]`. Esto ejecuta `j` para cada grupo en la columna `w` pero solo sobre las filas donde `x>1000`. Al colocar las 3 partes de la consulta (i=where, j=select y by=group by) dentro de los corchetes, data.table ve esta consulta como un todo antes de que se evalúe cualquier parte de ella. Por lo tanto, puede optimizar la consulta combinada para el rendimiento. Puede hacer esto porque el lenguaje R tiene una evaluación diferida única (Python y Julia no la tienen). data.table ve las expresiones dentro de `DT[...]` antes de que se evalúen y las optimiza antes de la evaluación. Por ejemplo, si data.table ve que solo está usando 2 columnas de 100, no se molestará en filtrar las 98 que no son necesarias para su expresión j.

## Vale, empiezo a entender la función de data.table, pero ¿por qué no mejoraron `data.frame` en R? ¿Por qué tiene que ser un paquete nuevo?

Como se [resaltó arriba](#j-num), `j` en `[.data.table` es fundamentalmente diferente de `j` en `[.data.frame`. Incluso si algo tan simple como `DF[ , 1]` se modificara en R base para devolver un data.frame en lugar de un vector, esto afectaría el código existente en miles de paquetes CRAN y código de usuario. En cuanto creamos una nueva clase que heredara de data.frame, tuvimos la oportunidad de cambiar algunas cosas, y lo hicimos. Queremos que data.table sea ligeramente diferente y funcione de esta manera para que funcione una sintaxis más compleja. También existen otras diferencias (véase [abajo](#SmallerDiffs)).

Además, data.table hereda de `data.frame`. También es un `data.frame`. Un data.table se puede pasar a cualquier paquete que solo acepte `data.frame` y ese paquete puede usar la sintaxis `[.data.frame` en data.table. Consulta [esta respuesta](https://stackoverflow.com/a/10529888/403310) para saber cómo lograrlo.

También *hemos* propuesto mejoras para R siempre que ha sido posible. Una de ellas se aceptó como nueva característica en R 2.12.0:

> `unique()` y `match()` ahora son más rápidos en vectores de caracteres donde todos los elementos están en la caché global CHARSXP y tienen codificación sin marcar (ASCII). Gracias a Matt Dowle por sugerir mejoras en la generación del código hash en unique.c.

Una segunda propuesta fue usar `memcpy` en duplicate.c, que es mucho más rápido que un bucle for en C. Esto mejoraría la *forma* en que R copia datos internamente (en algunas mediciones, hasta 13 veces). El hilo sobre r-devel está [aquí](https://stat.ethz.ch/pipermail/r-devel/2010-April/057249.html).

Una tercera propuesta más significativa que fue aceptada es que R ahora usa el código de ordenamiento por radix de data.table a partir de R 3.3.0:

> El algoritmo de ordenamiento por radio y su implementación de data.table (forder) reemplaza el ordenamiento por radio (conteo) anterior y añade un nuevo método para order(). Contribuido por Matt Dowle y Arun Srinivasan, el nuevo algoritmo admite vectores lógicos, enteros (incluso con valores grandes), reales y de caracteres. Supera a todos los demás métodos, pero presenta algunas desventajas (véase ?sort).

Este fue un gran evento para nosotros y lo celebramos hasta el cansancio. (En realidad, no).

## ¿Por qué los valores predeterminados son así? ¿Por qué funciona así?

La respuesta simple es que el autor principal lo diseñó originalmente para su propio uso. Así lo quiso. Le parece una forma más natural y rápida de escribir código, que también se ejecuta con mayor rapidez.

## ¿Esto no se hace ya con `with()` y `subset()` en `base`?

Algunas de las características comentadas hasta ahora son válidas. El paquete se basa en la funcionalidad básica. Hace lo mismo, pero requiere menos código y se ejecuta mucho más rápido si se usa correctamente.

## ¿Por qué «X[Y]» devuelve también todas las columnas de «Y»? ¿No debería devolver un subconjunto de «X»?

Esto se modificó en la versión 1.5.3 (febrero de 2011). Desde entonces, `X[Y]` incluye las columnas no unidas de `Y`. Esta función se denomina *ámbito heredado de unión* porque no solo las columnas `X` están disponibles para la expresión `j`, sino también las columnas `Y`. La desventaja es que `X[Y]` es menos eficiente, ya que cada elemento de las columnas no unidas de `Y` se duplica para coincidir con el (probablemente elevado) número de filas en `X` que coinciden. Por lo tanto, recomendamos encarecidamente `X[Y, j]` en lugar de `X[Y]`. Consulte las [siguientes preguntas frecuentes](#MergeDiff).

## ¿Cuál es la diferencia entre `X[Y]` y `merge(X, Y)`? {#MergeDiff}

`X[Y]` es una unión (join) que busca las filas de `X` utilizando `Y` (o la clave de `Y` si tiene una) como índice.

`Y[X]` es una unión que busca las filas de `Y` utilizando `X` (o la clave de `X` si tiene una) como índice.

`merge(X,Y)`[^1] funciona en ambos sentidos simultáneamente. El número de filas de `X[Y]` e `Y[X]` suele ser diferente, mientras que el número de filas devuelto por `merge(X, Y)` y `merge(Y, X)` es el mismo.

*PERO* eso pasa por alto el punto principal. La mayoría de las tareas requieren que se haga algo en los datos después de una unión o fusión. ¿Por qué fusionar todas las columnas de datos, solo para usar un pequeño subconjunto de ellas después? Puede sugerir `merge(X[ , ColsNeeded1], Y[ , ColsNeeded2])`, pero eso requiere que el programador determine qué columnas se necesitan. `X[Y, j]` en data.table hace todo eso en un solo paso para ti. Cuando escribes `X[Y, sum(foo*bar)]`, data.table inspecciona automáticamente la expresión `j` para ver qué columnas usa. Solo creará un subconjunto de esas columnas; las demás se ignoran. Solo se crea memoria para las columnas que usa `j` y las columnas `Y` disfrutan de las reglas de reciclaje estándar de R dentro del contexto de cada grupo. Digamos que `foo` está en `X` y `bar` está en `Y` (junto con otras 20 columnas en `Y`). ¿No es `X[Y, sum(foo*bar)]` más rápido de programar y más rápido de ejecutar que el desperdicio de un `merge` de todo seguido de `subset`?

[^1]: Nos referimos al método `merge` para data.table o al método `merge` para `data.frame`, ya que ambos funcionan de la misma manera. Consulte `?merge.data.table` y [a continuación](#r-dispatch) para obtener más información sobre el envío de métodos.

## ¿Algo más sobre `X[Y, sum(foo*bar)]`?

Este comportamiento cambió en la v1.9.4 (septiembre de 2014). Ahora realiza la unión `X[Y]` y luego ejecuta `sum(foo*bar)` sobre todas las filas; es decir, `X[Y][ , sum(foo*bar)]`. Antes, ejecutaba `j` para cada *grupo* de `X` con el que coincidía cada fila de `Y`. Esto aún se puede hacer, ya que es muy útil, pero ahora es necesario especificar explícitamente `by = .EACHI`, es decir, `X[Y, sum(foo*bar), by = .EACHI]`. A esto lo llamamos *agrupación por cada `i`*.

Por ejemplo, (para complicarlo aún más, también se utiliza *join legacy scope*):

```{r}
X = data.table(grp = c("a", "a", "b",
                       "b", "b", "c", "c"), foo = 1:7)
setkey(X, grp)
Y = data.table(c("b", "c"), bar = c(4, 2))
X
Y
X[Y, sum(foo*bar)]
X[Y, sum(foo*bar), by = .EACHI]
```

## Qué bien. ¿Cómo lograron cambiarlo si los usuarios dependían del comportamiento anterior?

La solicitud de cambio provino de los usuarios. Se creía que, si una consulta realiza agrupaciones, debería incluirse un `by=` explícito para facilitar la lectura del código. Se proporcionó una opción para restablecer el comportamiento anterior: `options(datatable.old.bywithoutby)`, con `FALSE` por defecto. Esto permitió la actualización para probar las demás nuevas funciones y correcciones de errores de la v1.9.4, y la posterior migración de cualquier consulta `by-without-by` cuando estuviera lista, añadiéndoles `by=.EACHI`. Conservamos 47 pruebas previas al cambio y las reintrodujimos como nuevas pruebas, con `options(datatable.old.bywithoutby=TRUE)`. Añadimos un mensaje de inicio sobre el cambio y cómo volver al comportamiento anterior. Tras un año, la opción quedó obsoleta con una advertencia al usarla. Tras dos años, se eliminó la opción para volver al comportamiento anterior.

De los 66 paquetes en CRAN o Bioconductor que dependían de o importaban data.table al momento de la publicación de la v1.9.4 (ahora son más de 300), solo uno se vio afectado por el cambio. Esto podría deberse a que muchos paquetes no cuentan con pruebas exhaustivas, o simplemente a que la agrupación por cada fila en `i` no se usaba mucho en los paquetes posteriores. Siempre probamos la nueva versión con todos los paquetes dependientes antes del lanzamiento y coordinamos cualquier cambio con los responsables. Por lo tanto, esta versión fue bastante sencilla en ese sentido.

Otra razón convincente para realizar el cambio fue que, anteriormente, no existía una forma eficiente de lograr lo que `X[Y, sum(foo*bar)]` hace ahora. Se debía escribir `X[Y][ , sum(foo*bar)]`. Esto no era óptimo porque `X[Y]` unía todas las columnas y las pasaba a la segunda consulta compuesta sin saber que solo se necesitaban `foo` y `bar`. Para solucionar este problema de eficiencia, se requería un esfuerzo de programación adicional: `X[Y, list(foo, bar)][ , sum(foo*bar)]`. El cambio a `by = .EACHI` ha simplificado esto al permitir que ambas consultas se expresen dentro de una única consulta `DT[...]` para mayor eficiencia.

# Sintaxis general

## ¿Cómo puedo evitar escribir una expresión `j` muy larga? Dijiste que debería usar la columna *nombres*, pero tengo muchas columnas.

Al agrupar, la expresión `j` puede usar nombres de columna como variables, como ya sabe, pero también puede usar el símbolo reservado `.SD`, que hace referencia al **S**subconjunto de **D**ata.table** para cada grupo (excluyendo las columnas de agrupación). Por lo tanto, para sumar todas las columnas, simplemente se usa `DT[ , lapply(.SD, sum), by = grp]`. Puede parecer complicado, pero es rápido de escribir y de ejecutar. Tenga en cuenta que no es necesario crear una función anónima. El objeto `.SD` se implementa internamente de forma eficiente y es más eficiente que pasar un argumento a una función. Sin embargo, si el símbolo `.SD` aparece en `j`, data.table debe rellenar `.SD` por completo para cada grupo, incluso si `j` no lo usa del todo.

Por lo tanto, no utilice, por ejemplo, `DT[ , sum(.SD[["sales"]]), by = grp]`. Esto funciona, pero es ineficiente y poco elegante. `DT[ , sum(sales), by = grp]` es lo que se pretendía, y podría ser cientos de veces más rápido. Si utiliza *todos* los datos en `.SD` para cada grupo (como en `DT[ , lapply(.SD, sum), by = grp]`), es un uso muy adecuado de `.SD`. Si utiliza *varias* columnas, pero no *todas*, puede combinar `.SD` con `.SDcols`; consulte `?data.table`.

## ¿Por qué el valor predeterminado para `mult` ahora es `"all"`?

En la v1.5.3, el valor predeterminado se cambió a `"all"`. Cuando `i` (o la clave de `i`, si la tiene) tiene menos columnas que la clave de `x`, `mult` ya estaba configurado automáticamente como `"all"`. Cambiar el valor predeterminado facilita y aclara esto para los usuarios, ya que se presentaba con bastante frecuencia.

En versiones anteriores a la v1.3, `"all"` era más lento. Internamente, `"all"` se implementaba uniendo con `"first"` y luego desde cero con `"last"`. Tras esto, se realizaba una comparación entre ellos para determinar el intervalo de coincidencias en `x` para cada fila en `i`. Sin embargo, la mayoría de las veces, unimos filas individuales, donde `"first"`, `"last"` y `"all"` devuelven el mismo resultado. Preferimos el máximo rendimiento en la mayoría de los casos, por lo que el valor predeterminado elegido fue `"first"`. Al trabajar con una clave no única (generalmente una sola columna que contiene una variable de agrupación), `DT["A"]` devolvía la primera fila de ese grupo, por lo que se necesitaba `DT["A", mult = "all"]` para devolver todas las filas de ese grupo.

En la v1.4, la búsqueda binaria en C se modificó para que se ramificara en el nivel más profundo para encontrar el primero y el último. Es probable que esta ramificación ocurra dentro de las mismas páginas finales de RAM, por lo que ya no debería haber una desventaja de velocidad al establecer `mult` como `"all"` por defecto. Advertimos que el valor predeterminado podría cambiar e implementamos el cambio en la v1.5.3.

Una versión futura de data.table podría permitir distinguir entre una clave y una *clave única*. Internamente, `mult = "all"` funcionaría de forma similar a `mult = "first"` cuando todas las columnas de la clave de `x` estuvieran unidas y la clave de `x` fuera única. data.table necesitaría comprobaciones al insertar y actualizar para garantizar que se mantenga una clave única. Una ventaja de especificar una clave única sería que, además de mejorar el rendimiento, data.table garantizaría que no se insertaran duplicados.

## Estoy usando `c()` en `j` y obtengo resultados extraños.

Esta es una fuente común de confusión. En `data.frame` se suele usar, por ejemplo:

```{r}
DF = data.frame(x = 1:3, y = 4:6, z = 7:9)
DF
DF[ , c("y", "z")]
```

Que devuelve las dos columnas. En data.table, sabe que puede usar los nombres de las columnas directamente y podría intentar:

```{r}
DT = data.table(DF)
DT[ , c(y, z)]
```

Pero esto devuelve un vector. Recuerde que la expresión `j` se evalúa en el entorno de `DT` y `c()` devuelve un vector. Si se requieren dos o más columnas, utilice `list()` o `.()` en su lugar:

```{r}
DT[ , .(y, z)]
```

`c()` también puede ser útil en una data.table, pero su comportamiento es diferente al de `[.data.frame`.

## He creado una tabla compleja con muchas columnas. Quiero usarla como plantilla para una nueva tabla; es decir, crear una tabla sin filas, pero con los nombres y tipos de columna copiados de mi tabla. ¿Es fácil hacerlo?

Sí. Si su tabla compleja se llama `DT`, intente `NEWDT = DT[0]`.

## ¿Es un data.table nulo lo mismo que `DT[0]`?

No. Por "data.table nulo" nos referimos al resultado de `data.table(NULL)` o `as.data.table(NULL)`; *es decir*,

```{r}
data.table(NULL)
data.frame(NULL)
as.data.table(NULL)
as.data.frame(NULL)
is.null(data.table(NULL))
is.null(data.frame(NULL))
```

El objeto data.table|`frame` nulo es `NULL` con algunos atributos adjuntos, lo que significa que ya no es `NULL`. En R, solo `NULL` puro es `NULL`, como se prueba con `is.null()`. Al referirnos al objeto "data.table" nulo, usamos `null` en minúscula para distinguirlo de `NULL` en mayúscula. Para comprobar si el objeto data.table es nulo, use `length(DT) == 0` o `ncol(DT) == 0` (`length` es ligeramente más rápido, ya que es una función primitiva).

Una data.table *vacía* (`DT[0]`) tiene una o más columnas, todas ellas vacías. Estas columnas vacías aún conservan nombres y tipos.

```{r}
DT = data.table(a = 1:3, b = c(4, 5, 6), d = c(7L,8L,9L))
DT[0]
sapply(DT[0], class)
```

## ¿Por qué se ha eliminado el alias `DT()`? {#DTremove1}

`DT` se introdujo originalmente como contenedor para una lista de expresiones `j`. Dado que `DT` era un alias de data.table, era una forma práctica de gestionar el reciclaje silencioso en casos en que cada elemento de la lista `j` evaluaba con longitudes diferentes. Sin embargo, el alias era una de las razones por las que la agrupación era lenta.

A partir de la v1.3, se deben pasar `list()` o `.()` al argumento `j`. Esto es mucho más rápido, especialmente cuando hay muchos grupos. Internamente, este cambio no fue trivial. El reciclaje de vectores ahora se realiza internamente, junto con otras mejoras de velocidad para la agrupación.

## Pero mi código usa `j = DT(...)` y funciona. Las preguntas frecuentes anteriores indican que se ha eliminado `DT()`. {#DTremove2}

Entonces estás usando una versión anterior a la 1.5.3. Antes de la 1.5.3, `[.data.table` detectaba el uso de `DT()` en `j` y lo reemplazaba automáticamente con una llamada a `list()`. Esto facilitaba la transición para los usuarios existentes.

## ¿Cuáles son las reglas de alcance para las expresiones 'j'?

Piense en el subconjunto como un entorno donde todos los nombres de columna son variables. Cuando se utiliza la variable `foo` en la `j` de una consulta como `X[Y, sum(foo)]`, se busca `foo` en el siguiente orden:

 1. El alcance del subconjunto de `X`; *es decir*, los nombres de las columnas de `X`.
 2. El alcance de cada fila de `Y`; *es decir*, los nombres de las columnas de `Y` (*unir el alcance heredado*)
 3. El alcance del marco de llamada; *por ejemplo*, la línea que aparece antes de la consulta data.table.
 4. Ejercicio para el lector: ¿luego navega los marcos de llamada o va directamente a `globalenv()`?
 5. El entorno global

Esto es *alcance léxico*, como se explica en [R FAQ 3.3.1](https://cran.r-project.org/doc/FAQ/R-FAQ.html#Lexical-scoping). Sin embargo, el entorno en el que se creó la función no es relevante, ya que *no hay función*. No se pasa ninguna *función* anónima a `j`. En su lugar, se pasa un *cuerpo* anónimo a `j`; por ejemplo,

```{r}
DT = data.table(x = rep(c("a", "b"), c(2, 3)), y = 1:5)
DT
DT[ , {z = sum(y); z + 3}, by = x]
```

Algunos lenguajes de programación llaman a esto un *lambda*.

## ¿Puedo rastrear la expresión 'j' a medida que se ejecuta a través de los grupos? {#j-trace}

Pruebe algo como esto:

```{r}
DT[ , {
  cat("Objects:", paste(objects(), collapse = ","), "\n")
  cat("Trace: x=", as.character(x), " y=", y, "\n")
  sum(y)},
  by = x]
```

## Dentro de cada grupo, ¿por qué las variables del grupo tienen una longitud de 1?

[Arriba](#j-trace), `x` es una variable de agrupación y (a partir de la v1.6.1) tiene `length` 1 (si se inspecciona o se usa en `j`). Esto se hace por eficiencia y conveniencia. Por lo tanto, no hay diferencia entre las dos siguientes afirmaciones:

```{r}
DT[ , .(g = 1, h = 2, i = 3, j = 4, repeatgroupname = x, sum(y)), by = x]
DT[ , .(g = 1, h = 2, i = 3, j = 4, repeatgroupname = x[1], sum(y)), by = x]
```

Si necesita el tamaño del grupo actual, utilice `.N` en lugar de llamar a `length()` en cualquier columna.

## Solo se imprimen las primeras 10 filas, ¿cómo imprimo más?

Aquí ocurren dos cosas. Primero, si el número de filas en una tabla data.table es grande (`> 100` por defecto), se imprime un resumen de la tabla en la consola por defecto. Segundo, el resumen de una tabla data.table grande se imprime tomando las `n` filas superiores e inferiores (`= 5` por defecto) de la tabla data.table e imprimiendo solo esas. Ambos parámetros (cuándo activar un resumen y qué parte de la tabla usar como resumen) se pueden configurar mediante el mecanismo `options` de R o llamando directamente a la función `print`.

Por ejemplo, para que el resumen de una tabla data.table solo se realice cuando esta tenga más de 50 filas, podría usar `options(datatable.print.nrows = 50)`. Para deshabilitar el resumen predeterminado por completo, podría usar `options(datatable.print.nrows = Inf)`. También podría llamar a `print` directamente, como en `print(your.data.table, nrows = Inf)`.

Si desea mostrar más de las 10 filas superiores (e inferiores) de un resumen de data.table (digamos que prefiere 20), configure `options(datatable.print.topn = 20)`, por ejemplo. También puede llamar a `print` directamente, como en `print(your.data.table, topn = 20)`.

## Con una unión `X[Y]`, ¿qué pasa si `X` contiene una columna llamada `"Y"`?

Cuando `i` es un nombre único, como `Y`, se evalúa en el marco de llamada. En todos los demás casos, como las llamadas a `.()` u otras expresiones, `i` se evalúa dentro del ámbito de `X`. Esto facilita las autouniones sencillas, como `X[J(unique(colA)), mult = "first"]`.

## `X[Z[Y]]` falla porque `X` contiene una columna `"Y"`. Me gustaría usar la tabla `Y` en el ámbito de llamada.

La parte `Z[Y]` no es un nombre único, por lo que se evalúa dentro del marco de `X` y surge el problema. Pruebe `tmp = Z[Y]; X[tmp]`. Esto es robusto para `X` que contiene una columna `"tmp"`, ya que `tmp` es un nombre único. Si se encuentran conflictos de este tipo con frecuencia, una solución sencilla podría ser nombrar todas las tablas en mayúsculas y todos los nombres de las columnas en minúsculas, o algún esquema similar.

## ¿Puedes explicar con más detalle por qué data.table está inspirado en la sintaxis 'A[B]' en 'base'?

Considere la sintaxis `A[B]` usando una matriz de ejemplo `A`:

```{r}
A = matrix(1:12, nrow = 4)
A
```

Para obtener las celdas `(1, 2) = 5` y `(3, 3) = 11` muchos usuarios (creemos) pueden intentar esto primero:

```{r}
A[c(1, 3), c(2, 3)]
```

Sin embargo, esto devuelve la unión de esas filas y columnas. Para referenciar las celdas, se requiere una matriz de dos columnas. `?Extract` dice:

> Al indexar matrices mediante `[`, un único argumento `i` puede ser una matriz con tantas columnas como dimensiones de `x`; el resultado es entonces un vector con elementos correspondientes a los conjuntos de índices en cada fila de `i`.

Vamos a intentarlo de nuevo.

```{r}
B = cbind(c(1, 3), c(2, 3))
B
A[B]
```

Una matriz es una estructura bidimensional con nombres de filas y columnas. ¿Podemos hacer lo mismo con los nombres?

```{r}
rownames(A) = letters[1:4]
colnames(A) = LETTERS[1:3]
A
B = cbind(c("a", "c"), c("B", "C"))
A[B]
```

Sí, podemos. ¿Podemos hacer lo mismo con un data.frame?

```{r}
A = data.frame(A = 1:4, B = letters[11:14], C = pi*1:4)
rownames(A) = letters[1:4]
A
B
A[B]
```

Pero, observe que el resultado se convirtió a `character`. R convirtió `A` a `matrix` primero para que la sintaxis funcionara, pero el resultado no es ideal. Intentemos convertir `B` en `data.frame`.

```{r}
B = data.frame(c("a", "c"), c("B", "C"))
cat(try(A[B], silent = TRUE))
```

Por lo tanto, no podemos filtrar un `data.frame` con otro `data.frame` en R base. ¿Qué sucede si queremos nombres de fila y de columna que no sean `character`, sino `entero` o `float`? ¿Qué sucede si queremos más de dos dimensiones de tipos mixtos? Introduzcamos data.table.

Más aún, las matrices, en especial las dispersas, suelen almacenarse en una tupla de tres columnas: `(i, j, valor)`. Esto puede considerarse como un par clave-valor donde `i` y `j` forman una clave de dos columnas. Si tenemos más de un valor, quizás de diferentes tipos, podría ser `(i, j, val1, val2, val3, ...)`. Esto se parece mucho a un `data.frame`. Por lo tanto, data.table extiende `data.frame`, de modo que un `data.frame` `X` puede ser «filtrado» por un `data.frame` `Y`, lo que da lugar a la sintaxis `X[Y]`.

## ¿Se puede cambiar R base para que haga esto, en lugar de un nuevo paquete?

`data.frame` se usa *en todas partes*, por lo que es muy difícil modificarlo. data.table *hereda* de `data.frame`. También *es* un `data.frame`. Un data.table *puede* pasarse a cualquier paquete que *solo* acepte `data.frame`. Cuando ese paquete usa la sintaxis `[.data.frame` en el data.table, funciona. Esto se debe a que `[.data.table` verifica desde dónde se llamó. Si se llamó desde dicho paquete, `[.data.table` desvía a `[.data.frame`.

## He oído que la sintaxis data.table es análoga a SQL.

Sí:

 - `i` $\Leftrightarrow$ donde
 - `j` $\Leftrightarrow$ select
 - `:=` $\Leftrightarrow$ actualizar
 - `por` $\Leftrightarrow$ group by
 - `i` $\Leftrightarrow$ order by (en sintaxis compuesta)
 - `i` $\Leftrightarrow$ having (en sintaxis compuesta)
 - `nomatch = NA` $\Leftrightarrow$ outer join
 - `nomatch = NULL` $\Leftrightarrow$ inner join
 - `mult = "first"|"last"` $\Leftrightarrow$ N/A porque SQL es inherentemente desordenado
 - `roll = TRUE` $\Leftrightarrow$ N/A porque SQL es inherentemente desordenado

La forma general es:

```r
DT[where, select|update, group by][order by][...] ... [...]
```

Una ventaja clave de los vectores columna en R es que están *ordenados*, a diferencia de SQL[^2]. Podemos usar funciones ordenadas en consultas `data.table`, como `diff()`, y cualquier función de R de cualquier paquete, no solo las definidas en SQL. Una desventaja es que los objetos de R deben caber en memoria; sin embargo, con varios paquetes de R como `ff`, `bigmemory`, `mmap` e `indexing`, esto está cambiando.

[^2]: Puede resultar sorprendente saber que `select top 10 * from ...` no devuelve las mismas filas de forma fiable a lo largo del tiempo en SQL. Es necesario incluir una cláusula `order by` o usar un índice agrupado para garantizar el orden de las filas; es decir, SQL es inherentemente desordenado.

## ¿Cuáles son las diferencias de sintaxis más pequeñas entre `data.frame` y data.table {#SmallerDiffs}?

 - `DT[3]` se refiere a la 3ra *fila*, pero `DF[3]` se refiere a la 3ra *columna*
 - `DT[3, ] == DT[3]`, pero `DF[ , 3] == DF[3]` (de manera algo confusa en data.frame, mientras que data.table es consistente)
 - Por esta razón decimos que la coma es *opcional* en `DT`, pero no opcional en `DF`
 - `DT[[3]] == DF[, 3] == DF[[3]]`
 - `DT[i, ]`, donde `i` es un entero único, devuelve una sola fila, al igual que `DF[i, ]`, pero a diferencia de un filtro de de matriz de una sola fila, que devuelve un vector.
 - `DT[ , j]` donde `j` es un entero único, devuelve un data.table de una columna, a diferencia de `DF[, j]` que devuelve un vector de manera predeterminada
 - `DT[ , "colA"][[1]] == DF[ , "colA"]`.
 - `DT[ , colA] == DF[ , "colA"]` (actualmente en data.table v1.9.8 pero está a punto de cambiar, consulte las notas de la versión)
 - `DT[ , list(colA)] == DF[ , "colA", drop = FALSE]`
 - `DT[NA]` devuelve 1 fila de `NA`, pero `DF[NA]` devuelve una copia completa de `DF` que contiene `NA` en todas partes. El símbolo «NA» es de tipo «lógico» en R y, por lo tanto, se recicla mediante «[.data.frame». La intención del usuario probablemente era «DF[NA_integer_]». `[.data.table` desvía a esta probable intención automáticamente, por conveniencia.
 - `DT[c(TRUE, NA, FALSE)]` trata el `NA` como `FALSE`, pero `DF[c(TRUE, NA, FALSE)]` devuelve `NA` filas para cada `NA` - `DT[ColA == ColB]` es más simple que `DF[!is.na(ColA) & !is.na(ColB) & ColA == ColB, ]`
 - `data.frame(list(1:2, "k", 1:4))` crea 3 columnas, data.table crea una columna `list`.
 - `check.names` es por defecto `TRUE` en `data.frame` pero `FALSE` en data.table, por conveniencia.
 - `data.table` siempre ha establecido `stringsAsFactors=FALSE` por defecto. En R 4.0.0 (abril de 2020), el valor predeterminado de `data.frame` se cambió de `TRUE` a `FALSE` y ya no existe diferencia en este aspecto. - Los vectores atómicos en las columnas `list` se contraen cuando se imprimen usando `", "` en `data.frame`, pero `","` en data.table con una coma final después del sexto elemento para evitar la impresión accidental de objetos incrustados grandes.
 - A diferencia de data.frames, un data.table no puede almacenar filas sin columnas, ya que las filas se consideran hijas de las columnas: `nrow(DF[, 0])` devuelve el número de filas, mientras que `nrow(DT[, 0])` siempre devuelve 0; pero vea el problema [#2422](https://github.com/Rdatatable/data.table/issues/2422).

En `[.data.frame`, solemos configurar `drop = FALSE`. Si nos olvidamos, pueden surgir errores en casos extremos donde se seleccionan columnas individuales y, de repente, se devuelve un vector en lugar de una sola columna `data.frame`. En `[.data.table`, aprovechamos la oportunidad para hacerlo consistente y eliminamos `drop`.

Cuando se pasa un data.table a un paquete que no lo tiene en cuenta, ese paquete no se preocupa por ninguna de estas diferencias; simplemente funciona.

## Estoy usando `j` solo por su efecto secundario, pero sigo obteniendo datos. ¿Cómo puedo detenerlo?

En este caso, `j` se puede envolver con `invisible()`; por ejemplo, `DT[ , invisible(hist(colB)), by = colA]`[^3]

[^3]: *por ejemplo*, `hist()` devuelve los puntos de interrupción además de trazar en el dispositivo gráfico.

## ¿Por qué `[.data.table` ahora tiene un argumento `drop` desde v1.5?

Para que data.table pueda heredar de `data.frame` sin usar `...`. Si usáramos `...`, no se detectarían los nombres de argumentos no válidos.

El argumento `drop` nunca se utiliza en `[.data.table`. Es un marcador de posición para paquetes que no son compatibles con data.table cuando usan la sintaxis `[.data.frame` directamente en un data.table.

## ¡Las uniones continuas son geniales y rapidísimas! ¿Fue difícil programarlas?

La fila que prevalece en o antes de la fila `i` es la última fila que la búsqueda binaria prueba. Por lo tanto, `roll = TRUE` es básicamente un cambio en el código C de búsqueda binaria para devolver esa fila.

## ¿Por qué `DT[i, col := value]` devuelve `DT` completo? Esperaba que no hubiera ningún valor visible (consistente con `<-`), o un mensaje o valor de retorno que indicara cuántas filas se actualizaron. No es evidente que los datos se hayan actualizado por referencia.

Esto ha cambiado en la v1.8.3 para cumplir con sus expectativas. Actualice.

Se devuelve la totalidad de `DT` (ahora de forma invisible) para que la sintaxis compuesta funcione; p. ej., `DT[i, done := TRUE][ , sum(done)]`. El número de filas actualizadas se devuelve cuando `verbose` es `TRUE`, ya sea por consulta o globalmente mediante `options(datatable.verbose = TRUE)`.

## Bien, gracias. ¿Qué tenía de difícil que el resultado de `DT[i, col := valor]` se devolviera de forma invisible?

R activa internamente la visibilidad para `[`. El valor de la columna eval de FunTab (ver [src/main/names.c](https://github.com/wch/r-source/blob/trunk/src/main/names.c)) para `[` es `0`, lo que significa que se activa `R_Visible` (ver [R-Internals sección 1.6](https://cran.r-project.org/doc/manuals/r-release/R-ints.html#Autoprinting)). Por lo tanto, al intentar `invisible()` o configurar `R_Visible` a `0` directamente, `eval` en [src/main/eval.c](https://github.com/wch/r-source/blob/trunk/src/main/eval.c) lo activaba de nuevo.

Para solucionar este problema, la clave fue dejar de intentar detener la ejecución del método de impresión después de un `:=`. En su lugar, dentro de `:=` ahora (a partir de la v1.8.3) configuramos un indicador global que el método de impresión usa para determinar si imprimir o no.

## ¿Por qué a veces tengo que escribir 'DT' dos veces después de usar ':=' para imprimir el resultado en la consola?

Esta es una desventaja desafortunada para que [#869](https://github.com/Rdatatable/data.table/issues/869) funcione. Si se usa un `:=` dentro de una función sin `DT[]` antes del final de la función, la próxima vez que se escriba `DT` en el prompt, no se imprimirá nada. Un `DT` repetido se imprimirá. Para evitar esto: incluya un `DT[]` después del último `:=` en su función. Si eso no es posible (por ejemplo, no es una función que pueda cambiar), se garantiza que `print(DT)` y `DT[]` en el prompt se imprimirán. Como antes, agregar un `[]` adicional al final de la consulta `:=` es un modismo recomendado para actualizar y luego imprimir; por ejemplo, `DT[,foo:=3L][]`.

## He observado que `base::cbind.data.frame` (y `base::rbind.data.frame`) parecen ser modificados por data.table. ¿Cómo es posible? ¿Por qué?

Era una solución temporal de último recurso antes de que se corrigiera la resolución de métodos S3 de rbind y cbind en R >= 4.0.0. En esencia, el problema residía en que `data.table` hereda de `data.frame`, *y* `base::cbind` y `base::rbind` (de forma única) realizan su propia resolución S3 internamente, como se documenta en `?cbind`. La solución alternativa para `data.table` consistía en añadir un bucle `for` al inicio de cada función directamente en `base`. Esta modificación se realizaba dinámicamente; es decir, se obtuvo la definición `base` de `cbind.data.frame`, se añadía el bucle `for` al inicio y luego se volvía a asignar a `base`. Esta solución se diseñó para ser robusta ante varias definiciones de `base::cbind.data.frame` en diferentes versiones de R, incluyendo cambios futuros desconocidos. Funcionó correctamente. Los requisitos en conflicto eran:

 - `cbind(DT, DF)` debe funcionar. La definición de `cbind.data.table` no funcionaba porque `base::cbind` realizaba su propia resolución S3 y requería (antes de R 4.0.0) que el *primer* método `cbind` para cada objeto que se le pasa fuera *idéntico*. Esto no se cumple en `cbind(DT, DF)`, ya que el primer método para `DT` es `cbind.data.table`, pero el primer método para `DF` es `cbind.data.frame`. `base::cbind` entonces fallaba en su código interno `bind`, que parece tratar `DT` como una `lista` normal y devuelve una salida `matrix` de aspecto extraño e inutilizable. Véase [a continuación](#cbinderror). No podemos simplemente aconsejar a los usuarios que no llamen a `cbind(DT, DF)` porque paquetes como `ggplot2` hacen dicha llamada ([prueba 167.2](https://github.com/Rdatatable/data.table/blob/master/inst/tests/tests.Rraw#L444-L447)).

 - Esto, naturalmente, llevó a intentar enmascarar `cbind.data.frame`. Dado que un data.table es un `data.frame`, `cbind` encontraría el mismo método para `DT` y `DF`. Sin embargo, esto tampoco funcionó porque `base::cbind` parece encontrar primero los métodos en `base`; *es decir*, `base::cbind.data.frame` no es enmascarable.

 - Finalmente, intentamos enmascarar `cbind` (v1.6.5 y v1.6.6). Esto permitió que `cbind(DT, DF)` funcionara, pero introdujo problemas de compatibilidad con el paquete `IRanges`, ya que `IRanges` también enmascara `cbind`. Funcionaba si `IRanges` estaba en una posición inferior a data.table en la ruta `search()`, pero si `IRanges` estaba en una posición superior a data.table, `cbind` nunca se llamaría y la salida de `matrix`, de aspecto extraño, volvía a aparecer (ver [abajo](#cbinderror)).

Muchas gracias al equipo central de R por solucionar el problema en septiembre de 2019. data.table v1.12.6+ ya no aplica la solución alternativa en R >= 4.0.0.

## He leído sobre la resolución de métodos (p. ej., "merge" puede o no derivar a "merge.data.table"), pero ¿cómo sabe R cómo derivar? ¿Son los puntos significativos o especiales? ¿Cómo sabe R a qué función resolver y cuándo? {#r-dispatch}

Esto se menciona con frecuencia, pero es increíblemente simple. Una función como `merge` es *genérica* si consiste en una llamada a `UseMethod`. Cuando se habla de si las funciones son o no *genéricas*, simplemente se escribe la función sin `()` después, se revisa el código del programa que contiene y si ven una llamada a `UseMethod`, entonces es *genérica*. ¿Qué hace `UseMethod`? Literalmente, combina el nombre de la función con la clase del primer argumento, separados por un punto (`.`) y luego llama a esa función, pasando los mismos argumentos. Así de simple. Por ejemplo, `merge(X, Y)` contiene una llamada a `UseMethod`, lo que significa que luego *despacha* (es decir, llama) a `paste("merge", class(X), sep = ".")`. Las funciones con puntos en su nombre pueden ser métodos o no. El punto es irrelevante, salvo que sea el separador que usa `UseMethod`. Conocer estos antecedentes debería ayudar a comprender por qué, por ejemplo, es obvio para los usuarios de R que `as.data.table.data.frame` es el método `data.frame` de la función genérica `as.data.table`. Además, puede ser útil aclarar que, sí, tienes razón, su nombre no indica que `ls.fit` no sea el método de ajuste de la función genérica `ls`. Solo se sabe escribiendo `ls` (no `ls()`) y observando que no se trata de una sola llamada a `UseMethod`.

Quizás te preguntes: ¿dónde está documentado esto en R? Respuesta: Está bastante claro, pero primero debe saber que debe buscar en `?UseMethod` y *ese* archivo de ayuda contiene:

> Cuando se aplica una función que llama a `UseMethod('fun')` a un objeto con el atributo de clase `c('first', 'second')`, el sistema busca una función llamada `fun.first` y, si la encuentra, la aplica al objeto. Si no se encuentra dicha función, se prueba con una función llamada `fun.second`. Si ningún nombre de clase produce una función adecuada, se utiliza la función `fun.default`, si existe, o se produce un error.

Afortunadamente, una búsqueda en internet de "How does R method dispatch work" (N. de T.:"¿Cómo funciona el despacho de métodos en R?"), al momento de escribir esto muestra la página de ayuda "UseMethod" entre los primeros enlaces. Es cierto que otros enlaces profundizan rápidamente en las complejidades de S3 vs. S4, genéricos internos, etc.

Sin embargo, características como el despacho básico de S3 (pegar el nombre de la función junto con el de la clase) son la razón por la que a algunos usuarios de R les encanta. Es muy simple. No se requieren registros ni firmas complejas. No hay mucho que aprender. Para crear el método `merge` para data.table, literalmente, solo se necesitó crear una función llamada `merge.data.table`.

## ¿Por qué `T` y `F` se comportan de manera diferente a `TRUE` y `FALSE` en algunas consultas `data.table`?

Usar `T` y `F` como abreviaturas de `TRUE` y `FALSE` en `data.table` puede provocar un comportamiento inesperado. Esto se debe a que `T` y `F` son variables globales redefinibles, lo que hace que se traten como nombres de variable en lugar de constantes lógicas. Este problema no ocurre con `TRUE` y `FALSE`. Se recomienda evitar `T` y `F` para usar R en general, pero se presenta en `data.table` de maneras sorprendentes, por ejemplo:

```r
DT <- data.table(x=rep(c("a", "b", "c"), each = 3), y=c(1, 3, 6), v=1:9)

# Using TRUE/FALSE works as expected in cases like the ones below:

DT[, .SD, .SDcols=c(TRUE, TRUE, FALSE)]
# A) This selects the first two columns (x and y) and excludes the third one (v). Output:
#>    x y
#> 1: a 1
#> 2: a 3
#> 3: a 6
#> 4: b 1
#> 5: b 3
#> 6: b 6
#> 7: c 1
#> 8: c 3
#> 9: c 6

DT[, .SD, .SDcols=c(T, T, F), with=FALSE]
# B) This forces data.table to treat T/F as logical constants.
# Same output as DT[, .SD, .SDcols=c(TRUE, TRUE, FALSE)]

# But, using T/F may lead to unexpected behavior in cases like:

DT[, .SD, .SDcols=c(T, T, F)]
# data.table treats T and F as variable names here, not logical constants. Output:
#> Detected that j uses these columns: <none>
#> [1]  TRUE  TRUE FALSE
```

Como consejo general, `lintr::T_and_F_symbol_linter()` detecta el uso de `T` y `F` y sugiere reemplazarlos con `TRUE` y `FALSE` para evitar tales problemas.

# Preguntas relacionadas con el tiempo de cómputo

## Tengo 20 columnas y muchas filas. ¿Por qué una expresión de una sola columna es tan rápida?

Varias razones:

 - Solo se agrupa esa columna; las otras 19 se ignoran porque data.table inspecciona la expresión `j` y detecta que no utiliza las demás columnas.
 - Se realiza una asignación de memoria solo para el grupo más grande, y luego esa memoria se reutiliza para los demás grupos. Hay muy poca basura que recolectar.
 - R es un almacén de columnas en memoria; es decir, las columnas son contiguas en la RAM. Se minimiza la recuperación de páginas de la RAM a la caché L2.

## No tengo una clave en una tabla grande, pero aun así la agrupación es muy rápida. ¿Por qué?

data.table utiliza ordenamiento *radix*. Esto es significativamente más rápido que otros algoritmos de ordenamiento. Para más información, consulte [nuestras presentaciones](https://github.com/Rdatatable/data.table/wiki/Presentations), en particular las de useR!2015 Dinamarca.

Esta es también una razón por la que `setkey()` es rápido.

Cuando no se establece ninguna `clave`, o agrupamos en un orden diferente al de la clave, lo llamamos un `por` *ad hoc*.

## ¿Por qué la agrupación por columnas en la clave es más rápida que un `por` *ad hoc*?

Debido a que cada grupo es contiguo en RAM, se minimizan las búsquedas de páginas y la memoria se puede copiar en masa (`memcpy` en C) en lugar de realizar un bucle en C.

## ¿Qué son los índices primarios y secundarios en data.table?

Manual: [`?setkey`](https://www.rdocumentation.org/packages/data.table/functions/setkey) SO: [¿Cuál es el propósito de establecer una clave en data.table?](https://stackoverflow.com/questions/20039335/what-is-the-purpose-of-setting-a-key-in-data-table/20057411#20057411)

`setkey(DT, col1, col2)` ordena las filas por la columna `col1` y, dentro de cada grupo de `col1`, las ordena por `col2`. Este es un *índice primario*. El orden de las filas se modifica *por referencia* en la RAM. Las uniones y agrupaciones posteriores en esas columnas clave aprovechan el orden de ordenación para mayor eficiencia. (Imagine lo difícil que sería buscar un número de teléfono en una guía telefónica impresa si no estuviera ordenado por apellido y nombre. Eso es literalmente todo lo que hace `setkey`: ordena las filas por las columnas que especifique). El índice no utiliza RAM. Simplemente modifica el orden de las filas en la RAM y marca las columnas clave. Análogo a un *índice agrupado* en SQL.

Sin embargo, solo puede tener una clave principal porque los datos solo se pueden ordenar físicamente en RAM de una manera a la vez. Elija el índice principal para que sea el que use con más frecuencia (por ejemplo, `[id,date]`). A veces no hay una elección obvia para la clave principal o necesita unir y agrupar muchas columnas diferentes en diferentes órdenes. Ingrese un índice secundario. Esto usa memoria (`4*nrow` bytes independientemente del número de columnas en el índice) para almacenar el orden de las filas por las columnas que especifique, pero en realidad no reordena las filas en RAM. Las uniones y grupos posteriores aprovechan el orden de la clave secundaria, pero necesitan *saltar* a través de ese índice, por lo que no son tan eficientes como los índices primarios. Pero aún así, mucho más rápido que un escaneo vectorial completo. No hay límite para el número de índices secundarios, ya que cada uno es solo un vector de ordenación diferente. Normalmente no necesita crear índices secundarios. Se crean automáticamente y se usan automáticamente para usted usando data.table normalmente; *p. ej.* `DT[someCol == someVal, ]` y `DT[someCol %in% someVals, ]` crearán, adjuntarán y usarán el índice secundario. Esto es más rápido en data.table que un escaneo vectorial, por lo que la indexación automática está activada por defecto, ya que no hay penalización inicial. Existe una opción para desactivar la indexación automática; *p. ej.*, si se crean muchos índices e incluso la relativamente pequeña cantidad de memoria adicional resulta excesiva.

Usamos las palabras *índice* y *clave* indistintamente.

# Mensajes de error

## "No se pudo encontrar la función `DT`"

Ver arriba [aquí](#DTremove1) y [aquí](#DTremove2).

## "argumentos no utilizados (`MySum = sum(v)`)"

Este error es generado por `DT[ , MySum = sum(v)]`. Se pretendía `DT[ , .(MySum = sum(v))]`, o `DT[ , j = .(MySum = sum(v))]`.

## "`translateCharUTF8` debe llamarse en un `CHARSXP`"

Este error (y otros similares, por ejemplo, "`getCharCE` debe llamarse en un `CHARSXP`") podría no tener nada que ver con los datos de caracteres ni con la configuración regional. En realidad, podría ser un síntoma de una corrupción de memoria previa. Hasta la fecha, estos errores se han podido reproducir y se han solucionado rápidamente. Por favor, repórtelo a nuestro [rastreador de problemas](https://github.com/Rdatatable/data.table/issues).

## `cbind(DT, DF)` devuelve un formato extraño, *por ejemplo* `Integer,5` {#cbinderror}

Esto también ocurre antes de la v1.6.5, con `rbind(DT, DF)`. Actualice a la v1.6.7 o posterior.

## "no se puede cambiar el valor del enlace bloqueado para `.SD`"

`.SD` está bloqueado por diseño. Consulte `?data.table`. Si desea manipular `.SD` antes de usarlo o devolverlo, y no desea modificar `DT` con `:=`, primero haga una copia (consulte `?copy`), por ejemplo:

```{r}
DT = data.table(a = rep(1:3, 1:3), b = 1:6, c = 7:12)
DT
DT[ , { mySD = copy(.SD)
      mySD[1, b := 99L]
      mySD},
    by = a]
```

## "no se puede cambiar el valor del enlace bloqueado para `.N`"

Actualice a la versión 1.8.1 o posterior. A partir de esta versión, si `.N` se devuelve mediante `j`, se renombra como `N` para evitar ambigüedades en cualquier agrupación posterior entre la variable especial `.N` y una columna llamada `".N"`.

El comportamiento anterior se puede reproducir forzando a que `.N` se llame `.N`, de la siguiente manera:

```{r}
DT = data.table(a = c(1,1,2,2,2), b = c(1,2,2,2,1))
DT
DT[ , list(.N = .N), list(a, b)]   # show intermediate result for exposition
cat(try(
    DT[ , list(.N = .N), by = list(a, b)][ , unique(.N), by = a]   # compound query more typical
, silent = TRUE))
```

Si ya está ejecutando v1.8.1 o posterior, entonces el mensaje de error ahora es más útil que el error "no se puede cambiar el valor del enlace bloqueado", como puede ver arriba, ya que esta viñeta se produjo usando v1.8.1 o posterior.

Ahora funciona la sintaxis más natural:

```{r}
if (packageVersion("data.table") >= "1.8.1") {
    DT[ , .N, by = list(a, b)][ , unique(N), by = a]
  }
if (packageVersion("data.table") >= "1.9.3") {
    DT[ , .N, by = .(a, b)][ , unique(N), by = a]   # same
}
```

# Mensajes de advertencia

## "Los siguientes objetos están enmascarados de `paquete:base`: `cbind`, `rbind`"

Esta advertencia solo aparecía en las versiones 1.6.5 y 1.6.6 al cargar el paquete. El objetivo era permitir que `cbind(DT, DF)` funcionara, pero resultó que esto interrumpía la compatibilidad total con el paquete `IRanges`. Actualice a la versión 1.6.7 o posterior.

## "Se convirtió el RHS numérico a entero para que coincida con el tipo de la columna"

Espero que esto se explique por sí solo. El mensaje completo es:

Se ha convertido el RHS numérico a entero para que coincida con el tipo de la columna; puede tener precisión truncada. Cambie la columna a numérica primero creando un nuevo vector numérico de longitud 5 (n filas de toda la tabla) y asignándolo (es decir, "reemplazar columna"), o convierta el RHS a entero (por ejemplo, 1L o as.integer) para aclarar su intención (y para mayor rapidez). O bien, configure el tipo de columna correctamente desde el principio al crear la tabla y manténgalo.

Para generarlo, prueba:

```{r}
DT = data.table(a = 1:5, b = 1:5)
suppressWarnings(
DT[2, b := 6]         # works (slower) with warning
)
class(6)              # numeric not integer
DT[2, b := 7L]        # works (faster) without warning
class(7L)             # L makes it an integer
DT[ , b := rnorm(5)]  # 'replace' integer column with a numeric column
```

## Lectura de data.table desde un archivo RDS o RData

`*.RDS` y `*.RData` son tipos de archivo que permiten almacenar objetos R en memoria en disco de forma eficiente. Sin embargo, al almacenar `data.table` en un archivo binario, se pierde la sobreasignación de columnas (véase también `?truelength`). Esto no supone un gran problema: su `data.table` se copiará en memoria en la siguiente operación *por referencia* y generará una advertencia. Por lo tanto, se recomienda ejecutar `setDT()` en cada `data.table` cargado con `readRDS()` o `load()` para restaurar sus atributos internos. Si solo necesita preasignar espacio para nuevas columnas, también puede usar `setalloccol()`.

Para obtener más detalles, consulte `?setDT` y `?truelength`.

# Preguntas generales sobre el paquete

## ¿Parece que la versión v1.3 falta en el archivo CRAN?

Así es. La versión 1.3 solo estaba disponible en R-Forge. Se implementaron varios cambios importantes internamente, y las pruebas en desarrollo llevaron tiempo.

## ¿Es data.table compatible con S-plus?

No actualmente.

 - Algunas partes principales del paquete están escritas en C y utilizan funciones y estructuras internas de R.
 - El paquete utiliza alcance léxico, que es una de las diferencias entre R y **S-plus** explicadas en [R FAQ 3.3.1](https://cran.r-project.org/doc/FAQ/R-FAQ.html#Lexical-scoping)

## ¿Está disponible para Linux, Mac y Windows?

Sí, tanto para 32 bits como para 64 bits en todas las plataformas. Gracias a CRAN. No se utilizan bibliotecas especiales ni específicas del sistema operativo.

## Me parece genial. ¿Qué puedo hacer?

Envíe sugerencias, informes de errores y solicitudes de mejora a nuestro [seguimiento de problemas](https://github.com/Rdatatable/data.table/issues). Esto contribuye a mejorar el paquete.

Por favor, marque el paquete con una estrella en [GitHub](https://github.com/Rdatatable/data.table). Esto anima a los desarrolladores y ayuda a otros usuarios de R a encontrarlo.

Puede enviar solicitudes de extracción para cambiar el código y/o la documentación usted mismo; consulte nuestras [Pautas de contribución](https://github.com/Rdatatable/data.table/blob/master/.github/CONTRIBUTING.md).

## No me parece bien. ¿Cómo puedo advertir a los demás sobre mi experiencia?

Añadimos todos los artículos que conocemos (ya sean positivos o negativos) a la página [Artículos](https://github.com/Rdatatable/data.table/wiki/Articles). Todas las páginas de la wiki del proyecto en GitHub son de acceso abierto sin restricciones de modificación. Siéntase libre de escribir un artículo, enlazar a uno negativo que haya encontrado o añadir una nueva página a nuestra wiki para recopilar sus críticas. Por favor, que sea constructivo para que podamos mejorar.

## Tengo una pregunta. Sé que la guía de publicación de r-help me indica que contacte al responsable (no a r-help), pero ¿hay algún grupo más amplio a quien pueda preguntar?

Consulte la [guía de soporte](https://github.com/Rdatatable/data.table/wiki/Support) en la página de inicio del proyecto, que contiene enlaces actualizados.

## ¿Dónde están los archivos de ayuda de datatable?

La [página de inicio](https://github.com/Rdatatable/data.table/wiki) contiene enlaces a los archivos en varios formatos.

## Preferiría no publicar en la página de Problemas, ¿puedo enviar un correo electrónico privado a una o dos personas?

Claro. Sin embargo, es más probable que obtenga una respuesta más rápida en la página de Problemas o en Stack Overflow. Además, preguntar públicamente en esos lugares ayuda a ampliar la base de conocimientos general.

## He creado un paquete que usa data.table. ¿Cómo puedo asegurarme de que mi paquete sea compatible con data.table para que la herencia de `data.frame` funcione?

Consulte [esta respuesta](https://stackoverflow.com/a/10529888/403310).

```{r, echo=FALSE}
setDTthreads(.old.th)
```
