---
title: "Índices secundarios y auto indexación"
date: "`{r} Sys.Date()`"
output:
  litedown::html_format
vignette: >
  %\VignetteIndexEntry{Secondary indices and auto indexing}
  %\VignetteEngine{litedown::vignette}
  \usepackage[utf8]{inputenc}
---

```{r, echo=FALSE, file='../_translation_links.R'}
```

`{r} .write.translation.links("Las traducciones de este documento están disponibles en: %s")`

```{r, echo = FALSE, message = FALSE}
library(data.table)
litedown::reactor(comment = "# ")
.old.th = setDTthreads(1)
```

Esta viñeta asume que el lector está familiarizado con la sintaxis `[i, j, by]` de data.table y cómo crear subconjuntos rápidos basados ​​en claves. Si no está familiarizado con estos conceptos, lea primero las siguientes viñetas:

- [`viñeta("datatable-intro", paquete="data.table")`](datatable-intro.html) 
- [`viñeta("datatable-reference-semantics", paquete="data.table")`](datatable-reference-semantics.html)
- [`viñeta("datatable-keys-fast-subset", paquete="data.table")`](datatable-keys-fast-subset.html)

***

## Datos {#data}

Utilizaremos los mismos datos de `flights` que en la viñeta [`vignette("datatable-intro", package="data.table")`](datatable-intro.html).

```{r, echo = FALSE}
options(width = 100L)
```

```{r}
flights <- fread("../flights14.csv")
head(flights)
dim(flights)
```

## Introducción

En esta viñeta, vamos a:

* analizar los *índices secundarios* y justificar por qué los necesitamos citando casos en los que configurar claves no es necesariamente ideal,

* realizar filtros rápidos, una vez más, pero usando el nuevo argumento `on`, que calcula índices secundarios internamente para la tarea (temporalmente) y reutiliza si ya existe uno,

* y finalmente veremos la *indexación automática* que va un paso más allá y crea índices secundarios automáticamente, pero lo hace en sintaxis nativa de R para filtrar.

## 1. Índices secundarios

### a) ¿Qué son los índices secundarios?

Los índices secundarios son similares a las "claves" en *data.table*, excepto por dos diferencias importantes:

* No reordena físicamente toda la tabla data.table en RAM. En su lugar, solo calcula el orden del conjunto de columnas proporcionado y almacena ese vector de orden en un atributo adicional llamado `index`.

* Puede haber más de un índice secundario para una tabla de datos (como veremos a continuación).

#### Subconjuntos con clave vs. subconjuntos indexados

Si bien tanto las **claves** como los **índices** permiten la subdivisión rápida de búsquedas binarias, difieren significativamente en su uso:

**filtrado mediante clave** (coincidencia de columnas implícita)

```{r keyed_operations}
DT = data.table(a = c(TRUE, FALSE), b = 1:2)
setkey(DT, a)                # Set key, reordering DT
DT[.(TRUE)]                  # 'on' is optional; if omitted, the key is used
```

**Filtrado mediante índice** (especificación de columna explícita)

```{r unkeyed_operations}
DT = data.table(a = c(TRUE, FALSE), b = 1:2)
setindex(DT, a)              # Set index only (no reorder)
DT[.(TRUE), on = "a"]        # 'on' is required
```

### b) Establecer y obtener índices secundarios

#### -- ¿Cómo podemos establecer la columna `origin` como un índice secundario en la *tabla de datos* `vuelos`?

```{r}
setindex(flights, origin)
head(flights)

## alternatively we can provide character vectors to the function 'setindexv()'
# setindexv(flights, "origin") # useful to program with

# 'index' attribute added
names(attributes(flights))
```

* `setindex` y `setindexv()` permiten agregar un índice secundario a la tabla de datos.

* Tenga en cuenta que `flights` **no** se reordena físicamente en orden creciente de `origen`, como habría sido el caso con `setkey()`.

* Tenga en cuenta también que se ha añadido el atributo `index` a `flights`.

* `setindex(flights, NULL)` eliminaría todos los índices secundarios.

#### -- ¿Cómo podemos obtener todos los índices secundarios establecidos hasta ahora en `vuelos`?

```{r}
indices(flights)

setindex(flights, origin, dest)
indices(flights)
```

* La función `indices()` devuelve todos los índices secundarios actuales en la tabla data.table. Si no existe ninguno, se devuelve `NULL`.

* Nótese que al crear otro índice en las columnas `origin, dest`, no perdemos el primer índice creado en la columna `origin`, es decir, podemos tener múltiples índices secundarios.

### c) ¿Por qué necesitamos índices secundarios?

#### -- Reordenar una tabla de datos puede ser costoso y no siempre ideal.

Considere el caso en el que desea realizar un subconjunto rápido basado en clave en la columna `origen` para el valor "JFK". Lo haríamos así:

```r
## not run
setkey(flights, origin)
flights["JFK"] # or flights[.("JFK")]
```

#### `setkey()` requiere:

a) calcular el vector de orden para la(s) columna(s) proporcionada(s), aquí, `origen`, y

b) reordenar toda la tabla de datos, por referencia, en función del vector de orden calculado.

# 

Calcular el orden no es la parte más laboriosa, ya que data.table utiliza un ordenamiento por radix real en vectores enteros, de caracteres y numéricos. Sin embargo, reordenar data.table podría requerir mucho tiempo (dependiendo del número de filas y columnas).

A menos que nuestra tarea implique la subconfiguración repetida de la misma columna, la subconfiguración rápida basada en clave podría anularse efectivamente al momento de reordenar, dependiendo de las dimensiones de nuestra tabla de datos.

#### -- Solo puede haber una `clave` como máximo

Ahora, si quisiéramos repetir la misma operación pero en la columna `dest`, para el valor "LAX", entonces tenemos que usar `setkey()`, *nuevamente*.

```r
## not run
setkey(flights, dest)
flights["LAX"]
```

Y esto reordena `flights` por `dest`, *de ​​nuevo*. Lo que realmente nos gustaría es poder realizar el filtrado rápido eliminando el paso de reordenación.

¡Y esto es precisamente lo que permiten los *índices secundarios*!

#### -- Los índices secundarios se pueden reutilizar

Dado que puede haber múltiples índices secundarios, y crear un índice es tan simple como almacenar el vector de orden como un atributo, esto nos permite incluso eliminar el tiempo para volver a calcular el vector de orden si ya existe un índice.

#### -- El nuevo argumento `on` permite una sintaxis más limpia y la creación y reutilización automática de índices secundarios.

Como veremos en la siguiente sección, el argumento `on` proporciona varias ventajas:

#### argumento `on`

* Permite la creación de subconjuntos calculando índices secundarios sobre la marcha. Esto elimina la necesidad de ejecutar `setindex()` cada vez.

* permite la reutilización sencilla de índices existentes simplemente verificando los atributos.

=====* permite una sintaxis más clara al incluir las columnas en las que se ejecuta el subconjunto como parte de la sintaxis. Esto facilita la lectura del código al revisarlo posteriormente.

    Note that `on` argument can also be used on keyed subsets as well. In fact, we encourage providing the `on` argument even when subsetting using keys for better readability.

# 

## 2. Subconjunto rápido utilizando el argumento `on` e índices secundarios

### a) Subconjuntos rápidos en `i`

#### -- Subconjunto de todas las filas donde el aeropuerto de origen coincide con *"JFK"* usando `on`

```{r}
flights["JFK", on = "origin"]

## alternatively
# flights[.("JFK"), on = "origin"] (or)
# flights[list("JFK"), on = "origin"]
```

=====* Esta instrucción también realiza una búsqueda binaria rápida basada en subconjuntos, calculando el índice sobre la marcha. Sin embargo, tenga en cuenta que no guarda el índice como atributo automáticamente. Esto podría cambiar en el futuro.

* Si ya hubiéramos creado un índice secundario con `setindex()`, `on` lo reutilizaría en lugar de recalcularlo. Podemos comprobarlo con `verbose = TRUE`:

    ```{r}
    setindex(flights, origin)
    flights["JFK", on = "origin", verbose = TRUE][1:5]
    ```

#### -- ¿Cómo puedo filtrar en función de las columnas `origin` *y* `dest`?

Por ejemplo, si queremos filtrar la combinación `"JFK", "LAX"`, entonces:

```{r}
flights[.("JFK", "LAX"), on = c("origin", "dest")][1:5]
```

* El argumento `on` acepta un vector de caracteres de nombres de columnas correspondientes al orden proporcionado a `i-argument`.

* Dado que el tiempo para calcular el índice secundario es bastante pequeño, no tenemos que usar `setindex()`, a menos que, una vez más, la tarea implique filtros repetidos en la misma columna.

* Para mayor claridad y legibilidad, podría ser útil nombrar las entradas en `i`, por ejemplo,

```{r}
flights[.(origin = "JFK", dest = "LAX"), on = c("origin", "dest")]
```

Esto deja claro qué entradas en `j` corresponden a qué elemento de `on`.

### b) Seleccionar en `j`

Todas las operaciones que analizaremos a continuación son idénticas a las que ya vimos en la viñeta [`vignette("datatable-keys-fast-subset", package="data.table")`](datatable-keys-fast-subset.html). Excepto que usaremos el argumento `on` en lugar de establecer las claves.

#### -- Devuelve la columna `arr_delay` sola como una tabla de datos correspondiente a `origin = "LGA"` y `dest = "TPA"`

```{r}
flights[.("LGA", "TPA"), .(arr_delay), on = c("origin", "dest")]
```

### c) Encadenamiento

#### -- Sobre el resultado obtenido anteriormente, utilice el encadenamiento para ordenar la columna en orden decreciente.

```{r}
flights[.("LGA", "TPA"), .(arr_delay), on = c("origin", "dest")][order(-arr_delay)]
```

### d) Calcular o *hacer* en `j`

#### -- Encuentra el retraso máximo de llegada correspondiente a `origin = "LGA"` y `dest = "TPA"`.

```{r}
flights[.("LGA", "TPA"), max(arr_delay), on = c("origin", "dest")]
```

### e) *sub-asignar* por referencia usando `:=` en `j`

Ya hemos visto este ejemplo en las viñetas [`vignette("datatable-reference-semantics", package="data.table")`](datatable-reference-semantics.html) y [`vignette("datatable-keys-fast-subset", package="data.table")`](datatable-keys-fast-subset.html). Veamos todas las horas disponibles en la tabla de datos `flights`:

```{r}
# get all 'hours' in flights
flights[, sort(unique(hour))]
```

Observamos que hay un total de 25 valores únicos en los datos. Parece que hay tanto *0* como *24* horas. Reemplacemos *24* por *0*, pero esta vez usando `on` en lugar de las claves de configuración.

```{r}
flights[.(24L), hour := 0L, on = "hour"]
```

Ahora, verifiquemos si `24` se reemplaza con `0` en la columna `hora`.

```{r}
flights[, sort(unique(hour))]
```

=====* Esta es una gran ventaja de los índices secundarios. Anteriormente, para actualizar solo algunas filas de `hour`, teníamos que ejecutar `setkey()`, lo que inevitablemente reordenaba toda la tabla data.table. Con `on`, el orden se conserva y la operación es mucho más rápida. Al observar el código, la tarea que queríamos realizar también está bastante clara.

### f) Agregación utilizando `by`

#### Obtener el retraso máximo de salida para cada mes correspondiente a «origen = "JFK"». Ordenar el resultado por `month`.

```{r}
ans <- flights["JFK", max(dep_delay), keyby = month, on = "origin"]
head(ans)
```

* Tendríamos que haber establecido la `clave` nuevamente en `origin, dest`, si no hubiéramos usado `on` que construye internamente índices secundarios sobre la marcha.

### g) El argumento *mult*

Los demás argumentos, incluido `mult`, funcionan exactamente igual que en la viñeta [`vignette("datatable-keys-fast-subset", package="data.table")`](datatable-keys-fast-subset.html). El valor predeterminado para `mult` es "all". Podemos elegir; en su lugar, solo se devolverán las *primeras* (`mult = "first"`) o *últimas* (`mult = "last"`) filas coincidentes.

#### -- Subconjunto solo de la primera fila coincidente donde `dest` coincide con *"BOS"* y *"DAY"*

```{r}
flights[c("BOS", "DAY"), on = "dest", mult = "first"]
```

#### -- Filtrar solo la última fila coincidente donde `origin` coincide con *"LGA", "JFK", "EWR"* y `dest` coincide con *"XNA"*

```{r}
flights[.(c("LGA", "JFK", "EWR"), "XNA"), on = c("origin", "dest"), mult = "last"]
```

### h) El argumento *nomatch*

Podemos elegir si las consultas que no coinciden deben devolver "NA" o ignorarse por completo utilizando el argumento "nomatch".

#### -- Del ejemplo anterior, filtre todas las filas solo si hay una coincidencia

```{r}
flights[.(c("LGA", "JFK", "EWR"), "XNA"), mult = "last", on = c("origin", "dest"), nomatch = NULL]
```

* No hay vuelos que conecten "JFK" y "XNA". Por lo tanto, esa fila se omite en el resultado.

## 3. Indexación automática

Primero, vimos cómo crear subconjuntos rápidos mediante búsqueda binaria con *claves*. Luego, descubrimos que podíamos mejorar aún más el rendimiento y lograr una sintaxis más clara usando índices secundarios.

Eso es lo que hace la *autoindexación*. Actualmente, solo está implementada para los operadores binarios `==` y `%in%`. Se crea automáticamente un índice *y* se guarda como atributo. Es decir, a diferencia del argumento `on`, que calcula el índice sobre la marcha cada vez (a menos que ya exista uno), aquí se crea un índice secundario.

Comencemos creando una tabla de datos lo suficientemente grande para resaltar la ventaja.

```{r}
set.seed(1L)
dt = data.table(x = sample(1e5L, 1e7L, TRUE), y = runif(100L))
print(object.size(dt), units = "Mb")
```

Cuando usamos `==` o `%in%` en una sola columna por primera vez, se crea automáticamente un índice secundario y se utiliza para filtrar.

```{r}
## have a look at all the attribute names
names(attributes(dt))

## run thefirst time
(t1 <- system.time(ans <- dt[x == 989L]))
head(ans)

## secondary index is created
names(attributes(dt))

indices(dt)
```

El tiempo para crear el subconjunto la primera vez equivale al tiempo para crear el índice + el tiempo para crear el subconjunto. Dado que crear un índice secundario solo implica crear el vector de orden, esta operación combinada es más rápida que los escaneos vectoriales en muchos casos. Pero la verdadera ventaja reside en los filtrados sucesivos, ya que son extremadamente rápidos.

```{r}
## successive subsets
(t2 <- system.time(dt[x == 989L]))
system.time(dt[x %in% 1989:2012])
```

* La primera ejecución tardó `r sprintf("%.3f", t1["elapsed"])` segundos, mientras que la segunda vez tardó `r sprintf("%.3f", t2["elapsed"])` segundos.

* La indexación automática se puede desactivar configurando el argumento global `options(datatable.auto.index = FALSE)`.

* Deshabilitar la indexación automática permite seguir usando índices creados explícitamente con `setindex` o `setindexv`. Puede deshabilitar los índices por completo configurando el argumento global `options(datatable.use.index = FALSE)`.

# 

En la versión reciente, ampliamos la indexación automática a expresiones que involucran más de una columna (combinadas con el operador `&`). En el futuro, planeamos ampliar la búsqueda binaria para que funcione con más operadores binarios como `<`, `<=`, `>` y `>=`.

Discutiremos *filtros* rápidos usando claves e índices secundarios para *uniones* (join) en la [siguiente viñeta (`vignette("datatable-joins", package="data.table")`)](datatable-joins.html).

***

```{r, echo=FALSE}
setDTthreads(.old.th)
```
