---
title: "Uso de .SD para Análisis de datos"
date: "`{r} Sys.Date()`"
output:
  litedown::html_format:
    options:
      toc: true
      number_sections: true
vignette: >
  %\VignetteIndexEntry{Using .SD for Data Analysis}
  %\VignetteEngine{litedown::vignette}
  \usepackage[utf8]{inputenc}
---

<style>
#TOC {
  border: 1px solid #ccc;
  border-radius: 5px;
  padding-left: 1em;
  background: #f6f6f6;
}
</style>

```{r, echo=FALSE, file='../_translation_links.R'}
```

`{r} .write.translation.links("Las traducciones de este documento están disponibles en: %s")`

```{r, echo = FALSE, message = FALSE}
library(data.table)
litedown::reactor(comment = "# ")
.old.th = setDTthreads(1)
```

Esta viñeta explica las formas más comunes de usar la variable `.SD` en los análisis de `data.table`. Es una adaptación de [esta respuesta](https://stackoverflow.com/a/47406952/3576984) de StackOverflow.

# ¿Qué es `.SD`?

En sentido amplio, `.SD` es simplemente una abreviatura para capturar una variable que aparece con frecuencia en el contexto del análisis de datos. Puede entenderse como *S*ubset, *S*elfsame o *S*elf-reference of the *D*ata. Es decir, `.SD` es, en su forma más básica, una *referencia reflexiva* a la propia `data.table`; como veremos en los ejemplos a continuación, esto es particularmente útil para encadenar "consultas" (extracciones/subconjuntos/etc. mediante `[`). En particular, esto también significa que `.SD` es *en sí mismo una `data.table`* (con la salvedad de que no permite la asignación con `:=`).

El uso más simple de `.SD` es para la subagrupación de columnas (es decir, cuando se especifica `.SDcols`); dado que esta versión es mucho más sencilla de entender, la abordaremos primero a continuación. La interpretación de `.SD` en su segundo uso, en escenarios de agrupación (es decir, cuando se especifica `by = ` o `keyby = `), es ligeramente diferente conceptualmente (aunque en esencia es la misma, ya que, después de todo, una operación no agrupada es un caso extremo de agrupación con un solo grupo).

## Carga y vista previa de datos de Lahman

Para darle una sensación más realista, en lugar de inventar datos, carguemos algunos conjuntos de datos sobre béisbol desde la [base de datos Lahman](https://github.com/cdalzell/Lahman). En el uso típico de R, simplemente cargaríamos estos conjuntos de datos desde el paquete R `Lahman`; en este ejemplo, los hemos descargado previamente directamente desde la página de GitHub del paquete.

```{r download_lahman}
load('../Teams.RData')
setDT(Teams)
Teams

load('../Pitching.RData')
setDT(Pitching)
Pitching
```

Los lectores familiarizados con la jerga del béisbol encontrarán el contenido de las tablas familiar: `Teams` registra las estadísticas de un equipo en un año determinado, mientras que `Pitching` registra las estadísticas de un lanzador en un año determinado. Por favor, consulte la documentación (https://github.com/cdalzell/Lahman) y explore los datos usted mismo antes de familiarizarse con su estructura.

# `.SD` en datos no agrupados

Para ilustrar lo que quiero decir sobre la naturaleza reflexiva de `.SD`, considere su uso más banal:

```{r plain_sd}
Pitching[ , .SD]
```

Es decir, `Pitching[ , .SD]` simplemente ha devuelto la tabla completa, en otras palabras, era una forma más extensa de escribir `Pitching` o `Pitching[]`:

```{r plain_sd_is_table}
identical(Pitching, Pitching[ , .SD])
```

En términos de subconjuntos, `.SD` sigue siendo un subconjunto de los datos, sólo que es trivial (el conjunto en sí).

## Subconjunto de columnas: `.SDcols`

La primera forma de influir en lo que es `.SD` es limitar las *columnas* contenidas en `.SD` usando el argumento `.SDcols` a `[`:

```{r simple_sdcols}
# W: Wins; L: Losses; G: Games
Pitching[ , .SD, .SDcols = c('W', 'L', 'G')]
```

Esto es solo para ilustrar y era bastante aburrido. Además de aceptar un vector de caracteres, `.SDcols` también acepta:

1. cualquier función como `is.character` para filtrar *columnas*
2. la función[^*] `patterns()` para filtrar *nombres de columnas* por expresión regular
3. vectores enteros y lógicos

[^*]: consulte `?patterns` para más detalles

Este uso simple se presta a una amplia variedad de operaciones de manipulación de datos altamente beneficiosas y omnipresentes:

## Conversión de tipo de columna

La conversión de tipos de columnas es una práctica habitual en la manipulación de datos. Aunque [`fwrite` ha adquirido recientemente la capacidad de declarar la clase de cada columna por adelantado](https://github.com/Rdatatable/data.table/pull/2545), no todos los conjuntos de datos provienen de `fread` (por ejemplo, en esta viñeta) y las conversiones entre tipos `carácter`/`factor`/`numérico` son comunes. Podemos usar `.SD` y `.SDcols` para convertir por lotes grupos de columnas a un tipo común.

Observamos que las siguientes columnas se almacenan como "carácter" en el conjunto de datos "Equipos", pero podrían almacenarse de manera más lógica como "factor":

```{r identify_factors}
# teamIDBR: Team ID used by Baseball Reference website
# teamIDlahman45: Team ID used in Lahman database version 4.5
# teamIDretro: Team ID used by Retrosheet
fkt = c('teamIDBR', 'teamIDlahman45', 'teamIDretro')
# confirm that they're stored as `character`
str(Teams[ , ..fkt])
```

La sintaxis para convertir ahora estas columnas a "factor" es simple:

```{r assign_factors}
Teams[ , names(.SD) := lapply(.SD, factor), .SDcols = patterns('teamID')]
# print out the first column to demonstrate success
head(unique(Teams[[fkt[1L]]]))
```

Nota:

1. El `:=` es un operador de asignación para actualizar `data.table` sin crear una copia. Consulte [`vignette("datatable-reference-semantics", package="data.table")`](datatable-reference-semantics.html) para obtener más información.
2. El operador izquierdo, `names(.SD)`, indica qué columnas estamos actualizando; en este caso, actualizamos todo el `.SD`.
3. El operador derecho, `lapply()`, recorre cada columna del `.SD` y la convierte en un factor.
4. Usamos `.SDcols` para seleccionar solo las columnas cuyo patrón sea `teamID`.

Nuevamente, el argumento `.SDcols` es bastante flexible; anteriormente, proporcionamos `patrones`, pero también podríamos haber proporcionado `fkt` o cualquier vector de `carácter` de nombres de columna. En otras situaciones, es más conveniente proporcionar un vector `entero` de *posiciones* de columna o un vector `lógico` que indique la inclusión/exclusión de cada columna. Finalmente, el uso de una función para filtrar columnas es muy útil.

Por ejemplo, podríamos hacer lo siguiente para convertir todas las columnas de tipo `factor` a `carácter`:

```{r sd_as_logical}
fct_idx = Teams[, which(sapply(.SD, is.factor))] # column numbers to show the class changing
str(Teams[[fct_idx[1L]]])
Teams[ , names(.SD) := lapply(.SD, as.character), .SDcols = is.factor]
str(Teams[[fct_idx[1L]]])
```

Por último, podemos hacer una selección por coincidencia de patrones en `.SDcols` para seleccionar todas las columnas que contienen `team` hasta `factor`:

```{r sd_patterns}
Teams[ , .SD, .SDcols = patterns('team')]
Teams[ , names(.SD) := lapply(.SD, factor), .SDcols = patterns('team')]
```

** Una salvedad a lo anterior: usar números de columna *explícitamente* (como `DT[ , (1) := rnorm(.N)]`) es una mala práctica y puede provocar la corrupción silenciosa del código con el tiempo si cambian las posiciones de las columnas. Incluso usar números implícitamente puede ser peligroso si no mantenemos un control estricto sobre el orden en que creamos y usamos el índice numerado.

## Controlar el lado derecho de un modelo

Variar la especificación del modelo es una característica fundamental del análisis estadístico robusto. Intentemos predecir la efectividad (Earned Runs Average, una medida de rendimiento) de un lanzador utilizando el pequeño conjunto de covariables disponibles en la tabla "Lanzamiento". ¿Cómo varía la relación (lineal) entre "W" (victorias) y "ERA" según las otras covariables incluidas en la especificación?

A continuación se muestra un breve script que aprovecha el poder de `.SD` y que explora esta pregunta:

```{r sd_for_lm, cache = FALSE, fig.cap="Fit OLS coefficient on W, various specifications, depicted as bars with distinct colors."}
# this generates a list of the 2^k possible extra variables
#   for models of the form ERA ~ G + (...)
extra_var = c('yearID', 'teamID', 'G', 'L')
models = unlist(
  lapply(0L:length(extra_var), combn, x = extra_var, simplify = FALSE),
  recursive = FALSE
)

# here are 16 visually distinct colors, taken from the list of 20 here:
#   https://sashat.me/2017/01/11/list-of-20-simple-distinct-colors/
col16 = c('#e6194b', '#3cb44b', '#ffe119', '#0082c8',
          '#f58231', '#911eb4', '#46f0f0', '#f032e6',
          '#d2f53c', '#fabebe', '#008080', '#e6beff',
          '#aa6e28', '#fffac8', '#800000', '#aaffc3')

par(oma = c(2, 0, 0, 0))
lm_coef = sapply(models, function(rhs) {
  # using ERA ~ . and data = .SD, then varying which
  #   columns are included in .SD allows us to perform this
  #   iteration over 16 models succinctly.
  #   coef(.)['W'] extracts the W coefficient from each model fit
  Pitching[ , coef(lm(ERA ~ ., data = .SD))['W'], .SDcols = c('W', rhs)]
})
barplot(lm_coef, names.arg = sapply(models, paste, collapse = '/'),
        main = 'Wins Coefficient\nWith Various Covariates',
        col = col16, las = 2L, cex.names = 0.8)
```

El coeficiente siempre tiene el signo esperado (los mejores lanzadores tienden a tener más victorias y menos carreras permitidas), pero la magnitud puede variar sustancialmente dependiendo de qué más controlemos.

## Uniones condicionales

La sintaxis de `data.table` es atractiva por su simplicidad y robustez. La sintaxis `x[i]` maneja con flexibilidad tres enfoques comunes para la creación de subconjuntos: cuando `i` es un vector `lógico`, `x[i]` devolverá las filas de `x` correspondientes a donde `i` es `VERDADERO`; cuando `i` es *otro `data.table`* (o una `lista`), se realiza una `join` (derecha) (en formato simple, usando las `key` de `x` e `i`; de lo contrario, cuando se especifica `on = `, usando las coincidencias de esas columnas); y cuando `i` es un carácter, se interpreta como una abreviatura de `x[list(i)]`, es decir, como una unión.

Esto es excelente en general, pero se queda corto cuando deseamos realizar una *unión condicional*, en donde la naturaleza exacta de la relación entre tablas depende de algunas características de las filas en una o más columnas.

Este ejemplo es ciertamente un poco artificial, pero ilustra la idea; consulte aquí ([1](https://stackoverflow.com/questions/31329939/conditional-keyed-join-update-and-update-a-flag-column-for-matches), [2](https://stackoverflow.com/questions/29658627/conditional-binary-join-and-update-by-reference-using-the-data-table-package)) para obtener más información.

El objetivo es agregar una columna `team_performance` a la tabla `Pitching` que registre el desempeño (ranking) del mejor lanzador de cada equipo (medido por la ERA más baja, entre los lanzadores con al menos 6 juegos registrados).

```{r conditional_join}
# to exclude pitchers with exceptional performance in a few games,
#   subset first; then define rank of pitchers within their team each year
#   (in general, we should put more care into the 'ties.method' of frank)
Pitching[G > 5, rank_in_team := frank(ERA), by = .(teamID, yearID)]
Pitching[rank_in_team == 1, team_performance :=
           Teams[.SD, Rank, on = c('teamID', 'yearID')]]
```

Tenga en cuenta que la sintaxis `x[y]` devuelve valores `nrow(y)` (es decir, es una unión derecha), por lo que `.SD` está a la derecha en `Teams[.SD]` (ya que el RHS de `:=` en este caso requiere valores `nrow(Pitching[rank_in_team == 1])`).

# Operaciones agrupadas `.SD`

A menudo, nos gustaría realizar alguna operación con nuestros datos *a nivel de grupo*. Cuando especificamos `by =` (o `keyby = `), el modelo mental de lo que sucede cuando `data.table` procesa `j` es pensar que `data.table` está dividido en varios sub`data.table` componentes, cada uno de los cuales corresponde a un único valor de la(s) variable(s) `by`:

![Agrupación, ilustrada](../plots/grouping_illustration.png)

<!-- 'A visual depiction of how grouping works. On the left is a grid. The first column is titled "ID COLUMN" with values the capital letters A through G, and the rest of the data is unlabelled, but is in a darker color and simply has "Data" written to indicate that's arbitrary. A right arrow shows how this data is split into groups. Each capital letter A through G has a grid on the right-hand side; the grid on the left has been subdivided to create that on the right.' -->

En el caso de la agrupación, `.SD` es de naturaleza múltiple: se refiere a *cada* una de estas sub-`data.table`s, *una a la vez* (para ser más precisos, el alcance de `.SD` es una sola sub-`data.table`). Esto nos permite expresar concisamente la operación que queremos realizar en *cada sub-`data.table`* antes de que se nos devuelva el resultado reensamblado.

Esto es útil en una variedad de configuraciones, las más comunes de las cuales se presentan aquí:

## Subconjunto de grupo

Obtengamos los datos de la temporada más reciente de cada equipo en los datos de Lahman. Esto se puede hacer de forma sencilla con:

```{r group_sd_last}
# the data is already sorted by year; if it weren't
#   we could do Teams[order(yearID), .SD[.N], by = teamID]
Teams[ , .SD[.N], by = teamID]
```

Recuerde que `.SD` es en sí mismo una `data.table`, y que `.N` se refiere al número total de filas en un grupo (es igual a `nrow(.SD)` dentro de cada grupo), por lo que `.SD[.N]` devuelve la *totalidad de `.SD`* para la fila final asociada con cada `teamID`.

Otra versión común de esto es utilizar `.SD[1L]` para obtener la *primera* observación para cada grupo, o `.SD[sample(.N, 1L)]` para devolver una fila *aleatoria* para cada grupo.

## Grupo Optima

Supongamos que quisiéramos devolver el *mejor* año de cada equipo, medido por su número total de carreras anotadas (`R`; podríamos ajustar esto fácilmente para referirnos a otras métricas, por supuesto). En lugar de tomar un elemento *fijo* de cada sub`data.table`, ahora definimos el índice deseado *dinámicamente* de la siguiente manera:

```{r sd_team_best_year}
Teams[ , .SD[which.max(R)], by = teamID]
```

Tenga en cuenta que este enfoque, por supuesto, se puede combinar con `.SDcols` para devolver solo partes de `data.table` para cada `.SD` (con la salvedad de que `.SDcols` debe fijarse en los distintos subconjuntos).

*NB*: `.SD[1L]` está actualmente optimizado por [*`GForce`*](https://Rdatatable.gitlab.io/data.table/library/data.table/html/datatable-optimize.html) ([ver también](https://stackoverflow.com/questions/22137591/about-gforce-in-data-table-1-9-2)), los elementos internos de `data.table` que aceleran enormemente las operaciones agrupadas más comunes como `sum` o `mean` - ver `?GForce` para más detalles y estar atento/voz de soporte para solicitudes de mejoras de características para actualizaciones en este frente: [1](https://github.com/Rdatatable/data.table/issues/735), [2](https://github.com/Rdatatable/data.table/issues/2778), [3](https://github.com/Rdatatable/data.table/issues/523), [4](https://github.com/Rdatatable/data.table/issues/971), [5](https://github.com/Rdatatable/data.table/issues/1197), [6](https://github.com/Rdatatable/data.table/issues/1414).

## Regresión agrupada

Volviendo a la pregunta anterior sobre la relación entre `ERA` y `W`, supongamos que esperamos que esta relación varíe según el equipo (es decir, que cada equipo tiene una pendiente diferente). Podemos volver a ejecutar fácilmente esta regresión para explorar la heterogeneidad de esta relación de la siguiente manera (teniendo en cuenta que los errores estándar de este enfoque suelen ser incorrectos; la especificación `ERA ~ W*teamID` será mejor; este enfoque es más fácil de leer y los *coeficientes* son correctos):

```{r group_lm, results = 'hide', fig.cap="A histogram depicting the distribution of fitted coefficients. It is vaguely bell-shaped and concentrated around -.2"}
# Overall coefficient for comparison
overall_coef = Pitching[ , coef(lm(ERA ~ W))['W']]
# use the .N > 20 filter to exclude teams with few observations
Pitching[ , if (.N > 20L) .(w_coef = coef(lm(ERA ~ W))['W']), by = teamID
          ][ , hist(w_coef, 20L, las = 1L,
                    xlab = 'Fitted Coefficient on W',
                    ylab = 'Number of Teams', col = 'darkgreen',
                    main = 'Team-Level Distribution\nWin Coefficients on ERA')]
abline(v = overall_coef, lty = 2L, col = 'red')
```

Si bien es cierto que existe un grado considerable de heterogeneidad, hay una clara concentración en torno al valor general observado.

Lo anterior es solo una breve introducción del poder de `.SD` para facilitar un código hermoso y eficiente en `data.table`.

```{r, echo=FALSE}
setDTthreads(.old.th)
```
