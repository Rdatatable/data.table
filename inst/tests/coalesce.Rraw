require(methods)

if (exists("test.data.table", .GlobalEnv, inherits=FALSE)) {
  if (!identical(suppressWarnings(packageDescription("data.table")), NA)) {
    remove.packages("data.table")
    stop("This is dev mode but data.table was installed. Uninstalled it. Please q() this R session and try cc() again. The installed namespace causes problems in dev mode for the S4 tests.\n")
  }
  if ((tt<-compiler::enableJIT(-1))>0)
    cat("This is dev mode and JIT is enabled (level ", tt, ") so there will be a brief pause around the first test.\n", sep="")
} else {
  require(data.table)
  test = data.table:::test
  #x = data.table:::x
}

# #3424 -- coalesce function
bool = c(TRUE, NA, FALSE)
bool_val = c(TRUE, TRUE, FALSE)
int = c(1L, 2L, NA_integer_, 4L)
int_val = 1:4
num = c(1, 2, NA_real_, 4)
num_val = c(1, 2, 3, 4)
str = c('a', NA_character_, 'b', NA_character_)
str_val = c('a', 'b', 'b', 'b')
fkt = factor(str)
fkt_val = factor(str_val)

## singleton replacements
test(2055.01, coalesce(bool, TRUE), bool_val)
test(2055.02, coalesce(bool, NA, TRUE), bool_val)
test(2055.03, coalesce(int, 3L), int_val)
test(2055.04, coalesce(int, NA_integer_, 3L), int_val)
test(2055.05, coalesce(num, 3), num_val)
test(2055.06, coalesce(num, NA_real_, 3), num_val)
test(2055.07, coalesce(str, 'b'), str_val)
test(2055.08, coalesce(str, NA_character_, 'b'), str_val)
test(2055.09, coalesce(fkt, factor('b', levels = c('a', 'b'))), fkt_val)
test(2055.10, coalesce(fkt, NA_integer_, factor('b', levels = c('a', 'b'))), fkt_val)

## vector replacements
test(2055.11, coalesce(bool, rep(TRUE, 3L)), bool_val)
test(2055.12, coalesce(bool, rep(NA, 3L), rep(TRUE, 3L)), bool_val)
test(2055.13, coalesce(int, rep(3L, 4L)), int_val)
test(2055.14, coalesce(int, rep(NA_integer_, 4L), rep(3L, 4L)), int_val)
test(2055.15, coalesce(num, rep(3, 4L)), num_val)
test(2055.16, coalesce(num, rep(NA_real_, 4L), rep(3, 4L)), num_val)
test(2055.17, coalesce(str, rep('b', 4L)), str_val)
test(2055.18, coalesce(str, rep(NA_character_, 4L), rep('b', 4L)), str_val)
test(2055.19, coalesce(fkt, factor(rep('b', 4L), levels=c('a', 'b'))), fkt_val)
test(2055.20, coalesce(fkt, rep(NA_integer_, 4L), factor(rep('b', 4L), levels=c('a', 'b'))), fkt_val)

## .dots argument
test(2055.21, coalesce(bool, .dots=list(NA, TRUE)), bool_val)

## edge cases/checks
test(2055.22, coalesce(bool), bool)
test(2055.23, coalesce(fkt), fkt)
test(2055.24, coalesce(bool, 1L), error='internal type integer')
#TODO should we error here, or convert any NA type to the right NA?
#test(2055.25, coalesce(bool, NA_integer_), error='internal type integer')
#TODO we don't have any robustness around factor/integer as yet
#test(2055.26, coalesce(fkt, 1L), error='')
#test(2055.27, coalesce(num, 3L), error='internal type integer')
#TODO two more placeholder tests -- do we really want to error here? or worth to add isReallyReal-type tests? numeric->integer should always be doable right?
#test(2055.28, coalesce(int, 3), error='internal type double')
test(2055.29, coalesce(fkt, 'b'), error='internal type character')
test(2055.30, coalesce(str, factor('b')), error='internal type integer')
test(2055.31, coalesce(bool, TRUE, .dots=list(FALSE)), error="either '...' or '.dots'")
test(2055.32, coalesce(bool, .dots=TRUE), error="'.dots' requires a list")
test(2055.33, coalesce(list(1), list(2)), error="'x' must be an atomic vector")
test(2055.34, coalesce(bool, c(TRUE, FALSE)), error="Only singletons will be recycled")
test(2055.35, coalesce(as.raw(0), as.raw(1)), error="Incompatible type: raw")

## verbose output
old = options(datatable.verbose=TRUE)
test(2055.36, coalesce(bool, TRUE), bool_val, output='which NA took.*duplicate.*took.*loop over NA indices of x took')
test(2055.37, coalesce(bool_val, TRUE), bool_val, output='no NAs in input, skip')
options(old)

## integer64 tests
if (test_bit64) {
  int64 = as.integer64(int)
  int64_val = as.integer64(1:4)

  test(2055.38, coalesce(int64, as.integer64(3)), int64_val)
  test(2055.39, coalesce(int64, as.integer64(NA), as.integer64(3)), int64_val)
  test(2055.40, coalesce(int64, as.integer64(rep(3, 4L))), int64_val)

  #TODO this line current runs and gives a nonsense answer
  #test(2055.41, coalesce(int64, 1), error='')
  test(2055.42, coalesce(int64, 1L), error = 'internal type integer')
}
