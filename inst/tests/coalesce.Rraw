require(methods)

if (exists("test.data.table", .GlobalEnv, inherits=FALSE)) {
  if (!identical(suppressWarnings(packageDescription("data.table")), NA)) {
    remove.packages("data.table")
    stop("This is dev mode but data.table was installed. Uninstalled it. Please q() this R session and try cc() again. The installed namespace causes problems in dev mode for the S4 tests.\n")
  }
  if ((tt<-compiler::enableJIT(-1))>0)
    cat("This is dev mode and JIT is enabled (level ", tt, ") so there will be a brief pause around the first test.\n", sep="")
} else {
  require(data.table)
  test = data.table:::test
  setcoalesce = data.table:::setcoalesce
  which_eq = data.table:::which_eq
}

sugg = c(
  "bit64",
  "nanotime"
)
for (s in sugg) {
  assign(paste0("test_",s), loaded<-suppressWarnings(suppressMessages(require(s, character.only=TRUE))))
  if (!loaded) cat("\n**** Suggested package",s,"is not installed. Tests using it will be skipped.\n\n")
}

# coalesce #3424
bool = c(TRUE, NA, FALSE)
bool_val = c(TRUE, TRUE, FALSE)
int = c(1L, 2L, NA_integer_, 4L)
int_val = 1:4
num = c(1, 2, NA_real_, 4)
num_val = c(1, 2, 3, 4)
str = c('a', NA_character_, 'b', NA_character_)
str_val = c('a', 'b', 'b', 'b')
fkt = factor(str)
fkt_val = factor(str_val)
date = as.Date(int, origin="1970-01-01")
date_val = as.Date(int_val, origin="1970-01-01")
idate = as.IDate(int, origin="1970-01-01")
idate_val = as.IDate(int_val, origin="1970-01-01")
itime = as.ITime(int)
itime_val = as.ITime(int_val)
posix = as.POSIXct(int, origin="1970-01-01")
posix_val = as.POSIXct(int_val, origin="1970-01-01")
# singleton replacements
test(2055.001, coalesce(bool, TRUE), bool_val)
test(2055.002, coalesce(bool, NA, TRUE), bool_val)
test(2055.003, coalesce(int, 3L), int_val)
test(2055.004, coalesce(int, NA_integer_, 3L), int_val)
test(2055.005, coalesce(num, 3), num_val)
test(2055.006, coalesce(num, NA_real_, 3), num_val)
test(2055.007, coalesce(str, 'b'), str_val)
test(2055.008, coalesce(str, NA_character_, 'b'), str_val)
test(2055.009, coalesce(fkt, factor('b', levels = c('a', 'b'))), fkt_val)
test(2055.010, coalesce(fkt, factor(NA_integer_, levels=c("a","b")), factor('b', levels = c('a', 'b'))), fkt_val)
test(2055.011, coalesce(date, as.Date("1970-01-04")), date_val)
test(2055.012, coalesce(date, as.Date(NA), as.Date("1970-01-04")), date_val)
test(2055.013, coalesce(idate, as.IDate("1970-01-04")), idate_val)
test(2055.014, coalesce(idate, as.IDate(NA), as.IDate("1970-01-04")), idate_val)
test(2055.015, coalesce(itime, as.ITime(3L)), itime_val)
test(2055.016, coalesce(itime, as.ITime(NA), as.ITime(3L)), itime_val)
test(2055.017, coalesce(posix, as.POSIXct(3L, origin="1970-01-01")), posix_val)
test(2055.018, coalesce(posix, as.POSIXct(NA_integer_, origin="1970-01-01"), as.POSIXct(3L, origin="1970-01-01")), posix_val)
# vector replacements
test(2055.051, coalesce(bool, rep(TRUE, 3L)), bool_val)
test(2055.052, coalesce(bool, rep(NA, 3L), rep(TRUE, 3L)), bool_val)
test(2055.053, coalesce(int, rep(3L, 4L)), int_val)
test(2055.054, coalesce(int, rep(NA_integer_, 4L), rep(3L, 4L)), int_val)
test(2055.055, coalesce(num, rep(3, 4L)), num_val)
test(2055.056, coalesce(num, rep(NA_real_, 4L), rep(3, 4L)), num_val)
test(2055.057, coalesce(str, rep('b', 4L)), str_val)
test(2055.058, coalesce(str, rep(NA_character_, 4L), rep('b', 4L)), str_val)
test(2055.059, coalesce(fkt, factor(rep('b', 4L), levels=c('a', 'b'))), fkt_val)
test(2055.060, coalesce(fkt, factor(rep(NA_integer_, 4L), levels=c("a","b")), factor(rep('b', 4L), levels=c('a', 'b'))), fkt_val)
test(2055.061, coalesce(date, rep(as.Date("1970-01-04"), 4L)), date_val)
test(2055.062, coalesce(date, rep(as.Date(NA), 4L), rep(as.Date("1970-01-04"), 4L)), date_val)
test(2055.063, coalesce(idate, rep(as.IDate("1970-01-04"), 4L)), idate_val)
test(2055.064, coalesce(idate, rep(as.IDate(NA), 4L), rep(as.IDate("1970-01-04"), 4L)), idate_val)
test(2055.065, coalesce(itime, rep(as.ITime(3L), 4L)), itime_val)
test(2055.066, coalesce(itime, rep(as.ITime(NA), 4L), rep(as.ITime(3L), 4L)), itime_val)
test(2055.067, coalesce(posix, as.POSIXct(rep(3L, 4L), origin="1970-01-01")), posix_val)
test(2055.068, coalesce(posix, as.POSIXct(rep(NA_integer_, 4L), origin="1970-01-01"), as.POSIXct(rep(3L, 4L), origin="1970-01-01")), posix_val)
# .dots argument
test(2055.101, coalesce(bool, .dots=list(NA, TRUE)), bool_val)
# floating point extras
x = c(11L, NA, 13L, NA, 15L, NaN, NA, NA, NA)+0.1
y = c(NA, 12L, 5L, NA, NA, 16L, NaN, Inf, NA)+0.1
z = c(11L, NA, 1L, 14L, NA, 16L, 1L, 2L, NA)+0.1
test(2055.151, coalesce(x, y, z), c(11:15,NaN,NaN,Inf,NA)+0.1)
# factor of different levels
x = factor(c('a','b',NA,NA,'b'))
y = factor(c('b','b','a',NA,'b'))
z = factor(c('a',NA,NA,'d','a'))
test(2055.152, coalesce(x, y, z), error='has different factor levels')
# edge cases/checks
test(2055.201, coalesce(bool), bool)
test(2055.202, coalesce(fkt), fkt)
test(2055.203, coalesce(bool, 1L), error='internal type integer')
test(2055.204, coalesce(bool, NA_integer_), error='internal type integer')
test(2055.205, coalesce(fkt, 1L), error='does not inherit factor class')
test(2055.206, coalesce(num, 3L), error='internal type integer')
test(2055.207, coalesce(int, 3), error='internal type double')
test(2055.208, coalesce(fkt, 'b'), error='internal type character')
test(2055.209, coalesce(str, factor('b')), error='internal type integer')
test(2055.210, coalesce(bool, TRUE, .dots=list(FALSE)), error="either '...' or '.dots'")
test(2055.211, coalesce(bool, .dots=TRUE), error="'.dots' requires a list")
test(2055.212, coalesce(list(1), list(2)), error="'x' must be an atomic vector")
test(2055.213, coalesce(bool, c(TRUE, FALSE)), error="Only singletons will be recycled")
test(2055.214, coalesce(as.raw(0), as.raw(1)), error="Incompatible type: raw")
test(2055.215, coalesce(bool, .dots=list()), bool)
test(2055.216, coalesce(structure(c(1:2,NA,4L), class=c("a")), c(NA,NA,3L,4L)), structure(1:4, class="a"))
# verbose output
old = options(datatable.verbose=TRUE)
test(2055.251, coalesce(bool, TRUE), bool_val, output='which NA took.*duplicate.*took.*loop over NA indices of x took')
test(2055.252, coalesce(bool_val, TRUE), bool_val, output='no NAs in input, skip')
options(old)
# integer64 tests
if (test_bit64) {
  int64 = as.integer64(int)
  int64_val = as.integer64(1:4)
  test(2055.301, as.character(coalesce(int64, as.integer64(3))), as.character(int64_val)) # why as.character see nanotime tests below
  test(2055.302, as.character(coalesce(int64, as.integer64(NA), as.integer64(3))), as.character(int64_val))
  test(2055.303, as.character(coalesce(int64, as.integer64(rep(3, 4L)))), as.character(int64_val))
  test(2055.304, coalesce(int64, 1), error='does not inherit integer64')
  test(2055.305, coalesce(int64, 1L), error = 'internal type integer')
}
# nanotime tests
if (test_nanotime) {
  nt = nanotime(int)
  nt_val = nanotime(1:4)
  test(2055.401, as.character(coalesce(nt, nanotime(3L))), as.character(nt_val)) # as.character due to eddelbuettel/nanotime#46
  test(2055.402, as.character(coalesce(nt, nanotime(NA), nanotime(3L))), as.character(nt_val))
  test(2055.403, as.character(coalesce(nt, nanotime(rep(3, 4L)))), as.character(nt_val))
  test(2055.404, coalesce(nt, 1), error='does not inherit nanotime')
  test(2055.405, coalesce(nt, 1L), error = 'internal type integer')
}

# setcoalesce
x = c(11L, NA, 13L, NA, 15L, NA)
y = c(NA, 12L, 5L, NA, NA, NA)
z = c(11L, NA, 1L, 14L, NA, NA)
xx = copy(x)
xx_addr = address(xx)
setcoalesce(xx, y, z)
test(2055.501, xx_addr, address(xx))
test(2055.502, xx, c(11:15, NA))
xx = copy(x)
xx_addr = address(xx)
setcoalesce(xx, .dots=list())
test(2055.503, xx_addr, address(xx))
test(2055.504, xx, x)
test(2055.505, address(setcoalesce(xx)), xx_addr)
test(2055.506, setcoalesce(xx, TRUE, .dots=list(FALSE)), error="either '...' or '.dots'")
test(2055.507, setcoalesce(xx, .dots=TRUE), error="'.dots' requires a list")

# which_eq
test(2056.01, which_eq(c(TRUE, NA, FALSE, FALSE), FALSE, negate=TRUE), 1:2)
test(2056.02, which_eq(c(TRUE, NA, FALSE, FALSE), NA, negate=TRUE), c(1L,3L,4L))
test(2056.03, which_eq(c(TRUE, TRUE), TRUE, negate=TRUE), integer())
test(2056.04, which_eq(c(1L, NA, 5L), 5L, negate=TRUE), c(1L,2L))
test(2056.05, which_eq(c(1L, NA, 5L), NA_integer_, negate=TRUE), c(1L,3L))
test(2056.06, which_eq(c(1L, 1L), 1L, negate=TRUE), integer())
test(2056.07, which_eq(c("a", NA, "r", "a"), "a", negate=TRUE), 2:3)
test(2056.08, which_eq(c("a", NA, "r", "a"), "r", negate=TRUE), c(1L,2L,4L))
test(2056.09, which_eq(c("a","a"), "a", negate=TRUE), integer())
test(2056.10, which_eq(c(1.1, NA, 3.1), NA_real_, negate=TRUE), c(1L,3L))
test(2056.11, which_eq(c(NA_real_, NA_real_), NA_real_, negate=TRUE), integer())
test(2056.12, which_eq(c(1.1, NaN, 3.1), NaN, negate=TRUE), c(1L,3L))
test(2056.13, which_eq(c(NaN, NaN), NaN, negate=TRUE), integer())
test(2056.14, which_eq(c(1.1, Inf, 3.1), Inf, negate=TRUE), c(1L,3L))
test(2056.15, which_eq(c(Inf, Inf), Inf, negate=TRUE), integer())
test(2056.16, which_eq(c(NA, 12L, 5L, NA, NA, 16L, NaN, Inf, NA)+0.1, NaN), 7L)
test(2056.17, which_eq(c(NA, 12L, 5L, NA, NA, 16L, NaN, Inf, NA)+0.1, Inf), 8L)
if (test_bit64) {
  test(2056.51, which_eq(as.integer64(c(1L, NA, 5L)), as.integer64(5L), negate=TRUE), c(1L,2L))
  test(2056.52, which_eq(as.integer64(c(1L, NA, 5L)), as.integer64(NA_integer_), negate=TRUE), c(1L,3L))
  test(2056.53, which_eq(as.integer64(c(1L, 1L)), as.integer64(1L), negate=TRUE), integer())
}
if (test_nanotime) {
  test(2056.61, which_eq(nanotime(c(1L, NA, 5L)), nanotime(5L), negate=TRUE), c(1L,2L))
  test(2056.62, which_eq(nanotime(c(1L, NA, 5L)), nanotime(NA_integer_), negate=TRUE), c(1L,3L))
  test(2056.63, which_eq(nanotime(c(1L, 1L)), nanotime(1L), negate=TRUE), integer())
}
test(2056.81, which_eq(list(1L,2L), 1L), error="argument 'x' must be atomic vector")
test(2056.82, which_eq(c(1:2), 1), error="argument 'value' must of the same type as argument 'x'")
test(2056.83, which_eq(c(1:2), 1L, negate=1L), error="argument 'negate' must be TRUE or FALSE")
test(2056.84, which_eq(as.raw(0), as.raw(1)), error="Incompatible type: raw")
