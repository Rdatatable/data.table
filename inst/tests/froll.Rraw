require(methods)

if (exists("test.data.table", .GlobalEnv, inherits=FALSE)) {
  if ((tt<-compiler::enableJIT(-1))>0)
    cat("This is dev mode and JIT is enabled (level ", tt, ") so there will be a brief pause around the first test.\n", sep="")
} else {
  require(data.table)
  test = data.table:::test
  froll = data.table:::froll
  frollfun = data.table:::frollfun
}

exact_NaN = isTRUE(capabilities()["long.double"]) && identical(as.integer(.Machine$longdouble.digits), 64L)
if (!exact_NaN) {
  cat("\n**** Skipping 7 NaN/NA algo='exact' tests because .Machine$longdouble.digits==", .Machine$longdouble.digits, " (!=64); e.g. under valgrind\n\n", sep="")
  # for Matt when he runs valgrind it is 53, but 64 when running regular R
  # froll.c uses long double and appears to require full long double accuracy in the algo='exact'
}

## rolling features

#### atomic vectors input and single window returns atomic vectors
x = 1:6/2
ans1 = frollmean(x, 3)
ans2 = frollmean(x, 3, algo="exact")
expected = c(rep(NA_real_,2), seq(1,2.5,0.5))
test(6000.001, ans1, expected)
test(6000.002, ans2, expected)

#### multiple columns at once
d = as.data.table(list(1:6/2, 3:8/4))
ans1 = frollmean(d, 3)
ans2 = frollmean(d, 3, algo="exact")
expected = list(
  c(rep(NA_real_,2), seq(1,2.5,0.5)),
  c(rep(NA_real_,2), seq(1,1.75,0.25))
)
test(6000.003, ans1, expected)
test(6000.004, ans2, expected)

#### multiple windows at once
ans1 = frollmean(d[, .(V1)], c(3, 4))
ans2 = frollmean(d[, .(V1)], c(3, 4), algo="exact")
expected = list(
  c(rep(NA_real_,2), seq(1,2.5,0.5)),
  c(rep(NA_real_,3), seq(1.25,2.25,0.5))
)
test(6000.005, ans1, expected)
test(6000.006, ans2, expected)

#### multiple columns and multiple windows at once
ans1 = frollmean(d, c(3, 4))
ans2 = frollmean(d, c(3, 4), algo="exact")
expected = list(
  c(rep(NA_real_,2), seq(1,2.5,0.5)), c(rep(NA_real_,3), seq(1.25,2.25,0.5)),
  c(rep(NA_real_,2), seq(1,1.75,0.25)), c(rep(NA_real_,3), seq(1.125,1.625,0.25))
)
test(6000.007, ans1, expected)
test(6000.008, ans2, expected)

#### in x integer and logical converted to double
di = data.table(real=1:10/2, int=1:10, lgl=c(TRUE,FALSE,TRUE,TRUE,FALSE,FALSE,FALSE,FALSE,TRUE,TRUE))
ans = frollmean(di, 3)
expected = list(
  c(rep(NA_real_,2), seq(1,4.5,0.5)),
  c(rep(NA_real_,2), seq(2,9,1)),
  c(rep(NA_real_,2), c(2,2,2,1,0,0,1,2)/3)
)
test(6000.009, ans, expected)
test(6000.0091, frollmean(di$int, 3), expected[[2L]]) # test also atomic vector input
test(6000.0092, frollmean(di$lgl, 3), expected[[3L]])

#### in n double converted to integer
x = 1:3/2
n = 2
test(6000.010, frollmean(x, n), c(NA, 0.75, 1.25))
n = list(c(2L,1L,2L), c(2,1,2))
test(6000.011, frollmean(x, n, adaptive=TRUE), list(c(NA, 1, 1.25), c(NA, 1, 1.25)))

#### error on unsupported type
dx = data.table(real=1:10/2, char=letters[1:10])
test(6000.012, frollmean(dx, 3), error="x must be of type numeric or logical, or a list, data.frame or data.table of such")
dx = data.table(real=1:10/2, fact=factor(letters[1:10]))
test(6000.013, frollmean(dx, 3), error="x must be of type numeric or logical, or a list, data.frame or data.table of such")
#dx = data.table(real=1:10/2, logi=logical(10))
#test(6000.014, frollmean(dx, 3), error="x must be list, data.frame or data.table of numeric types") # commented out as support added in #3749, tested in .009
dx = data.table(real=1:10/2, list=rep(list(NA), 10))
test(6000.015, frollmean(dx, 3), error="x must be of type numeric or logical, or a list, data.frame or data.table of such")
x = letters[1:10]
test(6000.016, frollmean(x, 3), error="x must be of type numeric or logical, or a list, data.frame or data.table of such")
x = 1:10/2
test(6000.017, frollmean(x, "a"), error="n must be integer")
test(6000.018, frollmean(x, factor("a")), error="n must be integer")
test(6000.019, frollmean(x, TRUE), error="n must be integer")
test(6000.020, frollmean(x, list(1:10)), error="n must be integer, list is accepted for adaptive TRUE")
test(6000.021, frollmean(x, list(NA), adaptive=TRUE), error="n must be integer vector or list of integer vectors")
test(6000.022, frollmean(x, list(c(1:5,1:5), NA), adaptive=TRUE), error="n must be integer vector or list of integer vectors")
test(6000.0221, frollmean(1:2, list(c(0L, 0L)), adaptive=TRUE), error="n must be positive integer values")

#### various length list vectors
l = list(1:6/2, 3:10/4)
ans = frollmean(l, c(3, 4))
expected = list(
  c(rep(NA_real_,2), seq(1,2.5,0.5)), c(rep(NA_real_,3), seq(1.25,2.25,0.5)),
  c(rep(NA_real_,2), seq(1,2.25,0.25)), c(rep(NA_real_,3), seq(1.125,2.125,0.25))
)
test(6000.023, ans, expected)

#### exact
set.seed(108)
x = sample(c(rnorm(1e3, 1e6, 5e5), 5e9, 5e-9))
n = 15
ma = function(x, n, na.rm=FALSE) {
  ans = rep(NA_real_, nx<-length(x))
  for (i in n:nx) ans[i] = mean(x[(i-n+1):i], na.rm=na.rm)
  ans
}
fastma = function(x, n, na.rm) {
  if (!missing(na.rm)) stop("NAs are unsupported, wrongly propagated by cumsum")
  cs = cumsum(x)
  scs = shift(cs, n)
  scs[n] = 0
  as.double((cs-scs)/n)
}
ans1 = ma(x, n)
ans2 = fastma(x, n)
ans3 = frollmean(x, n)
ans4 = frollmean(x, n, algo="exact")
anserr = list(
  fastma = ans2-ans1,
  froll_fast = ans3-ans1,
  froll_exact = ans4-ans1
)
errs = sapply(lapply(anserr, abs), sum, na.rm=TRUE)
if (!(.Platform$OS.type=="windows" && getDTthreads()>1L)) { # windows 2+ threads rounding issue: #3346
  if (.Machine$sizeof.longdouble == 16L) test(6000.024, errs[["froll_exact"]]==0) # only where long double available, otherwise we get noLD CRAN note
  if (Sys.info()["machine"] == "x86_64") test(6000.025, errs[["froll_fast"]]>errs[["froll_exact"]]) # floating point arithmetic issue on various machines #3491
}
test(6000.026, errs[["fastma"]]>errs[["froll_exact"]])
test(6000.027, errs[["fastma"]]>errs[["froll_fast"]])

#### align: right/center/left
d = as.data.table(list(1:8/2, 3:10/4))
ans1 = frollmean(d, 5, align="right") # default
ans2 = frollmean(d, 5, align="right", algo="exact")
expected = list(
  c(rep(NA_real_,4), seq(1.5,3,0.5)),
  c(rep(NA_real_,4), seq(1.25,2,0.25))
)
test(6000.028, ans1, expected)
test(6000.029, ans2, expected)
ans1 = frollmean(d, 5, align="center") # x even, n odd
ans2 = frollmean(d, 5, align="center", algo="exact")
expected = list(
  c(rep(NA_real_, 2), seq(1.5,3,0.5), rep(NA_real_, 2)),
  c(rep(NA_real_, 2), seq(1.25,2,0.25), rep(NA_real_, 2))
)
test(6000.030, ans1, expected)
test(6000.031, ans2, expected)
ans1 = frollmean(d, 6, align="center") # x even, n even
ans2 = frollmean(d, 6, align="center", algo="exact")
expected = list(
  c(rep(NA_real_, 2), seq(1.75,2.75,0.5), rep(NA_real_,3)),
  c(rep(NA_real_, 2), seq(1.375,1.875,0.25), rep(NA_real_,3))
)
test(6000.032, ans1, expected)
test(6000.033, ans2, expected)
de = rbind(d, data.table(4.5, 2.75))
ans1 = frollmean(de, 5, align="center") # x odd, n odd
ans2 = frollmean(de, 5, align="center", algo="exact")
expected = list(
  c(rep(NA_real_, 2), seq(1.5,3.5,0.5), rep(NA_real_, 2)),
  c(rep(NA_real_, 2), seq(1.25,2.25,0.25), rep(NA_real_, 2))
)
test(6000.034, ans1, expected)
test(6000.035, ans2, expected)
ans1 = frollmean(de, 6, align="center") # x odd, n even
ans2 = frollmean(de, 6, align="center", algo="exact")
expected = list(
  c(rep(NA_real_, 2), seq(1.75,3.25,0.5), rep(NA_real_,3)),
  c(rep(NA_real_, 2), seq(1.375,2.125,0.25), rep(NA_real_,3))
)
test(6000.036, ans1, expected)
test(6000.037, ans2, expected)
ans1 = frollmean(d, 5, align="left")
ans2 = frollmean(d, 5, align="left", algo="exact")
expected = list(
  c(seq(1.5,3,0.5), rep(NA_real_,4)),
  c(seq(1.25,2,0.25), rep(NA_real_,4))
)
test(6000.038, ans1, expected)
test(6000.039, ans2, expected)

#### handling NAs align na.rm
d = as.data.table(list(1:8/2, 3:10/4))
d[c(2L, 7L), "V1" := NA][c(1:2,8L), "V2" := NA]
ans1 = frollmean(d, 3, align="right") # default
ans2 = frollmean(d, 3, align="right", algo="exact")
expected = list(
  c(rep(NA_real_,4), seq(2,2.5,0.5), rep(NA_real_, 2)),
  c(rep(NA_real_,4), seq(1.5,2,0.25), rep(NA_real_, 1))
)
test(6000.040, ans1, expected)
if (exact_NaN) test(6000.041, ans2, expected)
ans1 = frollmean(d, 3, align="right", na.rm=TRUE)
ans2 = frollmean(d, 3, align="right", algo="exact", na.rm=TRUE)
expected = list(
  c(rep(NA_real_,2), 1, 1.75, 2, 2.5, 2.75, 3.5),
  c(rep(NA_real_,2), 1.25, 1.375, 1.5, 1.75, 2, 2.125)
)
test(6000.042, ans1, expected)
test(6000.043, ans2, expected)
ans1 = frollmean(d, 3, align="center") # x even, n odd
ans2 = frollmean(d, 3, align="center", algo="exact")
expected = list(
  c(rep(NA_real_,3), seq(2,2.5,0.5), rep(NA_real_, 3)),
  c(rep(NA_real_,3), seq(1.5,2,0.25), rep(NA_real_, 2))
)
test(6000.044, ans1, expected)
if (exact_NaN) test(6000.045, ans2, expected)
ans1 = frollmean(d, 3, align="center", na.rm=TRUE) # x even, n odd
ans2 = frollmean(d, 3, align="center", algo="exact", na.rm=TRUE)
expected = list(
  c(rep(NA_real_,1), 1, 1.75, 2, 2.5, 2.75, 3.5, rep(NA_real_,1)),
  c(rep(NA_real_,1), 1.25, 1.375, 1.5, 1.75, 2, 2.125, rep(NA_real_,1))
)
test(6000.046, ans1, expected)
test(6000.047, ans2, expected)
ans1 = frollmean(d, 4, align="center") # x even, n even
ans2 = frollmean(d, 4, align="center", algo="exact")
expected = list(
  c(rep(NA_real_,3), 2.25, rep(NA_real_, 4)),
  c(rep(NA_real_,3), 1.625, 1.875, rep(NA_real_, 3))
)
test(6000.048, ans1, expected)
if (exact_NaN) test(6000.049, ans2, expected)
ans1 = frollmean(d, 4, align="center", na.rm=TRUE) # x even, n even
ans2 = frollmean(d, 4, align="center", algo="exact", na.rm=TRUE)
expected = list(
  c(rep(NA_real_,1), 4/3, 2, 2.25, 2.5, 9.5/3, rep(NA_real_,2)),
  c(rep(NA_real_,1), 1.375, 1.5, 1.625, 1.875, 2, rep(NA_real_,2))
)
test(6000.050, ans1, expected)
test(6000.051, ans2, expected)
de = rbind(d, data.table(4.5, 2.75))
ans1 = frollmean(de, 3, align="center") # x odd, n odd
ans2 = frollmean(de, 3, align="center", algo="exact")
expected = list(
  c(rep(NA_real_,3), 2, 2.5, rep(NA_real_, 4)),
  c(rep(NA_real_,3), 1.5, 1.75, 2, rep(NA_real_, 3))
)
test(6000.052, ans1, expected)
if (exact_NaN) test(6000.053, ans2, expected)
ans1 = frollmean(de, 3, align="center", na.rm=TRUE) # x odd, n odd
ans2 = frollmean(de, 3, align="center", algo="exact", na.rm=TRUE)
expected = list(
  c(rep(NA_real_,1), 1, 1.75, 2, 2.5, 2.75, 3.5, 4.25, rep(NA_real_,1)),
  c(rep(NA_real_,1), 1.25, 1.375, 1.5, 1.75, 2, 2.125, 2.5, rep(NA_real_,1))
)
test(6000.054, ans1, expected)
test(6000.055, ans2, expected)
ans1 = frollmean(de, 4, align="center") # x odd, n even
ans2 = frollmean(de, 4, align="center", algo="exact")
expected = list(
  c(rep(NA_real_, 3), 2.25, rep(NA_real_,5)),
  c(rep(NA_real_, 3), 1.625, 1.875, rep(NA_real_,4))
)
test(6000.056, ans1, expected)
if (exact_NaN) test(6000.057, ans2, expected)
ans1 = frollmean(de, 4, align="center", na.rm=TRUE) # x odd, n even
ans2 = frollmean(de, 4, align="center", algo="exact", na.rm=TRUE)
expected = list(
  c(rep(NA_real_, 1), 4/3, 2, 2.25, 2.5, 9.5/3, 11.5/3, rep(NA_real_,2)),
  c(rep(NA_real_, 1), 1.375, 1.5, 1.625, 1.875, 2, 7/3, rep(NA_real_,2))
)
test(6000.058, ans1, expected)
test(6000.059, ans2, expected)
ans1 = frollmean(d, 3, align="left")
ans2 = frollmean(d, 3, align="left", algo="exact")
expected = list(
  c(rep(NA_real_, 2), 2, 2.5, rep(NA_real_,4)),
  c(rep(NA_real_, 2), 1.5, 1.75, 2, rep(NA_real_,3))
)
test(6000.060, ans1, expected)
if (exact_NaN) test(6000.061, ans2, expected)
ans1 = frollmean(d, 3, align="left", na.rm=TRUE)
ans2 = frollmean(d, 3, align="left", algo="exact", na.rm=TRUE)
expected = list(
  c(1, 1.75, 2, 2.5, 2.75, 3.5, rep(NA_real_,2)),
  c(1.25, 1.375, 1.5, 1.75, 2, 2.125, rep(NA_real_,2))
)
test(6000.062, ans1, expected)
test(6000.063, ans2, expected)
#### handling NAs for NaN output also
d = as.data.table(list(1:6/2, 3:8/4))
d[c(2L, 5L), V1:=NA][4:6, V2:=NA]
ans1 = frollmean(d, 2:3)
ans2 = frollmean(d, 2:3, algo="exact")
expected = list(c(NA, NA, NA, 1.75, NA, NA), rep(NA_real_, 6), c(NA, 0.875, 1.125, NA, NA, NA), c(NA, NA, 1, NA, NA, NA))
test(6000.064, ans1, expected)
if (exact_NaN) test(6000.065, ans2, expected)
ans1 = frollmean(d, 2:3, na.rm=TRUE)
ans2 = frollmean(d, 2:3, algo="exact", na.rm=TRUE)
expected = list(c(NA, 0.5, 1.5, 1.75, 2, 3), c(NA, NA, 1, 1.75, 1.75, 2.5), c(NA, 0.875, 1.125, 1.25, NaN, NaN), c(NA, NA, 1, 1.125, 1.25, NaN))
test(6000.066, ans1, expected)
test(6000.067, ans2, expected)
#### early stopping NAs in leading k obs
options(datatable.verbose=TRUE)
test(6000.0671, frollmean(c(1:2,NA,4:10), 4), c(rep(NA_real_, 6), 5.5, 6.5, 7.5, 8.5), output=c(
  "frollfunR: allocating memory for results 1x1",
  "frollfunR: 1 column.*1 window.*",
  "frollfunR: 1:",
  "frollmeanFast: running for input length 10, window 4, hasnf 0, narm 0",
  "frollmeanFast: non-finite values are present in input, skip non-finite unaware attempt and run with extra care for NFs straighaway",
  "frollfun: processing fun 0 algo 0 took.*",
  "frollfunR: processing.*took.*"
))
test(6000.0672, frollmean(c(1:2,NA,4:10), 4, has.nf=FALSE), c(rep(NA_real_, 6), 5.5, 6.5, 7.5, 8.5), output=c(
  "frollfunR: allocating memory for results 1x1",
  "frollfunR: 1 column.*1 window.*",
  "frollfunR: 1:",
  "frollmeanFast: running for input length 10, window 4, hasnf -1, narm 0",
  "frollmeanFast: non-finite values are present in input, skip non-finite unaware attempt and run with extra care for NFs straighaway",
  "frollfun: processing fun 0 algo 0 took.*",
  "frollfunR: processing.*took.*"
), warning="has.nf=FALSE used but non-finite values are present in input, use default has.nf=NA to avoid this warning")
test(6000.0673, frollmean(c(1:2,NA,4:10), 2, has.nf=FALSE), c(NA, 1.5, NA, NA, 4.5, 5.5, 6.5, 7.5, 8.5, 9.5), output=c(
  "frollfunR: allocating memory for results 1x1",
  "frollfunR: 1 column.*1 window.*",
  "frollfunR: 1:",
  "frollmeanFast: running for input length 10, window 2, hasnf -1, narm 0",
  "frollmeanFast: non-finite values are present in input, re-running with extra care for NFs",
  "frollfun: processing fun 0 algo 0 took.*",
  "frollfunR: processing.*took.*"
), warning="has.nf=FALSE used but non-finite values are present in input, use default has.nf=NA to avoid this warning")
test(6000.0674, frollmean(c(1:2,NA,4:10), 4, align="center"), c(rep(NA_real_, 4), 5.5, 6.5, 7.5, 8.5, NA, NA), output=c(
  "frollfunR: allocating memory for results 1x1",
  "frollfunR: 1 column.*1 window.*",
  "frollmeanFast: running for input length 10, window 4, hasnf 0, narm 0",
  "frollmeanFast: non-finite values are present in input, skip non-finite unaware attempt and run with extra care for NFs straighaway",
  "frollfun: align 0, shift answer by -2",
  "frollfun: processing fun 0 algo 0 took.*",
  "frollfunR: processing.*took.*"
))
options(datatable.verbose=FALSE)

#### fill constant
test(6000.068, frollmean(1:5, 4, fill=0), c(0, 0, 0, 2.5, 3.5))
test(6000.069, frollmean(1:5, 4, fill=-5), c(-5, -5, -5, 2.5, 3.5))
test(6000.070, frollmean(1:5, 4, fill=100), c(100, 100, 100, 2.5, 3.5))
test(6000.071, frollmean(1:5, 4, fill=Inf), c(Inf, Inf, Inf, 2.5, 3.5))
test(6000.072, frollmean(1:5, 4, fill=NaN), c(NaN, NaN, NaN, 2.5, 3.5))

#### fill coercion
test(6000.073, frollmean(1:3, 2, fill=0), c(0, 1.5, 2.5))
test(6000.074, frollmean(1:3, 2, fill=0L), c(0, 1.5, 2.5))
test(6000.075, frollmean(1:3, 2, fill=NA_integer_), c(NA_real_, 1.5, 2.5))
test(6000.076, frollmean(1:3, 2, fill=1:2), error="fill must be a vector of length 1")
test(6000.077, frollmean(1:3, 2, fill=NA), c(NA_real_, 1.5, 2.5))
test(6000.078, frollmean(1:3, 2, fill=TRUE), frollmean(1:3, 2, fill=1)) #error="fill must be numeric") # fill already coerced, as 'x' arg
test(6000.079, frollmean(1:3, 2, fill=FALSE), frollmean(1:3, 2, fill=0)) #error="fill must be numeric")
test(6000.080, frollmean(1:3, 2, fill="a"), error="fill must be numeric")
test(6000.081, frollmean(1:3, 2, fill=factor("a")), error="fill must be numeric")
test(6000.082, frollmean(1:3, 2, fill=list(NA)), error="fill must be numeric")

## edge cases
#### length(x)==0
test(6000.083, frollmean(numeric(0), 2), numeric(0))
test(6000.084, frollmean(list(1:3, numeric()), 2), list(c(NA_real_, 1.5, 2.5), numeric(0)))
#### length(n)==0
test(6000.085, frollmean(1:3, integer()), error="n must be non 0 length")
test(6000.086, frollmean(list(1:3, 2:4), integer()), error="n must be non 0 length")
#### n==0
test(6000.087, frollmean(1:3, c(2,0)), error="n must be positive integer values")
test(6000.088, frollmean(list(1:3, 2:4), 0), error="n must be positive integer values")
#### n<0
test(6000.089, frollmean(1:3, -2), error="n must be positive integer values")
#### n[[1L]]>0 && n[[2L]]<0
test(6000.090, frollmean(1:3, c(2, -2)), error="n must be positive integer values")
#### n[[1L]]==n[[2L]]
test(6000.091, frollmean(1:3, c(2, 2)), list(c(NA_real_, 1.5, 2.5), c(NA_real_, 1.5, 2.5)))
test(6000.092, frollmean(list(1:3, 4:6), c(2, 2)), list(c(NA_real_, 1.5, 2.5), c(NA_real_, 1.5, 2.5), c(NA_real_, 4.5, 5.5), c(NA_real_, 4.5, 5.5)))
#### n>length(x)
test(6000.093, frollmean(list(1:3, 4:6), 4), list(c(NA_real_, NA_real_, NA_real_), c(NA_real_, NA_real_, NA_real_)))
test(6000.0931, frollmean(list(1:3, 4:6), 4, align="center"), list(c(NA_real_, NA_real_, NA_real_), c(NA_real_, NA_real_, NA_real_)))
test(6000.0932, frollmean(list(1:3, 4:6), 4, align="left"), list(c(NA_real_, NA_real_, NA_real_), c(NA_real_, NA_real_, NA_real_)))
options(datatable.verbose=TRUE)
test(6000.0933, frollmean(list(1:3, 4:6), 4), list(c(NA_real_, NA_real_, NA_real_), c(NA_real_, NA_real_, NA_real_)), output="frollfun: window width longer than input vector, returning all NA vector")
options(datatable.verbose=FALSE)
#### n==length(x)
test(6000.094, frollmean(list(1:3, 4:6), 3), list(c(NA_real_, NA_real_, 2), c(NA_real_, NA_real_, 5)))
#### n<length(x[[1L]]) && n>length(x[[2L]])
test(6000.095, frollmean(list(1:5, 1:2), 3), list(c(NA_real_, NA_real_, 2, 3, 4), c(NA_real_, NA_real_)))
#### n==1
test(6000.096, frollmean(1:4, 1), as.double(1:4))
test(6000.097, frollmean(1:4, 1, algo="exact"), as.double(1:4))
test(6000.098, frollmean(1:4, 1, align="center"), as.double(1:4))
test(6000.099, frollmean(1:4, 1, align="center", algo="exact"), as.double(1:4))
test(6000.100, frollmean(1:4, 1, align="left"), as.double(1:4))
test(6000.101, frollmean(1:4, 1, align="left", algo="exact"), as.double(1:4))
#### length(x)==1 && n==1
test(6000.102, frollmean(5, 1), 5)
test(6000.103, frollmean(list(1, 10, 5), 1), list(1, 10, 5))
test(6000.104, frollmean(5, 1, align="left"), 5)
test(6000.105, frollmean(list(1, 10, 5), 1, align="left"), list(1, 10, 5))
test(6000.106, frollmean(5, 1, align="center"), 5)
test(6000.107, frollmean(list(1, 10, 5), 1, align="center"), list(1, 10, 5))
#### length(x)==1 && n==2
test(6000.108, frollmean(5, 2), NA_real_)
test(6000.109, frollmean(list(1, 10, 5), 2), list(NA_real_, NA_real_, NA_real_))
test(6000.110, frollmean(5, 2, align="left"), NA_real_)
test(6000.111, frollmean(list(1, 10, 5), 2, align="left"), list(NA_real_, NA_real_, NA_real_))
test(6000.112, frollmean(5, 2, align="center"), NA_real_)
test(6000.113, frollmean(list(1, 10, 5), 2, align="center"), list(NA_real_, NA_real_, NA_real_))
#### n==Inf
test(6000.114, frollmean(1:5, Inf), error="n must be positive integer values", warning="NAs introduced by coercion*")
#### n==c(5, Inf)
test(6000.115, frollmean(1:5, c(5, Inf)), error="n must be positive integer values", warning="NAs introduced by coercion*")
#### is.complex(n)
test(6000.116, frollmean(1:5, 3i), error="n must be integer")
#### is.character(n)
test(6000.117, frollmean(1:5, "a"), error="n must be integer")
#### is.factor(n)
test(6000.118, frollmean(1:5, as.factor("a")), error="n must be integer")
#### is.list(n)
test(6000.119, frollmean(1:5, list(1:5)), error="n must be integer, list is accepted for adaptive TRUE")
#### adaptive=NA
test(6000.1192, frollmean(1:5, 2, adaptive=NA), error="adaptive must be TRUE or FALSE")
#### na.rm=NA
test(6000.1193, frollmean(1:5, 2, na.rm=NA), error="na.rm must be TRUE or FALSE")
#### has.nf=1
test(6000.1194, frollmean(1:5, 2, has.nf=1), error="has.nf must be TRUE, FALSE or NA")
#### has.nf=FALSE na.rm=TRUE
test(6000.1195, frollmean(1:5, 2, na.rm=TRUE, has.nf=FALSE), error="using has.nf FALSE and na.rm TRUE does not make sense, if you know there are non-finite values then use has.nf TRUE, otherwise leave it as default NA")
#### exact na.rm=TRUE adaptive=TRUE verbose=TRUE
options(datatable.verbose=TRUE)
test(6000.1196, frollmean(c(1:5,NA), 1:6, algo="exact", na.rm=TRUE, adaptive=TRUE), output=c(
  "frollfunR: allocating memory for results 1x1",
  "frollfunR: 1 column.*1 window.*, not entering parallel execution here because algo='exact' will compute results in parallel",
  "frollfunR: 1:",
  "frolladaptivemeanExact: running in parallel for input length 6, hasnf 0, narm 1",
  "frolladaptivemeanExact: non-finite values are present in input, re-running with extra care for NFs",
  "frolladaptivefun: processing fun 0 algo 1 took.*",
  "frollfunR: processing.*took.*"
))
#### exact na.rm=TRUE verbose=TRUE
test(6000.1197, frollmean(c(1:5,NA), 2, algo="exact", na.rm=TRUE), output=c(
  "frollfunR: allocating memory for results 1x1",
  "frollfunR: 1 column.*1 window.*, not entering parallel execution here because algo='exact' will compute results in parallel",
  "frollfunR: 1:",
  "frollmeanExact: running in parallel for input length 6, window 2, hasnf 0, narm 1",
  "frollmeanExact: non-finite values are present in input, re-running with extra care for NFs",
  "frollfun: processing fun 0 algo 1 took.*",
  "frollfunR: processing.*took.*"
))
options(datatable.verbose=FALSE)
#### adaptive=TRUE n=character
test(6000.1198, frollmean(1:5, n=letters[1:5], adaptive=TRUE), error="n must be integer vector or list of integer vectors")

#### non-finite values (NA, NaN, Inf, -Inf)
ma = function(x, n, na.rm=FALSE, nf.rm=FALSE) {
  if (!is.double(x)) x = as.double(x)
  if (!is.integer(n)) n = as.integer(n)
  ans = rep(NA_real_, nx<-length(x))
  if (nf.rm) x[!is.finite(x)] = NA_real_ # algo=fast consistency due to https://bugs.r-project.org/bugzilla/show_bug.cgi?id=17441, actually affects also algo=exact #3353
  for (i in n:nx) ans[i]=mean(x[(i-n+1):i], na.rm=na.rm)
  ans
}

n = 4
x = 1:16
x[5] = NaN
test(6000.120, frollmean(x, n), ma(x, n))
test(6000.121, frollmean(x, n, algo="exact"), ma(x, n))
x[6] = NA
test(6000.122, frollmean(x, n), ma(x, n))
test(6000.123, frollmean(x, n, algo="exact"), ma(x, n)) # use do not use identical as NaN-NA behaviour is platform/compiler specific #3353
#### test inconsistency of NaN-NA order is consistent to https://bugs.r-project.org/bugzilla/show_bug.cgi?id=17441
x[5] = NA
x[6] = NaN
test(6000.124, frollmean(x, n), ma(x, n))
test(6000.125, frollmean(x, n, algo="exact"), ma(x, n))
x[5] = Inf
test(6000.126, frollmean(x, n), ma(x, n))
test(6000.127, frollmean(x, n, algo="exact"), ma(x, n))
x[6] = -Inf
test(6000.128, frollmean(x, n), ma(x, n))
test(6000.129, frollmean(x, n, algo="exact"), ma(x, n))
x[5:7] = c(NA, Inf, -Inf)
test(6000.130, frollmean(x, n), ma(x, n))
test(6000.131, frollmean(x, n, algo="exact"), ma(x, n))
x = c(Inf,-Inf,-Inf,Inf,Inf)
n = 2
test(6000.1311, frollmean(x, n), ma(x, n))
test(6000.1312, frollmean(x, n, algo="exact"), ma(x, n))
test(6000.1313, frollsum(x, n), c(NA,NaN,-Inf,NA,Inf))
test(6000.1314, frollsum(x, n, algo="exact"), c(NA,NaN,-Inf,NA,Inf))

#### adaptive window
ama = function(x, n, na.rm=FALSE, fill=NA, nf.rm=FALSE) {
  # adaptive moving average in R
  stopifnot((nx<-length(x))==length(n))
  if (nf.rm) x[!is.finite(x)] = NA_real_
  ans = rep(NA_real_, nx)
  for (i in seq_along(x)) {
    ans[i] = if (i >= n[i])
      mean(x[(i-n[i]+1):i], na.rm=na.rm)
    else as.double(fill)
  }
  ans
}

x = rnorm(1e3)
n = rep(20L, 1e3) # pseudo adaptive
test(6000.132, frollmean(x, n[1L]), frollmean(x, n, adaptive=TRUE)) # n auto wrapped in list
test(6000.133, frollmean(x, n[1L]), frollmean(x, list(n), adaptive=TRUE))
test(6000.134, frollmean(x, n[1L]), frollmean(x, n, algo="exact", adaptive=TRUE))

x = c(1:4,2:5,4:6,5L)
n = c(2L, 2L, 2L, 5L, 4L, 5L, 1L, 1L, 2L, 3L, 6L, 3L)
ans1 = ama(x, n)
ans2 = frollmean(x, list(n), adaptive=TRUE)
ans3 = frollmean(x, list(n), algo="exact", adaptive=TRUE)
test(6000.135, ans1, ans2)
test(6000.136, ans1, ans3)

x = data.table(x=x, y=x/2) # multiple columns and multiple windows
ln = list(n, n+1L)
ans1 = list(ama(x[[1L]], ln[[1L]]), ama(x[[1L]], ln[[2L]]), ama(x[[2L]], ln[[1L]]), ama(x[[2L]], ln[[2L]]))
ans2 = frollmean(x, ln, adaptive=TRUE)
ans3 = frollmean(x, ln, algo="exact", adaptive=TRUE)
test(6000.137, ans1, ans2)
test(6000.138, ans1, ans3)

#### adaptive fill
x = c(1:4,2:5,4:6,5L)
n = c(2L, 2L, 2L, 5L, 4L, 5L, 1L, 1L, 2L, 3L, 6L, 3L)
ans1 = ama(x, n, fill=150)
ans2 = frollmean(x, n, adaptive=TRUE, fill=150)
ans3 = frollmean(x, n, adaptive=TRUE, algo="exact", fill=150)
test(6000.139, ans1, ans2)
test(6000.140, ans1, ans3)

#### adaptive na.rm
x = c(1:4,NA,2:5,NA,4:6,NA,5L)
n = c(2L, 2L, 2L, 5L, 3L, 4L, 5L, 1L, 2L, 1L, 2L, 4L, 3L, 6L, 3L)
ans1 = ama(x, n)
ans2 = frollmean(x, n, adaptive=TRUE)
ans3 = frollmean(x, n, algo="exact", adaptive=TRUE)
test(6000.141, ans1, ans2)
test(6000.142, ans1, ans3)
ans1 = ama(x, n, na.rm=TRUE)
ans2 = frollmean(x, n, na.rm=TRUE, adaptive=TRUE)
ans3 = frollmean(x, n, na.rm=TRUE, algo="exact", adaptive=TRUE)
test(6000.143, ans1, ans2)
test(6000.144, ans1, ans3)
#### interactive test 3e9 vector where continuous 2.5e9 are NAs to confirm uint_fast64_t running NA counter
if (FALSE) {
  x = c(rep(1, 3e8), rep(NA_real_, 2.5e9), rep(1, 2e8))
  n1 = 1e3; n2 = 1e4
  n = c(rep(n1, 1.5e9), rep(n2, 1.5e9))
  stopifnot(length(x)==3e9, length(n)==3e9)
  ans = frollmean(x, list(n), adaptive=TRUE)
  stopifnot(
    all.equal(ans[1:(n1+1)], c(rep(NA_real_, n1-1), 1, 1)),
    all.equal(ans[3e8+(-1:1)], c(1, 1, NA)),
    all.equal(ans[2.8e9+n2+(-1:1)], c(NA_real_, 1, 1)),
    all.equal(ans[(3e9-n2):3e9], rep(1, n2+1))
  )
}

#### adaptive limitations
test(6000.145, frollmean(1:2, 1:2, adaptive=TRUE, align="right"), c(1, 1.5))
test(6000.146, frollmean(1:2, 1:2, adaptive=TRUE, align="center"), error="using adaptive TRUE and align 'center' is not implemented")
test(6000.147, frollmean(list(1:2, 1:3), list(1:2), adaptive=TRUE), error="adaptive rolling function can only process 'x' having equal length of elements, like data.table or data.frame. If you want to call rolling function on list having variable length of elements call it for each field separately")

#### adaptive align - added in #5441
options(datatable.verbose=TRUE)
test(6000.148, frollsum(c(1,3,4,2,0), c(3,2,2,3,2), adaptive=TRUE, align="left"), c(8,7,6,NA,NA), output=c("processing from align='right'"))
options(datatable.verbose=FALSE)
test(6000.1481, frollsum(c(1,3,4,2,0), list(c(3,2,2,3,2), c(3,3,3,3,3)), adaptive=TRUE, align="left"), list(c(8,7,6,NA,NA), c(8,9,6,NA,NA)))
test(6000.1482, frollsum(list(c(1,3,4,2,0), c(3,1,4,2,0)), c(3,2,2,3,2), adaptive=TRUE, align="left"), list(c(8,7,6,NA,NA), c(8,5,6,NA,NA)))
test(6000.1483, frollsum(list(c(1,3,4,2,0), c(3,1,4,2,0)), list(c(3,2,2,3,2), c(3,3,3,3,3)), adaptive=TRUE, align="left"), list(c(8,7,6,NA,NA),c(8,9,6,NA,NA),c(8,5,6,NA,NA),c(8,7,6,NA,NA)))

#### adaptive exact
fastama = function(x, n, na.rm, fill=NA) {
  if (!missing(na.rm)) stop("fast adaptive moving average implemented in R does not handle NAs, input having NAs will result in incorrect answer so not even try to compare to it")
  # fast implementation of adaptive moving average in R, in case of NAs incorrect answer
  stopifnot((nx<-length(x))==length(n))
  cs = cumsum(x)
  ans = rep(NA_real_, nx)
  for (i in seq_along(cs)) {
    ans[i] = if (i == n[i])
      cs[i]/n[i]
    else if (i > n[i])
      (cs[i]-cs[i-n[i]])/n[i]
    else as.double(fill)
  }
  ans
}
x = c(1:3, 1e9L, 2:5, 5e9, 4:6)
n = c(2L, 2L, 2L, 5L, 4L, 5L, 1L, 1L, 2L, 3L, 6L, 3L)
ans1 = ama(x, n)
ans2 = frollmean(x, n, adaptive=TRUE)
ans3 = frollmean(x, n, adaptive=TRUE, algo="exact")
ans4 = fastama(x, n)
test(6000.149, ans1, ans2)
test(6000.150, ans1, ans3)
test(6000.151, ans1, ans4)

x = sample(c(rnorm(1e3, 1e2), rnorm(1e1, 1e9, 1e2), abs(rnorm(1e1, 1e-9, 1e-2))))
n = sample(1:20, length(x), TRUE)
ans1 = ama(x, n)
ans2 = frollmean(x, n, adaptive=TRUE)
ans3 = frollmean(x, n, adaptive=TRUE, algo="exact")
ans4 = fastama(x, n)
anserr = list(
  froll_exact_f = ans1-ans2,
  froll_exact_t = ans1-ans3,
  fastama = ans1-ans4
)
errs = lapply(lapply(anserr, abs), sum, na.rm=TRUE)
test(6000.152, errs[["froll_exact_t"]] < errs[["froll_exact_f"]])
test(6000.153, errs[["froll_exact_t"]] < errs[["fastama"]])

x = sample(c(1:100, 5e9, 5e-9))
n = sample(1:10, length(x), TRUE)
ans1 = ama(x, n)
ans2 = frollmean(x, n, adaptive=TRUE)
ans3 = frollmean(x, n, adaptive=TRUE, algo="exact")
ans4 = fastama(x, n)
anserr = list(
  froll_exact_f = ans1-ans2,
  froll_exact_t = ans1-ans3,
  fastama = ans1-ans4
)
errs = lapply(lapply(anserr, abs), sum, na.rm=TRUE)
test(6000.154, errs[["froll_exact_t"]] < errs[["froll_exact_f"]])
test(6000.155, errs[["froll_exact_t"]] < errs[["fastama"]])

## edge cases adaptive
#### is.integer(n)
test(6000.156, frollmean(1:5, 1:5, adaptive=TRUE), seq(1,3,0.5))
#### is.integer(n) && length(n)!=length(x)
test(6000.157, frollmean(1:10, 1:5, adaptive=TRUE), error="length of integer vector(s) provided as list to 'n' argument must be equal to number of observations provided in 'x'")
#### is.list(n) && length(n[[1L]])!=length(x)
test(6000.158, frollmean(1:10, list(1:5), adaptive=TRUE), error="length of integer vector(s) provided as list to 'n' argument must be equal to number of observations provided in 'x'")

#### non-finite values (NA, NaN, Inf, -Inf)
n = c(4,1,4,5,5,4,6,5,4,4,2,3,4,3,2,4)
x = 1:16
x[5] = NaN
test(6000.159, frollmean(x, n, adaptive=TRUE), ama(x, n))
test(6000.160, frollmean(x, n, algo="exact", adaptive=TRUE), ama(x, n))
x[6] = NA
test(6000.161, frollmean(x, n, adaptive=TRUE), ama(x, n))
test(6000.162, frollmean(x, n, algo="exact", adaptive=TRUE), ama(x, n)) # use do not use identical as NaN-NA behaviour is platform/compiler specific #3353
#### test inconsistency of NaN-NA order is consistent to https://bugs.r-project.org/bugzilla/show_bug.cgi?id=17441
x[5] = NA
x[6] = NaN
test(6000.163, frollmean(x, n, adaptive=TRUE), ama(x, n))
test(6000.164, frollmean(x, n, algo="exact", adaptive=TRUE), ama(x, n))
x[5] = Inf
test(6000.165, frollmean(x, n, adaptive=TRUE), ama(x, n))
test(6000.166, frollmean(x, n, algo="exact", adaptive=TRUE), ama(x, n))
x[6] = -Inf
test(6000.167, frollmean(x, n, adaptive=TRUE), ama(x, n))
test(6000.168, frollmean(x, n, algo="exact", adaptive=TRUE), ama(x, n))
x[5:7] = c(NA, Inf, -Inf)
test(6000.169, frollmean(x, n, adaptive=TRUE), ama(x, n))
test(6000.170, frollmean(x, n, algo="exact", adaptive=TRUE), ama(x, n))

## test verbose messages
x = 1:10
n = 3
options(datatable.verbose=TRUE)
test(6000.171, frollmean(x, n), output=c(
  "frollfunR: allocating memory for results 1x1",
  "frollfunR: 1 column.*1 window.*",
  "frollfunR: 1:",
  "frollmeanFast: running for input length 10, window 3, hasnf 0, narm 0",
  "frollfun: processing fun 0 algo 0 took.*",
  "frollfunR: processing.*took.*"))
test(6000.172, frollmean(list(x, x+1), n), output=c(
  "frollfunR: allocating memory for results 2x1",
  "frollfunR: 2 column.*1 window.*",
  "frollfunR: 1:",
  "frollmeanFast: running for input length 10, window 3, hasnf 0, narm 0",
  "frollfun: processing fun 0 algo 0 took.*",
  "frollfunR: 2:",
  "frollmeanFast: running for input length 10, window 3, hasnf 0, narm 0",
  "frollfun: processing fun 0 algo 0 took.*",
  "frollfunR: processing.*took.*"))
test(6000.173, frollmean(x, c(n, n+1)), output=c(
  "frollfunR: allocating memory for results 1x2",
  "frollfunR: 1 column.*2 window.*",
  "frollfunR: 1:",
  "frollmeanFast: running for input length 10, window 3, hasnf 0, narm 0",
  "frollfun: processing fun 0 algo 0 took.*",
  "frollfunR: 2:",
  "frollmeanFast: running for input length 10, window 4, hasnf 0, narm 0",
  "frollfun: processing fun 0 algo 0 took.*",
  "frollfunR: processing.*took.*"))
test(6000.174, frollmean(list(x, x+1), c(n, n+1)), output=c(
  "frollfunR: allocating memory for results 2x2",
  "frollfunR: 2 column.*2 window.*",
  "frollfunR: 1:",
  "frollmeanFast: running for input length 10, window 3, hasnf 0, narm 0",
  "frollfun: processing fun 0 algo 0 took.*",
  "frollfunR: 2:",
  "frollmeanFast: running for input length 10, window 4, hasnf 0, narm 0",
  "frollfun: processing fun 0 algo 0 took.*",
  "frollfunR: 3:",
  "frollmeanFast: running for input length 10, window 3, hasnf 0, narm 0",
  "frollfun: processing fun 0 algo 0 took.*",
  "frollfunR: 4:",
  "frollmeanFast: running for input length 10, window 4, hasnf 0, narm 0",
  "frollfun: processing fun 0 algo 0 took.*",
  "frollfunR: processing.*took.*"))
test(6000.175, frollmean(x, n, algo="exact"), output=c(
  "frollfunR: allocating memory for results 1x1",
  "frollfunR: 1 column.*1 window.*",
  "frollfunR: 1:",
  "frollmeanExact: running in parallel for input length 10, window 3, hasnf 0, narm 0",
  "frollfun: processing fun 0 algo 1 took.*",
  "frollfunR: processing.*took.*"))
test(6000.176, frollmean(x, n, align="center"), output=c(
  "frollfunR: allocating memory for results 1x1",
  "frollfunR: 1 column.*1 window.*",
  "frollfunR: 1:",
  "frollmeanFast: running for input length 10, window 3, hasnf 0, narm 0",
  "frollfun: align 0, shift answer by -1",
  "frollfun: processing fun 0 algo 0 took.*",
  "frollfunR: processing.*took.*"))
test(6000.177, frollmean(x, n, align="left"), output=c(
  "frollfunR: allocating memory for results 1x1",
  "frollfunR: 1 column.*1 window.*",
  "frollfunR: 1:",
  "frollmeanFast: running for input length 10, window 3, hasnf 0, narm 0",
  "frollfun: align -1, shift answer by -2",
  "frollfun: processing fun 0 algo 0 took.*",
  "frollfunR: processing.*took.*"))
nn = c(1:4,2:3,1:4)
test(6000.178, frollmean(x, nn, adaptive=TRUE), output=c(
  "frollfunR: allocating memory for results 1x1",
  "frollfunR: 1 column.*1 window.*",
  "frollfunR: 1:",
  "frolladaptivemeanFast: running for input length 10, hasnf 0, narm 0",
  "frolladaptivefun: processing fun 0 algo 0 took.*",
  "frollfunR: processing.*took.*"))
test(6000.179, frollmean(x, nn, algo="exact", adaptive=TRUE), output=c(
  "frollfunR: allocating memory for results 1x1",
  "frollfunR: 1 column.*1 window.*",
  "frollfunR: 1:",
  "frolladaptivemeanExact: running in parallel for input length 10, hasnf 0, narm 0",
  "frolladaptivefun: processing fun 0 algo 1 took.*",
  "frollfunR: processing.*took.*"))

x[8] = NA
test(6000.180, frollmean(x, n), output=c(
  "frollfunR: allocating memory for results 1x1",
  "frollfunR: 1 column.*1 window.*",
  "frollfunR: 1:",
  "frollmeanFast: running for input length 10, window 3, hasnf 0, narm 0",
  "frollmeanFast: non-finite values are present in input, re-running with extra care for NFs",
  "frollfun: processing fun 0 algo 0 took.*",
  "frollfunR: processing.*took.*"))
test(6000.181, frollmean(x, n, algo="exact"), output=c(
  "frollfunR: allocating memory for results 1x1",
  "frollfunR: 1 column.*1 window.*",
  "frollfunR: 1:",
  "frollmeanExact: running in parallel for input length 10, window 3, hasnf 0, narm 0",
  "frollmeanExact: non-finite values are present in input, na.rm=FALSE and algo='exact' propagates NFs properply, no need to re-run",
  "frollfun: processing fun 0 algo 1 took.*",
  "frollfunR: processing.*took.*"))
test(6000.182, frollmean(x, nn, adaptive=TRUE), output=c(
  "frollfunR: allocating memory for results 1x1",
  "frollfunR: 1 column.*1 window.*",
  "frollfunR: 1:",
  "frolladaptivemeanFast: running for input length 10, hasnf 0, narm 0",
  "frolladaptivemeanFast: non-finite values are present in input, re-running with extra care for NFs",
  "frolladaptivefun: processing fun 0 algo 0 took.*",
  "frollfunR: processing.*took.*"))
test(6000.183, frollmean(x, nn, algo="exact", adaptive=TRUE), output=c(
  "frollfunR: allocating memory for results 1x1",
  "frollfunR: 1 column.*1 window.*",
  "frollfunR: 1:",
  "frolladaptivemeanExact: running in parallel for input length 10, hasnf 0, narm 0",
  "frolladaptivemeanExact: non-finite values are present in input, na.rm=FALSE and algo='exact' propagates NFs properply, no need to re-run",
  "frolladaptivefun: processing fun 0 algo 1 took.*",
  "frollfunR: processing.*took.*"))

d = as.data.table(list(1:10/2, 10:1/4))
test(6000.184, frollmean(d[,1], 3, algo="exact"), output=c(
  "frollfunR: allocating memory for results 1x1",
  "frollfunR: 1 column.*1 window.*",
  "frollfunR: 1:",
  "frollmeanExact: running in parallel for input length 10, window 3, hasnf 0, narm 0",
  "frollfun: processing fun 0 algo 1 took.*",
  "frollfunR: processing.*took.*"
))
test(6000.185, frollmean(d, 3:4, algo="exact"), output=c(
  "frollfunR: allocating memory for results 2x2",
  "frollfunR: 2 column.*2 window.*",
  "frollfunR: 1:",
  "frollmeanExact: running in parallel for input length 10, window 3, hasnf 0, narm 0",
  "frollfun: processing fun 0 algo 1 took.*",
  "frollfunR: 2:",
  "frollmeanExact: running in parallel for input length 10, window 4, hasnf 0, narm 0",
  "frollfun: processing fun 0 algo 1 took.*",
  "frollfunR: 3:",
  "frollmeanExact: running in parallel for input length 10, window 3, hasnf 0, narm 0",
  "frollfun: processing fun 0 algo 1 took.*",
  "frollfunR: 4:",
  "frollmeanExact: running in parallel for input length 10, window 4, hasnf 0, narm 0",
  "frollfun: processing fun 0 algo 1 took.*",
  "frollfunR: processing.*took.*"
))
options(datatable.verbose=FALSE)

## test warnings
test(6000.186, frollmean(c(1:2,NA,4:10), 4, has.nf=FALSE), c(rep(NA_real_, 6), 5.5, 6.5, 7.5, 8.5), warning="has.nf=FALSE used but non-finite values are present in input, use default has.nf=NA to avoid this warning")
test(6000.187, frollmean(c(1:2,NA,4:10), 2, has.nf=FALSE), c(NA, 1.5, NA, NA, 4.5, 5.5, 6.5, 7.5, 8.5, 9.5), warning="has.nf=FALSE used but non-finite values are present in input, use default has.nf=NA to avoid this warning")
test(6000.188, frollmean(c(1:2,NA,4:10), 4, has.nf=FALSE, algo="exact"), c(rep(NA_real_, 6), 5.5, 6.5, 7.5, 8.5), warning="has.nf=FALSE used but non-finite values are present in input, use default has.nf=NA to avoid this warning")
test(6000.189, frollmean(c(1:2,NA,4:10), 2, has.nf=FALSE, algo="exact"), c(NA, 1.5, NA, NA, 4.5, 5.5, 6.5, 7.5, 8.5, 9.5), warning="has.nf=FALSE used but non-finite values are present in input, use default has.nf=NA to avoid this warning")
test(6000.190, frollmean(c(1:2,NA,4:10), rep(4L,10), adaptive=TRUE, has.nf=FALSE), c(rep(NA_real_, 6), 5.5, 6.5, 7.5, 8.5), warning="has.nf=FALSE used but non-finite values are present in input, use default has.nf=NA to avoid this warning")
test(6000.191, frollmean(c(1:2,NA,4:10), rep(2L,10), adaptive=TRUE, has.nf=FALSE), c(NA, 1.5, NA, NA, 4.5, 5.5, 6.5, 7.5, 8.5, 9.5), warning="has.nf=FALSE used but non-finite values are present in input, use default has.nf=NA to avoid this warning")
test(6000.192, frollmean(c(1:2,NA,4:10), rep(4L,10), adaptive=TRUE, has.nf=FALSE, algo="exact"), c(rep(NA_real_, 6), 5.5, 6.5, 7.5, 8.5), warning="has.nf=FALSE used but non-finite values are present in input, use default has.nf=NA to avoid this warning")
test(6000.193, frollmean(c(1:2,NA,4:10), rep(2L,10), adaptive=TRUE, has.nf=FALSE, algo="exact"), c(NA, 1.5, NA, NA, 4.5, 5.5, 6.5, 7.5, 8.5, 9.5), warning="has.nf=FALSE used but non-finite values are present in input, use default has.nf=NA to avoid this warning")
test(6000.199, frollmean(1:2, 1, hasNA=TRUE), c(1,2), warning="hasNA is deprecated, use has.nf instead")
test(6000.1991, frollmean(1:2, 1, has.nf=FALSE, hasNA=TRUE), error="hasNA is deprecated, use has.nf instead")

## frollsum
x = 1:6/2
ans1 = frollsum(x, 3)
expected = c(rep(NA_real_,2), c(3,4.5,6,7.5))
test(6000.201, ans1, expected)
n = c(2L, 2L, 3L, 4L, 2L, 3L)
ans1 = frollsum(x, n, adaptive=TRUE)
expected = c(NA_real_, 1.5, 3, 5, 4.5, 7.5)
test(6000.202, ans1, expected)
## frollsum coverage
options(datatable.verbose=TRUE)
test(6000.211, frollsum(1:5, 6), rep(NA_real_, 5L), output="window width longer than input vector")
options(datatable.verbose=FALSE)
test(6000.212, frollsum(c(1:2,NA,4:10), 4, has.nf=FALSE), c(rep(NA_real_, 6), 22, 26, 30, 34), warning="has.nf=FALSE used but non-finite values are present in input, use default has.nf=NA to avoid this warning")
test(6000.213, frollsum(c(1:2,NA,4:10), 2, has.nf=FALSE), c(NA, 3, NA, NA, 9, 11, 13, 15, 17, 19), warning="has.nf=FALSE used but non-finite values are present in input, use default has.nf=NA to avoid this warning")
test(6000.214, frollsum(c(1:2,NA,4:10), 4, has.nf=FALSE, algo="exact"), c(rep(NA_real_, 6), 22, 26, 30, 34), warning="has.nf=FALSE used but non-finite values are present in input, use default has.nf=NA to avoid this warning")
options(datatable.verbose=TRUE)
test(6000.215, frollsum(c(1:2,NA,4:10), 4, algo="exact", na.rm=TRUE), c(rep(NA_real_, 3L), 7, 11, 15, 22, 26, 30, 34), output="non-finite values are present in input, re-running with extra care for NFs")
test(6000.216, frollsum(c(1:2,NA,4:10), 4, algo="exact"), c(rep(NA_real_, 6), 22, 26, 30, 34), output="non-finite values are present in input, na.rm=FALSE and algo='exact' propagates NFs properply, no need to re-run")
options(datatable.verbose=FALSE)
test(6000.217, frollsum(c(1:2,NA,4:10), rep(4L,10), adaptive=TRUE, has.nf=FALSE), c(rep(NA_real_, 6), 22, 26, 30, 34), warning="has.nf=FALSE used but non-finite values are present in input, use default has.nf=NA to avoid this warning")
test(6000.218, frollsum(c(1:2,NA,4:10), rep(4L,10), adaptive=TRUE, has.nf=FALSE, algo="exact"), c(rep(NA_real_, 6), 22, 26, 30, 34), warning="has.nf=FALSE used but non-finite values are present in input, use default has.nf=NA to avoid this warning")
options(datatable.verbose=TRUE)
test(6000.219, frollsum(c(1:2,NA,4:10), rep(4L,10), adaptive=TRUE, algo="exact", na.rm=TRUE), c(rep(NA_real_, 3L), 7, 11, 15, 22, 26, 30, 34), output="non-finite values are present in input, re-running with extra care for NFs")
test(6000.220, frollsum(c(1:2,NA,4:10), rep(4L,10), adaptive=TRUE, algo="exact"), c(rep(NA_real_, 6), 22, 26, 30, 34), output="non-finite values are present in input, na.rm=FALSE and algo='exact' propagates NFs properply, no need to re-run")
test(6000.221, frollsum(1:3, 2), c(NA, 3, 5), output="frollsumFast: running for input length")
test(6000.222, frollsum(1:3, 2, align="left"), c(3, 5, NA), output="frollfun: align")
test(6000.223, frollsum(c(1,2,NA), 2), c(NA, 3, NA), output="non-finite values are present in input, re-running with extra care for NFs")
test(6000.224, frollsum(c(NA,2,3), 2), c(NA, NA, 5), output="non-finite values are present in input, skip non-finite unaware attempt and run with extra care for NFs straighaway")
test(6000.225, frollsum(1:3, c(2,2,2), adaptive=TRUE), c(NA, 3, 5), output="frolladaptivesumFast: running for input length")
test(6000.226, frollsum(c(NA,2,3), c(2,2,2), adaptive=TRUE), c(NA, NA, 5), output="non-finite values are present in input, re-running with extra care for NFs")
options(datatable.verbose=FALSE)

## frollmax adaptive
options(datatable.verbose=TRUE) ## adaptive frollmax no fast algo
test(6000.3, frollmax(1:4, c(2,2,2,2), adaptive=TRUE), output="frolladaptivefun: algo 0 not implemented, fall back to 1")
test(6000.3001, frollmax(1:4, c(2,2,2,2), algo="fast", adaptive=TRUE), output="frolladaptivefun: algo 0 not implemented, fall back to 1")
test(6000.3002, frollmax(1:4, c(2,2,2,2), algo="exact", adaptive=TRUE), notOutput="frolladaptivefun: algo 0 not implemented, fall back to 1")
options(datatable.verbose=FALSE)
n = c(3,2,2,4,2,1,4,8)
x = c(7,2,3,6,3,2,6,6) # no NA
test(6000.3111, frollmax(x, n, adaptive=TRUE), c(NA,7,3,7,6,2,6,7)) # has.nf=NA # narm=F
test(6000.3112, frollmax(x, n, na.rm=TRUE, adaptive=TRUE), c(NA,7,3,7,6,2,6,7)) # narm=T
test(6000.3121, frollmax(x, n, has.nf=FALSE, adaptive=TRUE), c(NA,7,3,7,6,2,6,7)) # has.nf=F
test(6000.3122, frollmax(x, n, has.nf=FALSE, na.rm=TRUE, adaptive=TRUE), error="does not make sense")
test(6000.3131, frollmax(x, n, has.nf=TRUE, adaptive=TRUE), c(NA,7,3,7,6,2,6,7)) # has.nf=T
test(6000.3132, frollmax(x, n, has.nf=TRUE, na.rm=TRUE, adaptive=TRUE), c(NA,7,3,7,6,2,6,7))
x = c(7,2,NA,6,3,NA,6,6) # NA
test(6000.3211, frollmax(x, n, adaptive=TRUE), c(NA,7,NA,NA,6,NA,NA,NA))
test(6000.3212, frollmax(x, n, na.rm=TRUE, adaptive=TRUE), c(NA,7,2,7,6,-Inf,6,7))
test(6000.3221, frollmax(x, n, has.nf=FALSE, adaptive=TRUE), c(NA,7,2,7,6,-Inf,6,7)) ## expected incorrect results, see manual has.nf section for details, added in #5441
test(6000.3222, frollmax(x, n, has.nf=FALSE, na.rm=TRUE, adaptive=TRUE), error="does not make sense")
test(6000.3231, frollmax(x, n, has.nf=TRUE, adaptive=TRUE), c(NA,7,NA,NA,6,NA,NA,NA))
test(6000.3232, frollmax(x, n, has.nf=TRUE, na.rm=TRUE, adaptive=TRUE), c(NA,7,2,7,6,-Inf,6,7))
x = rep(NA_real_, 8) # all NA
test(6000.3241, frollmax(x, n, adaptive=TRUE), rep(NA_real_, 8))
test(6000.3242, frollmax(x, n, na.rm=TRUE, adaptive=TRUE), c(NA, rep(-Inf, 7)))
test(6000.3251, frollmax(x, n, has.nf=FALSE, adaptive=TRUE), c(NA, rep(-Inf, 7)))
test(6000.3252, frollmax(x, n, has.nf=FALSE, na.rm=TRUE, adaptive=TRUE), error="does not make sense")
test(6000.3261, frollmax(x, n, has.nf=TRUE, adaptive=TRUE), rep(NA_real_, 8))
test(6000.3262, frollmax(x, n, has.nf=TRUE, na.rm=TRUE, adaptive=TRUE), c(NA, rep(-Inf, 7)))
x = c(NA,NaN,NA,NaN,NaN,NaN,NA,NA) # all NaN/NA
test(6000.3271, frollmax(x, n, adaptive=TRUE), c(NA,NA,NA,NA,NaN,NaN,NA,NA))
test(6000.3272, frollmax(x, n, na.rm=TRUE, adaptive=TRUE), c(NA,-Inf,-Inf,-Inf,-Inf,-Inf,-Inf,-Inf))
test(6000.3281, frollmax(x, n, has.nf=FALSE, adaptive=TRUE), c(NA,-Inf,-Inf,-Inf,-Inf,-Inf,-Inf,-Inf)) ## expected incorrect results, see manual has.nf section for details, added in #5441
test(6000.3282, frollmax(x, n, has.nf=FALSE, na.rm=TRUE, adaptive=TRUE), error="does not make sense")
test(6000.3291, frollmax(x, n, has.nf=TRUE, adaptive=TRUE), c(NA,NA,NA,NA,NaN,NaN,NA,NA))
test(6000.3292, frollmax(x, n, has.nf=TRUE, na.rm=TRUE, adaptive=TRUE), c(NA,-Inf,-Inf,-Inf,-Inf,-Inf,-Inf,-Inf))
x = c(7,2,NA,6,3,Inf,6,6) # Inf
test(6000.3311, frollmax(x, n, adaptive=TRUE), c(NA,7,NA,NA,6,Inf,Inf,NA))
test(6000.3312, frollmax(x, n, na.rm=TRUE, adaptive=TRUE), c(NA,7,2,7,6,Inf,Inf,Inf))
test(6000.3321, frollmax(x, n, has.nf=FALSE, adaptive=TRUE), c(NA,7,2,7,6,Inf,Inf,Inf)) ## expected incorrect results, see manual has.nf section for details, added in #5441
test(6000.3322, frollmax(x, n, has.nf=FALSE, na.rm=TRUE, adaptive=TRUE), error="does not make sense")
test(6000.3331, frollmax(x, n, has.nf=TRUE, adaptive=TRUE), c(NA,7,NA,NA,6,Inf,Inf,NA))
test(6000.3332, frollmax(x, n, has.nf=TRUE, na.rm=TRUE, adaptive=TRUE), c(NA,7,2,7,6,Inf,Inf,Inf))
x = c(7,2,-Inf,6,3,NA,6,6) # -Inf
test(6000.3341, frollmax(x, n, adaptive=TRUE), c(NA,7,2,7,6,NA,NA,NA))
test(6000.3342, frollmax(x, n, na.rm=TRUE, adaptive=TRUE), c(NA,7,2,7,6,-Inf,6,7))
test(6000.3351, frollmax(x, n, has.nf=FALSE, adaptive=TRUE), c(NA,7,2,7,6,-Inf,6,7)) ## expected incorrect results, see manual has.nf section for details, added in #5441
test(6000.3352, frollmax(x, n, has.nf=FALSE, na.rm=TRUE, adaptive=TRUE), error="does not make sense")
test(6000.3361, frollmax(x, n, has.nf=TRUE, adaptive=TRUE), c(NA,7,2,7,6,NA,NA,NA))
test(6000.3362, frollmax(x, n, has.nf=TRUE, na.rm=TRUE, adaptive=TRUE), c(NA,7,2,7,6,-Inf,6,7))

## frollmax non-adaptive
options(datatable.verbose=TRUE)
test(6000.4001, frollmax(1:3, 2), c(NA, 2, 3), output="frollmaxFast: running for input length")
test(6000.4002, frollmax(1:10, 5), c(NA,NA,NA,NA,5,6,7,8,9,10), output="frollmaxFast: nested window max calculation called 0 times")
test(6000.4003, frollmax(10:1, 5), c(NA,NA,NA,NA,10,9,8,7,6,5), output="frollmaxFast: nested window max calculation called 5 times")
test(6000.4004, frollmax(1:3, 2, algo="exact"), c(NA, 2, 3), output="frollmaxExact: running in parallel for input length")
test(6000.4005, frollmax(c(1,2,3,NA,5), 2), c(NA, 2, 3, NA, NA), output="continue with extra care for NFs")
options(datatable.verbose=FALSE)
n = 3
x = c(7,2,3,6,3,2,4,5) # no NA
ans = c(NA,NA,7,6,6,6,4,5)
test(6000.4111, frollmax(x, n), ans) # has.nf=NA # narm=F
test(6000.4112, frollmax(x, n, na.rm=TRUE), ans) # narm=T
test(6000.4113, frollmax(x, n, algo="exact"), ans) # has.nf=NA # narm=F
test(6000.4114, frollmax(x, n, algo="exact", na.rm=TRUE), ans) # narm=T
test(6000.4121, frollmax(x, n, has.nf=FALSE), ans) # has.nf=F
test(6000.4122, frollmax(x, n, has.nf=FALSE, na.rm=TRUE), error="does not make sense")
test(6000.4123, frollmax(x, n, algo="exact", has.nf=FALSE), ans) # has.nf=F
test(6000.4124, frollmax(x, n, algo="exact", has.nf=FALSE, na.rm=TRUE), error="does not make sense")
test(6000.4131, frollmax(x, n, has.nf=TRUE), ans) # has.nf=T
test(6000.4132, frollmax(x, n, has.nf=TRUE, na.rm=TRUE), ans)
test(6000.4133, frollmax(x, n, algo="exact", has.nf=TRUE), ans) # has.nf=T
test(6000.4134, frollmax(x, n, algo="exact", has.nf=TRUE, na.rm=TRUE), ans)
x = c(7,2,3,NA,3,2,4,NA) # NA
test(6000.4211, frollmax(x, n), c(NA,NA,7,NA,NA,NA,4,NA))
test(6000.4212, frollmax(x, n, na.rm=TRUE), c(NA,NA,7,3,3,3,4,4))
test(6000.4213, frollmax(x, n, algo="exact"), c(NA,NA,7,NA,NA,NA,4,NA))
test(6000.4214, frollmax(x, n, algo="exact", na.rm=TRUE), c(NA,NA,7,3,3,3,4,4))
test(6000.4221, frollmax(x, n, has.nf=FALSE), c(NA,NA,7,3,3,3,4,4)) ## expected incorrect results, see manual has.nf section for details, added in #5441
test(6000.4222, frollmax(x, n, has.nf=FALSE, na.rm=TRUE), error="does not make sense")
test(6000.4223, frollmax(x, n, algo="exact", has.nf=FALSE), c(NA,NA,7,3,3,3,4,4)) ## expected incorrect results, see manual has.nf section for details, added in #5441
test(6000.4224, frollmax(x, n, algo="exact", has.nf=FALSE, na.rm=TRUE), error="does not make sense")
test(6000.4231, frollmax(x, n, has.nf=TRUE), c(NA,NA,7,NA,NA,NA,4,NA))
test(6000.4232, frollmax(x, n, has.nf=TRUE, na.rm=TRUE), c(NA,NA,7,3,3,3,4,4))
test(6000.4233, frollmax(x, n, algo="exact", has.nf=TRUE), c(NA,NA,7,NA,NA,NA,4,NA))
test(6000.4234, frollmax(x, n, algo="exact", has.nf=TRUE, na.rm=TRUE), c(NA,NA,7,3,3,3,4,4))
x = rep(NA_real_, 8) # all NA
test(6000.4241, frollmax(x, n), rep(NA_real_, 8))
test(6000.4242, frollmax(x, n, na.rm=TRUE), c(NA,NA, rep(-Inf, 6)))
test(6000.4243, frollmax(x, n, algo="exact"), rep(NA_real_, 8))
test(6000.4244, frollmax(x, n, algo="exact", na.rm=TRUE), c(NA,NA, rep(-Inf, 6)))
test(6000.4251, frollmax(x, n, has.nf=FALSE), c(NA,NA, rep(-Inf, 6)))
test(6000.4252, frollmax(x, n, has.nf=FALSE, na.rm=TRUE), error="does not make sense")
test(6000.4253, frollmax(x, n, algo="exact", has.nf=FALSE), c(NA,NA, rep(-Inf, 6)))
test(6000.4254, frollmax(x, n, algo="exact", has.nf=FALSE, na.rm=TRUE), error="does not make sense")
test(6000.4261, frollmax(x, n, has.nf=TRUE), rep(NA_real_, 8))
test(6000.4262, frollmax(x, n, has.nf=TRUE, na.rm=TRUE), c(NA,NA, rep(-Inf, 6)))
test(6000.4263, frollmax(x, n, algo="exact", has.nf=TRUE), rep(NA_real_, 8))
test(6000.4264, frollmax(x, n, algo="exact", has.nf=TRUE, na.rm=TRUE), c(NA,NA, rep(-Inf, 6)))
x = c(NA,NaN,NA,NaN,NaN,NaN,NA,NA) # all NaN/NA
test(6000.4271, frollmax(x, n), c(NA,NA,NA,NA,NA,NaN,NA,NA))
test(6000.4272, frollmax(x, n, na.rm=TRUE), c(NA,NA,-Inf,-Inf,-Inf,-Inf,-Inf,-Inf))
test(6000.4273, frollmax(x, n, algo="exact"), c(NA,NA,NA,NA,NA,NaN,NA,NA))
test(6000.4274, frollmax(x, n, algo="exact", na.rm=TRUE), c(NA,NA,-Inf,-Inf,-Inf,-Inf,-Inf,-Inf))
test(6000.4281, frollmax(x, n, has.nf=FALSE), c(NA,NA,-Inf,-Inf,-Inf,-Inf,-Inf,-Inf)) ## expected incorrect results, see manual has.nf section for details, added in #5441
test(6000.4282, frollmax(x, n, has.nf=FALSE, na.rm=TRUE), error="does not make sense")
test(6000.4283, frollmax(x, n, algo="exact", has.nf=FALSE), c(NA,NA,-Inf,-Inf,-Inf,-Inf,-Inf,-Inf)) ## expected incorrect results, see manual has.nf section for details, added in #5441
test(6000.4284, frollmax(x, n, algo="exact", has.nf=FALSE, na.rm=TRUE), error="does not make sense")
test(6000.4291, frollmax(x, n, has.nf=TRUE), c(NA,NA,NA,NA,NA,NaN,NA,NA))
test(6000.4292, frollmax(x, n, has.nf=TRUE, na.rm=TRUE), c(NA,NA,-Inf,-Inf,-Inf,-Inf,-Inf,-Inf))
test(6000.4293, frollmax(x, n, algo="exact", has.nf=TRUE), c(NA,NA,NA,NA,NA,NaN,NA,NA))
test(6000.4294, frollmax(x, n, algo="exact", has.nf=TRUE, na.rm=TRUE), c(NA,NA,-Inf,-Inf,-Inf,-Inf,-Inf,-Inf))
x = c(NA,2,6,3,Inf,2,4,5) # Inf
test(6000.4311, frollmax(x, n), c(NA,NA,NA,6,Inf,Inf,Inf,5))
test(6000.4312, frollmax(x, n, na.rm=TRUE), c(NA,NA,6,6,Inf,Inf,Inf,5))
test(6000.4313, frollmax(x, n, algo="exact"), c(NA,NA,NA,6,Inf,Inf,Inf,5))
test(6000.4314, frollmax(x, n, algo="exact", na.rm=TRUE), c(NA,NA,6,6,Inf,Inf,Inf,5))
test(6000.4321, frollmax(x, n, has.nf=FALSE), c(NA,NA,6,6,Inf,Inf,Inf,5)) ## expected incorrect results, see manual has.nf section for details, added in #5441
test(6000.4322, frollmax(x, n, has.nf=FALSE, na.rm=TRUE), error="does not make sense")
test(6000.4323, frollmax(x, n, algo="exact", has.nf=FALSE), c(NA,NA,6,6,Inf,Inf,Inf,5)) ## expected incorrect results, see manual has.nf section for details, added in #5441
test(6000.4324, frollmax(x, n, algo="exact", has.nf=FALSE, na.rm=TRUE), error="does not make sense")
test(6000.4331, frollmax(x, n, has.nf=TRUE), c(NA,NA,NA,6,Inf,Inf,Inf,5))
test(6000.4332, frollmax(x, n, has.nf=TRUE, na.rm=TRUE), c(NA,NA,6,6,Inf,Inf,Inf,5))
test(6000.4333, frollmax(x, n, algo="exact", has.nf=TRUE), c(NA,NA,NA,6,Inf,Inf,Inf,5))
test(6000.4334, frollmax(x, n, algo="exact", has.nf=TRUE, na.rm=TRUE), c(NA,NA,6,6,Inf,Inf,Inf,5))
x = c(NA,2,-Inf,3,Inf,2,4,5) # -Inf
test(6000.4341, frollmax(x, n), c(NA,NA,NA,3,Inf,Inf,Inf,5))
test(6000.4342, frollmax(x, n, na.rm=TRUE), c(NA,NA,2,3,Inf,Inf,Inf,5))
test(6000.4343, frollmax(x, n, algo="exact"), c(NA,NA,NA,3,Inf,Inf,Inf,5))
test(6000.4344, frollmax(x, n, algo="exact", na.rm=TRUE), c(NA,NA,2,3,Inf,Inf,Inf,5))
test(6000.4351, frollmax(x, n, has.nf=FALSE), c(NA,NA,2,3,Inf,Inf,Inf,5)) ## expected incorrect results, see manual has.nf section for details, added in #5441
test(6000.4352, frollmax(x, n, has.nf=FALSE, na.rm=TRUE), error="does not make sense")
test(6000.4353, frollmax(x, n, algo="exact", has.nf=FALSE), c(NA,NA,2,3,Inf,Inf,Inf,5)) ## expected incorrect results, see manual has.nf section for details, added in #5441
test(6000.4354, frollmax(x, n, algo="exact", has.nf=FALSE, na.rm=TRUE), error="does not make sense")
test(6000.4361, frollmax(x, n, has.nf=TRUE), c(NA,NA,NA,3,Inf,Inf,Inf,5))
test(6000.4362, frollmax(x, n, has.nf=TRUE, na.rm=TRUE), c(NA,NA,2,3,Inf,Inf,Inf,5))
test(6000.4363, frollmax(x, n, algo="exact", has.nf=TRUE), c(NA,NA,NA,3,Inf,Inf,Inf,5))
test(6000.4364, frollmax(x, n, algo="exact", has.nf=TRUE, na.rm=TRUE), c(NA,NA,2,3,Inf,Inf,Inf,5))
# edge cases
test(6000.501, frollmax(c(5,NA,1), 1L), c(5,NA,1)) ## na.rm=FALSE window recalc and NA happens to be the first element in a nested loop ## didn't help for codecov, adding internal error to wmax till we have a data that can reach there
test(6000.502, frollmax(c(5,NaN,1), 1L), c(5,NaN,1))
test(6000.503, frollmax(c(5,1,1,NaN,1,1,1), 2L), c(NA,5,1,NaN,NaN,1,1))
test(6000.504, frollmax(c(5,1,NA,NaN,1,1,1), 2L), c(NA,5,NA,NA,NaN,1,1))

## partial
x = 1:6/2
n = 3
an = function(n, len) c(seq.int(n), rep(n, len-n))
test(6006.011, frollmean(x, an(n, length(x)), adaptive=TRUE), c(0.5,0.75,1,1.5,2,2.5))
test(6006.012, frollmean(x, n, partial=TRUE), c(0.5,0.75,1,1.5,2,2.5))
ans = frollmean(x, n)
ans[seq.int(n-1L)] = frollmean(x[seq.int(n-1L)], n, partial=TRUE)
test(6006.013, ans, c(0.5,0.75,1,1.5,2,2.5))
test(6006.021, frollmean(x, rev(an(rev(n), length(x))), adaptive=TRUE, align="left"), c(1,1.5,2,2.5,2.75,3))
test(6006.022, frollmean(x, n, partial=TRUE, align="left"), c(1,1.5,2,2.5,2.75,3))
ans = frollmean(x, n, align="left")
ans[(length(x)-n-1L):length(x)] = frollmean(x[(length(x)-n-1L):length(x)], n, partial=TRUE, align="left")
test(6006.023, ans, c(1,1.5,2,2.5,2.75,3))
ans = list(c(0.50,0.75,1.00,1.50,2.00,2.50), c(0.50,0.75,1.00,1.25,1.75,2.25))
test(6006.031, frollmean(1:6/2, list(3L,4L), partial=TRUE), error="n must be an integer, list is accepted for adaptive TRUE")
test(6006.032, frollmean(1:6/2, 3:4, partial=TRUE), ans)
options(datatable.verbose=TRUE)
test(6006.901, frollmean(x, n, partial=TRUE), c(0.5,0.75,1,1.5,2,2.5), output="froll partial=TRUE trimming 'n' and redirecting to adaptive=TRUE")
test(6006.902, frollmean(x, rep(n, length(x)), adaptive=TRUE, partial=TRUE), c(0.5,0.75,1,1.5,2,2.5), output="trimming", notOutput="redirecting")
options(datatable.verbose=FALSE)
test(6006.903, frollmean(1:4, 2L, align="center", partial=TRUE), error="'partial' cannot be used together with align='center'")
test(6006.904, frollmean(list(1:4, 2:4), n, partial=TRUE), error="'partial' does not support variable length of columns in 'x'")
test(6006.905, frollmean(x, TRUE, partial=TRUE), error="n must be an integer vector or a list of integer vectors")
test(6006.906, frollmean(x, list(TRUE), partial=TRUE), error="n must be an integer, list is accepted for adaptive TRUE")
test(6006.907, frollsum(1:4, integer(), partial = TRUE), error = "n must be non 0 length")

## partial adaptive
test(6006.930, frollmean(1:4, rep(2L,4L), adaptive=TRUE, partial=TRUE), c(1,1.5,2.5,3.5))
test(6006.9301, frollmean(1:4, list(1:4, 1:3), adaptive=TRUE, partial=TRUE), error="adaptive window provided in 'n' must not to have different lengths")
test(6006.9302, frollmean(1:4, list(1:3), adaptive=TRUE, partial=TRUE), error="length of vectors in 'x' must match to length of adaptive window in 'n'")
test(6006.9303, frollmean(1:4, list(rep(2L,4L)), adaptive=TRUE, partial=TRUE), c(1,1.5,2.5,3.5))
test(6006.9311, frollsum(1:4, 1:4, adaptive=TRUE, partial=TRUE), c(1,3,6,10)) ## all same as index
test(6006.9312, frollsum(1:4, 1:4, align="left", adaptive=TRUE, partial=TRUE), c(1,5,7,4))
test(6006.9321, frollsum(1:4, c(2,3,1,1), adaptive=TRUE, partial=TRUE), c(1,3,3,4)) ## leading two bigger than index
test(6006.9322, frollsum(1:4, c(2,3,1,1), align="left", adaptive=TRUE, partial=TRUE), c(3,9,3,4))
test(6006.9323, frollsum(1:4, c(6,5,4,2), adaptive=TRUE, partial=TRUE), c(1,3,6,7)) ## leading two bigger than rev index
test(6006.9324, frollsum(1:4, c(6,5,4,2), align="left", adaptive=TRUE, partial=TRUE), c(10,9,7,4))
test(6006.9331, frollsum(1:4, c(2,4,5,6), adaptive=TRUE, partial=TRUE), c(1,3,6,10)) ## trailing two bigger than index
test(6006.9332, frollsum(1:4, c(2,4,5,6), align="left", adaptive=TRUE, partial=TRUE), c(3,9,7,4))
test(6006.9333, frollsum(1:4, c(1,1,3,2), adaptive=TRUE, partial=TRUE), c(1,2,6,7)) ## trailing two bigger than rev index
test(6006.9334, frollsum(1:4, c(1,1,3,2), align="left", adaptive=TRUE, partial=TRUE), c(1,2,7,4))
test(6006.9335, frollsum(1:4, list(c(1,1,3,2), c("a","b","c","d")), adaptive=TRUE, partial=TRUE), error = "n must be an integer vector or a list of integer vectors")
test(6006.9336, frollsum(1:4, c(1,2,3), adaptive=TRUE, partial=TRUE), error = "length of 'n' argument must be equal to number of observations provided in 'x'")

## give.names
test(6006.9511, frollsum(c(1,2,3), 2, give.names=TRUE), c(NA,3,5))
test(6006.9512, frollsum(c(1,2,3), c(b=2), give.names=TRUE), c(NA,3,5))
test(6006.9513, frollsum(c(a1=1,a2=2,a3=3), c(b=2), give.names=TRUE), c(NA,3,5))
test(6006.9514, frollsum(c(a1=1,a2=2,a3=3), 2, give.names=TRUE), c(NA,3,5))
test(6006.952, frollsum(list(c(1,2,3)), 2, give.names=TRUE), list(V1_rollsum2=c(NA,3,5)))
test(6006.953, frollsum(list(x1=c(1,2,3)), 2, give.names=TRUE), list(x1_rollsum2=c(NA,3,5)))
test(6006.954, frollsum(list(c(1,2,3)), c(n1=2), give.names=TRUE), list(V1_n1=c(NA,3,5)))
test(6006.955, frollsum(list(x1=c(1,2,3)), c(n1=2), give.names=TRUE), list(x1_n1=c(NA,3,5)))
test(6006.956, frollsum(c(1,2,3), 2:3, give.names=TRUE), list(rollsum2=c(NA,3,5), rollsum3=c(NA,NA,6)))
test(6006.957, frollsum(list(c(1,2,3)), 2:3, give.names=TRUE), list(V1_rollsum2=c(NA,3,5), V1_rollsum3=c(NA,NA,6)))
test(6006.958, frollsum(list(c(1,2,3), c(2,3,4)), 2, give.names=TRUE), list(V1_rollsum2=c(NA,3,5), V2_rollsum2=c(NA,5,7)))
test(6006.959, frollsum(list(c(1,2,3), c(2,3,4)), 2:3, give.names=TRUE), list(V1_rollsum2=c(NA,3,5), V1_rollsum3=c(NA,NA,6), V2_rollsum2=c(NA,5,7), V2_rollsum3=c(NA,NA,9)))
test(6006.960, frollsum(c(1,2,3), c(n1=2, n2=3), give.names=TRUE), list(n1=c(NA,3,5), n2=c(NA,NA,6)))
test(6006.961, frollsum(list(c(1,2,3)), c(n1=2, n2=3), give.names=TRUE), list(V1_n1=c(NA,3,5), V1_n2=c(NA,NA,6)))
test(6006.962, frollsum(list(x1=c(1,2,3)), 2:3, give.names=TRUE), list(x1_rollsum2=c(NA,3,5), x1_rollsum3=c(NA,NA,6)))
test(6006.963, frollsum(list(x1=c(1,2,3)), c(n1=2, n2=3), give.names=TRUE), list(x1_n1=c(NA,3,5), x1_n2=c(NA,NA,6)))
test(6006.964, frollsum(list(c(1,2,3), c(2,3,4)), c(n1=2), give.names=TRUE), list(V1_n1=c(NA,3,5), V2_n1=c(NA,5,7)))
test(6006.965, frollsum(list(c(1,2,3), c(2,3,4)), c(n1=2, n2=3), give.names=TRUE), list(V1_n1=c(NA,3,5), V1_n2=c(NA,NA,6), V2_n1=c(NA,5,7), V2_n2=c(NA,NA,9)))
test(6006.966, frollsum(list(x1=c(1,2,3), x2=c(2,3,4)), 2, give.names=TRUE), list(x1_rollsum2=c(NA,3,5), x2_rollsum2=c(NA,5,7)))
test(6006.967, frollsum(list(x1=c(1,2,3), x2=c(2,3,4)), 2:3, give.names=TRUE), list(x1_rollsum2=c(NA,3,5), x1_rollsum3=c(NA,NA,6), x2_rollsum2=c(NA,5,7), x2_rollsum3=c(NA,NA,9)))
test(6006.968, frollsum(list(x1=c(1,2,3), x2=c(2,3,4)), c(n1=2), give.names=TRUE), list(x1_n1=c(NA,3,5), x2_n1=c(NA,5,7)))
test(6006.969, frollsum(list(x1=c(1,2,3), x2=c(2,3,4)), c(n1=2, n2=3), give.names=TRUE), list(x1_n1=c(NA,3,5), x1_n2=c(NA,NA,6), x2_n1=c(NA,5,7), x2_n2=c(NA,NA,9)))
test(6006.971, frollsum(c(1,2,3), c(2,2,2), adaptive=TRUE, give.names=TRUE), c(NA,3,5)) ## adaptive
test(6006.972, frollsum(c(1,2,3), list(c(2,2,2)), adaptive=TRUE, give.names=TRUE), c(NA,3,5))
test(6006.973, frollsum(list(c(1,2,3)), c(2,2,2), adaptive=TRUE, give.names=TRUE), list(V1=c(NA,3,5)))
test(6006.974, frollsum(list(c(1,2,3)), list(c(2,2,2)), adaptive=TRUE, give.names=TRUE), list(V1_arollsum1=c(NA,3,5)))
test(6006.975, frollsum(list(x1=c(1,2,3)), c(2,2,2), adaptive=TRUE, give.names=TRUE), list(x1=c(NA,3,5)))
test(6006.976, frollsum(list(x1=c(1,2,3)), list(c(2,2,2)), adaptive=TRUE, give.names=TRUE), list(x1_arollsum1=c(NA,3,5)))
test(6006.977, frollsum(list(c(1,2,3)), list(n1=c(2,2,2)), adaptive=TRUE, give.names=TRUE), list(V1_n1=c(NA,3,5)))
test(6006.978, frollsum(list(x1=c(1,2,3)), list(n1=c(2,2,2)), adaptive=TRUE, give.names=TRUE), list(x1_n1=c(NA,3,5)))
test(6006.979, frollsum(c(1,2,3), list(c(2,2,2), c(3,3,3)), adaptive=TRUE, give.names=TRUE), list(arollsum1=c(NA,3,5), arollsum2=c(NA,NA,6)))
test(6006.980, frollsum(list(c(1,2,3)), list(c(2,2,2), c(3,3,3)), adaptive=TRUE, give.names=TRUE), list(V1_arollsum1=c(NA,3,5), V1_arollsum2=c(NA,NA,6)))
test(6006.981, frollsum(list(c(1,2,3), c(2,3,4)), c(2,2,2), adaptive=TRUE, give.names=TRUE), list(V1=c(NA,3,5), V2=c(NA,5,7)))
test(6006.982, frollsum(list(c(1,2,3), c(2,3,4)), list(c(2,2,2)), adaptive=TRUE, give.names=TRUE), list(V1_arollsum1=c(NA,3,5), V2_arollsum1=c(NA,5,7)))
test(6006.983, frollsum(list(c(1,2,3), c(2,3,4)), list(c(2,2,2), c(3,3,3)), adaptive=TRUE, give.names=TRUE), list(V1_arollsum1=c(NA,3,5), V1_arollsum2=c(NA,NA,6), V2_arollsum1=c(NA,5,7), V2_arollsum2=c(NA,NA,9)))
test(6006.984, frollsum(c(1,2,3), list(n1=c(2,2,2), n2=c(3,3,3)), adaptive=TRUE, give.names=TRUE), list(n1=c(NA,3,5), n2=c(NA,NA,6)))
test(6006.985, frollsum(list(c(1,2,3)), list(n1=c(2,2,2), n2=c(3,3,3)), adaptive=TRUE, give.names=TRUE), list(V1_n1=c(NA,3,5), V1_n2=c(NA,NA,6)))
test(6006.986, frollsum(list(x1=c(1,2,3)), list(c(2,2,2), c(3,3,3)), adaptive=TRUE, give.names=TRUE), list(x1_arollsum1=c(NA,3,5), x1_arollsum2=c(NA,NA,6)))
test(6006.987, frollsum(list(x1=c(1,2,3)), list(n1=c(2,2,2), n2=c(3,3,3)), adaptive=TRUE, give.names=TRUE), list(x1_n1=c(NA,3,5), x1_n2=c(NA,NA,6)))
test(6006.988, frollsum(list(c(1,2,3), c(2,3,4)), list(n1=c(2,2,2)), adaptive=TRUE, give.names=TRUE), list(V1_n1=c(NA,3,5), V2_n1=c(NA,5,7)))
test(6006.989, frollsum(list(c(1,2,3), c(2,3,4)), list(n1=c(2,2,2), n2=c(3,3,3)), adaptive=TRUE, give.names=TRUE), list(V1_n1=c(NA,3,5), V1_n2=c(NA,NA,6), V2_n1=c(NA,5,7), V2_n2=c(NA,NA,9)))
test(6006.990, frollsum(list(x1=c(1,2,3), x2=c(2,3,4)), c(2,2,2), adaptive=TRUE, give.names=TRUE), list(x1=c(NA,3,5), x2=c(NA,5,7)))
test(6006.991, frollsum(list(x1=c(1,2,3), x2=c(2,3,4)), list(c(2,2,2)), adaptive=TRUE, give.names=TRUE), list(x1_arollsum1=c(NA,3,5), x2_arollsum1=c(NA,5,7)))
test(6006.992, frollsum(list(x1=c(1,2,3), x2=c(2,3,4)), list(c(2,2,2), c(3,3,3)), adaptive=TRUE, give.names=TRUE), list(x1_arollsum1=c(NA,3,5), x1_arollsum2=c(NA,NA,6), x2_arollsum1=c(NA,5,7), x2_arollsum2=c(NA,NA,9)))
test(6006.993, frollsum(list(x1=c(1,2,3), x2=c(2,3,4)), list(n1=c(2,2,2)), adaptive=TRUE, give.names=TRUE), list(x1_n1=c(NA,3,5), x2_n1=c(NA,5,7)))
test(6006.994, frollsum(list(x1=c(1,2,3), x2=c(2,3,4)), list(n1=c(2,2,2), n2=c(3,3,3)), adaptive=TRUE, give.names=TRUE), list(x1_n1=c(NA,3,5), x1_n2=c(NA,NA,6), x2_n1=c(NA,5,7), x2_n2=c(NA,NA,9)))
test(6006.9950, frollsum(c(1,2,3), 2, partial=TRUE, give.names=TRUE), c(1,3,5)) ## partial
test(6006.9951, frollsum(c(1,2,3), c(n1=2), partial=TRUE, give.names=TRUE), c(1,3,5))
test(6006.9952, frollsum(list(c(1,2,3)), 2, partial=TRUE, give.names=TRUE), list(V1_rollsum2=c(1,3,5)))
test(6006.9953, frollsum(list(x1=c(1,2,3)), 2, partial=TRUE, give.names=TRUE), list(x1_rollsum2=c(1,3,5)))
test(6006.9954, frollsum(list(c(1,2,3)), c(n1=2), partial=TRUE, give.names=TRUE), list(V1_n1=c(1,3,5)))
test(6006.9955, frollsum(list(x1=c(1,2,3)), c(n1=2), partial=TRUE, give.names=TRUE), list(x1_n1=c(1,3,5)))
test(6006.9956, frollsum(list(c(1,2,3), c(2,3,4)), c(2, 3), partial=TRUE, give.names=TRUE), list(V1_rollsum2=c(1,3,5), V1_rollsum3=c(1,3,6), V2_rollsum2=c(2,5,7), V2_rollsum3=c(2,5,9)))
test(6006.9957, frollsum(list(c(1,2,3), c(2,3,4)), c(n1=2, n2=3), partial=TRUE, give.names=TRUE), list(V1_n1=c(1,3,5), V1_n2=c(1,3,6), V2_n1=c(2,5,7), V2_n2=c(2,5,9)))
test(6006.9958, frollsum(list(x1=c(1,2,3), x2=c(2,3,4)), c(2, 3), partial=TRUE, give.names=TRUE), list(x1_rollsum2=c(1,3,5), x1_rollsum3=c(1,3,6), x2_rollsum2=c(2,5,7), x2_rollsum3=c(2,5,9)))
test(6006.9959, frollsum(list(x1=c(1,2,3), x2=c(2,3,4)), c(n1=2, n2=3), partial=TRUE, give.names=TRUE), list(x1_n1=c(1,3,5), x1_n2=c(1,3,6), x2_n1=c(2,5,7), x2_n2=c(2,5,9)))
test(6006.9960, frollsum(c(1,2,3), c(2,2,2), adaptive=TRUE, partial=TRUE, give.names=TRUE), c(1,3,5)) ## adaptive partial
test(6006.9961, frollsum(c(1,2,3), list(c(2,2,2)), adaptive=TRUE, partial=TRUE, give.names=TRUE), c(1,3,5))
test(6006.9962, frollsum(list(c(1,2,3)), c(2,2,2), adaptive=TRUE, partial=TRUE, give.names=TRUE), list(V1=c(1,3,5)))
test(6006.9963, frollsum(list(c(1,2,3)), list(c(2,2,2)), adaptive=TRUE, partial=TRUE, give.names=TRUE), list(V1_arollsum1=c(1,3,5)))
test(6006.9964, frollsum(list(x1=c(1,2,3)), c(2,2,2), adaptive=TRUE, partial=TRUE, give.names=TRUE), list(x1=c(1,3,5)))
test(6006.9965, frollsum(list(x1=c(1,2,3)), list(c(2,2,2)), adaptive=TRUE, partial=TRUE, give.names=TRUE), list(x1_arollsum1=c(1,3,5)))
test(6006.9966, frollsum(c(1,2,3), list(c(n1=c(2,2,2))), adaptive=TRUE, partial=TRUE, give.names=TRUE), c(1,3,5))
test(6006.9967, frollsum(list(c(1,2,3)), c(2,2,2), adaptive=TRUE, partial=TRUE, give.names=TRUE), list(V1=c(1,3,5)))
test(6006.9968, frollsum(list(c(1,2,3)), list(n1=c(2,2,2)), adaptive=TRUE, partial=TRUE, give.names=TRUE), list(V1_n1=c(1,3,5)))
test(6006.9969, frollsum(list(x1=c(1,2,3)), list(n1=c(2,2,2)), adaptive=TRUE, partial=TRUE, give.names=TRUE), list(x1_n1=c(1,3,5)))

## validation

set.seed(108)
makeNA = function(x, ratio=0.1, nf=FALSE) {
  n = as.integer(length(x) * ratio)
  id = sample(length(x), n)
  if (!nf) {
    x[id] = NA
  } else {
    x[id[1:(n/4)]] = NA
    x[id[(n/4+1):(n/2)]] = NaN
    x[id[(n/2+1):(3*n/4)]] = -Inf
    x[id[(3*n/4+1):n]] = +Inf
  }
  x
}
num = 6007.0
## against base to verify exactness of non-finite values, not handled in zoo
rollfun = function(x, n, FUN, fill=NA_real_, na.rm=FALSE, nf.rm=FALSE, partial=FALSE) {
  ans = rep(fill, nx<-length(x))
  f = match.fun(FUN)
  if (nf.rm) x[is.infinite(x)] = NA_real_
  for (i in seq_along(x)) {
    ans[i] = if (i >= n)
      f(x[(i-n+1):i], na.rm=na.rm)
    else if (partial)
      f(x[max((i-n+1), 1L):i], na.rm=na.rm)
    else
      as.double(fill)
  }
  ans
}
base_compare = function(x, n, funs=c("mean","sum","max"), algos=c("fast","exact")) {
  num.step = 0.001
  for (fun in funs) {
    for (na.rm in c(FALSE, TRUE)) {
      for (fill in c(NA_real_, 0)) {
        for (partial in c(FALSE,TRUE)) {
          for (has.nf in c(NA,TRUE,FALSE)) {
            if (identical(has.nf, FALSE)) {
              if (na.rm)
                next ## errors "not make sense"
              if (any(!is.finite(x)))
                next ## do not test warnings (mean, sum) or incorrect expect results (max)
            }
            for (algo in algos) {
              num <<- num + num.step
              eval(substitute( # so we can have values displayed in output/log rather than variables
                test(.num, ignore.warning="no non-missing arguments",
                     rollfun(x, n, FUN=.fun, fill=.fill, na.rm=.na.rm, partial=.partial),
                     frollfun(.fun, x, n, fill=.fill, na.rm=.na.rm, algo=.algo, partial=.partial, has.nf=.has.nf)),
                list(.num=num, .fun=fun, .fill=fill, .na.rm=na.rm, .algo=algo, .partial=partial, .has.nf=has.nf)
              ))
            }
          }
          num <<- num + num.step
          eval(substitute( # so we can have values displayed in output/log rather than variables
            test(.num, ignore.warning="no non-missing arguments",
                 frollapply(x, n, FUN=match.fun(.fun), fill=.fill, na.rm=.na.rm, partial=.partial),
                 frollfun(.fun, x, n, fill=.fill, na.rm=.na.rm, partial=.partial)),
            list(.num=num, .fun=fun, .fill=fill, .na.rm=na.rm, .partial=partial)
          ))
        }
      }
    }
  }
}
## random NA non-finite
x = makeNA(rnorm(1e3), nf=TRUE); n = 50
base_compare(x, n)
x = makeNA(rnorm(1e3+1), nf=TRUE); n = 50
base_compare(x, n)
x = makeNA(rnorm(1e3), nf=TRUE); n = 51
base_compare(x, n)
x = makeNA(rnorm(1e3+1), nf=TRUE); n = 51
base_compare(x, n)
num = 6008.0
#### against zoo
if (requireNamespace("zoo", quietly=TRUE)) {
  drollapply = function(...) as.double(zoo::rollapply(...)) # rollapply is not consistent in data type of answer, force to double
  zoo_compare = function(x, n, funs=c("mean","sum","max"), algos=c("fast","exact")) {
    num.step = 0.0001
    #### fun, align, na.rm, fill, algo, partial
    for (fun in funs) {
      for (align in c("right","center","left")) {
        for (na.rm in c(FALSE, TRUE)) {
          for (fill in c(NA_real_, 0)) {
            for (partial in c(FALSE,TRUE)) {
              if (partial && align=="center")
                next ## not implemented
              for (has.nf in c(NA,TRUE,FALSE)) {
                if (identical(has.nf, FALSE)) {
                  if (na.rm)
                    next ## errors "not make sense"
                  if (any(!is.finite(x)))
                    next ## do not test warnings (mean, sum) or incorrect expect results (max)
                }
                for (algo in algos) {
                  num <<- num + num.step
                  eval(substitute( # so we can have values displayed in output/log rather than variables
                    test(.num, ignore.warning="no non-missing arguments",
                         drollapply(x, n, FUN=.fun, fill=.fill, align=.align, na.rm=.na.rm, partial=.partial),
                         frollfun(.fun, x, n, align=.align, fill=.fill, na.rm=.na.rm, algo=.algo, partial=.partial, has.nf=.has.nf)),
                    list(.num=num, .fun=fun, .align=align, .fill=fill, .na.rm=na.rm, .algo=algo, .partial=partial, .has.nf=has.nf)
                  ))
                }
              }
              num <<- num + num.step
              eval(substitute( # so we can have values displayed in output/log rather than variables
                test(.num, ignore.warning="no non-missing arguments",
                     frollapply(x, n, FUN=.fun, fill=.fill, align=.align, na.rm=.na.rm, partial=.partial),
                     frollfun(.fun, x, n, align=.align, fill=.fill, na.rm=.na.rm, partial=.partial)),
                list(.num=num, .fun=fun, .align=align, .fill=fill, .na.rm=na.rm, .partial=partial)
              ))
            }
          }
        }
      }
    }
  }
  ## no NA
  x = rnorm(1e3); n = 50 # x even, n even
  zoo_compare(x, n)
  x = rnorm(1e3+1); n = 50 # x odd, n even
  zoo_compare(x, n)
  x = rnorm(1e3); n = 51 # x even, n odd
  zoo_compare(x, n)
  x = rnorm(1e3+1); n = 51 # x odd, n odd
  zoo_compare(x, n)
  ## leading and trailing NAs
  x = c(rep(NA, 60), rnorm(1e3), rep(NA, 60)); n = 50
  zoo_compare(x, n)
  x = c(rep(NA, 60), rnorm(1e3+1), rep(NA, 60)); n = 50
  zoo_compare(x, n)
  x = c(rep(NA, 60), rnorm(1e3), rep(NA, 60)); n = 51
  zoo_compare(x, n)
  x = c(rep(NA, 60), rnorm(1e3+1), rep(NA, 60)); n = 51
  zoo_compare(x, n)
  ## random NA
  x = makeNA(rnorm(1e3)); n = 50
  zoo_compare(x, n)
  x = makeNA(rnorm(1e3+1)); n = 50
  zoo_compare(x, n)
  x = makeNA(rnorm(1e3)); n = 51
  zoo_compare(x, n)
  x = makeNA(rnorm(1e3+1)); n = 51
  zoo_compare(x, n)
}
#### adaptive moving average compare
num = 6009.0
arollfun = function(FUN, x, n, na.rm=FALSE, align=c("right","left"), fill=NA, nf.rm=FALSE, partial=FALSE) {
  # adaptive moving average in R
  stopifnot((nx<-length(x))==length(n))
  align = match.arg(align)
  ans = rep(fill, nx)
  if (nf.rm) x[is.infinite(x)] = NA_real_
  f = match.fun(FUN)
  if (align=="right") {
    for (i in seq_along(x)) {
      if (i >= n[i])
        ans[i] = f(x[(i-n[i]+1L):i], na.rm=na.rm)
      else if (partial)
        ans[i] = f(x[1L:i], na.rm=na.rm)
    }
  } else {
    for (i in seq_along(x)) {
      if (i <= nx-n[i]+1)
        ans[i] = f(x[i:(i+n[i]-1L)], na.rm=na.rm)
      else if (partial)
        ans[i] = f(x[i:length(x)], na.rm=na.rm)
    }
  }
  ans
}
afun_compare = function(x, n, funs=c("mean","sum","max"), algos=c("fast","exact")) {
  num.step = 0.0001
  #### fun, align, na.rm, fill, algo
  for (fun in funs) {
    for (align in c("right","left")) {
      for (na.rm in c(FALSE, TRUE)) {
        for (fill in c(NA_real_, 0)) {
          for (partial in c(FALSE, TRUE)) {
            for (has.nf in c(NA, TRUE, FALSE)) {
              if (identical(has.nf, FALSE)) {
                if (na.rm) {
                  next
                } ## errors "not make sense"
                if (any(!is.finite(x))) {
                  next
                } ## do not test warnings (mean, sum) or incorrect expect results (max)
              }
              for (algo in algos) {
                num <<- num + num.step
                eval(substitute(
                  test(.num,
                    ignore.warning = "no non-missing arguments",
                    arollfun(.fun, x, n, fill = .fill, na.rm = .na.rm, align = .align),
                    frollfun(.fun, x, n, fill = .fill, na.rm = .na.rm, algo = .algo, adaptive = TRUE, align = .align, has.nf = .has.nf)
                  ),
                  list(.num = num, .fun = fun, .fill = fill, .na.rm = na.rm, .algo = algo, .align = align, .has.nf = has.nf)
                ))
              }
            }
          }
          num <<- num + num.step
          eval(substitute(
            test(.num, ignore.warning="no non-missing arguments",
              frollapply(x, n, FUN=match.fun(.fun), fill=.fill, na.rm=.na.rm, adaptive=TRUE, align=.align, partial=.partial),
              frollfun(.fun, x, n, fill=.fill, na.rm=.na.rm, adaptive=TRUE, align=.align, partial=.partial)),
            list(.num=num, .fun=fun, .fill=fill, .na.rm=na.rm, .align=align, .partial=partial)
          ))
        }
      }
    }
  }
}
#### no NA
x = rnorm(1e3); n = sample(50, length(x), TRUE) # x even, n even
afun_compare(x, n)
x = rnorm(1e3+1); n = sample(50, length(x), TRUE) # x odd, n even
afun_compare(x, n)
x = rnorm(1e3); n = sample(51, length(x), TRUE) # x even, n odd
afun_compare(x, n)
x = rnorm(1e3+1); n = sample(51, length(x), TRUE) # x odd, n odd
afun_compare(x, n)
#### leading and trailing NAs
x = c(rep(NA, 60), rnorm(1e3), rep(NA, 60)); n = sample(50, length(x), TRUE)
afun_compare(x, n)
x = c(rep(NA, 60), rnorm(1e3+1), rep(NA, 60)); n = sample(50, length(x), TRUE)
afun_compare(x, n)
x = c(rep(NA, 60), rnorm(1e3), rep(NA, 60)); n = sample(51, length(x), TRUE)
afun_compare(x, n)
x = c(rep(NA, 60), rnorm(1e3+1), rep(NA, 60)); n = sample(51, length(x), TRUE)
afun_compare(x, n)
#### random NA
x = makeNA(rnorm(1e3)); n = sample(50, length(x), TRUE)
afun_compare(x, n)
x = makeNA(rnorm(1e3+1)); n = sample(50, length(x), TRUE)
afun_compare(x, n)
x = makeNA(rnorm(1e3)); n = sample(51, length(x), TRUE)
afun_compare(x, n)
x = makeNA(rnorm(1e3+1)); n = sample(51, length(x), TRUE)
afun_compare(x, n)
#### random NA non-finites
x = makeNA(rnorm(1e3), nf=TRUE); n = sample(50, length(x), TRUE)
afun_compare(x, n)
x = makeNA(rnorm(1e3+1), nf=TRUE); n = sample(50, length(x), TRUE)
afun_compare(x, n)
x = makeNA(rnorm(1e3), nf=TRUE); n = sample(51, length(x), TRUE)
afun_compare(x, n)
x = makeNA(rnorm(1e3+1), nf=TRUE); n = sample(51, length(x), TRUE)
afun_compare(x, n)
rm(num)

## frollapply
x = 1:10
test(6010.001, frollsum(x, 3L), frollapply(x, 3L, sum))
test(6010.002, frollsum(x, 6), frollapply(x, 6, sum))
test(6010.003, frollmean(x, 3), frollapply(x, 3, mean))
d = as.data.table(list(1:6/2, 3:8/4))
test(6010.004, frollsum(d, 3:4), frollapply(d, 3:4, sum))
test(6010.005, frollmean(d, 3:4), frollapply(d, 3:4, mean))
d = rbind(d, list(NA,NA))
ans = list(c(NA,NA,1.5,2,1.5,2,2.5), c(NA,NA,NA,2,1,1.5,2), c(NA,NA,1.25,1.5,1.75,1.5,2), c(NA,NA,NA,1.5,1,1.25,1.5))
test(6010.006, frollapply(d, 3:4, function(x, ...) if (sum(x, ...)>5) min(x, ...) else max(x, ...), na.rm=TRUE), ans)
# segfault and protect limits #3993 - disabled by default due to high memory usage
if (FALSE) {
  test(6010.007, frollapply(1, rep(1L, 1e5), identity), as.list(rep(1, 1e5)))
  test(6010.008, frollapply(1, rep(1L, 1e6), identity), as.list(rep(1, 1e6)))
  test(6010.009, frollapply(as.list(rep(1, 1e6)), 1, identity), as.list(rep(1, 1e6)))
}
#### corner cases from examples
test(6010.101, frollapply(1:5, 3, function(x) head(x, 2)), error="frollapply: results from provided FUN are not length 1")
f = function(x) {
  n = length(x)
  # length 1 will be returned only for first iteration where we check length
  if (n==x[n]) x[1L] else range(x) # range(x)[2L] is silently ignored
}
test(6010.102, frollapply(1:5, 3, f), c(NA,NA,1,2,3))
options(datatable.verbose=TRUE)
x = c(1,2,1,1,1,2,3,2)
ans = c(NA,NA,2,2,1,2,3,2)
numUniqueN = function(x) as.numeric(uniqueN(x))
test(6010.103, frollapply(x, 3, uniqueN), ans, output=c("frollapplyR: allocating memory.*","frollapply: results from provided FUN are not of type double, coercion from integer or logical will be applied on each iteration.*","frollapply: took.*","frollapplyR: processing.*took.*"))
test(6010.104, frollapply(x, 3, numUniqueN), ans, output=c("frollapplyR: allocating memory.*","frollapply: took.*","frollapplyR: processing.*took.*"))
test(6010.105, as.logical(frollapply(c(1,2,1,1,NA,2,NA,2), 3, anyNA)), c(NA,NA,FALSE,FALSE,TRUE,TRUE,TRUE,TRUE), output=c("frollapplyR: allocating memory.*","frollapply: results from provided FUN are not of type double, coercion from integer or logical will be applied on each iteration","frollapply: took.*","frollapplyR: processing.*took.*"))
f = function(x) {
  n = length(x)
  # double type will be returned only for first iteration where we check type
  if (n==x[n]) 1 else NA # NA logical turns into garbage without coercion to double
}
#test(6010.106, head(frollapply(1:5, 3, f), 3L), c(NA_real_,NA_real_,1), output=c("frollapplyR: allocating memory.*","frollapply: took.*","frollapplyR: processing.*took.*")) # only head 3 is valid, rest is undefined as REAL is applied on logical type, can return garbage or fail with REAL error
options(datatable.verbose=FALSE)

# frollapply adaptive
r340 = base::getRversion() >= "3.4.0" ## support SET_GROWABLE_BIT
if (!r340) {
  test(6010.2, frollapply(1:3, c(3,3,3), sum, adaptive=TRUE), error="frollapply adaptive=TRUE requires at least R 3.4.0")
} else {
  test(6010.2011, frollapply(1:3, c(3,3,3), sum, adaptive=TRUE), c(NA,NA,6))
  test(6010.2012, frollapply(1:3, c(4,4,4), sum, adaptive=TRUE), rep(NA_real_,3)) # none of the windows in k was small enough to cover length of x
  test(6010.2013, frollapply(1:5, rep(2, 5), mean, adaptive=NA), error="adaptive must be TRUE or FALSE")
  test(6010.2014, frollapply(1:5, rep(3, 5), toString, adaptive=TRUE), error="frolladaptiveapply: results from provided FUN are not of type double")
  test(6010.2015, frollapply(1:2, 1:2, mean, adaptive=TRUE, align="right"), c(1, 1.5))
  test(6010.2016, frollapply(1:2, 1:2, mean, adaptive=TRUE, align="center"), error="using adaptive TRUE and align 'center' is not implemented")
  test(6010.2017, frollapply(list(1:2, 1:3), list(1:2), mean, adaptive=TRUE), error="adaptive rolling function can only process 'x' having equal length of elements, like data.table or data.frame. If you want to call rolling function on list having variable length of elements call it for each field separately")
  test(6010.2018, frollapply(1:5, rep(3, 5), function(x) head(x, 2), adaptive=TRUE), error="frolladaptiveapply: results from provided FUN are not length 1")
  test(6010.2019, frollapply(1:10, list(1:5), mean, adaptive=TRUE), error="length of integer vector(s) provided as list to 'n' argument must be equal to number of observations provided in 'x'")
  test(6010.2020, frollapply(1:10, 1:5, mean, adaptive=TRUE), error="length of integer vector(s) provided as list to 'n' argument must be equal to number of observations provided in 'x'")
  test(6010.2021, frollapply(1:4, rep(2L,4L), mean, adaptive=TRUE, partial=TRUE), c(1,1.5,2.5,3.5))
  options(datatable.verbose=TRUE)
  test(6010.2029, frollapply(c(1,3,4,2,0), c(3,2,2,3,2), sum, adaptive=TRUE, align="left"), c(8,7,6,NA,NA), output=c("processing from align='right'"))
  x = c(1,2,1,1,1,2,3,2)
  ans = c(NA,NA,2,2,1,2,3,2)
  numUniqueN = function(x) as.numeric(uniqueN(x))
  test(6010.203, frollapply(x, rep(3, length(x)), uniqueN, adaptive=TRUE), ans, output=c("frollapplyR: allocating memory.*","frolladaptiveapply: results from provided FUN are not of type double, coercion from integer or logical will be applied on each iteration.*","frolladaptiveapply: took.*","frollapplyR: processing.*took.*"))
  test(6010.204, frollapply(x, rep(3, length(x)), numUniqueN, adaptive=TRUE), ans, output=c("frollapplyR: allocating memory.*","frolladaptiveapply: took.*","frollapplyR: processing.*took.*"))
  test(6010.205, as.logical(frollapply(c(1,2,1,1,NA,2,NA,2), rep(3, length(x)), anyNA, adaptive=TRUE)), c(NA,NA,FALSE,FALSE,TRUE,TRUE,TRUE,TRUE), output=c("frollapplyR: allocating memory.*","frolladaptiveapply: results from provided FUN are not of type double, coercion from integer or logical will be applied on each iteration","frolladaptiveapply: took.*","frollapplyR: processing.*took.*"))
  options(datatable.verbose=FALSE)
  test(6010.206, frollapply(c(2,2,2,3,4), c(1,3,3,2,3), uniqueN, adaptive=TRUE), c(1,NA,1,2,3)) ## window width bigger than location
}

#### test coverage
test(6010.501, frollapply(1:3, "b", sum), error="n must be integer")
test(6010.503, frollapply(1:3, integer(), sum), error="n must be non 0 length")
test(6010.504, frollapply(1:3, 2L, sum, fill=1:2), error="fill must be a vector of length 1")
test(6010.505, frollapply(1:3, 2L, sum, fill=NA_integer_), c(NA,3,5))
test(6010.506, frollapply(1:3, 2L, sum, fill=-1L), c(-1,3,5))
test(6010.507, frollapply(1:3, 2L, sum, fill=-2), c(-2,3,5))
test(6010.508, frollapply(1:3, 2L, sum, fill="z"), error="fill must be numeric")
test(6010.509, frollapply(1:3, 4L, sum), c(NA_real_,NA_real_,NA_real_))
test(6010.510, frollapply(1:5, 3L, sum), c(NA,NA,6,9,12))
test(6010.511, frollapply(1:5, 3L, sum, align="center"), c(NA,6,9,12,NA))
test(6010.512, frollapply(1:5, 3L, sum, align="left"), c(6,9,12,NA,NA))
test(6010.513, frollapply(1:5, 4L, sum), c(NA,NA,NA,10,14))
test(6010.514, frollapply(1:5, 4L, sum, align="center"), c(NA,10,14,NA,NA))
test(6010.515, frollapply(1:5, 4L, sum, align="left"), c(10,14,NA,NA,NA))
test(6010.516, frollapply(1:6, 3L, sum), c(NA,NA,6,9,12,15))
test(6010.517, frollapply(1:6, 3L, sum, align="center"), c(NA,6,9,12,15,NA))
test(6010.518, frollapply(1:6, 3L, sum, align="left"), c(6,9,12,15,NA,NA))
test(6010.519, frollapply(1:6, 4L, sum), c(NA,NA,NA,10,14,18))
test(6010.520, frollapply(1:6, 4L, sum, align="center"), c(NA,10,14,18,NA,NA))
test(6010.521, frollapply(1:6, 4L, sum, align="left"), c(10,14,18,NA,NA,NA))
test(6010.522, frollapply(c(1:3,NA,5:6), 4L, sum), rep(NA_real_,6))
test(6010.523, frollapply(c(1:3,NA,5:6), 4L, sum, na.rm=TRUE), c(NA,NA,NA,6,10,14))
test(6010.524, frollapply(c(1,2,3,NA,NA,NA,NA), 3L, mean), c(NA,NA,2,NA,NA,NA,NA))
test(6010.525, frollapply(c(1,2,3,NA,NA,NA,NA), 3L, mean, na.rm=TRUE), c(NA,NA,2,2.5,3,NaN,NaN))
test(6010.526, frollapply(numeric(), 3L, sum), numeric())
test(6010.527, frollapply(1:5, 3L, toString), error="frollapply: results from provided FUN are not of type double")
options(datatable.verbose=TRUE)
test(6010.551, frollapply(1:3, 4L, sum), c(NA_real_,NA_real_,NA_real_), output=c("frollapplyR: allocating memory.*","frollapply: window width longer than input vector.*","frollapplyR: processing.*took.*"))
test(6010.552, frollapply(1:5, 3L, sum), c(NA,NA,6,9,12), output=c("frollapplyR: allocating memory.*","frollapply: took.*","frollapplyR: processing.*took.*"))
test(6010.553, frollapply(1:5, 3L, sum, align="center"), c(NA,6,9,12,NA), output=c("frollapplyR: allocating memory.*","frollapply: align 0, shift.*","frollapply: took.*","frollapplyR: processing.*took.*"))
options(datatable.verbose=FALSE)
ma = function(x, n, na.rm=FALSE) {
  ans = rep(NA_real_, nx<-length(x))
  for (i in n:nx) ans[i]=mean(x[(i-n+1):i], na.rm=na.rm)
  ans
}
n = 4L
x = as.double(1:16)
x[5] = NaN
test(6010.601, frollapply(x, n, mean), ma(x, n))
x[6] = NA
test(6010.602, frollapply(x, n, mean), ma(x, n))
x[5] = NA
x[6] = NaN
test(6010.603, frollapply(x, n, mean), ma(x, n))
x[5] = Inf
test(6010.604, frollapply(x, n, mean), ma(x, n))
x[6] = -Inf
test(6010.605, frollapply(x, n, mean), ma(x, n))
x[5:7] = c(NA, Inf, -Inf)
test(6010.606, frollapply(x, n, mean), ma(x, n))
