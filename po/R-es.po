msgid ""
msgstr ""
"Project-Id-Version: data.table 1.15.99\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-07-30 17:45-0300\n"
"PO-Revision-Date: 2024-08-05 17:45-0300\n"
"Last-Translator: Ricardo Villalba <rikivillalba@gmail.com>\n"
"Language-Team: es\n"
"Language: es\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=2; plural=(n!=1);\n"

msgid "data.table package loaded. When developing don't load package"
msgstr "paquete data.table cargado. En desarrollo, no cargue el paquete."

msgid ""
"Internal error -- difftime objects may not be added to IDate, but Ops "
"dispatch should have intervened to prevent this"
msgstr ""
"Error interno: es posible que los objetos difftime no se agreguen a IDate, "
"pero el despacho por grupo genérico Ops debería haber intervenido para "
"evitarlo."

msgid "binary + is not defined for \"IDate\" objects"
msgstr "operador binario `+` no está definido para objetos \"IDate\""

msgid "can only subtract from \"IDate\" objects"
msgstr "sólo se puede restar de objetos \"IDate\""

msgid "Internal error: storage mode of IDate is somehow no longer integer"
msgstr ""
"Error interno: el modo de almacenamiento de IDate de alguna manera ya no es "
"un número entero"

msgid "unary - is not defined for \"IDate\" objects"
msgstr "operador unario `-` no está definido para objetos \"IDate\""

msgid ""
"Internal error -- difftime objects may not be subtracted from IDate, but Ops "
"dispatch should have intervened to prevent this"
msgstr ""
"Error interno: los objetos difftime no se pueden restar de IDate, pero el "
"despacho por grupo genérico Ops debería haber intervenido para evitarlo."

msgid "Valid options for ms are 'truncate', 'nearest', and 'ceil'."
msgstr "Las opciones válidas para ms son 'truncate', 'nearest' y 'ceil'."

msgid ""
"as.data.table.array method should only be called for arrays with 3+ "
"dimensions; use the matrix method for 2-dimensional arrays"
msgstr ""
"El método as.data.table.array solo debe llamarse para matrices con más de 3 "
"dimensiones; utilizar el método matricial para matrices bidimensionales"

msgid ""
"Argument 'value.name' must be scalar character, non-NA and at least one "
"character"
msgstr ""
"El argumento 'value.name' debe ser un carácter escalar, no NA y al menos un "
"carácter"

msgid "Argument 'sorted' must be scalar logical and non-NA"
msgstr "El argumento 'sorted' debe ser lógico escalar y no NA"

msgid "Argument 'na.rm' must be scalar logical and non-NA"
msgstr "El argumento 'na.rm' debe ser lógico escalar y no NA"

msgid "Please provide either 'key' or 'sorted', but not both."
msgstr "Proporcione 'key' o 'sorted', pero no ambos."

msgid ""
"Argument 'value.name' should not overlap with column names in result: %s"
msgstr ""
"El argumento 'value.name' no debe superponerse con los nombres de las "
"columnas en el resultado: %s"

msgid ""
"POSIXlt column type detected and converted to POSIXct. We do not recommend "
"use of POSIXlt at all because it uses 40 bytes to store one date."
msgstr ""
"Tipo de columna POSIXlt detectado y convertido a POSIXct. No recomendamos el "
"uso de POSIXlt porque utiliza 40 bytes para almacenar una fecha."

msgid "Item %d has %d rows but longest item has %d; recycled with remainder."
msgstr ""
"El elemento %d tiene %d filas pero el artículo más largo tiene %d; Reciclado "
"con resto."

msgid "A column may not be called .SD. That has special meaning."
msgstr "Una columna no puede llamarse .SD. Eso tiene un significado especial."

msgid "class must be length 1"
msgstr "la clase debe tener una longitud de 1"

msgid "between has been passed an argument x of type logical"
msgstr "entre se ha pasado un argumento x de tipo lógico"

msgid ""
"'between' function the 'x' argument is a POSIX class while '%s' was not, "
"coercion to POSIX failed with: %s"
msgstr ""
"'between' función el argumento 'x' es una clase POSIX mientras que '%s' no "
"lo era, la coerción a POSIX falló con: %s"

msgid ""
"'between' lower= and upper= are both POSIXct but have different tzone "
"attributes: %s. Please align their time zones."
msgstr ""
"'between' lower= y Upper= son ambos POSIXct pero tienen diferentes atributos "
"de tzone: %s. Por favor alinee las zonas horarias."

msgid ""
"'between' arguments are all POSIXct but have mismatched tzone attributes: "
"%s. The UTC times will be compared."
msgstr ""
"Los argumentos >>'between' son todos POSIXct pero tienen atributos de tzone "
"que no coinciden: %s. Se compararán las fechas-hora UTC."

msgid "trying to use integer64 class when 'bit64' package is not installed"
msgstr ""
"Se intentó utilizar la clase integer64 cuando el paquete 'bit64' no está "
"instalado"

msgid ""
"Not yet implemented NAbounds=TRUE for this non-numeric and non-character type"
msgstr ""
"Aún no se ha implementado NAbounds=TRUE para este tipo no numérico ni de "
"caracteres"

msgid "Some lower>upper for this non-numeric and non-character type"
msgstr ""
"Algunos valores 'lower' (inferior) son mayores que 'upper' (superior) para "
"este tipo que no es numérico ni de caracteres"

msgid "Perhaps you meant %s?"
msgstr "¿Quizás se refiere a %s?"

msgid ""
"RHS has length() %d; expecting length 2. %sThe first element should be the "
"lower bound(s); the second element should be the upper bound(s)."
msgstr ""
"RHS tiene longitud %d; se esparaba longitud 2. %s El primer elemento debe "
"ser el límite inferior; el segundo elemento debe ser el límite superior."

msgid "%s is type %s which is not supported by data.table join"
msgstr "%s es de tipo %s que no es compatible con data.table join"

msgid ""
"Attempting roll join on factor column when joining %s to %s. Only integer, "
"double or character columns may be roll joined."
msgstr ""
"Se intentó hacer un roll join en una columna de factor al unir %s con %s. "
"Sólo se puede hacer roll join en columnas de números enteros, dobles o de "
"caracteres."

msgid ""
"Incompatible join types: %s (%s) and %s (%s). Factor columns must join to "
"factor or character columns."
msgstr ""
"Tipos de unión incompatibles: %s (%s) y %s (%s). Las columnas de factores "
"deben unirse a columnas de factores o caracteres."

msgid "Incompatible join types: %s (%s) and %s (%s)"
msgstr "Tipos de unión incompatibles: %s (%s) y %s (%s)"

msgid ""
"Incompatible join types: %s is type integer64 but %s is type double and "
"contains fractions"
msgstr ""
"Tipos de unión incompatibles: %s es de tipo entero64 pero %s es de tipo "
"doble y contiene fracciones"

msgid "roll is not implemented for non-equi joins yet."
msgstr "roll aún no está implementado para non-equi joins"

msgid "Column name '_nqgrp_' is reserved for non-equi joins."
msgstr "El nombre de columna '_nqgrp_' está reservado para non-equi joins"

msgid "key argument of data.table() must be character"
msgstr "el argumento 'key' de data.table() debe ser tipo carácter"

msgid ""
"Usage of comma-separated literals in %s is deprecated, please split such "
"entries yourself before passing to data.table"
msgstr ""
"El uso de literales separados por comas en %s está obsoleto, divida dichas "
"entradas usted mismo antes de pasarlas a data.table"

msgid "Object '%s' not found. Perhaps you intended %s"
msgstr "Objeto '%s' no encontrado. Quizás buscaba %s"

msgid "Object '%s' not found amongst %s"
msgstr "Objeto '%s' no encontrado entre %s"

msgid ""
"[ was called on a data.table in an environment that is not data.table-aware "
"(i.e. cedta()), but '%s' was used, implying the owner of this call really "
"intended for data.table methods to be called. See vignette('datatable-"
"importing') for details on properly importing data.table."
msgstr ""
"`[` fue llamado en un data.table en un entorno que no está al tanto de la "
"presencia de data.table (es decir, cedta()), pero se usó '%s', lo que "
"implica que el propietario de esta llamada realmente tenía la intención de "
"llamar a métodos de data.table. Consulte vignette('datatable-importing') "
"para obtener detalles sobre la importación correcta de data.table."

msgid "verbose must be logical or integer"
msgstr "'verbose' debe ser lógico o entero"

msgid "verbose must be length 1 non-NA"
msgstr "'verbose' debe tener longitud 1 no NA"

msgid "Ignoring by/keyby because 'j' is not supplied"
msgstr "Ignorando by/keyby porque no se proporciona 'j'"

msgid "When by and keyby are both provided, keyby must be TRUE or FALSE"
msgstr "Cuando se proporcionan by y keyby, keyby debe ser TRUE o FALSE"

msgid ""
"When on= is provided but not i=, on= must be a named list or data.table|"
"frame, and a natural join (i.e. join on common names) is invoked. Ignoring "
"on= which is '%s'."
msgstr ""
"Cuando se proporciona on= pero no i=, on= debe ser una lista con nombre o "
"data.table|frame, y se invoca un «natural join» (es decir, unión en nombres "
"comunes). Ignorando on= que es '%s'."

msgid ""
"i and j are both missing so ignoring the other arguments. This warning will "
"be upgraded to error in future."
msgstr ""
"Faltan i y j, por lo que se ignoran los otros argumentos. Esta advertencia "
"se actualizará a error en el futuro."

msgid "mult argument can only be 'first', 'last' or 'all'"
msgstr "el argumento múltiple sólo puede ser 'first', 'last' o 'all'"

msgid ""
"roll must be a single TRUE, FALSE, positive/negative integer/double "
"including +Inf and -Inf or 'nearest'"
msgstr ""
"'roll' debe ser un único valor lógico TRUE/FALSE, número entero/doble "
"positivo o negativo incluyendo +Inf y -Inf, o 'nearest'"

msgid "roll is '%s' (type character). Only valid character value is 'nearest'."
msgstr ""
"roll es '%s' (tipo carácter). El único valor de carácter válido es 'nearest'."

msgid "rollends must be a logical vector"
msgstr "'rollends' debe ser un vector lógico"

msgid "rollends must be length 1 or 2"
msgstr "'rollends' deben tener una longitud de 1 o 2"

msgid ""
"nomatch= must be either NA or NULL (or 0 for backwards compatibility which "
"is the same as NULL but please use NULL)"
msgstr ""
"nomatch= debe ser NA o NULL (o 0 para compatibilidad con versiones "
"anteriores, que es lo mismo que NULL, pero por favor utilice NULL)"

msgid "which= must be a logical vector length 1. Either FALSE, TRUE or NA."
msgstr ""
"which= debe ser un vector lógico de longitud 1. Ya sea FALSE, TRUE o NA."

msgid ""
"which==%s (meaning return row numbers) but j is also supplied. Either you "
"need row numbers or the result of j, but only one type of result can be "
"returned."
msgstr ""
"which==%s (que significa que se devolverán los números de fila) pero también "
"se proporciona j. O bien necesita números de fila o el resultado de j, pero "
"solo se puede devolver un tipo de resultado."

msgid ""
"which=NA with nomatch=0|NULL would always return an empty vector. Please "
"change or remove either which or nomatch."
msgstr ""
"which=NA con nomatch=0|NULL siempre devolvería un vector vacío. Cambie o "
"elimine o bien which o nomatch."

msgid "j must be provided when with=FALSE"
msgstr "j debe proporcionarse cuando with=FALSE"

msgid ""
"The symbol .. is invalid. The .. prefix must be followed by at least one "
"character."
msgstr ""
"El símbolo .. no es válido. El prefijo .. debe ir seguido de al menos un "
"carácter."

msgid ""
"Variable '..%s' does exist in calling scope though, so please just removed "
"the .. prefix from that variable name in calling scope."
msgstr ""
"Sin embargo, la variable '..%s' existe en el ámbito de la llamada, así que "
"elimine el prefijo .. de ese nombre de variable en el ámbito de llamada."

msgid ""
"Variable '%s' is not found in calling scope. Looking in calling scope "
"because you used the .. prefix.%s"
msgstr ""
"La variable '%s' no se encuentra en el ámbito de la llamada. Buscando en el "
"ámbito de la llamada porque se utilizó el prefijo ..%s"

msgid ""
"Both '%1$s' and '..%1$s' exist in calling scope. Please remove the '..%1$s' "
"variable in calling scope for clarity."
msgstr ""
"Tanto '%1$s' como '..%1$s' existen en el ámbito de llamada. Elimine la "
"variable '..%1$s' al llamar al ámbito para mayor claridad."

msgid ""
"Internal error:  DT[, ..var] should be dealt with by the branch above now."
msgstr ""
"Error interno: DT[, ..var] debería ser tratado por la rama anterior ahora."

msgid ""
"Variable '%s' is not found in calling scope. Looking in calling scope "
"because you set with=FALSE. Also, please use .. symbol prefix and remove "
"with=FALSE."
msgstr ""
"La variable '%s' no se encuentra en el ámbito de la llamada. Buscando en el "
"ámbito de la llamada porque se proporcionó with = FALSE. Además, por favor "
"utilice el prefijo de símbolo .. y elimine with=FALSE."

msgid ""
"You have wrapped := with {} which is ok but then := must be the only thing "
"inside {}. You have something else inside {} as well. Consider placing the "
"{} on the RHS of := instead; e.g. DT[,someCol:={tmpVar1<-...;tmpVar2<-...;"
"tmpVar1*tmpVar2}"
msgstr ""
"Ha rodeado := con {} lo cual está bien, pero entonces := debe ser lo único "
"dentro de {}. También tiene algo más dentro de {}. Considere colocar {} en "
"el lado derecho de := en su lugar; p.ej. DT[,someCol:={tmpVar1<-...;"
"tmpVar2<-...;tmpVar1*tmpVar2}"

msgid ""
":= with keyby is only possible when i is not supplied since you can't setkey "
"on a subset of rows. Either change keyby to by or remove i"
msgstr ""
":= con keyby solo es posible cuando no se proporciona i ya que no se puede "
"configurar la clave en un subconjunto de filas. Cambie keyby a by o elimine i"

msgid "nomatch isn't relevant together with :=, ignoring nomatch"
msgstr "nomatch no es relevante junto con :=, ignorando nomatch"

msgid ""
"not-join '!' prefix is present on i but nomatch is provided. Please remove "
"nomatch."
msgstr ""
"not-join '!' El prefijo está presente en i pero no se proporciona ninguna "
"coincidencia. Por favor elimine nomatch."

msgid ""
"Operator := detected in i, the first argument inside DT[...], but is only "
"valid in the second argument, j. Most often, this happens when forgetting "
"the first comma (e.g. DT[newvar := 5] instead of DT[ , new_var := 5]). "
"Please double-check the syntax. Run traceback(), and debugger() to get a "
"line number."
msgstr ""
"Operador := detectado en i, el primer argumento dentro de DT[...], pero sólo "
"es válido en el segundo argumento, j. La mayoría de las veces, esto sucede "
"cuando se olvida la primera coma (por ejemplo, DT[newvar := 5] en lugar de "
"DT[ , new_var := 5]). Vuelva a verificar la sintaxis. Ejecute traceback() y "
"debugger() para obtener un número de línea."

msgid "'%s' is not found in calling scope and it is not a column name either"
msgstr ""
"'%s' no se encuentra en el ámbito de llamada y tampoco es un nombre de "
"columna"

msgid ""
"'%s' is not found in calling scope, but it is a column of type %s. If you "
"wish to select rows where that column contains TRUE, or perhaps that column "
"contains row numbers of itself to select, try DT[(col)], DT[DT$col], or "
"DT[col==TRUE} is particularly clear and is optimized"
msgstr ""
"'%s' no se encuentra en el ámbito de llamada, pero es una columna de tipo "
"%s. Si desea seleccionar filas donde esa columna contiene TRUE, o tal vez "
"esa columna contiene números de fila para seleccionar, intente con "
"DT[(col)], DT[DT$col] o DT[col==TRUE} es particularmente claro. y está "
"optimizado"

msgid ""
"%s. When the first argument inside DT[...] is a single symbol (e.g. "
"DT[var]), data.table looks for var in calling scope."
msgstr ""
"%s. Cuando el primer argumento dentro de DT[...] es un símbolo único (por "
"ejemplo, DT[var]), data.table busca var en el ámbito de llamada."

msgid ""
"i is invalid type (matrix). Perhaps in future a 2 column matrix could return "
"a list of elements of DT (in the spirit of A[B] in FAQ 2.14). Please report "
"to data.table issue tracker if you'd like this, or add your comments to FR "
"#657."
msgstr ""
"i es un tipo no válido (matriz). Quizás en el futuro una matriz de 2 "
"columnas podría devolver una lista de elementos de DT (en el espíritu de "
"A[B] en la pregunta frecuente 2.14). Informe al rastreador de problemas de "
"data.table si desea esto o agregue sus comentarios al FR #657."

msgid ""
"When i is a data.table (or character vector), the columns to join by must be "
"specified using 'on=' argument (see ?data.table), by keying x (i.e. sorted, "
"and, marked as sorted, see ?setkey), or by sharing column names between x "
"and i (i.e., a natural join). Keyed joins might have further speed benefits "
"on very large data due to x being sorted in RAM."
msgstr ""
"Cuando i es una tabla de datos (o un vector de caracteres), las columnas "
"para unir deben especificarse usando el argumento 'on=' (ver ?data.table), "
"ingresando x (es decir, ordenadas y marcadas como ordenadas, consulte ?"
"setkey), o compartiendo nombres de columnas entre xey (es decir, una unión "
"natural). Las uniones por clave pueden tener mayores beneficios de velocidad "
"en datos muy grandes debido a que x se ordena en la RAM."

msgid "Attempting to do natural join but no common columns in provided tables"
msgstr ""
"Intentando realizar una unión natural pero sin columnas comunes en las "
"tablas proporcionadas"

msgid "Internal error. Cannot by=.EACHI when joining to an index, yet"
msgstr ""
"Error interno. No es posible by=.EACHI cuando se hace join a un índice, "
"todavía"

msgid "Internal error. irows has length in by=.EACHI"
msgstr "Error interno. irows tiene longitud en by=.EACHI"

msgid "logical error. i is not a data.table, but 'on' argument is provided."
msgstr ""
"error lógico. i no es data.table, pero se proporciona el argumento 'on'."

msgid "i has evaluated to type %s. Expecting logical, integer or double."
msgstr "i fue evaluado como tipo %s. Se esperaba lógico, entero o doble."

msgid ""
"internal error: notjoin and which=NA (non-matches), huh? please provide "
"reproducible example to issue tracker"
msgstr ""
"error interno: not-join y which=NA (los no coincidentes), ¿eh? proporcione "
"un ejemplo reproducible para el rastreador de errores"

msgid ""
"i evaluates to a logical vector length %d but there are %d rows. Recycling "
"of logical i is no longer allowed as it hides more bugs than is worth the "
"rare convenience. Explicitly use rep(...,length=.N) if you really need to "
"recycle."
msgstr ""
"i se evalúa como vector lógico de longitud %d pero hay %d filas. Ya no se "
"permite el reciclaje de i lógico, ya que esto oculta más errores de los que "
"su rara conveniencia merece. Utilice explícitamente rep(...,length=.N) si "
"realmente necesita reciclar."

msgid ""
"Please use nomatch=NULL instead of nomatch=0; see news item 5 in v1.12.0 "
"(Jan 2019)"
msgstr ""
"Utilice nomatch=NULL en lugar de nomatch=0; ver novedades ítem 5 en v1.12.0 "
"(ene 2019)"

msgid "Internal error: notjoin but byjoin or !integer or nomatch==NA"
msgstr "Error interno: notjoin pero byjoin o !integer o nomatch==NA"

msgid ""
"with=FALSE together with := was deprecated in v1.9.4 released Oct 2014. "
"Please wrap the LHS of := with parentheses; e.g., DT[,(myVar):=sum(b),by=a] "
"to assign to column name(s) held in variable myVar. See ?':=' for other "
"examples. As warned in 2014, this is now a warning."
msgstr ""
"with=FALSE junto con := quedó obsoleto en la versión 1.9.4 lanzada en "
"octubre de 2014. Envuelva el LHS de := entre paréntesis; por ejemplo, DT[,"
"(myVar):=sum(b),by=a] para asignar a los nombres de las columnas contenidas "
"en la variable myVar. Consulte ?':=' para ver otros ejemplos. Como se "
"advirtió en 2014, esto ahora es una advertencia."

msgid ""
"with=FALSE ignored, it isn't needed when using :=. See ?':=' for examples."
msgstr ""
"with=FALSE ignorado, no es necesario cuando se usa :=. Consulte ?':=' para "
"ver ejemplos."

msgid "column(s) not removed because not found: %s"
msgstr "columnas no eliminadas porque no se encontraron: %s"

msgid "column(s) not found: %s"
msgstr "columnas no encontradas: %s"

msgid "Item %d of j is %d which is outside the column number range [1,ncol=%d]"
msgstr ""
"El elemento %d de j es %d que está fuera del rango de números de columna [1,"
"ncol=%d]"

msgid "j mixes positives and negatives"
msgstr "j mezcla índices positivos y negativos"

msgid ""
"When with=FALSE, j-argument should be of type logical/character/integer "
"indicating the columns to select."
msgstr ""
"Cuando with=FALSE, el argumento j debe ser de tipo lógico/carácter/entero "
"indicando las columnas a seleccionar."

msgid ""
"'by' contains .I but only the following are currently supported: by=.I, by=."
"(.I), by=c(.I), by=list(.I)"
msgstr ""
"'by' contiene .I, pero actualmente solo se admiten los siguientes: by=.I, "
"by=.(.I), by=c(.I), by=list(.I)"

msgid "by=c(...), key(...) or names(...) must evaluate to 'character'"
msgstr "by=c(...), key(...) o names(...) deben evaluarse como carácter"

msgid "At least one entry of by is empty"
msgstr "Al menos una entrada de by está vacía"

msgid "Internal error: irows isn't integer"
msgstr "Error interno: irows no es un número entero"

msgid ""
"'by' appears to evaluate to column names but isn't c() or key(). Use "
"by=list(...) if you can. Otherwise, by=eval%s should work. This is for "
"efficiency so data.table can detect which columns are needed."
msgstr ""
"'by' parece evaluar los nombres de las columnas pero no es c() o key(). "
"Utilice by=list(...) si puede. De lo contrario, by=eval%s debería funcionar. "
"Esto es por eficiencia para que data.table pueda detectar qué columnas son "
"necesarias."

msgid ""
"'by' or 'keyby' must evaluate to a vector or a list of vectors (where 'list' "
"includes data.table and data.frame which are lists, too)"
msgstr ""
"'by' o 'keyby' deben evaluarse como un vector o una lista de vectores (donde "
"'list' incluye data.table y data. frame que también son listas)"

msgid ""
"Column or expression %d of 'by' or 'keyby' is type '%s' which is not "
"currently supported. If you have a compelling use case, please add it to "
"https://github.com/Rdatatable/data.table/issues/1597. As a workaround, "
"consider converting the column to a supported type, e.g. by=sapply(list_col, "
"toString), whilst taking care to maintain distinctness in the process."
msgstr ""
"La columna o expresión %d de 'by' o 'keyby' es de tipo '%s' que no se admite "
"actualmente. Si tiene un caso de uso convincente, agréguelo a https://github."
"com/Rdatatable/data.table/issues/1597. Como solución alternativa, considere "
"convertir la columna a un tipo admitido, p. by=sapply(list_col, toString), "
"teniendo cuidado de mantener la distinción en el proceso."

msgid ""
"The items in the 'by' or 'keyby' list are length(s) %s. Each must be length "
"%d; the same length as there are rows in x (after subsetting if i is "
"provided)."
msgstr ""
"Los elementos en la lista 'by' o 'keyby' tienen length(es) %s. Cada uno debe "
"tener una length %d; la misma length que filas en x (después del subconjunto "
"si se proporciona i)."

msgid "Internal error: drop_dot passed %d items"
msgstr "Error interno: drop_dot pasó %d elementos"

msgid "Item %d of the .() or list() passed to j is missing"
msgstr "Falta el elemento %d de .() o list() pasado a j"

msgid ""
"j may not evaluate to the same number of columns for each group; if you're "
"sure this warning is in error, please put the branching logic outside of [ "
"for efficiency"
msgstr ""
"j puede no estar evaluando el mismo número de columnas para cada grupo; Si "
"está seguro de que esta advertencia es un error, coloque la lógica de "
"bifurcación fuera de [ para mayor eficiencia"

msgid ""
"Different branches of j expression produced different auto-named columns: "
"%s; using the most \"last\" names. If this was intentional (e.g., you know "
"only one branch will ever be used in a given query because the branch is "
"controlled by a function argument), please (1) pull this branch out of the "
"call; (2) explicitly provide missing defaults for each branch in all cases; "
"or (3) use the same name for each branch and re-name it in a follow-up call."
msgstr ""
"Diferentes ramas de la expresión j produjeron diferentes columnas con nombre "
"automático: %s; usando la mayoría de los nombres \"last\". Si esto fue "
"intencional (por ejemplo, sabe que solo se usará una rama en una consulta "
"determinada porque la rama está controlada por un argumento de función), (1) "
"retire esta rama de la llamada; (2) proporcione explícitamente los valores "
"predeterminados faltantes para cada rama en todos los casos; o (3) use el "
"mismo nombre para cada rama y cambie el nombre en una llamada de terminación."

msgid ""
"When .SDcols is a function, it is applied to each column; the output of this "
"function must be a non-missing boolean scalar signalling inclusion/exclusion "
"of the column. However, these conditions were not met for: %s"
msgstr ""
"Cuando .SDcols es una función, se aplica a cada columna; la salida de esta "
"función debe ser un escalar booleano no faltante que indique la inclusión/"
"exclusión de la columna. Sin embargo, estas condiciones no se cumplieron "
"para: %s"

msgid ".SDcols missing at the following indices: %s"
msgstr ".SDcols faltantes en los siguientes índices: %s"

msgid ".SDcols is a logical vector length %d but there are %d columns"
msgstr ".SDcols es un vector lógico de longitud %d pero hay %d columnas"

msgid ".SDcols is numeric but has both +ve and -ve indices"
msgstr ".SDcols es numérico pero tiene índices tanto positivos como negativos"

msgid ".SDcols is numeric but out of bounds [1, %d] at: %s"
msgstr ".SDcols es numérico pero está fuera de los límites [1, %d] en: %s"

msgid ".SDcols should be column numbers or names"
msgstr ".SDcols debe ser números o nombres de columnas"

msgid "Some items of .SDcols are not column names: %s"
msgstr "Algunos elementos de .SDcols no son nombres de columnas: %s"

msgid ""
"This j doesn't use .SD but .SDcols has been supplied. Ignoring .SDcols. See ?"
"data.table."
msgstr ""
"Este j no usa .SD pero se ha proporcionado .SDcols. Ignorando .SDcols. "
"Consulte ?data.table."

msgid ""
".SD is locked. Using := in .SD's j is reserved for possible future use; a "
"tortuously flexible way to modify by group. Use := in j directly to modify "
"by group by reference."
msgstr ""
".SD está bloqueado. El uso := en .SD's j está reservado para un posible uso "
"futuro; una forma tortuosamente flexible de modificar por grupo. Utilice := "
"en j directamente para modificar por grupo por referencia."

msgid "In %s(col1=val1, col2=val2, ...) form, all arguments must be named."
msgstr ""
"En la forma %s(col1=val1, col2=val2, ...), todos los argumentos deben tener "
"nombre."

msgid ""
"In %s(col1=val1, col2=val2, ...) form, all arguments must be named, but the "
"last argument has no name. Did you forget a trailing comma?"
msgstr ""
"En el formato %s(col1=val1, col2=val2, ...), todos los argumentos deben "
"tener nombre, pero el último argumento no tiene nombre. ¿Olvidó una coma "
"final?"

msgid ""
"In %s(col1=val1, col2=val2, ...) form, all arguments must be named, but "
"these arguments lack names: %s."
msgstr ""
"En el formato %s(col1=val1, col2=val2, ...), todos los argumentos deben "
"tener nombre, pero estos argumentos carecen de nombre: %s."

msgid ""
"LHS of := must be a symbol, or an atomic vector (column names or positions)."
msgstr ""
"LHS de := debe ser un símbolo o un vector atómico (nombres o posiciones de "
"columnas)."

msgid ""
"LHS of := appears to be column positions but are outside [1,ncol] range. New "
"columns can only be added by name."
msgstr ""
"LHS de := parecen ser posiciones de columna pero están fuera del rango [1,"
"ncol]. Solo se pueden agregar nuevas columnas por nombre."

msgid ""
"LHS of := isn't column names ('character') or positions ('integer' or "
"'numeric')"
msgstr ""
"LHS de := no son nombres de columnas ('character') ni posiciones ('integer' "
"o 'numeric')"

msgid ""
"Invalid .internal.selfref detected and fixed by taking a (shallow) copy of "
"the data.table so that := can add this new column by reference. At an "
"earlier point, this data.table has been copied by R (or was created manually "
"using structure() or similar). Avoid names<- and attr<- which in R currently "
"(and oddly) may copy the whole data.table. Use set* syntax instead to avoid "
"copying: ?set, ?setnames and ?setattr. If this message doesn't help, please "
"report your use case to the data.table issue tracker so the root cause can "
"be fixed or this message improved."
msgstr ""
" .internal.selfref no válido detectado y solucionado tomando una copia "
"(superficial) de data.table para que := pueda agregar esta nueva columna por "
"referencia. En un momento anterior, R copió esta data.table (o se creó "
"manualmente usando structure() o similar). Evite names<- y attr<- que en R "
"actualmente (y curiosamente) pueden copiar toda la data.table. Utilice la "
"sintaxis set* en su lugar para evitar copiar: ?set, ?setnames y ?setattr. Si "
"este mensaje no ayuda, informe su caso de uso al rastreador de problemas de "
"data.table para que se pueda solucionar la causa raíz o mejorar este mensaje."

msgid ""
"Cannot assign to an under-allocated recursively indexed list -- L[[i]][,:=] "
"syntax is only valid when i is length 1, but its length is %d"
msgstr ""
"No se puede asignar a una lista indexada recursiva con  espacio sub-"
"asignado: la sintaxis L[[i]][,:=] solo es válida cuando i tiene una longitud "
"de 1, pero su longitud es %d"

msgid "Internal error -- item '%s' not found in names of list"
msgstr ""
"Error interno: el elemento '%s' no se encuentra en los nombres de la lista"

msgid "Internal error -- column(s) not found: %s"
msgstr "Error interno: columna(s) no encontrada(s): %s"

msgid ""
"strptime() usage detected and wrapped with as.POSIXct(). This is to minimize "
"the chance of assigning POSIXlt columns, which use 40+ bytes to store one "
"date (versus 8 for POSIXct). Use as.POSIXct() (which will call strptime() as "
"needed internally) to avoid this warning."
msgstr ""
"uso de strptime() detectado y ajustado con as.POSIXct(). Esto es para "
"minimizar la posibilidad de asignar columnas POSIXlt, que utilizan más de 40 "
"bytes para almacenar una fecha (frente a 8 para POSIXct). Utilice as."
"POSIXct() (que llamará a strptime() según sea necesario internamente) para "
"evitar esta advertencia."

msgid ""
"Variable '%s' is not found in calling scope. Looking in calling scope "
"because this symbol was prefixed with .. in the j= parameter."
msgstr ""
"La variable '%s' no se encuentra en el ámbito de la llamada. Se busca en el "
"ámbito de la llamada porque este símbolo tenía el prefijo .. en el parámetro "
"j=."

msgid "Internal error: xcolAns does not pass checks: %d/%d/%d/%s"
msgstr "Error interno: xcolAns no pasa las comprobaciones: %d/%d/%d/%s"

msgid ""
"Internal error: irows is NULL when making join result at R level. Should no "
"longer happen now we use CsubsetDT earlier."
msgstr ""
"Error interno: irows es NULL al realizar la unión como resultado en el nivel "
"R. Ya no debería suceder ahora que usamos CsubsetDT antes."

msgid ""
"j (the 2nd argument inside [...]) is a single symbol but column name '%1$s' "
"is not found. If you intended to select columns using a variable in calling "
"scope, please try DT[, ..%1$s]. The .. prefix conveys one-level-up similar "
"to a file system path."
msgstr ""
"j (el segundo argumento dentro de [...]) es un símbolo único pero no se "
"encuentra el nombre de la columna '%1$s'. Si tenía la intención de "
"seleccionar columnas usando una variable al llamar al ámbito, intente con "
"DT[, ..%1$s]. El prefijo .. transmite un nivel superior similar a la ruta de "
"un sistema de archivos."

msgid ""
"Internal error: j has created a data.table result containing a NULL column"
msgstr ""
"Error interno: j ha creado un resultado de data.table que contiene una "
"columna NULL"

msgid ""
"The column '.N' can't be grouped because it conflicts with the special .N "
"variable. Try setnames(DT,'.N','N') first."
msgstr ""
"La columna '.N' no se puede agrupar porque entra en conflicto con la "
"variable especial .N. Pruebe setnames(DT,'.N','N') primero."

msgid ""
"The column '.I' can't be grouped because it conflicts with the special .I "
"variable. Try setnames(DT,'.I','I') first."
msgstr ""
"La columna '.I' no se puede agrupar porque entra en conflicto con la "
"variable especial .I. Pruebe setnames(DT,'.I','I') primero."

msgid "logical error. i is not data.table, but mult='all' and 'by'=.EACHI"
msgstr "error lógico. i no es data.table, pero mult='all' y 'by'=.EACHI"

msgid "Internal error: by= is missing"
msgstr "Error interno: by= faltante"

msgid "Internal error: byindex not the index name"
msgstr "Error interno: byindex no es el nombre del índice"

msgid "Internal error: byindex not found"
msgstr "Error interno: byindex no encontrado"

msgid ""
"Unable to optimize call to mean() and could be very slow. You must name 'na."
"rm' like that otherwise if you do mean(x,TRUE) the TRUE is taken to mean "
"'trim' which is the 2nd argument of mean. 'trim' is not yet optimized."
msgstr ""
"No se puede optimizar la llamada a mean() y podría ser muy lento. Debe "
"nombrar 'na.rm' así; de lo contrario, si quiere decir (x, TRUE), se "
"considera que TRUE significa 'trim', que es el segundo argumento de la "
"media. 'trim' aún no está optimizado."

msgid "Internal error: length(irows)!=length(o__)"
msgstr "Error interno: length(irows)!=length(o__)"

msgid ""
"The setkey() normally performed by keyby= has been skipped (as if by= was "
"used) because := is being used together with keyby= but the keyby= contains "
"some expressions. To avoid this warning, use by= instead, or provide "
"existing column names to keyby=."
msgstr ""
"El setkey() normalmente realizado por keyby= se ha omitido (como si se usara "
"by=) porque := se usa junto con keyby= pero keyby= contiene algunas "
"expresiones. Para evitar esta advertencia, utilice by= en su lugar o "
"proporcione nombres de columnas existentes a keyby=."

msgid "Internal error: jvnames is length %d but ans is %d and bynames is %d"
msgstr ""
"Error interno: jvnames tiene una longitud %d pero ans es %d y bynames es %d"

msgid "rownames and rownames.value cannot both be used at the same time"
msgstr "rownames y rownames.value no se pueden usar al mismo tiempo"

msgid ""
"length(rownames)==%d but nrow(DT)==%d. The rownames argument specifies a "
"single column name or number. Consider rownames.value= instead."
msgstr ""
"length(rownames)==%d pero nrow(DT)==%d. El argumento rownames especifica un "
"único nombre o número de columna. Considere rownames.value= en su lugar."

msgid ""
"length(rownames)==0 but should be a single column name or number, or NULL"
msgstr ""
"length(rownames)==0 pero debe ser un nombre o número de columna única, o NULL"

msgid ""
"rownames is TRUE but key has multiple columns %s; taking first column x[,1] "
"as rownames"
msgstr ""
"rownames es TRUE pero la clave tiene varias columnas %s; tomando la primera "
"columna x[,1] como nombres de fila"

msgid "'%s' is not a column of x"
msgstr "'%s' no es una columna de x"

msgid ""
"as.integer(rownames)==%d which is outside the column number range [1,ncol="
"%d]."
msgstr ""
"as.integer(rownames)==%d que está fuera del rango de números de columna [1,"
"ncol=%d]."

msgid "length(rownames.value)==%d but should be nrow(x)==%d"
msgstr "length(rownames.value)==%d pero debería ser nrow(x)==%d"

msgid ""
"Internal error: as.matrix.data.table length(X)==%d but a dimension is zero"
msgstr ""
"Error interno: as.matrix.data.table length(X)==%d pero una dimensión es cero"

msgid ""
"When i is a matrix in DT[i]<-value syntax, it doesn't make sense to provide j"
msgstr ""
"Cuando i es una matriz en DT[i]<-sintaxis de valor, no tiene sentido "
"proporcionar j"

msgid "j must be an atomic vector, see ?is.atomic"
msgstr "j debe ser un vector atómico, ver ?is.atomic"

msgid "NA in j"
msgstr "NA en j"

msgid "j must be vector of column name or positions"
msgstr "j debe ser un vector del nombre de la columna o de las posiciones"

msgid ""
"Attempt to assign to column position greater than ncol(x). Create the column "
"by name, instead. This logic intends to catch (most likely) user errors."
msgstr ""
"intento de asignar una posición de columna mayor que ncol(x). En su lugar, "
"cree la columna por nombre. Esta lógica pretende detectar (los que "
"probablemente sean) errores de usuario."

msgid ""
"data.table inherits from data.frame (from v1.5), but this data.table does "
"not. Has it been created manually (e.g. by using 'structure' rather than "
"'data.table') or saved to disk using a prior version of data.table?"
msgstr ""
"data.table hereda de data.frame (de v1.5), pero este data.table no. ¿Se ha "
"creado manualmente (por ejemplo, utilizando 'structure' en lugar de 'data."
"table') o se ha guardado en el disco utilizando una versión anterior de data."
"table?"

msgid "attempting to assign invalid object to dimnames of a data.table"
msgstr ""
"intento de asignar un objeto no válido a los nombres tenues de una data.table"

msgid "data.tables do not have rownames"
msgstr "las data.tables no tienen nombres de fila"

msgid "Can't assign %d names to a %d-column data.table"
msgstr "No se pueden asignar %d nombres a una data.table de %d columnas"

msgid "'subset' must evaluate to logical"
msgstr "'subset' debe evaluarse como lógico"

msgid "Argument 'invert' must be logical TRUE/FALSE"
msgstr "El argumento 'invert' debe ser lógico TRUE/FALSE"

msgid "x argument must be a data.table"
msgstr "x argumento debe ser una data.table"

msgid "group length is 0 but data nrow > 0"
msgstr "la longitud del grupo es 0 pero los datos son > 0"

msgid ""
"passing 'f' argument together with 'by' is not allowed, use 'by' when split "
"by column in data.table and 'f' when split by external factor"
msgstr ""
"no se permite pasar el argumento 'f' junto con 'by', utilice 'by' cuando se "
"divida por columna en data.table y 'f' cuando se divida por factor externo"

msgid "Either 'by' or 'f' argument must be supplied"
msgstr "Se debe proporcionar el argumento 'by' o 'f'"

msgid "Column '.ll.tech.split' is reserved for split.data.table processing"
msgstr ""
"La columna '.ll.tech.split' está reservada para el procesamiento de split."
"data.table"

msgid "Column '.nm.tech.split' is reserved for split.data.table processing"
msgstr ""
"La columna '.nm.tech.split' está reservada para el procesamiento de split."
"data.table"

msgid "Argument 'by' must refer to column names in x"
msgstr ""
"El argumento 'by' debe hacer referencia a los nombres de las columnas en x"

msgid ""
"Argument 'by' must refer only to atomic-type columns, but the following "
"columns are non-atomic: %s"
msgstr ""
"El argumento 'by' debe hacer referencia solo a columnas de tipo atómico, "
"pero las siguientes columnas no son atómicas: %s"

msgid ""
"x is not a data.table|frame. Shallow copy is a copy of the vector of column "
"pointers (only), so is only meaningful for data.table|frame"
msgstr ""
"x no es data.frame o data.table. La copia superficial es una copia del "
"vector de punteros de columna (únicamente), por lo que solo tiene sentido "
"para data.table o data.frame"

msgid "setalloccol attempting to modify `*tmp*`"
msgstr "setalloccol intenta modificar `*tmp*`"

msgid ""
"Input is a length=1 logical that points to the same address as R's global "
"value. Therefore the attribute has not been set by reference, rather on a "
"copy. You will need to assign the result back to a variable. See issue #1281."
msgstr ""
"La entrada es un vector lógico de longitud=1 que apunta a la misma dirección "
"que el valor global de R. Por lo tanto el atributo no ha sido establecido "
"por referencia, sino sobre una copia. Deberá volver a asignar el resultado a "
"una variable. Consulte el issue #1281."

msgid "x is not a data.table or data.frame"
msgstr "x no es una data.table o un data.frame"

msgid "x has %d columns but its names are length %d"
msgstr "x tiene %d columnas pero sus nombres tienen una longitud %d"

msgid "Passed a vector of type '%s'. Needs to be type 'character'."
msgstr "Se pasó un vector de tipo '%s'. Debe escribirse 'character'."

msgid "'new' is not a character vector or a function"
msgstr "'new' no es un vector de caracteres ni una función"

msgid "NA in 'new' at positions %s"
msgstr "NA en 'new' en las posiciones %s"

msgid "Some duplicates exist in 'old': %s"
msgstr "Existen algunos duplicados en 'old': %s"

msgid "'old' is type %s but should be integer, double or character"
msgstr "'old' es de tipo %s pero debe ser un número entero, doble o carácter"

msgid "'old' is length %d but 'new' is length %d"
msgstr "'old' tiene una longitud %d pero 'new' tiene una longitud %d"

msgid "NA (or out of bounds) in 'old' at positions %s"
msgstr "NA (o fuera de límites) en 'old' en las posiciones %s"

msgid ""
"Item %d of 'old' is '%s' which appears several times in column names. Just "
"the first will be changed. There are %d other items in 'old' that are also "
"duplicated in column names."
msgstr ""
"El elemento %d de 'old' es '%s' que aparece varias veces en los nombres de "
"las columnas. Sólo se cambiará el primero. Hay %d otros elementos en 'old' "
"que también están duplicados en los nombres de las columnas."

msgid ""
"Items of 'old' not found in column names: %s. Consider skip_absent=TRUE."
msgstr ""
"Elementos de 'old' no encontrados en los nombres de las columnas: %s. "
"Considere skip_absent=TRUE."

msgid "Internal error: length(i)!=length(new)"
msgstr "Error interno: length(i)!=length(nuevo)"

msgid ""
"x has some duplicated column name(s): %s. Please remove or rename the "
"duplicate(s) and try again."
msgstr ""
"x tiene algunos nombres de columna duplicados: %s. Elimine o cambie el "
"nombre de los duplicados e inténtelo de nuevo."

msgid "Provide either before= or after= but not both"
msgstr "Proporcione before= o after= pero no ambos"

msgid "before=/after= accept a single column name or number, not more than one"
msgstr ""
"before=/after= aceptar un solo nombre de columna o número, no más de uno"

msgid "Input is %s but should be a plain list of items to be stacked"
msgstr ""
"La entrada es %s pero debería ser una lista simple de elementos a apilar"

msgid ""
"idcol must be a logical or character vector of length 1. If logical TRUE the "
"id column will named '.id'."
msgstr ""
"idcol debe ser un vector lógico o de caracteres de longitud 1. Si es TRUE "
"lógico, la columna de identificación se llamará '.id'."

msgid "use.names=NA invalid"
msgstr "use.names=NA no válido"

msgid ""
"use.names='check' cannot be used explicitly because the value 'check' is new "
"in v1.12.2 and subject to change. It is just meant to convey default "
"behavior. See ?rbindlist."
msgstr ""
"use.names='check' no se puede usar explícitamente porque el valor 'check' es "
"nuevo en v1.12.2 y está sujeto a cambios. Simplemente está destinado a "
"transmitir un comportamiento predeterminado. Consulte ?rbindlist."

msgid ""
"Check that is.data.table(DT) == TRUE. Otherwise, :=, `:=`(...) and let(...) "
"are defined for use in j, once only and in particular ways. See help(\":=\")."
msgstr ""
"Compruebe que is.data.table(DT) == TRUE. De lo contrario, :=, `:=`(...) y "
"let(...) se definen para su uso en j, una sola vez y de manera particular. "
"Ver ayuda(\":=\")."

msgid "J() called outside of [.data.table. J() is only intended for use in i."
msgstr ""
"J() se llamó fuera de [.data.table. J() solo está destinado a usarse en i."

msgid ""
".() called outside of [.data.table. .() is only intended as an alias for "
"list() inside DT[...]."
msgstr ""
".() se llamó fuera de [.data.table. .() solo está pensado como un alias para "
"list() dentro de DT[...]."

msgid ""
"setDF only accepts data.table, data.frame or list of equal length as input"
msgstr ""
"setDF solo acepta data.table, data.frame o lista de igual longitud como "
"entrada"

msgid "rownames contains duplicates"
msgstr "rownames contiene duplicados"

msgid "rownames incorrect length; expected %d names, got %d"
msgstr ""
"rownames de longitud incorrecta; %d nombres esperados, se obtuvieron %d"

msgid "All elements in argument 'x' to 'setDF' must be of same length"
msgstr ""
"Todos los elementos del argumento 'x' a 'setDF' deben tener la misma longitud"

msgid "Cannot find symbol %s"
msgstr "No se puede encontrar el símbolo %s"

msgid ""
"Cannot convert '%1$s' to data.table by reference because binding is locked. "
"It is very likely that '%1$s' resides within a package (or an environment) "
"that is locked to prevent modifying its variable bindings. Try copying the "
"object to your current environment, ex: var <- copy(var) and then using "
"setDT again."
msgstr ""
"No se puede convertir '%1$s' a data.table por referencia porque el "
"vinculación (binding) está bloqueado. Es muy probable que '%1$s' resida "
"dentro de un paquete (o entorno) que esté bloqueado para evitar modificar "
"sus vinculaciones de nombres de variables. Intente copiar el objeto a su "
"entorno actual, por ejemplo: var <- copy(var) y luego use setDT nuevamente."

msgid ""
"Argument 'x' to 'setDT' should be a 'list', 'data.frame' or 'data.table'"
msgstr ""
"El argumento 'x' a 'setDT' debe ser 'list', 'data.frame' o 'data.table'"

msgid "Item '%s' not found in names of input list"
msgstr "El elemento '%s' no se encuentra en los nombres de la lista de entrada"

msgid "'prefix' must be NULL or a character vector of length 1."
msgstr "'prefix' debe ser NULL o un vector de caracteres de longitud 1."

msgid "x is a single vector, non-NULL 'cols' doesn't make sense."
msgstr "x es un vector único, 'cols' no NULL no tiene sentido."

msgid "x is a list, 'cols' cannot be 0-length."
msgstr "x es una lista, 'cols' no puede tener una longitud de 0."

msgid ""
"RHS of %s is length %d which is not 1 or nrow (%d). For robustness, no "
"recycling is allowed (other than of length 1 RHS). Consider %%in%% instead."
msgstr ""
"RHS de %s tiene una longitud %d que no es 1 ni nrow (%d). Por razones de "
"robustez, no se permite ningún reciclaje (excepto el de longitud 1 RHS). "
"Considere %%in%% en su lugar."

msgid ""
"Internal error in .isFastSubsettable. Please report to data.table developers"
msgstr ""
"Error interno en .isFastSubsettable. Informe a los desarrolladores de data."
"table"

msgid ""
"'on' argument should be a named atomic vector of column names indicating "
"which columns in 'i' should be joined with which columns in 'x'."
msgstr ""
"El argumento >>'on' debe ser un vector atómico con nombre de nombres de "
"columnas que indique qué columnas en 'i' deben unirse con qué columnas en "
"'x'."

msgid ""
"Found more than one operator in one 'on' statement: %s. Please specify a "
"single operator."
msgstr ""
"Se encontró más de un operador en una declaración 'on': %s. Por favor "
"especifique un solo operador."

msgid ""
"'on' contains no column name: %s. Each 'on' clause must contain one or two "
"column names."
msgstr ""
"'on' no contiene ningún nombre de columna: %s. Cada cláusula 'on' debe "
"contener uno o dos nombres de columna."

msgid ""
"'on' contains more than 2 column names: %s. Each 'on' clause must contain "
"one or two column names."
msgstr ""
"'on' contiene más de 2 nombres de columnas: %s. Cada cláusula 'on' debe "
"contener uno o dos nombres de columna."

msgid "Invalid join operators %s. Only allowed operators are %s."
msgstr ""
"Operadores de unión no válidos %s. Los únicos operadores permitidos son %s."

msgid "There is no package %s in provided repository."
msgstr "No hay ningún paquete %s en el repositorio proporcionado."

msgid "'fromLast' must be TRUE or FALSE"
msgstr "'fromLast' debe ser TRUE o FALSE"

msgid "x must be an atomic vector or data.frames/data.tables"
msgstr "x debe ser un vector atómico o data.frames/data.tables"

msgid "Using '%s' as value column. Use 'value.var' to override"
msgstr "Usando '%s' como columna de valor. Utilice 'value.var' para anular"

msgid ""
"The %1$s generic in data.table has been passed a %2$s, but data.table::%1$s "
"currently only has a method for data.tables. Please confirm your input is a "
"data.table, with setDT(%3$s) or as.data.table(%3$s). If you intend to use a "
"method from reshape2, try installing that package first, but do note that "
"reshape2 is superseded and is no longer actively developed."
msgstr ""
"Al %1$s genérico en data.table se le ha pasado %2$s, pero data.table::%1$s "
"actualmente solo tiene un método para data.tables. Confirme que su entrada "
"es data.table, con setDT(%3$s) o as.data.table(%3$s). Si tiene la intención "
"de utilizar un método de reshape2, intente instalar ese paquete primero, "
"pero tenga en cuenta que reshape2 ha sido reemplazado y ya no se desarrolla "
"activamente."

msgid ""
"The %1$s generic in data.table has been passed a %2$s and will attempt to "
"redirect to the relevant reshape2 method; please note that reshape2 is "
"superseded and is no longer actively developed, and this redirection is now "
"deprecated. Please do this redirection yourself like reshape2::%1$s(%3$s). "
"In the next version, this warning will become an error."
msgstr ""
"Al %1$s genérico en data.table se le ha pasado un %2$s e intentará redirigir "
"al método reshape2 relevante; tenga en cuenta que reshape2 ha sido "
"reemplazado y ya no se desarrolla activamente, y esta redirección ahora está "
"obsoleta. Realice esta redirección usted mismo como reshape2::%1$s(%3$s). En "
"la próxima versión, esta advertencia se convertirá en un error."

msgid ""
"Invalid formula. Cast formula should be of the form LHS ~ RHS, for e.g., a + "
"b ~ c."
msgstr ""
"Fórmula no válida. La fórmula moldeada debe tener la forma LHS ~ RHS, por "
"ejemplo, a + b ~ c."

msgid "data.table to cast must have unique column names"
msgstr "data.table para transmitir debe tener nombres de columna únicos"

msgid "value.var values %s are not found in 'data'."
msgstr "valores de value.var %s no se encuentran en 'data'."

msgid ""
"When 'fun.aggregate' and 'value.var' are both lists, 'value.var' must be "
"either of length =1 or =length(fun.aggregate)."
msgstr ""
"Cuando 'fun.aggregate' y 'value.var' son listas, 'value.var' debe tener "
"length =1 o =length(fun.aggregate)."

msgid "'data' must be a data.table."
msgstr "'data' debe ser una data.table."

msgid "'drop' must be logical TRUE/FALSE"
msgstr "'drop' debe ser lógico TRUE/FALSE"

msgid "Argument 'value.var.in.dots' should be logical TRUE/FALSE"
msgstr "El argumento 'value.var.in.dots' debe ser TRUE/FALSE lógico"

msgid ""
"Arguments 'value.var.in.LHSdots', 'value.var.in.RHSdots' should be logical "
"TRUE/FALSE"
msgstr ""
"Los argumentos 'value.var.in.LHSdots', 'value.var.in.RHSdots' deben ser TRUE/"
"FALSE lógico"

msgid "Column [%s] not found or of unknown type."
msgstr "Columna [%s] no encontrada o de tipo desconocido."

msgid "Columns specified in formula can not be of type list"
msgstr "Las columnas especificadas en la fórmula no pueden ser de tipo lista"

msgid ""
"'fun.aggregate' is NULL, but found duplicate row/column combinations, so "
"defaulting to length(). That is, the variables %s used in 'formula' do not "
"uniquely identify rows in the input 'data'. In such cases, 'fun.aggregate' "
"is used to derive a single representative value for each combination in the "
"output data.table, for example by summing or averaging (fun.aggregate=sum or "
"fun.aggregate=mean, respectively). Check the resulting table for values "
"larger than 1 to see which combinations were not unique. See ?dcast.data."
"table for more details."
msgstr ""
"'fun.aggregate' es NULL, pero encontró combinaciones de fila/columna "
"duplicadas, por lo que se usa length() de manera predeterminada. Es decir, "
"las variables %s utilizadas en 'formula' no identifican de manera única las "
"filas en la entrada 'data'. En tales casos, 'fun.aggregate' se utiliza para "
"derivar un único valor representativo para cada combinación en la tabla de "
"datos de salida, por ejemplo, sumando o promediando (fun.aggregate=sum o fun."
"aggregate=mean, respectivamente). Verifique la tabla resultante para ver si "
"hay valores mayores que 1 para ver qué combinaciones no fueron únicas. "
"Consulte ?dcast.data.table para obtener más detalles."

msgid ""
"Aggregating function(s) should take vector inputs and return a single value "
"(length=1). However, function(s) returns length!=1. This value will have to "
"be used to fill any missing combinations, and therefore must be length=1. "
"Either override by setting the 'fill' argument explicitly or modify your "
"function to handle this case appropriately."
msgstr ""
"Las funciones de agregación deben tomar entradas vectoriales y devolver un "
"valor único (longitud=1). Sin embargo, las funciones devuelven longitud!=1. "
"Este valor tiene que  usarse para completar cualquier combinación que falte "
"y, por lo tanto, debe tener una longitud = 1. Anule este comportamiento "
"estableciendo el argumento 'fill' explícitamente o modifique su función para "
"manejar este caso de manera adecuada."

msgid "Internal error -- empty rhsnames in dcast; please report"
msgstr "Error interno: rshnames vacíos en en dcast; por favor reportar"

msgid ""
"The %1$s generic in data.table has been passed a %2$s and will attempt to "
"redirect to the relevant reshape2 method; please note that reshape2 is "
"superseded and is no longer actively developed, and this redirection is now "
"deprecated. To continue using melt methods from reshape2 while both "
"libraries are attached, e.g. melt.list, you can prepend the namespace, i.e. "
"reshape2::%1$s(%3$s). In the next version, this warning will become an error."
msgstr ""
"Al %1$s genérico en data.table se le ha pasado un %2$s e intentará redirigir "
"al método reshape2 relevante; tenga en cuenta que reshape2 ha sido "
"reemplazado y ya no se desarrolla activamente, y esta redirección ahora está "
"obsoleta. Para continuar usando métodos de fusión de reshape2 mientras ambas "
"bibliotecas están adjuntas, p. melt.list, puede anteponer el espacio de "
"nombres, es decir, reshape2::%1$s(%3$s). En la próxima versión, esta "
"advertencia se convertirá en un error."

msgid "Input patterns must be of type character."
msgstr "Los patrones de entrada deben ser de tipo carácter."

msgid "Pattern(s) not found: [%s]"
msgstr "Patrones no encontrados: [%s]"

msgid ""
"each ... argument to measure must be either a symbol without argument name, "
"or a function with argument name, problems: %s"
msgstr ""
"cada... argumento a medir debe ser un símbolo sin nombre de argumento, o una "
"función con nombre de argumento, problemas: %s"

msgid ""
"group names specified in ... conflict with measure argument names; please "
"fix by changing group names: %s"
msgstr ""
"los nombres de grupo especificados en ... entran en conflicto con los "
"nombres de los argumentos de medida; por favor solucione cambiando los "
"nombres de los grupos: %s"

msgid ""
"each ... argument to measure must be a function with at least one argument, "
"problem: %s"
msgstr ""
"cada... argumento a medir debe ser una función con al menos un argumento, "
"problema: %s"

msgid ""
"both sep and pattern arguments used; must use either sep or pattern (not "
"both)"
msgstr "se utilizan argumentos sep y patrón; debe usar sep o patrón (no ambos)"

msgid "multiple.keyword must be a character string with nchar>0"
msgstr "multiple.keyword debe ser una cadena de caracteres con nchar>0"

msgid "cols must be a character vector of column names"
msgstr "cols debe ser un vector de caracteres de nombres de columnas"

msgid "in measurev, %s must be named, problems: %s"
msgstr "en medidav, se debe nombrar %s, problemas: %s"

msgid "%s should be uniquely named, problems: %s"
msgstr "%s debe tener un nombre único, problemas: %s"

msgid "number of %s =%d must be same as %s =%d"
msgstr "el número de %s =%d debe ser el mismo que %s =%d"

msgid "pattern must be character string"
msgstr "el patrón debe ser una cadena de caracteres"

msgid ""
"pattern did not match any cols, so nothing would be melted; fix by changing "
"pattern"
msgstr ""
"el patrón no coincidía con ninguna columna, por lo que no se remodelará "
"nada; arreglar cambiando el patrón"

msgid ""
"pattern must contain at least one capture group (parenthesized sub-pattern)"
msgstr ""
"el patrón debe contener al menos un grupo de captura (subpatrón entre "
"paréntesis)"

msgid "sep must be character string"
msgstr "sep debe ser una cadena de caracteres"

msgid ""
"each column name results in only one item after splitting using sep, which "
"means that all columns would be melted; to fix please either specify melt on "
"all columns directly without using measure, or use a different sep/pattern "
"specification"
msgstr ""
"cada nombre de columna da como resultado solo un elemento después de dividir "
"usando sep, lo que significa que todas las columnas se fusionarían; Para "
"solucionarlo, especifique la fusión en todas las columnas directamente sin "
"usar la medida o use una especificación de patrón/separador diferente."

msgid ""
"number of unique column IDs =%d is less than number of melted columns =%d; "
"fix by changing pattern/sep"
msgstr ""
"el número de ID de columna únicos =%d es menor que el número de columnas "
"remodeladas =%d; arreglar cambiando patrón/sep"

msgid ""
"in the measurev fun.list, each non-NULL element must be a function with at "
"least one argument, problem: %s"
msgstr ""
"en fun.list de measurev, cada elemento no NULL debe ser una función con al "
"menos un argumento, problema: %s"

msgid ""
"each conversion function must return an atomic vector with same length as "
"its first argument, problem: %s"
msgstr ""
"cada función de conversión debe devolver un vector atómico con la misma "
"longitud que su primer argumento, problema: %s"

msgid "%s conversion function returned vector of all NA"
msgstr "La función de conversión %s devolvió el vector de todos los NA"

msgid ""
"number of unique groups after applying type conversion functions less than "
"number of groups, change type conversion"
msgstr ""
"número de grupos únicos después de aplicar funciones de conversión de tipo "
"menor que el número de grupos, cambiar la conversión de tipo"

msgid ""
"%s column class=%s after applying conversion function, but must be character"
msgstr ""
"columna %s de clase=%s después de aplicar la función de conversión, pero "
"debe ser de carácter"

msgid "%s is the only group; fix by creating at least one more group"
msgstr "%s es el único grupo; arréglelo creando al menos un grupo más"

msgid "'data' must be a data.table"
msgstr "'data' debe ser una data.table"

msgid ""
"'value.name' provided in both 'measure.vars' and 'value.name argument'; "
"value provided in 'measure.vars' is given precedence."
msgstr ""
"'value.name' proporcionado tanto en 'measure.vars' como en argumento 'value."
"name'; el valor proporcionado en 'measure.vars' tiene prioridad."

msgid "Please provide a name to each element of 'measure.vars'."
msgstr "Proporcione un nombre para cada elemento de 'measure.vars'."

msgid ""
"y and x must both be data.tables. Use `setDT()` to convert list/data.frames "
"to data.tables by reference or as.data.table() to convert to data.tables by "
"copying."
msgstr ""
"'y' y 'x' deben ser tablas de datos. Utilice `setDT()` para convertir list/"
"data.frames a data.tables por referencia o as.data.table() para convertir a "
"data.tables copiando."

msgid "maxgap must be a non-negative integer value of length 1"
msgstr "maxgap debe ser un valor entero no negativo de longitud 1"

msgid "minoverlap must be a positive integer value of length 1"
msgstr "minoverlap debe ser un valor entero positivo de longitud 1"

msgid "which must be a logical vector of length 1. Either TRUE/FALSE"
msgstr "que debe ser un vector lógico de longitud 1. Ya sea TRUE/FALSE"

msgid "nomatch must either be NA or NULL"
msgstr "nomatch debe ser NA o NULL"

msgid "maxgap and minoverlap arguments are not yet implemented."
msgstr "Los argumentos maxgap y minoverlap aún no se han implementado."

msgid ""
"y must be keyed (i.e., sorted, and, marked as sorted). Call setkey(y, ...) "
"first, see ?setkey. Also check the examples in ?foverlaps."
msgstr ""
"'y' debe tener una clave (es decir, ordenada y marcada como ordenada). Llame "
"primero a setkey(y, ...), consulte ?setkey. Consulte también los ejemplos "
"en ?foverlaps."

msgid ""
"'by.x' and 'by.y' should contain at least two column names (or numbers) "
"each - corresponding to 'start' and 'end' points of intervals. Please see ?"
"foverlaps and examples for more info."
msgstr ""
"'by.x' y 'by.y' deben contener al menos dos nombres de columna (o números) "
"cada uno, correspondientes a los puntos 'start' y 'end' de intervalos. "
"Consulte Foverlaps y ejemplos para obtener más información."

msgid ""
"Invalid numeric value for 'by.x'; it should be a vector with values 1 <= by."
"x <= length(x)"
msgstr ""
"Valor numérico no válido para 'by.x'; debería ser un vector con valores 1 <= "
"by.x <= length(x)"

msgid ""
"Invalid numeric value for 'by.y'; it should be a vector with values 1 <= by."
"y <= length(y)"
msgstr ""
"Valor numérico no válido para 'by.y'; debería ser un vector con valores 1 <= "
"by.y <= length(y)"

msgid "A non-empty vector of column names or numbers is required for by.x"
msgstr ""
"Se requiere un vector no vacío de nombres de columnas o números para by.x"

msgid "A non-empty vector of column names or numbers is required for by.y"
msgstr ""
"Se requiere un vector no vacío de nombres de columnas o números para by.y"

msgid ""
"The first %d columns of y's key must be identical to the columns specified "
"in by.y."
msgstr ""
"Las primeras %d columnas de la clave de y deben ser idénticas a las columnas "
"especificadas en by.y."

msgid "Elements listed in 'by.x' must be valid names in data.table x"
msgstr ""
"Los elementos enumerados en 'by.x' deben ser nombres válidos en data.table x"

msgid ""
"Duplicate columns are not allowed in overlap joins. This may change in the "
"future."
msgstr ""
"No se permiten columnas duplicadas en uniones superpuestas. Esto puede "
"cambiar en el futuro."

msgid ""
"length(by.x) != length(by.y). Columns specified in by.x should correspond to "
"columns specified in by.y and should be of same lengths."
msgstr ""
"length(por.x) != length(por.y). Las columnas especificadas en by.x deben "
"corresponder a las columnas especificadas en by.y y deben tener la misma "
"length."

msgid ""
"%s has some duplicated column name(s): %s. Please remove or rename the "
"duplicate(s) and try again."
msgstr ""
"%s tiene algunos nombres de columna duplicados: %s. Elimine o cambie el "
"nombre de los duplicados e inténtelo de nuevo."

msgid ""
"The last two columns in by.x should correspond to the 'start' and 'end' "
"intervals in data.table x and must be integer/numeric type."
msgstr ""
"Las dos últimas columnas en by.x deben corresponder a los intervalos 'start' "
"y 'end' en data.table x y deben ser de tipo entero/numérico."

msgid ""
"NA values in data.table %s '%s' column: '%s'. All rows with NA values in the "
"range columns must be removed for foverlaps() to work."
msgstr ""
"Valores NA en la columna data.table %s '%s': '%s'. Todas las filas con "
"valores NA en las columnas de rango deben eliminarse para que funcione "
"foverlaps()."

msgid ""
"All entries in column '%s' should be <= corresponding entries in column '%s' "
"in data.table x."
msgstr ""
"Todas las entradas en la columna '%s' deben ser <= entradas correspondientes "
"en la columna '%s' en data.table x."

msgid ""
"The last two columns in by.y should correspond to the 'start' and 'end' "
"intervals in data.table y and must be integer/numeric type."
msgstr ""
"Las dos últimas columnas en by.y deben corresponder a los intervalos 'start' "
"y 'end' en data.table y y deben ser de tipo entero/numérico."

msgid ""
"All entries in column '%s' should be <= corresponding entries in column '%s' "
"in data.table y."
msgstr ""
"Todas las entradas en la columna '%s' edeben ser <= a las entradas "
"correspondientes en las columnas '%s' en la data.table y."

msgid ""
"Some interval cols are of type POSIXct while others are not. Please ensure "
"all interval cols are (or are not) of POSIXct type"
msgstr ""
"Algunas columnas de intervalo son de tipo POSIXct mientras que otras no. "
"Asegúrese de que todas las columnas de intervalo sean (o no sean) de tipo "
"POSIXct"

msgid ""
"POSIXct interval cols have mixed timezones. Overlaps are performed on the "
"internal numerical representation of POSIXct objects (always in UTC epoch "
"time), therefore printed values may give the impression that values don't "
"overlap but their internal representations do Please ensure that POSIXct "
"type interval cols have identical 'tzone' attributes to avoid confusion."
msgstr ""
"Las columnas de intervalo POSIXct tienen zonas horarias mixtas. Las "
"superposiciones se realizan en la representación numérica interna de los "
"objetos POSIXct (siempre en la época UTC), por lo tanto, los valores "
"impresos pueden dar la impresión de que los valores no se superponen, pero "
"sus representaciones internas sí. Asegúrese de que las columnas de intervalo "
"de tipo POSIXct tengan atributos 'tzone' idénticos, para evitar confusiones."

msgid "Not yet implemented"
msgstr "Aún no implementado"

msgid "maxgap > minoverlap. maxgap will have no effect here."
msgstr "maxgap > minoverlap. maxgap no tendrá ningún efecto aquí."

msgid "length(na.last) = 0"
msgstr "length(na.last) = 0"

msgid "length(na.last) > 1, only the first element will be used"
msgstr "length(na.last) > 1, sólo se utilizará el primer elemento"

msgid "x is a single vector, non-NULL 'cols' doesn't make sense"
msgstr "x es un vector único, 'cols' no NULL no tiene sentido"

msgid "x is a list, 'cols' can not be 0-length"
msgstr "x es una lista, 'cols' no puede tener longitud 0"

msgid ""
"Input column '..na_prefix..' conflicts with data.table internal usage; "
"please rename"
msgstr ""
"La columna de entrada '..na_prefix..' entra en conflicto con el uso interno "
"de data.table; por favor cambie el nombre"

msgid ""
"Input column '..stats_runif..' conflicts with data.table internal usage; "
"please rename"
msgstr ""
"La columna de entrada '..stats_runif..' entra en conflicto con el uso "
"interno de data.table; por favor cambie el nombre"

msgid "Used more than one of the arguments input=, file=, text= and cmd=."
msgstr "Utilizó más de uno de los argumentos input=, file=, text= y cmd=."

msgid "Argument 'encoding' must be 'unknown', 'UTF-8' or 'Latin-1'."
msgstr "El argumento 'encoding' debe ser 'unknown', 'UTF-8' o 'Latin-1 '."

msgid "'text=' is type %s but must be character."
msgstr "'text=' es de tipo %s pero debe ser un carácter."

msgid ""
"input= must be a single character string containing a file name, a system "
"command containing at least one space, a URL starting 'http[s]://', "
"'ftp[s]://' or 'file://', or, the input data itself containing at least one "
"\\n or \\r"
msgstr ""
"input= debe ser una cadena de un solo carácter que contenga un nombre de "
"archivo, un comando del sistema que contenga al menos un espacio, una URL "
"que comience con 'http[s]://', ​​'ftp[s]://' o 'file: //', o los datos de "
"entrada que contienen al menos un \\n o \\r"

msgid ""
"input= contains no \\n or \\r, but starts with a space. Please remove the "
"leading space, or use text=, file= or cmd="
msgstr ""
"input= no contiene \\n o \\r, pero comienza con un espacio. Elimine el "
"espacio inicial o utilice text=, file= o cmd="

msgid ""
"Taking input= as a system command because it contains a space ('%s'). If "
"it's a filename please remove the space, or use file= explicitly. A variable "
"is being passed to input= and when this is taken as a system command there "
"is a security concern if you are creating an app, the app could have a "
"malicious user, and the app is not running in a secure environment; e.g. the "
"app is running as root. Please read item 5 in the NEWS file for v1.11.6 for "
"more information and for the option to suppress this message."
msgstr ""
"Tomando input= como comando del sistema porque contiene un espacio ('%s'). "
"Si es un nombre de archivo, elimine el espacio o use file= explícitamente. "
"Se pasa una variable a input= y cuando se toma como un comando del sistema, "
"existe un problema de seguridad si está creando una aplicación, la "
"aplicación podría tener un usuario malintencionado y la aplicación no se "
"ejecuta en un entorno seguro; p.ej. la aplicación se ejecuta como root. Lea "
"el elemento 5 en el archivo NEWS de v1.11.6 para obtener más información y "
"conocer la opción de suprimir este mensaje."

msgid ""
"file= must be a single character string containing a filename, or URL "
"starting 'http[s]://', 'ftp[s]://' or 'file://'"
msgstr ""
"file= debe ser una cadena de un solo carácter que contenga un nombre de "
"archivo o una URL que comience con 'http[s]://', ​​'ftp[s]://' o 'file://'"

msgid ""
"URL requires download.file functionalities from R >=3.2.2. You can still "
"manually download the file and fread the downloaded file."
msgstr ""
"La URL requiere funcionalidades de download.file de R >=3.2.2. Aún puede "
"descargar el archivo manualmente usar fread sobre el archivo descargado"

msgid "File '%s' does not exist or is non-readable. getwd()=='%s'"
msgstr "El archivo '%s' no existe o no es legible. getwd()=='%s'"

msgid "File '%s' is a directory. Not yet implemented."
msgstr "El archivo '%s' es un directorio. Aun no implementado."

msgid "File '%s' has size 0. Returning a NULL %s."
msgstr "El archivo '%s' tiene tamaño 0. Devolviendo un %s NULL."

msgid ""
"Compressed files containing more than 1 file are currently not supported."
msgstr ""
"Actualmente no se admiten archivos comprimidos que contengan más de 1 "
"archivo."

msgid ""
"To read gz and bz2 files directly, fread() requires 'R.utils' package which "
"cannot be found. Please install 'R.utils' using 'install.packages('R."
"utils')'."
msgstr ""
"Para leer archivos gz y bz2 directamente, fread() requiere el paquete 'R."
"utils' que no se puede encontrar. Instale 'R.utils' usando 'install."
"packages('R.utils')'."

msgid ""
"'autostart' is now deprecated and ignored. Consider skip='string' or skip=n"
msgstr ""
"'autostart' ahora está obsoleto y se ignora. Considere skip='string' o skip=n"

msgid ""
"colClasses is type 'logical' which is ok if all NA but it has some TRUE or "
"FALSE values in it which is not allowed. Please consider the drop= or "
"select= argument instead. See ?fread."
msgstr ""
"colClasses es de tipo 'logical', lo cual está bien si todo es NA, pero tiene "
"algunos valores TRUE o FALSE, lo que no está permitido. Considere el "
"argumento drop= o select= en su lugar. Ver ?fread."

msgid "colClasses is not type list or character vector"
msgstr "colClasses no es una lista de tipos ni un vector de caracteres"

msgid ""
"colClasses=\"NULL\" (quoted) is interpreted as colClasses=NULL (the default) "
"as opposed to dropping every column."
msgstr ""
"colClasses=\"NULL\" (entre comillas) se interpreta como colClasses=NULL (el "
"valor predeterminado) en lugar de eliminar todas las columnas."

msgid "na.strings[%d]==\"%s\" consists only of whitespace, ignoring"
msgstr "na.strings[%d]==\"%s\" consta solo de espacios en blanco, ignorando"

msgid ""
"%s. Since strip.white=TRUE (default), use na.strings=\"\" to specify that "
"any number of spaces in a string column should be read as <NA>."
msgstr ""
"%s. Dado que strip.white=TRUE (predeterminado), use na.strings=\"\" para "
"especificar que cualquier número de espacios en una columna de cadena debe "
"leerse como <NA>."

msgid ""
"%s. strip.white==TRUE (default) and \"\" is present in na.strings, so any "
"number of spaces in string columns will already be read as <NA>."
msgstr ""
"%s. strip.white==TRUE (predeterminado) y \"\" está presente en na.strings, "
"por lo que cualquier número de espacios en las columnas de cadena ya se "
"leerán como <NA>."

msgid ""
"%s. But strip.white=FALSE. Use strip.white=TRUE (default) together with na."
"strings=\"\" to turn any number of spaces in string columns into <NA>"
msgstr ""
"%s. Pero strip.white=FALSE. Utilice strip.white=TRUE (predeterminado) junto "
"con na.strings=\"\" para convertir cualquier número de espacios en columnas "
"de cadena en <NA>"

msgid ""
"'data.table' relies on the package 'yaml' to parse the file header; please "
"add this to your library with install.packages('yaml') and try again."
msgstr ""
"'data.table' se basa en el paquete 'yaml' para analizar el encabezado del "
"archivo; agréguelo a su biblioteca con install.packages('yaml') e inténtelo "
"de nuevo."

msgid ""
"Combining a search string as 'skip' and reading a YAML header may not work "
"as expected -- currently, reading will proceed to search for 'skip' from the "
"beginning of the file, NOT from the end of the metadata; please file an "
"issue on GitHub if you'd like to see more intuitive behavior supported."
msgstr ""
"Combinar una cadena de búsqueda como 'skip' y leer un encabezado YAML puede "
"no funcionar como se esperaba; actualmente, la lectura procederá a buscar "
"'skip' desde el principio. del archivo, NO desde el final de los metadatos; "
"Presente un problema en GitHub si desea que se admita un comportamiento más "
"intuitivo."

msgid ""
"Encountered <%s%s> at the first unskipped line (%d), which does not "
"constitute the start to a valid YAML header (expecting something matching "
"regex \"%s\"); please check your input and try again."
msgstr ""
"Se encontró <%s%s> en la primera línea no omitida (%d), que no constituye el "
"inicio de un encabezado YAML válido (se esperaba algo que coincida con la "
"expresión regular \"%s\"); por favor verifique su entrada e inténtelo "
"nuevamente."

msgid ""
"Reached the end of the file before finding a completion to the YAML header. "
"A valid YAML header is bookended by lines matching the regex \"%s\". Please "
"double check the input file is a valid csvy."
msgstr ""
"Se llegó al final del archivo antes de encontrar una finalización del "
"encabezado YAML. Un encabezado YAML válido está delimitado por líneas que "
"coinciden con la expresión regular \"%s\". Verifique que el archivo de "
"entrada sea un csvy válido."

msgid "User-supplied 'header' will override that found in metadata."
msgstr ""
"'header' proporcionado por el usuario reemplazará al que se encuentra en los "
"metadatos."

msgid ""
"User-supplied column names in 'col.names' will override those found in YAML "
"metadata."
msgstr ""
"Los nombres de columnas proporcionados por el usuario en 'col.names' "
"reemplazarán los que se encuentran en los metadatos YAML."

msgid ""
"colClasses dictated by user input and those read from YAML header are in "
"conflict (specifically, for column(s) [%s]); the proceeding assumes the user "
"input was an intentional override and will ignore the type(s) implied by the "
"YAML header; please exclude the column(s) from colClasses if this was "
"unintentional."
msgstr ""
"colClasses dictadas por la entrada del usuario y las leídas del encabezado "
"YAML están en conflicto (específicamente, para las columnas [%s]); el "
"procedimiento supone que la entrada del usuario fue un reemplazo intencional "
"e ignorará los tipos implícitos en el encabezado YAML; excluya las columnas "
"de colClasses si esto no fue intencional."

msgid "User-supplied 'sep' will override that found in metadata."
msgstr ""
"'sep' proporcionado por el usuario reemplazará el que se encuentra en los "
"metadatos."

msgid "User-supplied 'quote' will override that found in metadata."
msgstr ""
"'quote' proporcionado por el usuario reemplazará el que se encuentra en los "
"metadatos."

msgid "User-supplied 'dec' will override that found in metadata."
msgstr ""
"'dec' proporcionado por el usuario reemplazará el que se encuentra en los "
"metadatos."

msgid "User-supplied 'na.strings' will override that found in metadata."
msgstr ""
"'na.strings' proporcionado por el usuario reemplazará el que se encuentra en "
"los metadatos."

msgid ""
"Column '%s' was requested to be '%s' but fread encountered the following %s:\n"
"\t%s\n"
"so the column has been left as type '%s'"
msgstr ""
"Se solicitó que la columna '%s' fuera '%s' pero fread encontró el siguiente "
"%s:\n"
"\t%s\n"
"por lo que la columna se dejó como tipo '%s'"

msgid ""
"key argument of data.table() must be a character vector naming columns (NB: "
"col.names are applied before this)"
msgstr ""
"el argumento key de data.table() debe ser un vector de caracteres que nombra "
"las columnas (nótese que col.names se aplica antes de esto)"

msgid ""
"index argument of data.table() must be a character vector naming columns "
"(NB: col.names are applied before this)"
msgstr ""
"el argumento de índice de data.table() debe ser un vector de caracteres que "
"nombra columnas (nótese que col.names se aplican antes de esto)"

msgid "Argument 'encoding' must be '', 'UTF-8' or 'native'."
msgstr "El argumento 'encoding' debe ser '', 'UTF-8' o 'native'."

msgid "dateTimeAs must be a single string"
msgstr "dateTimeAs debe ser una sola cadena"

msgid "dateTimeAs must be 'ISO','squash','epoch' or 'write.csv'"
msgstr "dateTimeAs debe ser 'ISO','squash','epoch' o 'write.csv'"

msgid "logicalAsInt has been renamed logical01. Use logical01 only, not both."
msgstr ""
"logicAsInt ha pasado a llamarse logic01. Utilice sólo logic01, no ambos."

msgid ""
"logicalAsInt has been renamed logical01 for consistency with fread. It works "
"fine for now but please change to logical01 at your convenience so we can "
"remove logicalAsInt in future."
msgstr ""
"logicAsInt ha sido renombrado como logic01 para mantener la coherencia con "
"fread. Funciona bien por ahora, pero cámbielo a logic01 cuando le resulte "
"conveniente para que podamos eliminar logicAsInt en el futuro."

msgid "x being coerced from class: matrix to data.table"
msgstr "x siendo forzado de clase: matrix a data.table"

msgid ""
"If you intended to overwrite the file at %s with an empty one, please use "
"file.remove first."
msgstr ""
"Si tenía la intención de sobrescribir el archivo en %s con uno vacío, use "
"file.remove primero."

msgid "Input has no columns; doing nothing.%s"
msgstr "La entrada no tiene columnas; sin hacer nada.%s"

msgid "Input has no columns; creating an empty file at '%s' and exiting."
msgstr ""
"La entrada no tiene columnas; creando un archivo vacío en '%s' y saliendo."

msgid ""
"'data.table' relies on the package 'yaml' to write the file header; please "
"add this to your library with install.packages('yaml') and try again."
msgstr ""
"'data.table' se basa en el paquete 'yaml' para escribir el encabezado del "
"archivo; agregue esto a su biblioteca con install.packages('yaml') e "
"inténtelo nuevamente."

msgid "Argument 'x' must be a data.table object"
msgstr "El argumento 'x' debe ser un objeto data.table"

msgid ""
"Argument 'by' must be a character vector of column names used in grouping."
msgstr ""
"El argumento 'by' debe ser un vector de caracteres de los nombres de las "
"columnas utilizadas en la agrupación."

msgid "Argument 'id' must be a logical scalar."
msgstr "El argumento 'id' debe ser un escalar lógico."

msgid "Argument 'j' is required"
msgstr "Se requiere el argumento 'j'"

msgid ""
"Argument 'x' is a 0-column data.table; no measure to apply grouping over."
msgstr ""
"El argumento 'x' es una data.table de 0 columnas; no hay medida para aplicar "
"la agrupación."

msgid "Input data.table must not contain duplicate column names."
msgstr ""
"La data.table de entrada no debe contener nombres de columnas duplicados."

msgid "Argument 'by' must have unique column names for grouping."
msgstr ""
"El argumento 'by' debe tener nombres de columna únicos para la agrupación."

msgid "Argument 'sets' must be a list of character vectors."
msgstr "El argumento 'sets' debe ser una lista de vectores de caracteres."

msgid ""
"All columns used in 'sets' argument must be in 'by' too. Columns used in "
"'sets' but not present in 'by': %s"
msgstr ""
"Todas las columnas utilizadas en el argumento 'sets' también deben estar en "
"'by'. Columnas utilizadas en 'sets' pero no presentes en 'by': %s"

msgid ""
"When using `id=TRUE` the 'x' data.table must not have a column named "
"'grouping'."
msgstr ""
"Cuando se usa `id=TRUE`, la data.table 'x' no debe tener una columna llamada "
"'grouping'."

msgid ""
"Character vectors in 'sets' list must not have duplicated column names "
"within a single grouping set."
msgstr ""
"Los vectores de caracteres en la lista 'sets' no deben tener nombres de "
"columnas duplicados dentro de un único conjunto de agrupación."

msgid ""
"'sets' contains a duplicate (i.e., equivalent up to sorting) element at "
"index %d; as such, there will be duplicate rows in the output -- note that "
"grouping by A,B and B,A will produce the same aggregations. Use "
"`sets=unique(lapply(sets, sort))` to eliminate duplicates."
msgstr ""
"'sets' contiene un elemento duplicado (es decir, equivalente hasta la "
"clasificación) en el índice %d; como tal, habrá filas duplicadas en la "
"salida; tenga en cuenta que agrupar por A,B y B,A producirá las mismas "
"agregaciones. Utilice `sets=unique(lapply(sets, sort))` para eliminar "
"duplicados."

msgid ""
"Expression passed to grouping sets function must not update by reference. "
"Use ':=' on results of your grouping function."
msgstr ""
"La expresión pasada a la función groupingsets no debe actualizarse por "
"referencia. Utilice ':=' en los resultados de su función de agrupación."

msgid ""
"When using `id=TRUE` the 'j' expression must not evaluate to a column named "
"'grouping'."
msgstr ""
"Cuando se usa `id=TRUE`, la expresión 'j' no debe evaluarse como una columna "
"llamada 'grouping'."

msgid ""
"There exists duplicated column names in the results, ensure the column "
"passed/evaluated in `j` and those in `by` are not overlapping."
msgstr ""
"Existen nombres de columnas duplicados en los resultados, asegúrese de que "
"la columna aprobada/evaluada en `j` y las de `by` no se superpongan."

msgid ""
"Using integer64 class columns require to have 'bit64' package installed."
msgstr ""
"El uso de columnas de clase integer64 requiere tener instalado el paquete "
"'bit64'."

msgid ""
"'xts' class passed to %s function but 'xts' is not available, you should "
"have 'xts' installed already"
msgstr ""
"La clase 'xts' pasó a la función %s pero 'xts' no está disponible, ya "
"deberías tener 'xts' instalado"

msgid "Argument 'sort' should be logical TRUE/FALSE"
msgstr "El argumento 'sort' debe ser lógico TRUE/FALSE"

msgid "Argument 'no.dups' should be logical TRUE/FALSE"
msgstr "El argumento 'no.dups' debe ser lógico TRUE/FALSE"

msgid "Neither of the input data.tables to join have columns."
msgstr "Ninguna de las data.tables de entrada para unir tiene columnas."

msgid "Input data.table '%s' has no columns."
msgstr "La data.table de entrada '%s' no tiene columnas."

msgid "`by.x` and `by.y` must be of same length."
msgstr "`by.x` y `by.y` deben tener la misma longitud."

msgid "Supplied both `by` and `by.x/by.y`. `by` argument will be ignored."
msgstr ""
"Se suministra tanto `by` como `by.x/by.y`. El argumento `by` será ignorado."

msgid "A non-empty vector of column names is required for `by.x` and `by.y`."
msgstr ""
"Se requiere un vector no vacío de nombres de columnas para `by.x` y `by.y`."

msgid "Elements listed in `by.x` must be valid column names in x."
msgstr ""
"Los elementos enumerados en `by.x` deben ser nombres de columna válidos en x."

msgid "Elements listed in `by.y` must be valid column names in y."
msgstr ""
"Los elementos enumerados en `by.y` deben ser nombres de columna válidos en y."

msgid "A non-empty vector of column names for `by` is required."
msgstr "Se requiere un vector no vacío de nombres de columnas para `por`."

msgid "Elements listed in `by` must be valid column names in x and y"
msgstr ""
"Los elementos enumerados en `by` deben ser nombres de columna válidos en xey"

msgid "Unknown argument '%s' has been passed."
msgstr "Se pasó el argumento desconocido '%s'."

msgid "Passed %d unknown and unnamed arguments."
msgstr "Se aprobaron %d argumentos desconocidos y sin nombre."

msgid "column names %s are duplicated in the result"
msgstr "los nombres de las columnas %s están duplicados en el resultado"

msgid ""
"data.table %s IN DEVELOPMENT built %s%s using %d threads (see ?getDTthreads)."
msgstr ""
"data.table %s EN DESARROLLO compilación %s%s usando %d hilos (ver ?"
"getDTthreads)."

msgid "data.table %s using %d threads (see ?getDTthreads)."
msgstr "data.table %s usando %d hilos (ver ?getDTthreads)."

msgid "Latest news: r-datatable.com"
msgstr "Últimas novedades: r-datatable.com"

msgid "TRANSLATION CHECK"
msgstr "VERIFICACIÓN DE TRADUCCIÓN"

msgid ""
"**********\n"
"Running data.table in English; package support is available in English only. "
"When searching for online help, be sure to also check for the English error "
"message. This can be obtained by looking at the po/R-<locale>.po and po/"
"<locale>.po files in the package source, where the native language and "
"English error messages can be found side-by-side\n"
"**********"
msgstr ""
"**********\n"
"Ejecutando data.table en Español; El soporte del paquete está disponible "
"solo en inglés. Cuando busque ayuda en línea, asegúrese de comprobar también "
"el mensaje de error en inglés. Esto se puede obtener mirando los archivos "
"po/R-<locale>.po y po/<locale>.po en el código fuente del paquete, donde se "
"pueden encontrar los mensajes de error en el idioma nativo y en inglés uno "
"al lado del otro\n"
"* *********"

msgid ""
"**********\n"
"This development version of data.table was built more than 4 weeks ago. "
"Please update: data.table::update_dev_pkg()\n"
"**********"
msgstr ""
"**********\n"
"Esta versión de desarrollo de data.table se creó hace más de 4 semanas. "
"Actualice: data.table::update_dev_pkg()\n"
"**********"

msgid ""
"**********\n"
"This installation of data.table has not detected OpenMP support. It should "
"still work but in single-threaded mode."
msgstr ""
"************\n"
"Esta instalación de data.table no ha detectado compatibilidad con OpenMP. "
"Aún debería funcionar pero en modo de un solo hilo."

msgid ""
"This is a Mac. Please read https://mac.r-project.org/openmp/. Please engage "
"with Apple and ask them for support. Check r-datatable.com for updates, and "
"our Mac instructions here: https://github.com/Rdatatable/data.table/wiki/"
"Installation. After several years of many reports of installation problems "
"on Mac, it's time to gingerly point out that there have been no similar "
"problems on Windows or Linux.\n"
"**********"
msgstr ""
"Esta es una Mac. Lea https://mac.r-project.org/openmp/. Comuníquese con "
"Apple y pídales ayuda. Consulte r-datatable.com para obtener actualizaciones "
"y nuestras instrucciones para Mac aquí: https://github.com/Rdatatable/data."
"table/wiki/Installation. Después de varios años de muchos informes de "
"problemas de instalación en Mac, es hora de señalar con cautela que no ha "
"habido problemas similares en Windows o Linux.\n"
"**********"

msgid ""
"This is %s. This warning should not normally occur on Windows or Linux where "
"OpenMP is turned on by data.table's configure script by passing -fopenmp to "
"the compiler. If you see this warning on Windows or Linux, please file a "
"GitHub issue.\n"
"**********"
msgstr ""
"Esto es %s. Esta advertencia normalmente no debería aparecer en Windows o "
"Linux donde OpenMP se activa mediante el script de configuración de data."
"table pasando -fopenmp al compilador. Si ve esta advertencia en Windows o "
"Linux, presente un problema en GitHub.\n"
"**********"

msgid ""
"**********\n"
"This data.table installation was compiled for R < 3.4.0 (Apr 2017) and is "
"known to leak memory. Please upgrade R and reinstall data.table to fix the "
"leak. Maintaining and testing code branches to support very old versions "
"increases development time so please do upgrade R. We intend to bump data."
"table's dependency from 8 year old R 3.1.0 (Apr 2014) to 5 year old R 3.4.0 "
"(Apr 2017).\n"
"**********"
msgstr ""
"**********\n"
"Esta instalación de data.table se compiló para R < 3.4.0 (abril de 2017) y "
"se sabe que tiene fugas de memoria. Actualice R y reinstale data.table para "
"solucionar la fuga. Mantener y probar ramas de código para admitir versiones "
"muy antiguas aumenta el tiempo de desarrollo, así que actualice R. Tenemos "
"la intención de aumentar la dependencia de data.table de R 3.1.0 de 8 años "
"(abril de 2014) a R 3.4.0 de 5 años (abril de 2017). ).\n"
"orte**********"

msgid ""
"Option 'datatable.nomatch' is defined but is now ignored. Please see note 11 "
"in v1.12.4 NEWS (Oct 2019), and note 14 in v1.14.2."
msgstr ""
"La opción 'datatable.nomatch' está definida pero ahora se ignora. Consulte "
"la nota 11 en v1.12.4 NEWS (octubre de 2019) y la nota 14 en v1.14.2."

msgid ""
"The data_table.%s version (%s) does not match the package (%s). Please close "
"all R sessions to release the old %s and reinstall data.table in a fresh R "
"session. The root cause is that R's package installer can in some "
"unconfirmed circumstances leave a package in a state that is apparently "
"functional but where new R code is calling old C code silently: https://bugs."
"r-project.org/bugzilla/show_bug.cgi?id=17478. Once a package is in this "
"mismatch state it may produce wrong results silently until you next upgrade "
"the package. Please help by adding precise circumstances to 17478 to move "
"the status to confirmed. This mismatch between R and C code can happen with "
"any package not just data.table. It is just that data.table has added this "
"check."
msgstr ""
"La versión data_table.%s (%s) no coincide con el paquete (%s). Cierre todas "
"las sesiones de R para liberar el %s anterior y reinstale data.table en una "
"nueva sesión de R. La causa principal es que el instalador del paquete de R "
"puede, en algunas circunstancias no confirmadas, dejar un paquete en un "
"estado que aparentemente es funcional pero donde el nuevo código de R llama "
"al código C antiguo de forma silenciosa: https://bugs.r-project.org/bugzilla/"
"show_bug .cgi?id=17478. Una vez que un paquete se encuentra en este estado "
"de discrepancia, puede producir resultados incorrectos de forma silenciosa "
"hasta la próxima actualización del paquete. Ayúdenos agregando "
"circunstancias precisas a 17478 para pasar el estado a confirmado. Esta "
"discrepancia entre el código R y C puede ocurrir con cualquier paquete, no "
"solo con data.table. Es solo que data.table ha agregado esta verificación."

msgid ""
"This is R %s but data.table has been installed using R %s. The major version "
"must match. Please reinstall data.table."
msgstr ""
"Esto es R %s pero data.table se instaló usando R %s. La versión principal "
"debe coincidir. Vuelva a instalar data.table."

msgid ""
"Option 'datatable.CJ.names' no longer has any effect, as promised for 4 "
"years. It is now ignored. Manually name `...` entries as needed if you still "
"prefer the old behavior."
msgstr ""
"La opción 'datatable.CJ.names' ya no tiene ningún efecto, como se prometió "
"durante 4 años. Ahora se ignora. Nombre manualmente las entradas `...` según "
"sea necesario si aún prefiere el comportamiento anterior."

msgid "Unexpected base R behaviour: list(x) has copied x"
msgstr " Comportamiento inesperado en R base: list(x) ha copiado x"

msgid "Unexpected base R behaviour: names<- has copied column contents"
msgstr ""
"Comportamiento inesperado de la base R: names<- ha copiado el contenido de "
"la columna"

msgid ""
"Unexpected base R behaviour: DF[2,2]<- did not copy column 2 which was "
"assigned to"
msgstr ""
"Comportamiento inesperado de la base R: DF[2,2]<- no copió la columna 2 a la "
"cual algo le fue asignado"

msgid ""
"Unexpected base R behaviour: DF[2,2]<- copied the first column which was not "
"assigned to, too"
msgstr ""
"Comportamiento inesperado de la base R: DF[2,2]<- también copió la primera "
"columna a la que nada fue asignado"

msgid "Unexpected base R behaviour: DF[2,2]<- has not copied address(DF)"
msgstr ""
"Comportamiento inesperado de la base R: DF[2,2]<- no ha copiado la dirección "
"`address(DF)`"

msgid "Provide either threads= or percent= but not both"
msgstr "Proporcione threads= o percent= pero no ambos"

msgid "percent= is provided but is length %d"
msgstr "percent= se proporciona pero tiene una longitud %d"

msgid "percent==%d but should be a number between 2 and 100"
msgstr "percent==%d pero debe ser un número entre 2 y 100"

msgid "Valid options for col.names are 'auto', 'top', and 'none'"
msgstr ""
"Las opciones válidas para nombres de columnas son 'auto', 'top' y 'none'"

msgid "Valid options for trunc.cols are TRUE and FALSE"
msgstr "Las opciones válidas para trunc.cols son TRUE y FALSE"

msgid "Column classes will be suppressed when col.names is 'none'"
msgstr "Las clases de columnas se suprimirán cuando col.names sea 'none'"

msgid ""
"Internal structure doesn't seem to be a list. Possibly corrupt data.table."
msgstr ""
"La estructura interna no parece ser una lista. Posiblemente sea una data."
"table corrupta."

msgid "'x' must be a list"
msgstr "'x' debe ser una lista"

msgid ""
"Character objects provided in the input are not scalar objects, if you need "
"them as character vector rather than a name, then wrap each into 'I' call: %s"
msgstr ""
"Los objetos de caracteres proporcionados en la entrada no son objetos "
"escalares, si los necesita como un vector de caracteres en lugar de un "
"nombre, envuelva cada uno en la llamada 'I': %s"

msgid "'env' must not be missing"
msgstr "'env' no puede ser faltante"

msgid "'env' must be a list or an environment"
msgstr "'env' debe ser una lista o un entorno"

msgid "'env' argument does not have names"
msgstr "'env' argumento no tiene nombres"

msgid "'env' argument has zero char names"
msgstr "'env' argumento tiene nombres de cero caracteres"

msgid "'env' argument has NA names"
msgstr "'env' argumento tiene nombres NA"

msgid "'env' argument has duplicated names"
msgstr "'env' argumento tiene nombres duplicados"

msgid ""
"x may no longer be the character name of the data.table. The possibility was "
"undocumented and has been removed."
msgstr ""
"x puede que ya no sea el nombre del carácter de la data.table. La "
"posibilidad no estaba documentada y ha sido eliminada."

msgid ""
"key(x)<-value is deprecated and not supported. Please change to use setkey() "
"with perhaps copy(). Has been warning since 2012."
msgstr ""
"key(x)<-value está obsoleto y no está soportado. Por favor cambie a "
"setkey(), quizás con copy(). Ha sido una advertencia desde 2012."

msgid "x is not a data.table"
msgstr "x no es una data.table"

msgid ""
"cols is not a character vector. Please see further information in ?setkey."
msgstr ""
"cols no es un vector de caracteres. Consulte más información en ?setkey."

msgid ""
"Setting a physical key on .SD is reserved for possible future use; to modify "
"the original data's order by group. Try setindex() instead. Or, set*(copy(."
"SD)) as a (slow) last resort."
msgstr ""
"La configuración de una clave física en .SD está reservada para un posible "
"uso futuro; para modificar el orden de los datos originales por grupo. "
"Pruebe con setindex() en su lugar. O set*(copy(.SD)) como último recurso "
"(lento)."

msgid ""
"cols is a character vector of zero length. Removed the key, but use NULL "
"instead, or wrap with suppressWarnings() to avoid this warning."
msgstr ""
"cols es un vector de caracteres de longitud cero. Se eliminó la clave, pero "
"use NULL en su lugar o ajuste con suprimirWarnings() para evitar esta "
"advertencia."

msgid "cols is the empty string. Use NULL to remove the key."
msgstr "cols es la cadena vacía. Utilice NULL para eliminar la clave."

msgid "cols contains some blanks."
msgstr "cols contiene algunos espacios en blanco."

msgid "some columns are not in the data.table: %s"
msgstr "algunas columnas no están en la data.table: %s"

msgid ""
"x contains a column called '.xi'. Conflicts with internal use by data.table."
msgstr ""
"x contiene una columna llamada '.xi'. Conflictos con el uso interno de data."
"table."

msgid ""
"Column '%s' is type '%s' which is not supported as a key column type, "
"currently."
msgstr ""
"La columna '%s' es de tipo '%s' que actualmente no se admite como tipo de "
"columna clave."

msgid ""
"Internal error. 'cols' should be character at this point in setkey; please "
"report."
msgstr ""
"Error interno. 'cols' debe ser un carácter en este punto de setkey; por "
"favor reportar."

msgid "Internal error: index '%s' exists but is invalid"
msgstr "Error interno: el índice '%s' existe pero no es válido"

msgid "x is vector but 'by' is supplied"
msgstr "x es un vector pero se proporciona 'by'"

msgid "x is a single vector, non-NULL 'by' doesn't make sense"
msgstr "x es un vector único, 'by' no NULL no tiene sentido"

msgid "Attempting to order a 0-column data.table or data.frame."
msgstr "Intentando ordenar una data.table o un data.frame de 0 columnas."

msgid ""
"The first item passed to [f]order is a plain list but there are more items. "
"It should be a data.table or data.frame."
msgstr ""
"El primer elemento pasado a [f]order es una lista simple pero hay más "
"elementos. Debería ser una data.table o un data.frame."

msgid "Internal code should not be being called on type double"
msgstr "El código interno no debería estar siendo llamado en un tipo doble"

msgid ""
"Input is not a vector of type double. New parallel sort has only been done "
"for double vectors so far. Using one thread."
msgstr ""
"La entrada no es un vector de tipo doble. Hasta ahora solo se ha realizado "
"una nueva clasificación paralela para vectores dobles. Usando un hilo."

msgid ""
"New parallel sort has not been implemented for decreasing=TRUE so far. Using "
"one thread."
msgstr ""
"Hasta ahora no se ha implementado una nueva clasificación en paralelo para "
"decreasing=TRUE. Usando un hilo."

msgid ""
"New parallel sort has not been implemented for vectors containing NA values "
"so far. Using one thread."
msgstr ""
"Hasta ahora no se ha implementado una nueva clasificación en paralelo para "
"los vectores que contienen valores NA. Usando un hilo."

msgid "x must be a data.frame or data.table"
msgstr "x debe ser un data.frame o data.table"

msgid "na.last must be logical TRUE/FALSE"
msgstr "na.last debe ser lógico TRUE/FALSE"

msgid ""
"cols is not a character vector. Please see further information in ?setorder."
msgstr ""
"cols no es un vector de caracteres. Consulte más información en ?setorder."

msgid ""
"cols is a character vector of zero length. Use NULL instead, or wrap with "
"suppressWarnings() to avoid this warning."
msgstr ""
"cols es un vector de caracteres de longitud cero. Utilice NULL en su lugar o "
"ajuste con suppressWarnings() para evitar esta advertencia."

msgid "Column '%s' is type '%s' which is not supported for ordering currently."
msgstr ""
"La columna '%s' es de tipo '%s' que no se admite para ordenamiento "
"actualmente."

msgid ""
"'sorted' is TRUE but element %d is non-atomic, which can't be sorted; try "
"setting sorted = FALSE"
msgstr ""
"'sorted' es TRUE pero el elemento %d no es atómico, por lo que no se puede "
"ordenar; intente configurar sorted = FALSE"

msgid ""
"Cross product of elements provided to CJ() would result in %.0f rows which "
"exceeds .Machine$integer.max == %d"
msgstr ""
"El producto cruzado de los elementos proporcionados a CJ() daría como "
"resultado %.0f filas que exceden .Machine$integer.max == %d"

msgid "x and y must both be data.tables"
msgstr "x e y deben ser data.table"

msgid "length(by.x) != length(by.y)"
msgstr "length(by.x) != length(by.y)"

msgid ""
"When x's column ('%s') is character, the corresponding column in y ('%s') "
"should be factor or character, but found incompatible type '%s'."
msgstr ""
"Cuando la columna de x ('%s') es un carácter, la columna correspondiente en "
"y ('%s') debe ser un factor o un carácter, pero se encontró el tipo "
"incompatible '%s'."

msgid ""
"When x's column ('%s') is factor, the corresponding column in y ('%s') "
"should be character or factor, but found incompatible type '%s'."
msgstr ""
"Cuando la columna de x ('%s') es factor, la columna correspondiente en y ("
"'%s') debe ser carácter o factor, pero se encontró que el tipo '%s' es "
"incompatible."

msgid ""
"When x's column ('%s') is integer or numeric, the corresponding column in y ("
"'%s') can not be character or logical types, but found incompatible type "
"'%s'."
msgstr ""
"Cuando la columna de x ('%s') es entera o numérica, la columna "
"correspondiente en y ('%s') no puede ser de caracteres o de tipos lógicos, "
"pero se encontró que el tipo '%s' es incompatible."

msgid "argument 'all' should be logical of length one"
msgstr "el argumento 'all' debe ser lógico de longitud uno"

msgid "x and y must have the same column names"
msgstr "x e y deben tener los mismos nombres de columna"

msgid "x and y must have the same column order"
msgstr "x e y deben tener el mismo orden de columnas"

msgid "unsupported column type(s) found in x or y: %s"
msgstr "tipo(s) de columna no admitidos encontrados en x o y: %s"

msgid "Item %d of x is '%s' but the corresponding item of y is '%s'."
msgstr ""
"El elemento %d de x es '%s' pero el elemento correspondiente de y es '%s'."

msgid "None of the datasets should contain a column named '.seqn'"
msgstr ""
"Ninguno de los conjuntos de datos debe contener una columna denominada '."
"seqn'"

msgid "Internal error: ncol(current)==ncol(target) was checked above"
msgstr "Error interno: ncol(current)==ncol(target) fue chequeado más arriba"

msgid "Datasets have different %s. 'target': %s. 'current': %s."
msgstr ""
"Los conjuntos de datos tienen %s diferentes. 'target': %s. 'current': %s."

msgid "has no key"
msgstr "no tiene clave (key)"

msgid "has no index"
msgstr "no tiene índice"

msgid "None of the datasets to compare should contain a column named '.seqn'"
msgstr ""
"Ninguno de los conjuntos de datos a comparar debe contener una columna "
"denominada '.seqn'"

msgid ""
"Datasets to compare with 'ignore.row.order' must not have unsupported column "
"types: %s"
msgstr ""
"Los conjuntos de datos a comparar con 'ignore.row.order' no deben tener "
"tipos de columnas no admitidas: %s"

msgid ""
"Argument 'tolerance' was forced to lowest accepted value `sqrt(."
"Machine$double.eps)` from provided %s"
msgstr ""
"El argumento 'tolerance' fue forzado al valor más bajo aceptado `sqrt(."
"Machine$double.eps)` del %s proporcionado"

msgid ""
"Duplicate rows in datasets, numeric columns and ignore.row.order cannot be "
"used with non 0 tolerance argument"
msgstr ""
"Las filas duplicadas en conjuntos de datos, columnas numéricas e ignore.row."
"order no se pueden usar con un argumento tolerance que no sea 0"

msgid ""
"Factor columns and ignore.row.order cannot be used with non 0 tolerance "
"argument"
msgstr ""
"Las columnas de factor e ignore.row.order no se pueden usar con un argumento "
"tolerance que no sea 0"

msgid "Internal error: factor type mismatch should have been caught earlier"
msgstr ""
"Error interno: la discrepancia en el tipo de factor debería haberse "
"detectado antes"

msgid "Provided argument fill=%s will be ignored since type='cyclic'."
msgstr "El argumento proporcionado fill=%s será ignorado ya que type='cyclic'."

msgid "order.col='%s' not a column name of info"
msgstr "order.col='%s' no es un nombre de columna de información"

msgid "data.table package is loaded. Unload or start a fresh R session."
msgstr ""
"El paquete data.table está cargado. Descargue o inicie una nueva sesión de R."

msgid ""
"script must end with '.Rraw'. If a file ending '.Rraw.bz2' exists, that will "
"be found and used."
msgstr ""
"el script debe terminar con '.Rraw'. Si existe un archivo que termina en '."
"Rraw.bz2', se encontrará y se utilizará."

msgid "Neither %s nor %s exist in %s"
msgstr "Ni %s ni %s existen en %s"

msgid "object '%s' not found"
msgstr "objeto '%s' no encontrado"

msgid ""
"memtest intended for Linux. Step through data.table:::rss() to see what went "
"wrong."
msgstr ""
"memtest destinado a Linux. Revise data.table:::rss() para ver qué salió mal."

msgid "Attempt to subset to %d tests matching '%s' failed, running full suite."
msgstr ""
"El intento de crear un subconjunto de %d pruebas que coincidan con '%s' "
"falló; se ejecutó el conjunto completo."

msgid "Failed in %s after test %s before the next test() call in %s"
msgstr ""
"Error en %s después de la prueba %s antes de la siguiente llamada de "
"prueba() en %s"

msgid "%d error(s) out of %d. Search %s for test number(s) %s. Duration: %s."
msgstr ""
"%d error(es) de %d. Busque en %s los números de prueba %s. Duración: %s."

msgid "Timings count mismatch: %d vs %d"
msgstr "El recuento de tiempos no coincide: %d vs %d"

msgid ""
"Test %s is invalid: when error= is provided it does not make sense to pass y "
"as well"
msgstr ""
"La prueba %s no es válida: cuando se proporciona error= no tiene sentido "
"pasar 'y' también"

msgid "Use started.at=proc.time() not Sys.time() (POSIXt and slow)"
msgstr "Utilice start.at=proc.time(), no Sys.time() (POSIXt y lento)"

msgid "make.names='%s' not found in names of input"
msgstr "make.names='%s' no encontrado en los nombres de entrada"

msgid "make.names=%d is out of range [1,ncol=%d]"
msgstr "make.names=%d está fuera de rango [1,ncol=%d]"

msgid "'names' must be TRUE/FALSE or a character vector."
msgstr "'names' debe ser TRUE/FALSE o un vector de caracteres."

msgid "'keep' should contain integer values between %d and %d."
msgstr "'keep' debe contener valores enteros entre %d y %d."

msgid "The argument 'type.convert' does not support empty list."
msgstr "El argumento 'type.convert' no admite listas vacías."

msgid ""
"When the argument 'type.convert' contains an unnamed element, it is expected "
"to be the last element and should be a function. More than one unnamed "
"element is not allowed unless all elements are functions with length equal "
"to %d (the length of the transpose list or 'keep' argument if it is "
"specified)."
msgstr ""
"Cuando el argumento 'type.convert' contiene un elemento sin nombre, se "
"espera que sea el último elemento y debería ser una función. No se permite "
"más de un elemento sin nombre a menos que todos los elementos sean funciones "
"con una longitud igual a %d (la longitud de la lista de transposición o el "
"argumento 'keep' si se especifica)."

msgid ""
"When the argument 'type.convert' contains transpose list indices, it should "
"be a named list of non-missing integer values (with no duplicate) except the "
"last element that should be unnamed if it is a function."
msgstr ""
"Cuando el argumento 'type.convert' contiene índices de lista transpuesta, "
"debe ser una lista con nombre de valores enteros no faltantes (sin "
"duplicados), excepto el último elemento que no debe tener nombre si es una "
"función."

msgid ""
"When the argument 'type.convert' contains transpose list indices, they "
"should be integer values contained in the argument 'keep' (if it is "
"specified) or be between %d and %d (if it is not). But '%s' is/are not "
"contained in '%s'."
msgstr ""
"Cuando el argumento 'type.convert' contiene índices de lista transpuesta, "
"deben ser valores enteros contenidos en el argumento 'keep' (si se "
"especifica) o estar entre %d y %d (si No lo es). Pero '%s' no está contenido "
"en '%s'."

msgid ""
"In the argument 'type.convert', '%s' was ignored because all elements in the "
"transpose list or elements corresponding to indices specified in the 'keep' "
"argument have already been converted."
msgstr ""
"En el argumento 'type.convert', se ignoró '%s' porque todos los elementos en "
"la lista de transposición o los elementos correspondientes a los índices "
"especificados en el argumento 'keep' ya se han convertido."

msgid ""
"The argument 'type.convert' should be TRUE/FALSE, a function, a list of "
"functions, or a named list of pairs 'fun=indices' with optionally one "
"unnamed element (a function) but an object of type '%s' was provided."
msgstr ""
"El argumento 'type.convert' debe ser TRUE/FALSE, una función, una lista de "
"funciones o una lista de pares con nombre 'fun=indices' con opcionalmente un "
"elemento sin nombre (una función) pero un objeto de tipo '%s' fue "
"proporcionado."

msgid "length(names) (= %d) is not equal to length(%s) (= %d)."
msgstr "length(nombres) (= %d) no es igual a length(%s) (= %d)."

msgid "l not type list"
msgstr "l no es de tipo lista"

msgid "Argument 'nan' must be length 1"
msgstr "El argumento 'nan' debe tener una longitud de 1"

msgid "Argument 'nan' must be NA or NaN"
msgstr "El argumento 'nan' debe ser NA o NaN"

msgid "Internal error: use endsWithAny instead of base::endsWith"
msgstr "Error interno: use EndsWithAny en lugar de base::endsWith"

msgid "x not boolean"
msgstr "x no booleano"

msgid ""
"Some columns are type 'integer64' but package bit64 is not installed. Those "
"columns will print as strange looking floating point data. There is no need "
"to reload the data. Simply install.packages('bit64') to obtain the integer64 "
"print method and print the data again."
msgstr ""
"Algunas columnas son de tipo 'integer64' pero el paquete bit64 no está "
"instalado. Esas columnas se imprimirán como datos de punto flotante de "
"aspecto extraño. No es necesario recargar los datos. Simplemente instale."
"packages('bit64') para obtener el método de impresión integer64 e imprimir "
"los datos nuevamente."

msgid "keep.rownames must be length 1"
msgstr "keep.rownames debe tener una longitud de 1"

msgid "keep.rownames must not be NA"
msgstr "keep.rownames no debe ser NA"

msgid ""
"Input xts object should not have '%s' column because it would result in "
"duplicate column names. Rename '%s' column in xts or use `keep.rownames` to "
"change the index column name."
msgstr ""
"El objeto xts de entrada no debe tener la columna '%s' porque daría como "
"resultado nombres de columna duplicados. Cambie el nombre de la columna '%s' "
"en xts o use `keep.rownames` para cambiar el nombre de la columna del índice."

msgid ""
"data.table must have a time based column in first position, use "
"`setcolorder` function to change the order, or see ?timeBased for supported "
"types"
msgstr ""
"data.table debe tener una columna basada en tiempo en la primera posición, "
"use la función `setcolorder` para cambiar el orden, o vea ?timeBased para "
"los tipos admitidos"

msgid "Following columns are not numeric and will be omitted: %s"
msgstr "Las siguientes columnas no son numéricas y se omitirán: %s"

msgid "Index: %s\n"
msgid_plural "Indices: %s\n"
msgstr[0] "Índice: %s\n"
msgstr[1] "Índices: %s\n"
