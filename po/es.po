msgid ""
msgstr ""
"Project-Id-Version: data.table 1.15.99\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-06-23 12:07-0300\n"
"PO-Revision-Date: 2024-08-05 17:43-0300\n"
"Last-Translator: Ricardo Villalba <rikivillalba@gmail.com>\n"
"Language-Team: es\n"
"Language: es\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Internal error: finalizer hasn't received an ExternalPtr"
msgstr "Error interno: el finalizador no ha recibido un ExternalPtr"

msgid "Internal error: finalizer's ExternalPtr doesn't see names in tag"
msgstr ""
"Error interno: ExternalPtr del finalizador no ve los nombres en la etiqueta"

msgid "Internal error: finalizer sees l=%d, tl=%d"
msgstr "Error interno: el finalizador ve l=%d, tl=%d"

msgid ""
".internal.selfref ptr is NULL. This is expected and normal for a data.table "
"loaded from disk. Please remember to always setDT() immediately after "
"loading to prevent unexpected behavior. If this table was not loaded from "
"disk or you've already run setDT(), please report to data.table issue "
"tracker.\n"
msgstr ""
".internal.selfref ptr es NULL. Esto es esperado y normal para una data.table "
"cargada desde el disco. Recuerde siempre hacer setDT() inmediatamente "
"después de la carga para evitar comportamientos inesperados. Si esta tabla "
"no se cargó desde el disco o ya ejecutó setDT(), informe al rastreador de "
"problemas de data.table.\n"

msgid "Internal error: .internal.selfref ptr is neither NULL nor R_NilValue"
msgstr "Error interno: .internal.selfref ptr no es NULL ni R_NilValue"

msgid ""
"Internal error: .internal.selfref tag is neither NULL nor a character vector"
msgstr ""
"Error interno: la etiqueta .internal.selfref no es NULL ni es un vector de "
"caracteres"

msgid "Internal error: length(names)>0 but <length(dt)"
msgstr "Error interno: length(names)>0 pero <length(dt)"

msgid ""
"Some columns are a multi-column type (such as a matrix column), for example "
"column %d. setDT will retain these columns as-is but subsequent operations "
"like grouping and joining may fail. Please consider as.data.table() instead "
"which will create a new column for each embedded column."
msgstr ""
"Algunas columnas son de tipo multicolumna (como una columna de matriz), por "
"ejemplo, la columna %d. setDT conservará estas columnas tal como están, pero "
"las operaciones posteriores, como la agrupación y la unión, pueden fallar. "
"Considere en cambio as.data.table(), que creará una nueva columna para cada "
"columna incrustada."

msgid ""
"Column %d has class 'POSIXlt'. Please convert it to POSIXct (using as."
"POSIXct) and run setDT() again. We do not recommend the use of POSIXlt at "
"all because it uses 40 bytes to store one date."
msgstr ""
"La columna %d tiene la clase 'POSIXlt'. Conviértala a POSIXct (usando as."
"POSIXct) y ejecute setDT() nuevamente. No recomendamos el uso de POSIXlt en "
"absoluto porque utiliza 40 bytes para almacenar una fecha."

msgid ""
"All elements in argument 'x' to 'setDT' must be of equal length, but input "
"%d has length %d whereas the first non-empty input had length %d"
msgstr ""
"Todos los elementos en el argumento 'x' de 'setDT' deben tener la misma "
"longitud, pero la entrada %d tiene una longitud %d mientras que la primera "
"entrada no vacía tenía una longitud %d"

msgid "alloccol has been passed a NULL dt"
msgstr " a 'alloccol' se le ha pasado un dt NULL"

msgid "dt passed to alloccol isn't type VECSXP"
msgstr "dt pasado a 'alloccol' no es del tipo VECSXP"

msgid ""
"dt passed to alloccol has no class attribute. Please report result of "
"traceback() to data.table issue tracker."
msgstr ""
"dt pasado a 'alloccol' no tiene atributo de clase. Informe el resultado de "
"traceback() al rastreador de problemas de data.table."

msgid "Internal error: length of names (%d) is not length of dt (%d)"
msgstr ""
"Error interno: la longitud de los nombres (%d) no es la longitud de dt (%d)"

msgid "Internal error, tl of class is marked but tl<0."
msgstr "Error interno, tl de clase está marcado pero tl<0."

msgid ""
"Internal error, please report (including result of sessionInfo()) to data."
"table issue tracker: tl (%d) < l (%d) but tl of class is marked."
msgstr ""
"Error interno, informe (incluido el resultado de sessionInfo()) al "
"rastreador de problemas de data.table: tl (%d) < l (%d) pero el tl de la "
"clase está marcado."

msgid ""
"tl (%d) is greater than 10,000 items over-allocated (l = %d). If you didn't "
"set the datatable.alloccol option to be very large, please report to data."
"table issue tracker including the result of sessionInfo()."
msgstr ""
"tl (%d) es mayor que 10000 elementos sobreasignados (l = %d). Si no "
"configuró la opción datatable.alloccol para que sea muy grande, informe al "
"rastreador de problemas de data.table, incluido el resultado de "
"sessionInfo()."

msgid ""
"Attempt to reduce allocation from %d to %d ignored. Can only increase "
"allocation via shallow copy. Please do not use DT[...]<- or DT$someCol<-. "
"Use := inside DT[...] instead."
msgstr ""
"Se ignora el intento de reducir la asignación de %d a %d. Solo se puede "
"aumentar la asignación mediante una copia superficial. No utilice DT[...]<- "
"o DT$someCol<-. Utilice := dentro de DT[...] en su lugar."

msgid ""
"Has getOption('datatable.alloccol') somehow become unset? It should be a "
"number, by default 1024."
msgstr ""
"¿Se ha desconfigurado getOption('datatable.alloccol') de alguna manera? "
"Debería ser un número, por defecto 1024."

msgid ""
"getOption('datatable.alloccol') should be a number, by default 1024. But its "
"type is '%s'."
msgstr ""
"getOption('datatable.alloccol') debería ser un número, por defecto 1024. "
"Pero su tipo es '%s'."

msgid ""
"getOption('datatable.alloc') is a numeric vector ok but its length is %d. "
"Its length should be 1."
msgstr ""
"getOption('datatable.alloc') es un vector numérico correcto, pero su "
"longitud es %d. Su longitud debe ser 1."

msgid "getOption('datatable.alloc')==%d.  It must be >=0 and not NA."
msgstr "getOption('datatable.alloc')==%d. Debe ser >=0 y no NA."

msgid "%s must be TRUE or FALSE"
msgstr "%s debe ser TRUE o FALSE"

msgid "assign has been passed a NULL dt"
msgstr "a la asignación se le ha pasado un dt NULL"

msgid "dt passed to assign isn't type VECSXP"
msgstr "dt pasado para asignar no es del tipo VECSXP"

msgid ""
".SD is locked. Updating .SD by reference using := or set are reserved for "
"future use. Use := in j directly. Or use copy(.SD) as a (slow) last resort, "
"until shallow() is exported."
msgstr ""
".SD está bloqueado. La actualización de .SD por referencia usando := o set "
"está reservada para uso futuro. Utilice := en 'j' directamente. O utilice "
"copy(.SD) como último recurso (lento), hasta que se exporte shallow()."

msgid "Internal error: dt passed to Cassign is not a data.table or data.frame"
msgstr "Error interno: el dt pasado a Cassign no es un data.table o data.frame"

msgid "dt passed to assign has no names"
msgstr "dt pasado para asignar no tiene nombres"

msgid ""
"data.table is NULL; malformed. A null data.table should be an empty list. "
"typeof() should always return 'list' for data.table."
msgstr ""
"datos.tabla es NULL; malformado. Una data.table nula debe ser una lista "
"vacía. typeof() siempre debe devolver 'list' para data.table."

msgid "Assigning to all %d rows\n"
msgstr "Asignando a todas las %d filas\n"

msgid ""
"Coerced i from numeric to integer. Please pass integer for efficiency; e.g., "
"2L rather than 2"
msgstr ""
"Forzando 'i' a numérico a entero. Pase un número entero para mayor "
"eficiencia; por ejemplo, 2L en lugar de 2"

msgid ""
"i is type '%s'. Must be integer, or numeric is coerced with warning. If i is "
"a logical subset, simply wrap with which(), and take the which() outside the "
"loop if possible for efficiency."
msgstr ""
"'i' es del tipo '%s'. Debe ser un número entero o el valor numérico se "
"fuerza con una advertencia. Si i es un subconjunto lógico, simplemente "
"envuélvalo con which() y, si es posible, saque el which() fuera del bucle "
"para mayor eficiencia."

msgid "i[%d] is %d which is out of range [1,nrow=%d]"
msgstr "i[%d] es %d que está fuera de rango [1,nrow=%d]"

msgid "Assigning to %d row subset of %d rows\n"
msgstr "Asignando a %d subconjunto de filas de %d filas\n"

msgid "Added %d new column%s initialized with all-NA\n"
msgstr "Se agregó %d nuevas columnas%s inicializadas con todo-NA\n"

msgid "length(LHS)==0; no columns to delete or assign RHS to."
msgstr "length(LHS)==0; no hay columnas para eliminar o asignar RHS."

msgid ""
"set() on a data.frame is for changing existing columns, not adding new ones. "
"Please use a data.table for that. data.table's are over-allocated and don't "
"shallow copy."
msgstr ""
"set() en un data.frame es para cambiar columnas existentes, no para agregar "
"nuevas. Utilice una data.table para eso. Los data.table están sobreasignados "
"y no realizan copias superficiales."

msgid ""
"Coerced j from numeric to integer. Please pass integer for efficiency; e.g., "
"2L rather than 2"
msgstr ""
"J forzado de numérico a entero. Pase un número entero para mayor eficiencia; "
"por ejemplo, 2L en lugar de 2"

msgid ""
"j is type '%s'. Must be integer, character, or numeric is coerced with "
"warning."
msgstr ""
"j es tipo '%s'. Debe ser un número entero, un carácter o un número numérico "
"con advertencia."

msgid ""
"Can't assign to the same column twice in the same query (duplicates "
"detected)."
msgstr ""
"No se puede asignar a la misma columna dos veces en la misma consulta (se "
"detectaron duplicados)."

msgid "newcolnames is supplied but isn't a character vector"
msgstr "se proporciona 'newcolnames' pero no es un vector de caracteres"

msgid "RHS_list_of_columns == %s\n"
msgstr "RHS_list_of_columns == %s\n"

msgid ""
"RHS_list_of_columns revised to true because RHS list has 1 item which is "
"NULL, or whose length %d is either 1 or targetlen (%d). Please unwrap RHS.\n"
msgstr ""
"RHS_list_of_columns revisado a verdadero porque la lista RHS tiene 1 "
"elemento que es NULL, o cuya longitud %d es 1 o targetlen (%d). Desenvuelva "
"el RHS.\n"

msgid ""
"Supplied %d columns to be assigned an empty list (which may be an empty data."
"table or data.frame since they are lists too). To delete multiple columns "
"use NULL instead. To add multiple empty list columns, use list(list())."
msgstr ""
"Se proporcionaron %d columnas a las que se les asignará una lista vacía (que "
"puede ser una data.table o un data.frame vacío, ya que también son listas). "
"Para eliminar varias columnas, utilice NULL en su lugar. Para agregar varias "
"columnas de lista vacías, use list(list())."

msgid "Recycling single RHS list item across %d columns. Please unwrap RHS.\n"
msgstr ""
"Reciclando un solo elemento de la lista RHS en %d columnas. Desenvuelva el "
"RHS.\n"

msgid ""
"Supplied %d columns to be assigned %d items. Please see NEWS for v1.12.2."
msgstr ""
"Se proporcionaron %d columnas para asignar %d elementos. Consulte NEWS para "
"v1.12.2."

msgid ""
"Item %d of column numbers in j is %d which is outside range [1,ncol=%d]. "
"set() on a data.frame is for changing existing columns, not adding new ones. "
"Please use a data.table for that."
msgstr ""
"El elemento %d de los números de columna en 'j' es %d que está fuera del "
"rango [1,ncol=%d]. set() en un data.frame es para cambiar columnas "
"existentes, no para agregar otras nuevas. Utilice una data.table para eso."

msgid ""
"Item %d of column numbers in j is %d which is outside range [1,ncol=%d]. Use "
"column names instead in j to add new columns."
msgstr ""
"El elemento %d de los números de columna en 'j' es %d que está fuera del "
"rango [1,ncol=%d]. Utilice nombres de columnas en su lugar en 'j' para "
"agregar nuevas columnas."

msgid "When deleting columns, i should not be provided"
msgstr "Al eliminar columnas, 'i' no debe ser proporcionado"

msgid ""
"RHS of assignment to existing column '%s' is zero length but not NULL. If "
"you intend to delete the column use NULL. Otherwise, the RHS must have "
"length > 0; e.g., NA_integer_. If you are trying to change the column type "
"to be an empty list column then, as with all column type changes, provide a "
"full length RHS vector such as vector('list',nrow(DT)); i.e., 'plonk' in the "
"new column."
msgstr ""
"RHS de la asignación a la columna existente '%s' tiene longitud cero pero no "
"es NULL. Si tiene la intención de eliminar la columna, utilice NULL. De lo "
"contrario, el RHS debe tener una longitud > 0; por ejemplo, NA_integer_. Si "
"está intentando cambiar el tipo de columna para que sea una columna de lista "
"vacía, al igual que con todos los cambios de tipo de columna, proporcione un "
"vector RHS de longitud completa como vector('list',nrow(DT)) ; es decir, "
"'plonk' en la nueva columna."

msgid ""
"Internal error in assign.c: length(newcolnames)=%d, length(names)=%d, coln=%d"
msgstr ""
"Error interno <assign.c>: length(newcolnames)=%d, length(names)=%d, coln=%d"

msgid ""
"Tried to assign NULL to column '%s', but this column does not exist to remove"
msgstr ""
"Se intentó asignar NULL a la columna '%s', pero esta columna no existe para "
"eliminarla"

msgid "%d column matrix RHS of := will be treated as one vector"
msgstr "matriz de %d columnas en RHS de := será tratada como un vector"

msgid ""
"Can't assign to column '%s' (type 'factor') a value of type '%s' (not "
"character, factor, integer or numeric)"
msgstr ""
"No se puede asignar a la columna '%s' (escriba 'factor') un valor de tipo "
"'%s' (ni carácter, factor, número entero o numérico)"

msgid ""
"Supplied %d items to be assigned to %d items of column '%s'. If you wish to "
"'recycle' the RHS please use rep() to make this intent clear to readers of "
"your code."
msgstr ""
"Se proporcionaron %d elementos para asignarlos a %d elementos de la columna "
"'%s'. Si desea 'recycle' el RHS, utilice rep() para dejar clara esta "
"intención a los lectores de su código."

msgid ""
"This data.table has either been loaded from disk (e.g. using readRDS()/"
"load()) or constructed manually (e.g. using structure()). Please run setDT() "
"or setalloccol() on it first (to pre-allocate space for new columns) before "
"assigning by reference to it."
msgstr ""
"Esta data.table se ha cargado desde el disco (por ejemplo, usando readRDS()/"
"load()) o se ha construido manualmente (por ejemplo, usando estructura()). "
"Ejecute setDT() o setalloccol() en él primero (para preasignar espacio para "
"nuevas columnas) antes de asignarlo por referencia."

msgid ""
"Internal error: oldtncol(%d) < oldncol(%d). Please report to data.table "
"issue tracker, including result of sessionInfo()."
msgstr ""
"Error interno: oldtncol(%d) < oldncol(%d). Informe al rastreador de "
"problemas de data.table, incluido el resultado de sessionInfo()."

msgid ""
"truelength (%d) is greater than 10,000 items over-allocated (length = %d). "
"See ?truelength. If you didn't set the datatable.alloccol option very large, "
"please report to data.table issue tracker including the result of "
"sessionInfo()."
msgstr ""
"truelength (%d) es mayor que 10000 elementos sobreasignados (length = %d). "
"Ver ?truelength. Si no configuró la opción datatable.alloccol en un tamaño "
"muy grande, informe al rastreador de problemas de data.table, incluido el "
"resultado de sessionInfo()."

msgid ""
"Internal error: DT passed to assign has not been allocated enough column "
"slots. l=%d, tl=%d, adding %d"
msgstr ""
"Error interno: al DT pasado para asignar no se le han asignado suficientes "
"espacios de columna. l=%d, tl=%d, agregando %d"

msgid ""
"It appears that at some earlier point, names of this data.table have been "
"reassigned. Please ensure to use setnames() rather than names<- or "
"colnames<-. Otherwise, please report to data.table issue tracker."
msgstr ""
"Parece que en algún momento anterior, los nombres de esta data.table han "
"sido reasignados. Asegúrese de utilizar setnames() en lugar de` names<-` o "
"`colnames<-`. De lo contrario, informe al rastreador de problemas de data."
"table."

msgid "Internal error: selfrefnames is ok but tl names [%lld] != tl [%d]"
msgstr "Error interno: selfrefnames está bien, pero tl names [%lld] != tl [%d]"

msgid ""
"Internal error: earlier error 'When deleting columns, i should not be "
"provided' did not happen."
msgstr ""
"Error interno: el error anterior 'Al eliminar columnas, no se debe "
"proporcionar i' no ocurrió."

msgid ""
"RHS for item %d has been duplicated because NAMED==%d MAYBE_SHARED==%d, but "
"then is being plonked. length(values)==%d; length(cols)==%d)\n"
msgstr ""
"RHS para el elemento %d se ha duplicado porque NAMED==%d MAYBE_SHARED==%d, "
"pero luego se está eliminando. length(valores)==%d; length(columnas)==%d)\n"

msgid "Direct plonk of unnamed RHS, no copy. NAMED==%d, MAYBE_SHARED==%d\n"
msgstr ""
"Eliminación directa de RHS sin nombre, no hay copia. NAMED==%d, "
"MAYBE_SHARED==%d\n"

msgid ""
"Dropping index '%s' as it doesn't have '__' at the beginning of its name. It "
"was very likely created by v1.9.4 of data.table.\n"
msgstr ""
"Eliminando el índice '%s' ya que no tiene '__' al principio de su nombre. Es "
"muy probable que haya sido creado por la versión 1.9.4 de data.table.\n"

msgid "Internal error: index name ends with trailing __"
msgstr "Error interno: el nombre del índice termina con __ al final"

msgid "Internal error: Couldn't allocate memory for s4."
msgstr "Error interno: No se pudo asignar memoria para s4."

msgid "Internal error: Couldn't allocate memory for s5."
msgstr "Error interno: No se pudo asignar memoria para s5."

msgid "Dropping index '%s' due to an update on a key column\n"
msgstr ""
"Se elimina el índice '%s' debido a una actualización en una columna de "
"clave\n"

msgid "Shortening index '%s' to '%s' due to an update on a key column\n"
msgstr ""
"Acortamiento del índice '%s' a '%s' debido a una actualización en una "
"columna de clave\n"

msgid ""
"Internal error: %d column numbers to delete not now in strictly increasing "
"order. No-dups were checked earlier."
msgstr ""
"Error interno: %d números de columnas para eliminar ahora no están en orden "
"estrictamente creciente. Los no duplicados se comprobaron antes."

msgid "target vector"
msgstr "vector objetivo"

msgid "column %d named '%s'"
msgstr "columna %d llamada '%s'"

msgid ""
"Internal error memrecycle: sourceStart=%d sourceLen=%d length(source)=%d"
msgstr ""
"Error interno memrecycle: sourceStart=%d sourceLen=%d length(source)=%d"

msgid "Internal error memrecycle: start=%d len=%d length(target)=%d"
msgstr "Error interno memrecycle: inicio=%d len=%d length(objetivo)=%d"

msgid "Internal error: recycle length error not caught earlier. slen=%d len=%d"
msgstr ""
"Error interno: error de longitud de reciclaje no detectado antes. slen=%d "
"len=%d"

msgid "Internal error: memrecycle has received NULL colname"
msgstr "Error interno: 'memrecycle' ha recibido un nombre de columna NULL"

msgid ""
"Cannot assign 'factor' to '%s'. Factors can only be assigned to factor, "
"character or list columns."
msgstr ""
"No se puede asignar 'factor' a '%s. Los factores sólo se pueden asignar a "
"columnas de factores, caracteres o listas."

msgid ""
"Assigning factor numbers to %s. But %d is outside the level range [1,%d]"
msgstr ""
"Se asignan números de factor a %s. Pero %d está fuera del rango de nivel [1,"
"%d]"

msgid ""
"Assigning factor numbers to %s. But %f is outside the level range [1,%d], or "
"is not a whole number."
msgstr ""
"Se asignan números de factor a %s. Pero %f está fuera del rango de niveles "
"[1,%d] o no es un número entero."

msgid ""
"Cannot assign '%s' to 'factor'. Factor columns can be assigned factor, "
"character, NA in any type, or level numbers."
msgstr ""
"No se puede asignar '%s' a 'factor'. A las columnas de factores se les puede "
"asignar factor, carácter, NA de cualquier tipo, o números de nivel."

msgid ""
"Internal error: levels of target are either not unique or have truelength<0"
msgstr ""
"Error interno: los niveles del objetivo no son únicos o tienen truelength<0"

msgid "Unable to allocate working memory of %zu bytes to combine factor levels"
msgstr ""
"No se puede asignar memoria de trabajo de %zu bytes para combinar niveles de "
"factor"

msgid "Internal error: extra level check sum failed"
msgstr "Error interno: falló la suma de verificación de nivel adicional"

msgid "Coercing 'character' RHS to '%s' to match the type of %s."
msgstr ""
"Coaccionando 'character' RHS a '%s' para que coincida con el tipo de %s."

msgid "Cannot coerce 'list' RHS to 'integer64' to match the type of %s."
msgstr ""
"No se puede forzar a 'list' RHS a 'integer64' para que coincida con el tipo "
"de %s."

msgid "Coercing 'list' RHS to '%s' to match the type of %s."
msgstr "Forzar 'list' RHS a '%s' para que coincida con el tipo de %s."

msgid "Zero-copy coerce when assigning '%s' to '%s' %s.\n"
msgstr "Coacción de copia cero al asignar '%s' a '%s' %s.\n"

msgid "type '%s' cannot be coerced to '%s'"
msgstr "el tipo '%s' no puede ser forzado a '%s'"

msgid "Unsupported column type in assign.c:memrecycle '%s'"
msgstr "<assign.c> Tipo de columna no admitido: 'memrecycle' '%s'"

msgid "Internal error: writeNA passed a vector of type '%s'"
msgstr "Error interno: writeNA pasó un vector de tipo '%s'"

msgid ""
"Internal error: savetl_init checks failed (%d %d %p %p). please report to "
"data.table issue tracker."
msgstr ""
"Error interno: las comprobaciones de savetl_init fallaron (%d %d %p %p). "
"informe al rastreador de problemas de data.table."

msgid "Failed to allocate initial %d items in savetl_init"
msgstr "No se pudieron asignar %d elementos iniciales en savetl_init"

msgid ""
"Internal error: reached maximum %d items for savetl. Please report to data."
"table issue tracker."
msgstr ""
"Error interno: se alcanzó el máximo de %d elementos para 'savetl'. Informe "
"al rastreador de problemas de data.table."

msgid "Failed to realloc saveds to %d items in savetl"
msgstr "No se pudo hacer realloc() sobre 'saveds' a %d elementos en 'savetl'"

msgid "Failed to realloc savedtl to %d items in savetl"
msgstr "No se pudo hacer realloc() sobre 'savedtl' a %d elementos en 'savetl'"

msgid "x must be a character vector"
msgstr "x debe ser un vector de caracteres"

msgid "'which' must be an integer vector"
msgstr "'which' debe ser un vector entero"

msgid "'new' must be a character vector"
msgstr "'new' debe ser un vector de caracteres"

msgid "'new' is length %d. Should be the same as length of 'which' (%d)"
msgstr ""
"'new' tiene una longitud %d. Debe ser la misma que la longitud de 'which' ("
"%d)"

msgid ""
"Item %d of 'which' is %d which is outside range of the length %d character "
"vector"
msgstr ""
"El elemento %d de 'which' es %d que está fuera del rango del vector de "
"caracteres de longitud %d"

msgid ""
"Incompatible vector lengths: length(x)==%d length(lower)==%d length(upper)=="
"%d. Each should be either length 1 or the length of the longest."
msgstr ""
"Longitudes de vectores incompatibles: length(x)==%d length(lower)==%d "
"length(upper)==%d. Cada uno debe tener una longitud de 1 o la longitud del "
"más largo."

msgid "NAbounds must be TRUE or NA"
msgstr "'NAbounds' debe ser TRUE o NA"

msgid "Item %d of lower (%d) is greater than item %d of upper (%d)"
msgstr ""
"El elemento %d del inferior (%d) es mayor que el elemento %d del superior ("
"%d)"

msgid "between parallel processing of integer took %8.3fs\n"
msgstr "'between' con procesamiento paralelo de un número entero tomó %8.3fs\n"

msgid "x is integer64 but lower and/or upper are not."
msgstr "'x' es entero64 pero inferior y/o superior no lo son."

msgid ""
"Item %d of lower (%<PRId64>) is greater than item %d of upper (%<PRId64>)"
msgstr ""
"El elemento %d del inferior (%<PRId64>) es mayor que el elemento %d del "
"superior (%<PRId64>)"

msgid "between parallel processing of integer64 took %8.3fs\n"
msgstr "'between' con procesamiento paralelo de integer64 tomó %8.3fs\n"

msgid ""
"x is not integer64 but lower and/or upper is integer64. Please align classes."
msgstr ""
"'x' no es entero64 pero inferior y/o superior es entero64. Por favor alinee "
"las clases."

msgid "Item %d of lower (%f) is greater than item %d of upper (%f)"
msgstr ""
"El elemento %d de 'lower' (%f) es mayor que el elemento %d de 'upper' (%f)"

msgid "between parallel processing of double with open bounds took %8.3fs\n"
msgstr ""
"'between' con procesamiento paralelo de 'double' con intervalo abierto tomó "
"%8.3fs\n"

msgid "between parallel processing of double with closed bounds took %8.3fs\n"
msgstr ""
"'between' con procesamiento paralelo de 'double' con intervalo cerrado tomó "
"%8.3fs\n"

msgid "Item %d of lower ('%s') is greater than item %d of upper ('%s')"
msgstr ""
"El elemento %d de 'lower' ('%s') es mayor que el elemento %d de 'upper' ("
"'%s')."

msgid "between non-parallel processing of character took %8.3fs\n"
msgstr "'between' con procesamiento no paralelo del carácter tomó %8.3fs\n"

msgid ""
"Internal error: between.c unsupported type '%s' should have been caught at R "
"level"
msgstr ""
"Error interno:  <between.c> el tipo '%s' no admitido debería haber sido "
"detectado a nivel R"

msgid "Internal error: icols is not integer vector"
msgstr "Error interno: icols no es un vector entero"

msgid "Internal error: xcols is not integer vector"
msgstr "Error interno: xcols no es un vector entero"

msgid "Internal error: icols and xcols must be non-empty integer vectors."
msgstr "Error interno: icols y xcols deben ser vectores enteros no vacíos."

msgid "Internal error: length(icols) [%d] > length(xcols) [%d]"
msgstr "Error interno: length(icols) [%d] > length(xcols) [%d]"

msgid "Internal error. icols[%d] is NA"
msgstr "Error interno. icols[%d] es NA"

msgid "Internal error. xcols[%d] is NA"
msgstr "Error interno. xcols[%d] es NA"

msgid "icols[%d]=%d outside range [1,length(i)=%d]"
msgstr "icols[%d]=%d fuera del rango [1,length(i)=%d]"

msgid "xcols[%d]=%d outside range [1,length(x)=%d]"
msgstr "xcols[%d]=%d fuera del rango [1,length(x)=%d]"

msgid "typeof x.%s (%s) != typeof i.%s (%s)"
msgstr "tipo de x.%s (%s) != tipo de i.%s (%s)"

msgid "Type '%s' is not supported for joining/merging"
msgstr "El tipo '%s' no es compatible para join/merge"

msgid "roll is character but not 'nearest'"
msgstr "roll es un carácter pero no 'nearest'"

msgid "roll='nearest' can't be applied to a character column, yet."
msgstr ""
"roll='nearest' todavía no se puede aplicar a una columna de caracteres."

msgid "Internal error: roll is not character or double"
msgstr "Error interno: 'roll' no es carácter o es double"

msgid "rollends must be a length 2 logical vector"
msgstr "'rollends' debe ser un vector lógico de longitud 2"

msgid "Internal error: nomatchArg must be NULL or length-1 logical/integer"
msgstr "Error interno: 'nomatchArg' debe ser NULL o longitud-1 lógico/entero"

msgid "Internal error: nomatchArg must be NULL, NA, NA_integer_ or 0L"
msgstr "Error interno: 'nomatchArg' debe ser NULL, NA, NA_integer_ o 0L"

msgid ""
"Internal error: invalid value for 'mult'. please report to data.table issue "
"tracker"
msgstr ""
"Error interno: valor no válido para 'mult'. informe al rastreador de "
"problemas de data.table"

msgid ""
"Internal error: opArg is not an integer vector of length equal to length(on)"
msgstr ""
"Error interno: 'opArg' no es un vector entero de longitud igual a length(on)"

msgid "Internal error in bmerge_r for x.'%s'. Unrecognized value op[col]=%d"
msgstr ""
"Error interno en 'bmerge_r' para 'x'.'%s'. Valor no reconocido op[col]=%d"

msgid "Only '==' operator is supported for columns of type character."
msgstr "Solo se admite el operador '==' para columnas de tipo carácter."

msgid "Internal error: nqgrpArg must be an integer vector"
msgstr "Error interno: 'nqgrpArg' debe ser un vector entero"

msgid "Internal error: nqmaxgrpArg is not a positive length-1 integer vector"
msgstr ""
"Error interno: nqmaxgrpArg no es un vector entero de longitud positiva 1"

msgid "Internal error in allocating memory for non-equi join"
msgstr ""
"Error interno al asignar memoria para una unión no equivalente (non-equi "
"join)"

msgid "Internal error: xoArg is not an integer vector"
msgstr "Error interno: 'xoArg' no es un vector entero"

msgid "table is type '%s' (must be 'character' or NULL)"
msgstr "la tabla es del tipo '%s' (debe ser 'character' o NULL)"

msgid "Internal error: either chin or chmatchdup should be true not both"
msgstr ""
"Error interno: o bien 'chin' o 'chmatchdup' deberían ser verdaderos, pero no "
"ambos"

msgid "Internal error: length of SYMSXP is %d not 1"
msgstr "Error interno: la longitud de SYMSXP es %d, no 1"

msgid "x is type '%s' (must be 'character' or NULL)"
msgstr "'x' es del tipo '%s' (debe ser 'character' o NULL)"

msgid ""
"Internal error: CHARSXP '%s' has a negative truelength (%d). Please file an "
"issue on the data.table tracker."
msgstr ""
"Error interno: CHARSXP '%s' tiene un truelength negativo (%d). Presente un "
"problema en el rastreador de problemas data.table."

msgid ""
"Failed to allocate %<PRIu64> bytes working memory in chmatchdup: "
"length(table)=%d length(unique(table))=%d"
msgstr ""
"Error al asignar %<PRIu64> bytes de memoria de trabajo en chmatchdup: "
"length(tabla)=%d length(unique(tabla))=%d"

msgid "Type '%s' is not supported by CJ."
msgstr "El tipo '%s' no es soportado por CJ."

msgid "Internal error in coalesce.c: input is list(...) at R level"
msgstr "Error interno <coalesce.c>: la entrada es list(...) en el nivel R"

msgid ""
"Internal error in coalesce.c: argument 'inplaceArg' must be TRUE or FALSE"
msgstr ""
"Error interno <coalesce.c>: el argumento 'inplaceArg' debe ser TRUE o FALSE"

msgid ""
"The first argument is a list, data.table or data.frame. In this case there "
"should be no other arguments provided."
msgstr ""
"El primer argumento es una lista, data.table o data.frame. En este caso no "
"deberían haber sido proporcionados otros argumentos."

msgid ""
"Item 1 is a factor but item %d is not a factor. When factors are involved, "
"all items must be factor."
msgstr ""
"El elemento 1 es un factor pero el elemento %d no es un factor. Cuando hay "
"factores involucrados, todos los elementos deben ser factores."

msgid ""
"Item %d is a factor but its levels are not identical to the first item's "
"levels."
msgstr ""
"El elemento %d es un factor pero sus niveles no son idénticos a los niveles "
"del primer elemento."

msgid ""
"Item %d is a factor but item 1 is not a factor. When factors are involved, "
"all items must be factor."
msgstr ""
"El elemento %d es un factor pero el elemento 1 no es un factor. Cuando hay "
"factores involucrados, todos los elementos deben ser factores."

msgid ""
"Item %d is type %s but the first item is type %s. Please coerce before "
"coalescing."
msgstr ""
"El elemento %d es del tipo %s pero el primer elemento es del tipo %s. Por "
"favor, coaccione antes de fusionarse."

msgid "Item %d has a different class than item 1."
msgstr "El elemento %d tiene una clase diferente a la del elemento 1."

msgid ""
"Item %d is length %d but the first item is length %d. Only singletons are "
"recycled."
msgstr ""
"El elemento %d tiene una longitud %d pero el primer elemento tiene una "
"longitud %d. Sólo se reciclan los singleton."

msgid "coalesce copied first item (inplace=FALSE)\n"
msgstr "'coalesce' copió primer elemento (inplace=FALSE)\n"

msgid "Type '%s' is not supported"
msgstr "El tipo '%s' no está soportado"

msgid "Internal error: order not integer vector"
msgstr "Error interno: 'order' no es vector entero"

msgid "Internal error: starts not integer"
msgstr "Error interno: 'starts' no es un número entero"

msgid "Internal error: lens not integer"
msgstr "Error interno: 'lens' no es un número entero"

msgid "Internal error: jiscols not NULL but o__ has length"
msgstr "Error interno: 'jiscols' no es NULL pero o__ tiene longitud"

msgid "Internal error: xjiscols not NULL but o__ has length"
msgstr "Error interno: 'xjiscols' no es NULL pero o__ tiene longitud"

msgid "env is not an environment"
msgstr "env no es un entorno"

msgid ""
"Internal error: unsupported size-0 type '%s' in column %d of 'by' should "
"have been caught earlier"
msgstr ""
"Error interno: el tipo '%s' de tamaño 0 no admitido en la columna %d de 'by' "
"debería haberse detectado antes"

msgid "!length(bynames)[%d]==length(groups)[%d]==length(grpcols)[%d]"
msgstr "!length(bynames)[%d]==length(groups)[%d]==length(grpcols)[%d]"

msgid "row.names attribute of .SD not found"
msgstr "atributo row.names de .SD no encontrado"

msgid ""
"row.names of .SD isn't integer length 2 with NA as first item; i.e., ."
"set_row_names(). [%s %d %d]"
msgstr ""
"row.names de .SD no tiene una longitud entera de 2 con NA como primer "
"elemento; es decir, .set_row_names(). [%s %d %d]"

msgid "length(names)!=length(SD)"
msgstr "length(names)!=length(SD)"

msgid ""
"Internal error: size-0 type %d in .SD column %d should have been caught "
"earlier"
msgstr ""
"Error interno: el tipo %d de tamaño 0 en la columna .SD %d debería haberse "
"detectado antes"

msgid "Internal error: SDall %d length = %d != %d"
msgstr "Error interno: SDall %d length = %d != %d"

msgid "length(xknames)!=length(xSD)"
msgstr "length(xknames)!=length(xSD)"

msgid ""
"Internal error: type %d in .xSD column %d should have been caught by now"
msgstr ""
"Error interno: tipo %d en la columna .xSD %d ya debería haber sido detectado"

msgid "length(iSD)[%d] != length(jiscols)[%d]"
msgstr "length(iSD)[%d] != length(jiscols)[%d]"

msgid "length(xSD)[%d] != length(xjiscols)[%d]"
msgstr "length(xSD)[%d] != length(xjiscols)[%d]"

msgid "j evaluates to type '%s'. Must evaluate to atomic vector or list."
msgstr "j evalúa escribir '%s'. Debe evaluarse como vector atómico o lista."

msgid ""
"Entry %d for group %d in j=list(...) should be atomic vector or list. If you "
"are trying something like j=list(.SD,newcol=mean(colA)) then use := by group "
"instead (much quicker), or cbind or merge afterwards."
msgstr ""
"La entrada %d para el grupo %d en j=list(...) debe ser un vector atómico o "
"una lista. Si está intentando algo como j=list(.SD,newcol=mean(colA)), "
"utilice := por grupo en su lugar (mucho más rápido), o cbind o merge después."

msgid ""
"Entry %d for group %d in j=list(...) is an array with %d dimensions > 1, "
"which is disallowed. \"Break\" the array yourself with c() or as.vector() if "
"that is intentional."
msgstr ""
"La entrada %d para el grupo %d en j=list(...) es una matriz con %d "
"dimensiones > 1, lo cual no está permitido. \"Rompe\" la matriz tú mismo con "
"c() o as.vector() si es intencional."

msgid ""
"RHS of := is NULL during grouped assignment, but it's not possible to delete "
"parts of a column."
msgstr ""
"RHS de := es NULL durante la asignación agrupada, pero no es posible "
"eliminar partes de una columna."

msgid ""
"Supplied %d items to be assigned to group %d of size %d in column '%s'. The "
"RHS length must either be 1 (single values are ok) or match the LHS length "
"exactly. If you wish to 'recycle' the RHS please use rep() explicitly to "
"make this intent clear to readers of your code."
msgstr ""
"Se suministraron %d elementos para asignarlos al grupo %d de tamaño %d en la "
"columna '%s'. La longitud del RHS debe ser 1 (los valores individuales están "
"bien) o coincidir exactamente con la longitud del LHS. Si desea 'recycle' el "
"RHS, utilice rep() explícitamente para dejar clara esta intención a los "
"lectores de su código."

msgid ""
"Internal error: Trying to add new column by reference but tl is full; "
"setalloccol should have run first at R level before getting to this point in "
"dogroups"
msgstr ""
"Error interno: Intentando agregar una nueva columna por referencia pero está "
"lleno; setalloccol debería haberse ejecutado primero en el nivel R antes de "
"llegar a este punto en dogroups"

msgid "Group %d column '%s': %s"
msgstr "Grupo %d columna '%s': %s"

msgid "j doesn't evaluate to the same number of columns for each group"
msgstr "'j' no evalúa el mismo número de columnas para cada grupo"

msgid ""
"Column %d of j's result for the first group is NULL. We rely on the column "
"types of the first result to decide the type expected for the remaining "
"groups (and require consistency). NULL columns are acceptable for later "
"groups (and those are replaced with NA of appropriate type and recycled) but "
"not for the first. Please use a typed empty vector instead, such as "
"integer() or numeric()."
msgstr ""
"La columna %d del resultado de 'j' para el primer grupo es NULL. Nos basamos "
"en los tipos de columnas del primer resultado para decidir el tipo esperado "
"para los grupos restantes (y requerir coherencia). Las columnas NULL son "
"aceptables para grupos posteriores (y se reemplazan con NA del tipo "
"apropiado y se reciclan) pero no para el primero. Utilice en su lugar un "
"vector vacío con tipo, como integer() o numeric()."

msgid ""
"j appears to be a named vector. The same names will likely be created over "
"and over again for each group and slow things down. Try and pass a named "
"list (which data.table optimizes) or an unnamed list() instead.\n"
msgstr ""
"'j' parece ser un vector con nombre. Es probable que se creen los mismos "
"nombres una y otra vez para cada grupo y que el proceso sea más lento. "
"Intente pasar una lista con nombre (que data.table optimiza) o una lista sin "
"nombre en su lugar.\n"

msgid ""
"Column %d of j is a named vector (each item down the rows is named, "
"somehow). Please remove those names for efficiency (to save creating them "
"over and over for each group). They are ignored anyway.\n"
msgstr ""
"La columna %d de 'j' es un vector con nombre (cada elemento de las filas "
"tiene un nombre, de alguna manera). Elimine esos nombres para mayor "
"eficiencia (para evitar crearlos una y otra vez para cada grupo). Se ignoran "
"de todos modos.\n"

msgid ""
"The result of j is a named list. It's very inefficient to create the same "
"names over and over again for each group. When j=list(...), any names are "
"detected, removed and put back after grouping has completed, for efficiency. "
"Using j=transform(), for example, prevents that speedup (consider changing "
"to :=). This message may be upgraded to warning in future.\n"
msgstr ""
"El resultado de 'j' es una lista con nombre. Es muy ineficaz crear los "
"mismos nombres una y otra vez para cada grupo. Cuando j=list(...), cualquier "
"nombre se detecta, se elimina y se vuelve a colocar después de que se haya "
"completado la agrupación, para mayor eficiencia. El uso de j=transform(), "
"por ejemplo, evita esa mejora en eficiencia (considere cambiar a :=). Es "
"posible que este mensaje se actualice a advertencia en el futuro.\n"

msgid "dogroups: growing from %d to %d rows\n"
msgstr "dogroups: creciendo de %d a %d filas\n"

msgid "dogroups: length(ans)[%d]!=ngrpcols[%d]+njval[%d]"
msgstr "dogrupos: length(ans)[%d]!=ngrpcols[%d]+njval[%d]"

msgid ""
"Item %d of j's result for group %d is zero length. This will be filled with "
"%d NAs to match the longest column in this result. Later groups may have a "
"similar problem but only the first is reported to save filling the warning "
"buffer."
msgstr ""
"El elemento %d del resultado de 'j' para el grupo %d tiene longitud cero. "
"Esto se completará con %d NA para que coincida con la columna más larga de "
"este resultado. Los grupos posteriores pueden tener un problema similar, "
"pero solo se informa que el primero guarda el llenado del búfer de "
"advertencia."

msgid ""
"Column %d of result for group %d is type '%s' but expecting type '%s'. "
"Column types must be consistent for each group."
msgstr ""
"La columna %d del resultado para el grupo %d es del tipo '%s' pero se espera "
"el tipo '%s'. Los tipos de columnas deben ser coherentes para cada grupo."

msgid ""
"Supplied %d items for column %d of group %d which has %d rows. The RHS "
"length must either be 1 (single values are ok) or match the LHS length "
"exactly. If you wish to 'recycle' the RHS please use rep() explicitly to "
"make this intent clear to readers of your code."
msgstr ""
"Se proporcionaron %d elementos para la columna %d del grupo %d que tiene %d "
"filas. La longitud del RHS debe ser 1 (los valores individuales están bien) "
"o coincidir exactamente con la longitud del LHS. Si desea 'recycle' en el "
"RHS, utilice rep() explícitamente para dejar clara esta intención a los "
"lectores de su código."

msgid "Wrote less rows (%d) than allocated (%d).\n"
msgstr "Escribió menos filas (%d) de las asignadas (%d).\n"

msgid "Internal error: block 0 [%d] and block 1 [%d] have both run"
msgstr ""
"Error interno: el bloque 0 [%d] y el bloque 1 [%d] se han ejecutado ambos"

msgid ""
"\n"
"  %s took %.3fs for %d groups\n"
msgstr ""
"\n"
" %s tomó %.3fs para %d grupos\n"

msgid "  eval(j) took %.3fs for %d calls\n"
msgstr " eval(j) tomó %.3fs para %d llamadas\n"

msgid "growVector passed NULL"
msgstr "growVector pasó NULL"

msgid "Internal error: growVector doesn't support type '%s'"
msgstr "Error interno: growVector no admite el tipo '%s'"

msgid "%s should be TRUE or FALSE"
msgstr "%s debe ser TRUE o FALSE"

msgid "fastmean was passed type %s, not numeric or logical"
msgstr "fastmean recibió tipo %s, no numérico ni lógico"

msgid "Internal error: type '%s' not caught earlier in fastmean"
msgstr "Error interno: escriba '%s' no detectado anteriormente en fastmean"

msgid "Unsupported column type in fcast val: '%s'"
msgstr "Tipo de columna no admitido en fcast val: '%s'"

msgid "Argument 'test' must be logical."
msgstr "El argumento 'test' debe ser lógico."

msgid "S4 class objects (except nanotime) are not supported."
msgstr "Los objetos de clase S4 (excepto nanotime) no son compatibles."

msgid ""
"Length of 'yes' is %<PRId64> but must be 1 or length of 'test' (%<PRId64>)."
msgstr ""
"La longitud de 'yes' es %<PRId64> pero debe ser 1 o la longitud de 'test' ("
"%<PRId64>)."

msgid ""
"Length of 'no' is %<PRId64> but must be 1 or length of 'test' (%<PRId64>)."
msgstr ""
"La longitud de 'no' es %<PRId64> pero debe ser 1 o la longitud de 'test' ("
"%<PRId64>)."

msgid ""
"Length of 'na' is %<PRId64> but must be 1 or length of 'test' (%<PRId64>)."
msgstr ""
"La longitud de 'na' es %<PRId64> pero debe ser 1 o la longitud de 'test' ("
"%<PRId64>)."

msgid ""
"'no' is of type %s but '%s' is %s. Please make all arguments have the same "
"type."
msgstr ""
"'no' es del tipo %s pero '%s' es %s. Por favor haga que todos los argumentos "
"sean del mismo tipo."

msgid ""
"'na' is of type %s but '%s' is %s. Please make all arguments have the same "
"type."
msgstr ""
"'na' es del tipo %s pero '%s' es %s. Por favor haga que todos los argumentos "
"sean del mismo tipo."

msgid ""
"'yes' has different class than 'no'. Please make sure that both arguments "
"have the same class."
msgstr ""
"'yes' tiene una clase diferente a la de 'no'. Asegúrese de que ambos "
"argumentos tengan la misma clase."

msgid ""
"'yes' has different class than 'na'. Please make sure that both arguments "
"have the same class."
msgstr ""
"'yes' tiene una clase diferente a la de 'na'. Asegúrese de que ambos "
"argumentos tengan la misma clase."

msgid ""
"'no' has different class than 'na'. Please make sure that both arguments "
"have the same class."
msgstr ""
"'no' tiene una clase diferente a la de 'na'. Asegúrese de que ambos "
"argumentos tengan la misma clase."

msgid "'yes' and 'no' are both type factor but their levels are different."
msgstr "'yes' y 'no' son factores de tipo pero sus niveles son diferentes."

msgid "'yes' and 'na' are both type factor but their levels are different."
msgstr "'yes' y 'na' son factores de tipo pero sus niveles son diferentes."

msgid "'no' and 'na' are both type factor but their levels are different."
msgstr "'no' y 'na' son factores de tipo pero sus niveles son diferentes."

msgid ""
"Received %d inputs; please supply an even number of arguments in ..., "
"consisting of logical condition, resulting value pairs (in that order). Note "
"that the default argument must be named explicitly, e.g., default=0"
msgstr ""
"Se recibieron %d entradas; proporcione un número par de argumentos en..., "
"que consistan en pares condición lógica, valor resultante (en ese orden). "
"Tenga en cuenta que el argumento predeterminado debe nombrarse "
"explícitamente, por ejemplo, default=0"

msgid ""
"S4 class objects (except nanotime) are not supported. Please see https://"
"github.com/Rdatatable/data.table/issues/4131."
msgstr ""
"Los objetos de clase S4 (excepto nanotime) no son compatibles. Consulte "
"https://github.com/Rdatatable/data.table/issues/4131."

msgid "Length of 'default' must be 1."
msgstr "La longitud de 'default' debe ser 1."

msgid ""
"Resulting value is of type %s but 'default' is of type %s. Please make sure "
"that both arguments have the same type."
msgstr ""
"El valor resultante es de tipo %s pero 'default' es de tipo %s. Asegúrese de "
"que ambos argumentos sean del mismo tipo."

msgid ""
"Resulting value has different class than 'default'. Please make sure that "
"both arguments have the same class."
msgstr ""
"El valor resultante tiene una clase diferente a 'default'. Asegúrese de que "
"ambos argumentos tengan la misma clase."

msgid ""
"Resulting value and 'default' are both type factor but their levels are "
"different."
msgstr ""
"El valor resultante y 'default' son factores de tipo pero sus niveles son "
"diferentes."

msgid "Argument #%d must be logical."
msgstr "El argumento #%d debe ser lógico."

msgid ""
"Argument #%d has a different length than argument #1. Please make sure all "
"logical conditions have the same length."
msgstr ""
"El argumento #%d tiene una longitud diferente a la del argumento #1. "
"Asegúrese de que todas las condiciones lógicas tengan la misma longitud."

msgid ""
"Argument #%d is of type %s, however argument #2 is of type %s. Please make "
"sure all output values have the same type."
msgstr ""
"El argumento #%d es de tipo %s, sin embargo, el argumento #2 es de tipo %s. "
"Asegúrese de que todos los valores de salida sean del mismo tipo."

msgid ""
"Argument #%d has different class than argument #2, Please make sure all "
"output values have the same class."
msgstr ""
"El argumento #%d tiene una clase diferente a la del argumento #2. Asegúrese "
"de que todos los valores de salida tengan la misma clase."

msgid ""
"Argument #2 and argument #%d are both factor but their levels are different."
msgstr ""
"El argumento #2 y el argumento #%d son ambos factores pero sus niveles son "
"diferentes."

msgid ""
"Length of output value #%d must either be 1 or length of logical condition."
msgstr ""
"La longitud del valor de salida #%d debe ser 1 o la longitud de la condición "
"lógica."

msgid "'x' must be an integer"
msgstr "'x' debe ser un número entero"

msgid "'n' must be a positive integer"
msgstr "'n' debe ser un número entero positivo"

msgid "Argument to 'which' must be logical"
msgstr "El argumento de 'which' debe ser lógico"

msgid "concat: 'vec' must be a character vector"
msgstr "concat: 'vec' debe ser un vector de caracteres"

msgid "concat: 'idx' must be an integer vector of length >= 0"
msgstr "concat: 'idx' debe ser un vector entero de longitud >= 0"

msgid ""
"Internal error in concat: 'idx' must take values between 1 and length(vec); "
"1 <= idx <= %d"
msgstr ""
"Error interno en concat: 'idx' debe tomar valores entre 1 y longitud (vec); "
"1 <= idx <= %d"

msgid "Unknown 'measure.vars' type %s at index %d of list"
msgstr "Tipo 'measure.vars' desconocido %s en el índice %d de la lista"

msgid "One or more values in 'measure.vars' is invalid."
msgstr "Uno o más valores en 'measure.vars' no son válidos."

msgid "One or more values in 'id.vars' is invalid."
msgstr "Uno o más valores en 'id.vars' no son válidos."

msgid ""
"Unknown 'measure.vars' type %s, must be character or integer vector/list"
msgstr ""
"Tipo 'measure.vars' desconocido %s, debe ser un vector/lista de caracteres o "
"enteros"

msgid "Unknown 'id.vars' type %s, must be character or integer vector"
msgstr "Tipo 'id.vars' desconocido %s, debe ser un vector de carácter o entero"

msgid ""
"id.vars and measure.vars are internally guessed when both are 'NULL'. All "
"non-numeric/integer/logical type columns are considered id.vars, which in "
"this case are columns [%s]. Consider providing at least one of 'id' or "
"'measure' vars in future."
msgstr ""
"id.vars y measure.vars se infieren internamente cuando ambos son 'NULL'. "
"Todas las columnas de tipo no numérico/entero/lógico se consideran id.vars, "
"que en este caso son columnas [%s]. Considere proporcionar al menos una de "
"las variables 'id' o 'measure' en el futuro."

msgid ""
"'measure.vars' is missing. Assigning all columns other than 'id.vars' "
"columns as 'measure.vars'.\n"
msgstr ""
"Falta 'measure.vars'. Asignar todas las columnas que no sean 'id.vars' como "
"'measure.vars'.\n"

msgid "Assigned 'measure.vars' are [%s].\n"
msgstr "Las 'measure.vars' asignadas son [%s].\n"

msgid ""
"'id.vars' is missing. Assigning all columns other than 'measure.vars' "
"columns as 'id.vars'.\n"
msgstr ""
"Falta 'id.vars'. Asignar todas las columnas que no sean 'measure.vars' como "
"'id.vars'.\n"

msgid "Assigned 'id.vars' are [%s].\n"
msgstr "Los 'id.vars' asignados son [%s].\n"

msgid ""
"When 'measure.vars' is a list, 'value.name' must be a character vector of "
"length =1 or =length(measure.vars)."
msgstr ""
"Cuando 'measure.vars' es una lista, 'value.name' debe ser un vector de "
"caracteres de longitud =1 o =length(measure.vars)."

msgid ""
"When 'measure.vars' is either not specified or a character/integer vector, "
"'value.name' must be a character vector of length =1."
msgstr ""
"Cuando no se especifica 'measure.vars' o es un vector de caracteres/entero, "
"'value.name' debe ser un vector de caracteres de longitud =1."

msgid "'variable.name' must be a character/integer vector of length 1."
msgstr "'variable.name' debe ser un vector de carácter/entero de longitud 1."

msgid ""
"variable_table attribute of measure.vars should be a data table with at "
"least one column"
msgstr ""
"el atributo variable_table de measure.vars debe ser una data.table con al "
"menos una columna"

msgid ""
"variable_table attribute of measure.vars should be a data table with same "
"number of rows as max length of measure.vars vectors =%d"
msgstr ""
"El atributo variable_table de measure.vars debe ser una data.table con el "
"mismo número de filas que la longitud máxima de los vectores de measure.vars "
"=%d"

msgid ""
"variable_table attribute of measure.vars should be either NULL or a data "
"table"
msgstr ""
"el atributo variable_table de measure.vars debe ser NULL o una data.table"

msgid ""
"Internal error: combineFactorLevels in fmelt.c expects all-character input"
msgstr ""
"Error interno <fmelt.c>: combineFactorLevels espera una entrada solo de tipo "
"carácter"

msgid ""
"Internal error: combineFactorLevels in fmelt.c expects a character target to "
"factorize"
msgstr ""
"Error interno  <fmelt.c>: combineFactorLevels espera una entrada objetivo de "
"tipo carácter para convertir a factor"

msgid ""
"'measure.vars' [%s] are not all of the same type. By order of hierarchy, the "
"molten data value column will be of type '%s'. All measure variables not of "
"type '%s' will be coerced too. Check DETAILS in ?melt.data.table for more on "
"coercion.\n"
msgstr ""
"las 'measure.vars' [%s] no son todas del mismo tipo. Por orden de jerarquía, "
"la columna de valores de datos \"fundida\" será del tipo '%s'. Todas las "
"variables de medida que no sean del tipo '%s' también serán coercionadas. "
"Consulte los detalles en ?melt.data.table para obtener más información sobre "
"la coerción.\n"

msgid "Unknown column type '%s' for column '%s'."
msgstr "Tipo de columna desconocida '%s' para la columna '%s'."

msgid "Internal error: fmelt.c:getvarcols %d %d"
msgstr "Error interno <fmelt.c>: getvarcols %d %d"

msgid "variable_table does not support column type '%s' for column '%s'."
msgstr "variable_table no admite el tipo de columna '%s' para la columna '%s'."

msgid "Unknown column type '%s' for column '%s' in 'data'"
msgstr "Tipo de columna desconocido '%s' para la columna '%s' en 'data'"

msgid "Input is not of type VECSXP, expected a data.table, data.frame or list"
msgstr ""
"La entrada no es del tipo VECSXP, se esperaba una data.table, un data.frame "
"o una lista"

msgid "Argument 'value.factor' should be logical TRUE/FALSE"
msgstr "El argumento 'value.factor' debe ser lógico TRUE/FALSE"

msgid "Argument 'variable.factor' should be logical TRUE/FALSE"
msgstr "El argumento 'variable.factor' debe ser lógico TRUE/FALSE"

msgid "Argument 'na.rm' should be logical TRUE/FALSE."
msgstr "El argumento 'na.rm' debe ser lógico TRUE/FALSE."

msgid "Argument 'variable.name' must be a character vector"
msgstr "El argumento 'variable.name' debe ser un vector de caracteres"

msgid "Argument 'value.name' must be a character vector"
msgstr "El argumento 'value.name' debe ser un vector de caracteres"

msgid "Argument 'verbose' should be logical TRUE/FALSE"
msgstr "El argumento 'verbose' debe ser lógico TRUE/FALSE"

msgid "ncol(data) is 0. Nothing to melt. Returning original data.table."
msgstr ""
"ncol(data) es 0. Nada que \"fundir\". Devolviendo la data.table original."

msgid "names(data) is NULL. Please report to data.table-help"
msgstr "nombres(datos) es NULL. Por favor informe a data.table-help"

msgid "Failed to realloc thread private group size buffer to %d*4bytes"
msgstr ""
"No se pudo reasignar el búfer del tamaño del grupo privado del hilo de "
"ejecución a %d*4bytes"

msgid "Failed to realloc group size result to %d*4bytes"
msgstr "No se pudo reasignar el resultado del tamaño del grupo a %d*4bytes"

msgid ""
"Logical error. counts[0]=%d in cradix but should have been decremented to 0. "
"radix=%d"
msgstr ""
"Error lógico. counts[0]=%d en cradix pero debería haberse reducido a 0. "
"radix=%d"

msgid "Failed to alloc cradix_counts"
msgstr "No se pudo asignar cradix_counts"

msgid "Failed to alloc cradix_tmp"
msgstr "No se pudo asignar cradix_tmp"

msgid ""
"Internal error: ustr isn't empty when starting range_str: ustr_n=%d, "
"ustr_alloc=%d"
msgstr ""
"Error interno: ustr no está vacío al iniciar range_str: ustr_n=%d, "
"ustr_alloc=%d"

msgid "Internal error: ustr_maxlen isn't 0 when starting range_str"
msgstr "Error interno: ustr_maxlen no es 0 al iniciar range_str"

msgid "Unable to realloc %d * %d bytes in range_str"
msgstr "No se puede reasignar %d * %d bytes en range_str"

msgid "Failed to alloc ustr3 when converting strings to UTF8"
msgstr "No se pudo asignar ustr3 al convertir cadenas a UTF8"

msgid "Failed to alloc tl when converting strings to UTF8"
msgstr "No se pudo asignar tl al convertir cadenas a UTF8"

msgid "Must an integer or numeric vector length 1"
msgstr "Debe ser un vector entero o numérico de longitud 1"

msgid "Must be 2, 1 or 0"
msgstr "Debe ser 2, 1 o 0"

msgid "Unknown non-finite value; not NA, NaN, -Inf or +Inf"
msgstr "Valor desconocido no finito; no NA, NaN, -Inf o +Inf"

msgid ""
"Internal error: input is not either a list of columns, or an atomic vector."
msgstr ""
"Error interno: la entrada no es una lista de columnas ni un vector atómico."

msgid ""
"Internal error: input is an atomic vector (not a list of columns) but by= is "
"not NULL"
msgstr ""
"Error interno: la entrada es un vector atómico (no una lista de columnas) "
"pero by= no es NULL"

msgid ""
"Input is an atomic vector (not a list of columns) but order= is not a length "
"1 integer"
msgstr ""
"La entrada es un vector atómico (no una lista de columnas) pero order= no es "
"un entero de longitud 1"

msgid "forder.c received a vector type '%s' length %d\n"
msgstr "<forder.c>: recibió un tipo de vector '%s' de longitud %d\n"

msgid "forder.c received %d rows and %d columns\n"
msgstr "<forder.c>: recibió %d filas y %d columnas\n"

msgid "Internal error: DT is an empty list() of 0 columns"
msgstr "Error interno: DT es una lista vacía de 0 columnas"

msgid ""
"Internal error: DT has %d columns but 'by' is either not integer or is "
"length 0"
msgstr ""
"Error interno: DT tiene %d columnas pero 'by' no es un número entero o tiene "
"una longitud de 0"

msgid ""
"Either order= is not integer or its length (%d) is different to by='s length "
"(%d)"
msgstr ""
"o bien order= no es un número entero o su longitud (%d) es diferente a la "
"longitud de by= (%d)"

msgid "internal error: 'by' value %d out of range [1,%d]"
msgstr "error interno: valor 'by' %d fuera de rango [1,%d]"

msgid ""
"Column %d is length %d which differs from length of column 1 (%d), are you "
"attempting to order by a list column?\n"
msgstr ""
"La columna %d tiene una longitud %d que difiere de la longitud de la columna "
"1 (%d). ¿Está intentando ordenarla por una columna de lista?\n"

msgid "At least one of retGrp= or sort= must be TRUE"
msgstr "Al menos uno de retGrp= o sort= debe ser TRUE"

msgid "na.last must be logical TRUE, FALSE or NA of length 1"
msgstr "na.last debe ser lógico TRUE, FALSE o NA de longitud 1"

msgid "Unable to allocate %<PRIu64> bytes of working memory"
msgstr "No se pueden asignar %<PRIu64> bytes de memoria de trabajo"

msgid "Item %d of order (ascending/descending) is %d. Must be +1 or -1."
msgstr ""
"El elemento %d del orden (ascendente/descendente) es %d. Debe ser +1 o -1."

msgid ""
"\n"
"*** Column %d passed to forder is a date stored as an 8 byte double but no "
"fractions are present. Please consider a 4 byte integer date such as IDate "
"to save space and time.\n"
msgstr ""
"\n"
"*** La columna %d pasada al forder es una fecha almacenada como un double de "
"8 bytes pero no hay fracciones presentes. Considere una fecha entera de 4 "
"bytes como IDate para ahorrar espacio y tiempo.\n"

msgid "Column %d passed to [f]order is type '%s', not yet supported."
msgstr ""
"La columna %d pasada al pedido [f] es del tipo '%s' y aún no se admite."

msgid "Internal error: column not supported, not caught earlier"
msgstr "Error interno: columna no compatible, no detectada antes"

msgid "nradix=%d\n"
msgstr "nradix=%d\n"

msgid ""
"Failed to allocate TMP or UGRP or they weren't cache line aligned: nth=%d"
msgstr ""
"No se pudo asignar TMP o UGRP o no estaban alineadas con la línea de caché: "
"nth=%d"

msgid "Could not allocate (very tiny) group size thread buffers"
msgstr ""
"No se pudieron asignar búferes de hilos de (muy pequeños) tamaño de grupo"

msgid "Timing block %2d%s = %8.3f   %8d\n"
msgstr "Bloque de tiempo %2d%s = %8.3f %8d\n"

msgid "stat[%03d]==%20<PRIu64>\n"
msgstr "stat[%03d]==%20<PRIu64>\n"

msgid "Failed to allocate parallel counts. my_n=%d, nBatch=%d"
msgstr ""
"Fallo al asignar memoria para conteo de lotes en paralelo . my_n=%d, nBatch="
"%d"

msgid "Unable to allocate TMP for my_n=%d items in parallel batch counting"
msgstr ""
"No se puede asignar TMP para my_n=%d elementos en el conteo de lotes en "
"paralelo"

msgid "Internal error: issorted 'by' must be NULL or integer vector"
msgstr "Error interno: el 'by' en issorted debe ser NULL o un vector entero"

msgid "issorted 'by' [%d] out of range [1,%d]"
msgstr "issorted 'by' [%d] fuera de rango [1,%d]"

msgid "is.sorted does not work on list columns"
msgstr "is.sorted no funciona en columnas de lista"

msgid "type '%s' is not yet supported"
msgstr "el tipo '%s' aún no es compatible"

msgid "x must be either NULL or an integer vector"
msgstr "'x' debe ser NULL o un vector entero"

msgid "nrow must be integer vector length 1"
msgstr "nrow debe ser un vector entero de longitud 1"

msgid "nrow==%d but must be >=0"
msgstr "nrow==%d pero debe ser >=0"

msgid "x must be type 'double'"
msgstr "'x' debe ser del tipo 'double'"

msgid "Internal error. Argument '%s' to %s is type '%s' not '%s'"
msgstr "Error interno. El argumento '%s' para %s es del tipo '%s', no '%s'"

msgid "Item %d of 'cols' is %d which is outside 1-based range [1,ncol(x)=%d]"
msgstr ""
"El elemento %d de 'cols' es %d que está fuera del rango basado en 1 [1,"
"ncol(x)=%d]"

msgid ""
"Column %d of input list x is length %d, inconsistent with first column of "
"that item which is length %d."
msgstr ""
"La columna %d de la lista de entrada x tiene una longitud %d, inconsistente "
"con la primera columna de ese elemento que tiene una longitud %d."

msgid "Unsupported column type '%s'"
msgstr "Tipo de columna no admitido '%s'"

msgid ""
"Internal error: invalid ties.method for frankv(), should have been caught "
"before. please report to data.table issue tracker"
msgstr ""
"Error interno: método ties.method no válido para frankv(), debería haberse "
"detectado antes. informe al rastreador de problemas de data.table"

msgid "Internal error: unknown ties value in frank: %d"
msgstr "Error interno: valor de vínculos desconocido en frank(): %d"

msgid ""
"Internal error in line %d of fread.c, please report on data.table GitHub:  "
msgstr ""
"Error interno en la línea %d de <fread.c>, informe en data.table GitHub: "

msgid "System error %lu unmapping view of file\n"
msgstr "Error del sistema %lu al desasignar la vista del archivo\n"

msgid "System errno %d unmapping file: %s\n"
msgstr "Error del sistema %d archivo de desasignación: %s\n"

msgid "Internal error: NUMTYPE(%d) > nLetters(%d)"
msgstr "Error interno: NUMTYPE(%d) > nLetras(%d)"

msgid "Unable to allocate %s of contiguous virtual RAM. %s allocation."
msgstr "No se puede asignar %s de RAM virtual contigua. %s asignación."

msgid "Avoidable %.3f seconds. %s time to copy.\n"
msgstr " %.3f segundos evitables. %s tiempo para copiar.\n"

msgid "  File copy in RAM took %.3f seconds.\n"
msgstr "  La copia del archivo en la RAM tomó %.3f segundos.\n"

msgid ""
"Previous fread() session was not cleaned up properly. Cleaned up ok at the "
"beginning of this fread() call.\n"
msgstr ""
"La sesión anterior de fread() no se limpió correctamente. Se limpió bien al "
"comienzo de esta llamada fread().\n"

msgid "[01] Check arguments\n"
msgstr "[01] Verificar argumentos\n"

msgid "  Using %d threads (omp_get_max_threads()=%d, nth=%d)\n"
msgstr " Usando %d hilos (omp_get_max_threads()=%d, nth=%d)\n"

msgid ""
"Internal error: NAstrings is itself NULL. When empty it should be pointer to "
"NULL."
msgstr ""
"Error interno: NAstrings es en sí mismo NULL. Cuando esté vacío, debería ser "
"un puntero a NULL."

msgid "freadMain: NAstring <<%s>> has whitespace at the beginning or end"
msgstr ""
"freadMain: NAstring <<%s>> tiene espacios en blanco al principio o al final"

msgid ""
"freadMain: NAstring <<%s>> is recognized as type boolean, this is not "
"permitted."
msgstr ""
"freadMain: NAstring <<%s>> se reconoce como tipo booleano, esto no está "
"permitido."

msgid "freadMain: NAstring <<%s>> and logical01=TRUE, this is not permitted."
msgstr "freadMain: NAstring <<%s>> y logic01=TRUE, esto no está permitido."

msgid "  No NAstrings provided.\n"
msgstr " No se proporcionan cadenas NA.\n"

msgid "  NAstrings = ["
msgstr " NAstrings = ["

msgid "]\n"
msgstr "]\n"

msgid "  One or more of the NAstrings looks like a number.\n"
msgstr " Una o más de las NAstrings parecen un número.\n"

msgid "  None of the NAstrings look like numbers.\n"
msgstr " Ninguna de las cadenas NA parece números.\n"

msgid "  skip num lines = %<PRId64>\n"
msgstr " saltar núm líneas = %<PRId64>\n"

msgid "  skip to string = <<%s>>\n"
msgstr " saltar a cadena = <<%s>>\n"

msgid "  show progress = %d\n"
msgstr " mostrar progreso = %d\n"

msgid "  0/1 column will be read as %s\n"
msgstr " 0/1 columna se leerá como %s\n"

msgid "sep == quote ('%c') is not allowed"
msgstr "sep == quote ('%c') no está permitido"

msgid "sep == dec ('%c') is not allowed"
msgstr "sep == dec ('%c') no está permitido"

msgid "quote == dec ('%c') is not allowed"
msgstr "quote == dec ('%c') no está permitido"

msgid "[02] Opening the file\n"
msgstr "[02] Abriendo el archivo\n"

msgid ""
"  `input` argument is provided rather than a file name, interpreting as raw "
"text to read\n"
msgstr ""
" Se proporciona el argumento `input` en lugar de un nombre de archivo, "
"interpretándose como texto sin formato para leer\n"

msgid "Internal error: last byte of character input isn't \\0"
msgstr "Error interno: el último byte de la entrada de caracteres no es \\0"

msgid "  Opening file %s\n"
msgstr " Abriendo archivo %s\n"

msgid "File not found: %s"
msgstr "Archivo no encontrado: %s"

msgid "Opened file ok but couldn't obtain its size: %s"
msgstr "Archivo abierto correctamente pero no se pudo obtener su tamaño: %s"

msgid "File is empty: %s"
msgstr "El archivo está vacío: %s"

msgid "  File opened, size = %s.\n"
msgstr " Archivo abierto, tamaño = %s.\n"

msgid "Unable to open file after %d attempts (error %lu): %s"
msgstr "No se puede abrir el archivo después de %d intentos (error %lu): %s"

msgid "GetFileSizeEx failed (returned 0) on file: %s"
msgstr "GetFileSizeEx falló (devolvió 0) en el archivo: %s"

msgid "This is Windows, CreateFileMapping returned error %lu for file %s"
msgstr ""
"Esto es Windows, CreateFileMapping devolvió el error %lu para el archivo %s"

msgid ""
"Opened %s file ok but could not memory map it. This is a %dbit process. %s."
msgstr ""
"Abierto el archivo %s correctamente pero no fue posible mapearlo en memoria. "
"Este es un proceso de %dbit. %s."

msgid "Please upgrade to 64bit"
msgstr "Actualice a 64 bits"

msgid "There is probably not enough contiguous virtual memory available"
msgstr "Probablemente no haya suficiente memoria virtual contigua disponible"

msgid "  Memory mapped ok\n"
msgstr " Memoria asignada correctamente\n"

msgid ""
"Internal error: Neither `input` nor `filename` are given, nothing to read."
msgstr ""
"Error interno: no se proporcionan ni `input` ni `filename`, no hay nada que "
"leer."

msgid "[03] Detect and skip BOM\n"
msgstr "[03] Detectar y omitir BOM (marca de orden de bytes)\n"

msgid ""
"  UTF-8 byte order mark EF BB BF found at the start of the file and skipped."
"\n"
msgstr ""
" Marca de orden de bytes UTF-8 EF BB BF encontrada al inicio del archivo y "
"omitida.\n"

msgid ""
"GB-18030 encoding detected, however fread() is unable to decode it. Some "
"character fields may be garbled.\n"
msgstr ""
"Se detectó la codificación GB-18030, sin embargo, fread() no puede "
"decodificarla. Es posible que algunos campos de caracteres estén confusos.\n"

msgid ""
"File is encoded in UTF-16, this encoding is not supported by fread(). Please "
"recode the file to UTF-8."
msgstr ""
"El archivo está codificado en UTF-16, esta codificación no es compatible con "
"fread(). Vuelva a codificar el archivo en UTF-8."

msgid "  Last byte(s) of input found to be %s and removed.\n"
msgstr " Los últimos bytes de entrada encontrados son %s y eliminados.\n"

msgid "Input is empty or only contains BOM or terminal control characters"
msgstr ""
"La entrada está vacía o solo contiene la lista de materiales o caracteres de "
"control del terminal"

msgid "[04] Arrange mmap to be \\0 terminated\n"
msgstr "[04] Organizar mmap para ser terminado en \\0 \n"

msgid ""
"  No \\n exists in the file at all, so single \\r (if any) will be taken as "
"one line ending. This is unusual but will happen normally when there is no "
"\\r either; e.g. a single line missing its end of line.\n"
msgstr ""
" No existe ningún \\n en el archivo, por lo que un único \\r (si lo hay) se "
"tomará como final de línea. Esto es inusual pero sucederá normalmente cuando "
"tampoco hay \\r; p.ej. si hay una sola línea a la que le falta el fin de "
"línea.\n"

msgid ""
"  \\n has been found in the input and different lines can end with different "
"line endings (e.g. mixed \\n and \\r\\n in one file). This is common and "
"ideal.\n"
msgstr ""
"se ha encontrado  \\n en la entrada y diferentes líneas pueden terminar con "
"diferentes finales de línea (por ejemplo, \\n y \\r\\n mezclados en un "
"archivo). Esto es común e ideal.\n"

msgid ""
"  File ends abruptly with '%c'. Final end-of-line is missing. Using cow page "
"to write 0 to the last byte.\n"
msgstr ""
" El archivo termina abruptamente con '%c'. Falta el último fin de línea. "
"Usando página COW  para escribir 0 en el último byte.\n"

msgid ""
"This file is very unusual: it ends abruptly without a final newline, and "
"also its size is a multiple of 4096 bytes. Please properly end the last row "
"with a newline using for example 'echo >> file' to avoid this "
msgstr ""
"Este archivo es muy inusual: termina abruptamente sin una nueva línea final, "
"y además su tamaño es múltiplo de 4096 bytes. Termine correctamente la "
"última fila con una nueva línea usando, por ejemplo, 'echo >> file' para "
"evitarlo. "

msgid "  File ends abruptly with '%c'. Copying file in RAM. %s copy.\n"
msgstr ""
" El archivo termina abruptamente con '%c'. Copiando archivo en RAM. %s (esta "
"copia).\n"

msgid "[05] Skipping initial rows if needed\n"
msgstr "[05] Saltando filas iniciales si es necesario\n"

msgid ""
"skip='%s' not found in input (it is case sensitive and literal; i.e., no "
"patterns, wildcards or regex)"
msgstr ""
"skip='%s' no se encuentra en la entrada (tenga en cuenta que distingue entre "
"mayúsculas y minúsculas y es literal; es decir, no hay patrones, comodines "
"ni expresiones regulares)"

msgid ""
"Found skip='%s' on line %<PRIu64>. Taking this to be header row or first row "
"of data.\n"
msgstr ""
"Encontrado skip='%s' en la línea %<PRIu64>. Tomando esto como fila de "
"encabezado o primera fila de datos.\n"

msgid "  Skipped to line %<PRIu64> in the file"
msgstr " Saltó a la línea %<PRIu64> en el archivo"

msgid "skip=%<PRIu64> but the input only has %<PRIu64> line%s"
msgstr "skip=%<PRIu64> pero la entrada solo tiene %<PRIu64> línea%s"

msgid ""
"Input is either empty, fully whitespace, or skip has been set after the last "
"non-whitespace."
msgstr ""
"La entrada está vacía, completamente con espacios en blanco o se ha omitido "
"después del último espacio que no es en blanco."

msgid "  Moved forward to first non-blank line (%d)\n"
msgstr " Se ha avanzado a la primera línea que no está en blanco (%d)\n"

msgid "  Positioned on line %d starting: <<%s>>\n"
msgstr " Posicionado en la línea %d comenzando en: <<%s>>\n"

msgid "[06] Detect separator, quoting rule, and ncolumns\n"
msgstr ""
"[06] Detectar separador, regla de entrecomillado y número de columnas\n"

msgid ""
"  sep='\\n' passed in meaning read lines as single character column\n"
msgstr ""
" pasar sep='\n"
"' significa leer líneas como una sola columna de tipo carácter\n"

msgid "  Detecting sep automatically ...\n"
msgstr " Detectando 'sep' automáticamente...\n"

msgid "  Using supplied sep '%s'\n"
msgstr " Usando el 'sep' suministrado '%s'\n"

msgid "  with %d fields using quote rule %d\n"
msgstr " con %d campos usando la regla de entrecomillado %d\n"

msgid "  with %d lines of %d fields using quote rule %d\n"
msgstr " con %d líneas de %d campos usando la regla de entrecomillado %d\n"

msgid ""
"  No sep and quote rule found a block of 2x2 or greater. Single column input."
"\n"
msgstr ""
" Ninguna regla de separación y entrecomillado encontró un bloque de 2x2 o "
"mayor. Entrada de una sola columna.\n"

msgid ""
"Single column input contains invalid quotes. Self healing only effective "
"when ncol>1"
msgstr ""
"La entrada de una sola columna contiene comillas no válidas. La "
"autorreparación sólo es efectiva cuando ncol>1"

msgid ""
"Found and resolved improper quoting in first %d rows. If the fields are not "
"quoted (e.g. field separator does not appear within any field), try quote=\""
"\" to avoid this warning."
msgstr ""
"Se encontraron y resolvieron comillas incorrectas en las primeras %d filas. "
"Si los campos no están entrecomillados (por ejemplo, el separador de campos "
"no aparece dentro de ningún campo), intente quote=\"\" para evitar esta "
"advertencia."

msgid ""
"Internal error: ncol==%d line==%d after detecting sep, ncol and first line"
msgstr ""
"Error interno: ncol==%d línea==%d después de detectar sep, ncol y primera "
"línea"

msgid "Internal error: first line has field count %d but expecting %d"
msgstr ""
"Error interno: la primera línea tiene un recuento de campos %d pero se "
"espera %d"

msgid ""
"  Detected %d columns on line %d. This line is either column names or first "
"data row. Line starts as: <<%s>>\n"
msgstr ""
" Se detectaron %d columnas en la línea %d. Esta línea son nombres de "
"columnas o la primera fila de datos. La línea comienza como: <<%s>>\n"

msgid "  Quote rule picked = %d\n"
msgstr " Regla de entrecomillado elegida = %d\n"

msgid "  fill=%s and the most number of columns found is %d\n"
msgstr " fill=%s y el mayor número de columnas encontradas es %d\n"

msgid ""
"This file is very unusual: it's one single column, ends with 2 or more end-"
"of-line (representing several NA at the end), and is a multiple of 4096, too."
msgstr ""
"Este archivo es muy inusual: es una sola columna, termina con 2 o más "
"finales de línea (que representan varios NA al final) y también es un "
"múltiplo de 4096."

msgid "  Copying file in RAM. %s\n"
msgstr " Copiando archivo en RAM. %s\n"

msgid ""
"  1-column file ends with 2 or more end-of-line. Restoring last eol using "
"extra byte in cow page.\n"
msgstr ""
" El archivo de 1 columna termina con 2 o más finales de línea. Restaurando "
"el último eol usando un byte adicional en la página de vaca.\n"

msgid ""
"[07] Detect column types, dec, good nrow estimate and whether first row is "
"column names\n"
msgstr ""
"[07] Detecta tipos de columnas, dec, buena estimación de nrow y si la "
"primera fila son nombres de columnas\n"

msgid "  'header' changed by user from 'auto' to %s\n"
msgstr " 'header' cambiado por el usuario de 'auto' a %s\n"

msgid "Failed to allocate 2 x %d bytes for type and tmpType: %s"
msgstr "No se pudieron asignar 2 x %d bytes para tipo y tmpType: %s"

msgid "  sep=',' so dec set to '.'\n"
msgstr " sep=',' por lo que dec se establece en '.'\n"

msgid "  Number of sampling jump points = %d because "
msgstr " Número de puntos de salto de muestreo = %d porque "

msgid "nrow limit (%<PRIu64>) supplied\n"
msgstr "límite de nrow (%<PRIu64>) proporcionado\n"

msgid "jump0size==0\n"
msgstr "saltar0tamaño==0\n"

msgid ""
"(%<PRIu64> bytes from row 1 to eof) / (2 * %<PRIu64> jump0size) == "
"%<PRIu64>\n"
msgstr ""
"(%<PRIu64> bytes de la fila 1 al eof) / (2 * %<PRIu64> jump0size) == "
"%<PRIu64>\n"

msgid ""
"  A line with too-%s fields (%d/%d) was found on line %d of sample jump %d. "
"%s\n"
msgstr ""
" Se encontró una línea con %s campos (%d/%d) en la línea %d del salto de "
"muestra %d. %s\n"

msgid "few"
msgstr "pocos"

msgid "many"
msgstr "muchos"

msgid ""
"Most likely this jump landed awkwardly so type bumps here will be skipped."
msgstr ""
"Lo más probable es que este salto haya aterrizado de manera extraña, por lo "
"que se omitirán los golpes de tipo aquí."

msgid "  dec='%c' detected based on a balance of %d parsed fields\n"
msgstr " dec='%c' detectado en función de un balance de %d campos analizados\n"

msgid "  Type codes (jump %03d)    : %s  Quote rule %d\n"
msgstr " Códigos de tipo (salto %03d): %s Regla de entrecomillado %d\n"

msgid ""
"  'header' determined to be true due to column %d containing a string on row "
"1 and a lower type (%s) in the rest of the %<PRId64> sample rows\n"
msgstr ""
"  'header' se determinó como verdadero debido a que la columna %d contiene "
"una cadena en la fila 1 y un tipo inferior (%s) en el resto de las "
"%<PRId64>filas de muestra  \n"

msgid ""
"Internal error: row before first data row has the same number of fields but "
"we're not using it."
msgstr ""
"Error interno: la fila anterior a la primera fila de datos tiene la misma "
"cantidad de campos pero no la estamos usando."

msgid ""
"Internal error: ch!=pos after counting fields in the line before the first "
"data row."
msgstr ""
"Error interno: ch!=pos después de contar los campos en la línea anterior a "
"la primera fila de datos."

msgid ""
"Types in 1st data row match types in 2nd data row but previous row has %d "
"fields. Taking previous row as column names."
msgstr ""
"Los tipos en la primera fila de datos coinciden con los tipos en la segunda "
"fila de datos, pero la fila anterior tiene %d campos. Tomando la fila "
"anterior como nombres de columna."

msgid ""
"Detected %d column names but the data has %d columns (i.e. invalid file). "
"Added %d extra default column name%s\n"
msgstr ""
"Se detectaron %d nombres de columnas pero los datos tienen %d columnas (es "
"decir, un archivo no válido). Se agrega/n %d nombre(s) predeterminado(s) "
"adicional/es de columna%s\n"

msgid ""
" for the first column which is guessed to be row names or an index. Use "
"setnames() afterwards if this guess is not correct, or fix the file write "
"command that created the file to create a valid file."
msgstr ""
" para la primera columna que se supone que son nombres de filas o un índice. "
"Utilice setnames() después si esta suposición no es correcta, o corrija el "
"comando de escritura de archivo que creó el archivo para crear un archivo "
"válido."

msgid "s at the end."
msgstr "s al final."

msgid ""
"Internal error: fill=true but there is a previous row which should already "
"have been filled."
msgstr ""
"Error interno: fill=true pero hay una fila anterior que ya debería haber "
"sido completada."

msgid ""
"Detected %d column names but the data has %d columns. Filling rows "
"automatically. Set fill=TRUE explicitly to avoid this warning.\n"
msgstr ""
"Se detectaron %d nombres de columnas pero los datos tienen %d columnas. "
"Llenando filas automáticamente. Establezca fill=TRUE explícitamente para "
"evitar esta advertencia.\n"

msgid "Failed to realloc 2 x %d bytes for type and tmpType: %s"
msgstr "Error al reasignar 2 x %d bytes para tipo y tmpType: %s"

msgid ""
"  'header' determined to be %s because there are%s number fields in the "
"first and only row\n"
msgstr ""
" 'header' determinado como %s porque hay %s campos numéricos en la primera y "
"única fila\n"

msgid " no"
msgstr " no"

msgid ""
"  'header' determined to be true because all columns are type string and a "
"better guess is not possible\n"
msgstr ""
" 'header' se determinó como verdadero porque todas las columnas son de tipo "
"cadena y no es posible realizar una suposición mejor\n"

msgid ""
"  'header' determined to be false because there are some number columns and "
"those columns do not have a string field at the top of them\n"
msgstr ""
" 'header' se determinó que es falso porque hay algunas columnas numéricas y "
"esas columnas no tienen un campo de cadena en la parte superior\n"

msgid "  Type codes (first row)   : %s  Quote rule %d\n"
msgstr " Códigos de tipo (primera fila): %s Regla de entrecomillado %d\n"

msgid ""
"  All rows were sampled since file is small so we know nrow=%<PRIu64> "
"exactly\n"
msgstr ""
" Se tomaron muestras de todas las filas ya que el archivo es pequeño, por lo "
"que sabemos exactamente nrow=%<PRIu64>\n"

msgid "  =====\n"
msgstr " =====\n"

msgid ""
"  Sampled %<PRIu64> rows (handled \\n inside quoted fields) at %d jump "
"points\n"
msgstr ""
" %<PRIu64> filas muestreadas (manejadas \\n dentro de los campos entre "
"comillas) en %d puntos de salto\n"

msgid ""
"  Bytes from first data row on line %d to the end of last row: %<PRIu64>\n"
msgstr ""
" Bytes desde la primera fila de datos en la línea %d hasta el final de la "
"última fila: %<PRIu64>\n"

msgid "  Line length: mean=%.2f sd=%.2f min=%d max=%d\n"
msgstr " Longitud de línea: media=%.2f sd=%.2f min=%d max=%d\n"

msgid "  Estimated number of rows: %<PRIu64> / %.2f = %<PRIu64>\n"
msgstr " Número estimado de filas: %<PRIu64> / %.2f = %<PRIu64>\n"

msgid ""
"  Initial alloc = %<PRIu64> rows (%<PRIu64> + %d%%) using bytes/max(mean-"
"2*sd,min) clamped between [1.1*estn, 2.0*estn]\n"
msgstr ""
" Asignación inicial = %<PRIu64> filas (%<PRIu64> + %d%%) usando bytes/"
"max(mean-2*sd,min) sujetos entre [1.1*estn, 2.0*estn]\n"

msgid "Internal error: sampleLines(%<PRIu64>) > allocnrow(%<PRIu64>)"
msgstr "Error interno: sampleLines(%<PRIu64>) > allocnrow(%<PRIu64>)"

msgid "  Alloc limited to lower nrows=%<PRIu64> passed in.\n"
msgstr " Alloc limitado a nrows=%<PRIu64> inferior pasado.\n"

msgid "[08] Assign column names\n"
msgstr "[08] Asignando nombres de columnas\n"

msgid "Unable to allocate %d*%d bytes for column name pointers: %s"
msgstr ""
"No se pueden asignar %d*%d bytes para los punteros de nombre de columna: %s"

msgid "Internal error: reading colnames ending on '%c'"
msgstr "Error interno: leyendo nombres de columnas que terminan en '%c'"

msgid "[09] Apply user overrides on column types\n"
msgstr ""
"[09] Aplicando sobreescritura de tipos de columnas provisto por el usuario\n"

msgid "  Cancelled by user: userOverride() returned false."
msgstr " Cancelado por el usuario: userOverride() devolvió false."

msgid "Failed to allocate %d bytes for size array: %s"
msgstr "Error al asignar %d bytes para la matriz de tamaño: %s"

msgid ""
"Attempt to override column %d%s%.*s%s of inherent type '%s' down to '%s' "
"ignored. Only overrides to a higher type are currently supported. If this "
"was intended, please coerce to the lower type afterwards."
msgstr ""
"Se ignora el intento de sobreescribir tipo de columna %d%s%.*s%s del tipo "
"inherente '%s' a '%s'. Actualmente solo se admiten reemplazos a un tipo "
"superior. Si esto era lo que pretendía, coercione al tipo inferior después."

msgid "  After %d type and %d drop user overrides : %s\n"
msgstr " Después de %d tipo y %d eliminar sobreescrituras de usuario: %s\n"

msgid "[10] Allocate memory for the datatable\n"
msgstr "[10] Asignar memoria para la data.table\n"

msgid "  Allocating %d column slots (%d - %d dropped) with %<PRIu64> rows\n"
msgstr ""
" Asignando %d espacios de columna (%d - %d eliminados) con %<PRIu64> filas\n"

msgid "Buffer size %<PRId64> is too large\n"
msgstr "El tamaño del búfer %<PRId64> es demasiado grande\n"

msgid "[11] Read the data\n"
msgstr "[11] Leer los datos\n"

msgid "  jumps=[%d..%d), chunk_size=%<PRIu64>, total_size=%<PRIu64>\n"
msgstr " jumps=[%d..%d), chunk_size=%<PRIu64>, total_size=%<PRIu64>\n"

msgid "Internal error: Master thread is not thread 0 but thread %d.\n"
msgstr "Error interno: el hilo maestro no es el hilo 0 sino el hilo %d.\n"

msgid ""
"Column %d%s%.*s%s bumped from '%s' to '%s' due to <<%.*s>> on row %<PRIu64>\n"
msgstr ""
"La columna %d%s%.*s%s pasó de '%s' a '%s' debido a <<%.*s>> en la fila "
"%<PRIu64>\n"

msgid ""
"Internal error: invalid head position. jump=%d, headPos=%p, thisJumpStart="
"%p, sof=%p"
msgstr ""
"Error interno: posición de head no válida. jump=%d, headPos=%p, "
"thisJumpStart=%p, sof=%p"

msgid "  Provided number of fill columns: %d but only found %d\n"
msgstr ""
" Número proporcionado de columnas de relleno: %d pero solo se encontró %d\n"

msgid "  Dropping %d overallocated columns\n"
msgstr " Descartando %d columnas sobreasignadas\n"

msgid ""
"  Too few rows allocated. Allocating additional %<PRIu64> rows (now nrows="
"%<PRIu64>) and continue reading from jump %d\n"
msgstr ""
" Muy pocas filas asignadas en memoria. Asignar %<PRIu64> filas adicionales "
"(ahora nrows=%<PRIu64>) y continuar leyendo desde el salto %d\n"

msgid "  Restarting team from jump %d. nSwept==%d quoteRule==%d\n"
msgstr " Reiniciando desde el salto %d. nSwept==%d quoteRule==%d\n"

msgid "  %d out-of-sample type bumps: %s\n"
msgstr " %d aumentos de tipo fuera de muestra: %s\n"

msgid ""
"Read %<PRIu64> rows x %d columns from %s file in %02d:%06.3f wall clock "
"time\n"
msgstr ""
"Leer %<PRIu64> filas x %d columnas del archivo %s en %02d:%06.3f tiempo "
"actual\n"

msgid "[12] Finalizing the datatable\n"
msgstr "[12] Finalizando la data.table\n"

msgid "  Type counts:\n"
msgstr " El tipo cuenta:\n"

msgid "%10d : %-9s '%c'\n"
msgstr "%10d : %-9s '%c'\n"

msgid "Discarded single-line footer: <<%s>>"
msgstr "Pie de página de una sola línea descartado: <<%s>>"

msgid ""
"Stopped early on line %<PRIu64>. Expected %d fields but found %d. Consider "
"fill=%d or even more based on your knowledge of the input file. First "
"discarded non-empty line: <<%s>>"
msgstr ""
" Se detuvo antes en la línea %<PRIu64>. Se esperaban %d campos pero se "
"encontraron %d. Considera fill=%d o incluso más en función de tu "
"conocimiento del archivo de entrada. Primera línea no vacía descartada: <<"
"%s>>"

msgid ""
"Stopped early on line %<PRIu64>. Expected %d fields but found %d. Consider "
"fill=TRUE and comment.char=. First discarded non-empty line: <<%s>>"
msgstr ""
"Se detuvo anticipadamente en la línea %<PRIu64>. Se esperaban %d campos pero "
"se encontraron %d. Considere fill=TRUE y comment.char=. Primera línea no "
"vacía descartada: <<%s>>"

msgid ""
"Found and resolved improper quoting out-of-sample. First healed line "
"%<PRIu64>: <<%s>>. If the fields are not quoted (e.g. field separator does "
"not appear within any field), try quote=\"\" to avoid this warning."
msgstr ""
"Se encontraron y resolvieron comillas inadecuadas fuera de la muestra. "
"Primera línea saneada %<PRIu64>: <<%s>>. Si los campos no están "
"entrecomillados (por ejemplo, el separador de campos no aparece dentro de "
"ningún campo), intente quote=\"\" para evitar esta advertencia."

msgid "=============================\n"
msgstr "==============================\n"

msgid "%8.3fs (%3.0f%%) Memory map %.3fGB file\n"
msgstr "%8.3fs (%3.0f%%) Archivo de mapa de memoria de %.3fGB\n"

msgid "%8.3fs (%3.0f%%) sep="
msgstr "%8.3fs (%3.0f%%) sep="

msgid " ncol=%d and header detection\n"
msgstr " ncol=%dy detección de encabezado\n"

msgid "%8.3fs (%3.0f%%) Column type detection using %<PRIu64> sample rows\n"
msgstr ""
"%8.3fs (%3.0f%%) Detección de tipo de columna usando %<PRIu64> filas de "
"muestra\n"

msgid ""
"%8.3fs (%3.0f%%) Allocation of %<PRIu64> rows x %d cols (%.3fGB) of which "
"%<PRIu64> (%3.0f%%) rows used\n"
msgstr ""
"%8.3fs (%3.0f%%) Asignación de %<PRIu64> filas x %d columnas (%.3fGB) de las "
"cuales se utilizan %<PRIu64> (%3.0f%%) filas\n"

msgid ""
"%8.3fs (%3.0f%%) Reading %d chunks (%d swept) of %.3fMB (each chunk %d rows) "
"using %d threads\n"
msgstr ""
"%8.3fs (%3.0f%%) Leyendo %d fragmentos (%d barridos) de %.3fMB (cada "
"fragmento %d filas) usando %d hilos\n"

msgid ""
"   + %8.3fs (%3.0f%%) Parse to row-major thread buffers (grown %d times)\n"
msgstr ""
" + %8.3fs (%3.0f%%) Parsear a búferes de hilo por fila principal (aumentados "
"%d veces)\n"

msgid "   + %8.3fs (%3.0f%%) Transpose\n"
msgstr " + %8.3fs (%3.0f%%) Transponer\n"

msgid "   + %8.3fs (%3.0f%%) Waiting\n"
msgstr " + %8.3fs (%3.0f%%) Esperando\n"

msgid ""
"%8.3fs (%3.0f%%) Rereading %d columns due to out-of-sample type exceptions\n"
msgstr ""
"%8.3fs (%3.0f%%) Releyendo %d columnas debido a excepciones de tipo fuera de "
"muestra\n"

msgid "%8.3fs        Total\n"
msgstr "%8.3fsTotal\n"

msgid ""
"Internal error: freadR input not a single character string: a filename or "
"the data itself. Should have been caught at R level."
msgstr ""
"Error interno: freadR no introdujo ni una sola cadena de caracteres: un "
"nombre de archivo o los datos en sí. Debería haber sido interceptado en el "
"nivel R."

msgid "Internal error: freadR isFileNameArg not TRUE or FALSE"
msgstr "Error interno: freadR isFileNameArg no es TRUE o FALSE"

msgid "freadR.c has been passed a filename: %s\n"
msgstr "<freadR.c>: se ha pasado un nombre de archivo: %s\n"

msgid "freadR.c has been passed the data as text input (not a filename)\n"
msgstr ""
"<freadR.c>: se han pasado los datos como entrada de texto (no como nombre de "
"archivo)\n"

msgid ""
"Internal error: freadR sep not a single character. R level catches this."
msgstr ""
"Error interno: freadR no contiene ni un solo carácter. A nivel R se capta "
"esto."

msgid ""
"Internal error: freadR dec not a single character. R level catches this."
msgstr ""
"Error interno: freadR dec no tiene ni un solo carácter. A nivel R se capta "
"esto."

msgid "quote= must be a single character, blank \"\", or FALSE"
msgstr "quote= debe ser un solo carácter, \"\", o FALSE"

msgid "Internal error: freadR nrows not a single real. R level catches this."
msgstr ""
"Error interno: freadR no muestra ni un solo real. A nivel R se capta esto."

msgid "Internal error: skip not integer or string in freadR.c"
msgstr "Error interno <freadR.c>: valor no entero o cadena se pasa por alto"

msgid "Internal error: NAstringsArg is type '%s'. R level catches this"
msgstr "Error interno: NAstringsArg es del tipo '%s'. A nivel R se capta esto"

msgid "nThread(%d)<1"
msgstr "nThread(%d)<1"

msgid "'integer64' must be a single character string"
msgstr "'integer64' debe ser una cadena de un solo carácter"

msgid ""
"Invalid value integer64='%s'. Must be 'integer64', 'character', 'double' or "
"'numeric'"
msgstr ""
"Valor no válido entero64='%s'. Debe ser 'integer64', 'character', 'double' o "
"'^n^u^m^ e^r^i^c'"

msgid "Use either select= or drop= but not both."
msgstr "Utilice select= o drop= pero no ambos."

msgid ""
"select= is type list for specifying types in select=, but colClasses= has "
"been provided as well. Please remove colClasses=."
msgstr ""
"select= es una lista de tipos para especificar tipos en select=, pero "
"también se ha proporcionado colClasses=. Elimine colClasses=."

msgid ""
"select= is type list but has no names; expecting list(type1=cols1, "
"type2=cols2, ...)"
msgstr ""
"select= es una lista de tipos pero no tiene nombres; se esperaba "
"list(tipo1=cols1, tipo2=cols2, ...)"

msgid ""
"select= is a named vector specifying the columns to select and their types, "
"but colClasses= has been provided as well. Please remove colClasses=."
msgstr ""
"select= es un vector con nombre que especifica las columnas a seleccionar y "
"sus tipos, pero también se ha proporcionado colClasses=. Elimine colClasses=."

msgid "colClasses is type list but has no names"
msgstr "colClasses es una lista de tipos pero no tiene nombres"

msgid "encoding='%s' invalid. Must be 'unknown', 'Latin-1' or 'UTF-8'"
msgstr "codificación='%s' no válida. Debe ser 'unknown', 'Latin-1' o 'UTF-8'"

msgid "Column name '%s' (%s) not found"
msgstr "Nombre de columna '%s' (%s) no encontrada"

msgid "%s is NA"
msgstr "%s es NA"

msgid "%s is %d which is out of range [1,ncol=%d]"
msgstr "%s es %d que está fuera de rango [1,ncol=%d]"

msgid "Internal error: typeSize[CT_BOOL8_N] != 1"
msgstr "Error interno: typeSize[CT_BOOL8_N] != 1"

msgid "Internal error: typeSize[CT_STRING] != 1"
msgstr "Error interno: typeSize[CT_STRING] != 1"

msgid ""
"Column name '%s' not found in column name header (case sensitive), skipping."
msgstr ""
"El nombre de columna '%s' no se encuentra en el encabezado de nombres de "
"columna (distingue entre mayúsculas y minúsculas), omitiendo."

msgid ""
"Column number %d (select[%d]) is negative but should be in the range [1,ncol="
"%d]. Consider drop= for column exclusion."
msgstr ""
"El número de columna %d (select[%d]) es negativo pero debe estar en el rango "
"[1,ncol=%d]. Considere drop= para la exclusión de columnas."

msgid ""
"select = 0 (select[%d]) has no meaning. All values of select should be in "
"the range [1,ncol=%d]."
msgstr ""
"select = 0 (select[%d]) no tiene sentido. Todos los valores de select deben "
"estar en el rango [1,ncol=%d]."

msgid ""
"Column number %d (select[%d]) is too large for this table, which only has %d "
"columns."
msgstr ""
"El número de columna %d (select[%d]) es demasiado grande para esta tabla, "
"que solo tiene %d columnas."

msgid "Column number %d ('%s') has been selected twice by select="
msgstr ""
"El número de columna %d ('%s') ha sido seleccionado dos veces por select="

msgid ""
"colClasses= is an unnamed vector of types, length %d, but there are %d "
"columns in the input. To specify types for a subset of columns, you can use "
"a named vector, list format, or specify types using select= instead of "
"colClasses=. Please see examples in ?fread."
msgstr ""
"colClasses= es un vector de tipos sin nombre, longitud %d, pero hay %d "
"columnas en la entrada. Para especificar tipos para un subconjunto de "
"columnas, puede usar un vector con nombre, un formato de lista o especificar "
"tipos usando select= en lugar de colClasses=. Consulte ejemplos en ?fread."

msgid "Internal error: selectInts is NULL but selectColClasses is true"
msgstr "Error interno: selectInts es NULL pero selectColClasses es verdadero"

msgid ""
"Internal error: length(selectSxp)!=length(colClassesSxp) but "
"selectColClasses is true"
msgstr ""
"Error interno: length(selectSxp)!=length(colClassesSxp) pero "
"selectColClasses es verdadero"

msgid "colClasses is type '%s' but should be list or character"
msgstr "colClasses es del tipo '%s' pero debe ser una lista o un carácter"

msgid "Column name '%s' (colClasses[[%d]][%d]) not found"
msgstr "Nombre de columna '%s' (colClasses[[%d]][%d]) no encontrada"

msgid "colClasses[[%d]][%d] is NA"
msgstr "colClasses[[%d]][%d] es NA"

msgid "Column number %d (colClasses[[%d]][%d]) is out of range [1,ncol=%d]"
msgstr ""
"El número de columna %d (colClasses[[%d]][%d]) está fuera de rango [1,ncol="
"%d]"

msgid ""
"Column %d ('%s') appears more than once in colClasses. The second time is "
"colClasses[[%d]][%d]."
msgstr ""
"La columna %d ('%s') aparece más de una vez en colClasses. La segunda vez es "
"colClasses[[%d]][%d]."

msgid "Field size is 1 but the field is of type %d\n"
msgstr "El tamaño del campo es 1 pero el campo es de tipo %d\n"

msgid "Internal error: unexpected field of size %d\n"
msgstr "Error interno: campo inesperado de tamaño %d\n"

msgid "%s"
msgstr "%s"

msgid "%s: window width longer than input vector, returning all NA vector\n"
msgstr ""
"%s: ancho de ventana más largo que el vector de entrada, devolviendo vector "
"de NAs\n"

msgid "%s: align %d, shift answer by %d\n"
msgstr "%s: 'align'=%d, se desplaza respuesta en %d\n"

msgid "%s: processing algo %u took %.3fs\n"
msgstr "%s: procesando algoritmo 'algo'=%u tomó %.3fs\n"

msgid "%s: running for input length %<PRIu64>, window %d, hasna %d, narm %d\n"
msgstr ""
"%s: corriendo para longitud de entrada %<PRIu64>, ventana %d, hasna %d, narm "
"%d\n"

msgid ""
"%s: hasNA=FALSE used but NA (or other non-finite) value(s) are present in "
"input, use default hasNA=NA to avoid this warning"
msgstr ""
"%s: hasNA=FALSE usado pero NA (u otros valores no finitos) están presentes "
"en la entrada, use el valor por defecto 'hasNA'=NA para evitar esta "
"advertencia"

msgid ""
"%s: NA (or other non-finite) value(s) are present in input, re-running with "
"extra care for NAs\n"
msgstr ""
"%s: Los valores NA (u otros no finitos) están presentes en la entrada, "
"volviendo a ejecutar con especial cuidado para los NA\n"

msgid ""
"%s: NA (or other non-finite) value(s) are present in input, skip non-NA "
"attempt and run with extra care for NAs\n"
msgstr ""
"%s: Los valores NA (u otros no finitos) están presentes en la entrada: "
"omitiendo intento sin Nas y ejecutando con especial cuidado para los NA\n"

msgid ""
"%s: running in parallel for input length %<PRIu64>, window %d, hasna %d, "
"narm %d\n"
msgstr ""
"%s: ejecutándose en paralelo para la longitud de entrada %<PRIu64>, ventana "
"%d, hasna %d, narm %d\n"

msgid ""
"%s: NA (or other non-finite) value(s) are present in input, na.rm was FALSE "
"so in 'exact' implementation NAs were handled already, no need to re-run\n"
msgstr ""
"%s: Los valores NA (u otros no finitos) están presentes en la entrada, na.rm "
"era FALSE, por lo que en la implementación 'exact' los NA ya se manejaron, "
"no es necesario volver a ejecutar\n"

msgid "%s: results from provided FUN are not length 1"
msgstr "%s: los resultados de FUN proporcionados no tienen una longitud de 1"

msgid ""
"%s: results from provided FUN are not of type double, coercion from integer "
"or logical will be applied on each iteration\n"
msgstr ""
"%s: los resultados de FUN proporcionados no son de tipo double, se aplicará "
"coerción de entero o lógico en cada iteración\n"

msgid "%s: results from provided FUN are not of type double"
msgstr "%s: los resultados de FUN proporcionados no son de tipo double"

msgid "%s: took %.3fs\n"
msgstr "%s: tomó %.3fs\n"

msgid ""
"x must be of type numeric or logical, or a list, data.frame or data.table of "
"such"
msgstr ""
"'x' debe ser de tipo numérico o lógico, o una lista, data.frame o data.table "
"con esos tipos"

msgid "n must be non 0 length"
msgstr "n debe tener una longitud distinta de 0"

msgid "n must be integer, list is accepted for adaptive TRUE"
msgstr "n debe ser un número entero, se acepta una lista para TRUE adaptativo"

msgid "n must be integer"
msgstr "n debe ser un número entero"

msgid "n must be positive integer values (> 0)"
msgstr "n deben ser valores enteros positivos (> 0)"

msgid "n must be integer vector or list of integer vectors"
msgstr "n debe ser un vector entero o una lista de vectores enteros"

msgid "hasNA must be TRUE, FALSE or NA"
msgstr "hasNA debe ser TRUE, FALSE o NA"

msgid ""
"using hasNA FALSE and na.rm TRUE does not make sense, if you know there are "
"NA values use hasNA TRUE, otherwise leave it as default NA"
msgstr ""
"usar hasNA FALSE y na.rm TRUE no tiene sentido, si sabe que hay valores NA "
"usa hasNA = TRUE, de lo contrario dejelo como NA predeterminado"

msgid ""
"Internal error: invalid %s argument in %s function should have been caught "
"earlier. Please report to the data.table issue tracker."
msgstr ""
"Error interno: el argumento %s no válido en la función %s debería haberse "
"detectado antes. Informe al rastreador de problemas de data.table."

msgid ""
"using adaptive TRUE and align argument different than 'right' is not "
"implemented"
msgstr ""
"el uso de TRUE adaptativo y un argumento de alineación diferente a 'right' "
"no está implementado"

msgid "%s: allocating memory for results %dx%d\n"
msgstr "%s: asignando memoria para resultados %dx%d\n"

msgid ""
"adaptive rolling function can only process 'x' having equal length of "
"elements, like data.table or data.frame; If you want to call rolling "
"function on list having variable length of elements call it for each field "
"separately"
msgstr ""
"la función de ventana adaptativa solo puede procesar 'x' que tenga la misma "
"longitud de elementos, como data.table o data.frame; Si desea llamar a la "
"función de ventana en una lista que tiene elementos de longitud variable, "
"llámela para cada campo por separado"

msgid ""
"length of integer vector(s) provided as list to 'n' argument must be equal "
"to number of observations provided in 'x'"
msgstr ""
"la longitud de los vectores enteros proporcionados como lista para el "
"argumento 'n' debe ser igual al número de observaciones proporcionadas en 'x'"

msgid "fill must be a vector of length 1"
msgstr "'fill' debe ser un vector de longitud 1"

msgid "fill must be numeric or logical"
msgstr "el relleno debe ser numérico o lógico"

msgid "Internal error: badaptive=%d but ik is not integer"
msgstr "Error interno: badaptive=%d pero ik no es un número entero"

msgid ""
"%s: %d column(s) and %d window(s), if product > 1 then entering parallel "
"execution\n"
msgstr ""
"%s: %d columnas y %d ventanas, si producto > 1 entonces se ingresa a "
"ejecución en paralelo\n"

msgid ""
"%s: %d column(s) and %d window(s), not entering parallel execution here "
"because algo='exact' will compute results in parallel\n"
msgstr ""
"%s: %d columnas y %d ventanas, no se ingresa la ejecución en paralelo aquí "
"porque algo='exact' calculará los resultados en paralelo\n"

msgid "Internal error: Unknown sfun value in froll: %d"
msgstr "Error interno: Valor sfun desconocido en froll: %d"

msgid "%s: processing of %d column(s) and %d window(s) took %.3fs\n"
msgstr "%s: el procesamiento de %d columnas y %d ventanas tomó %.3fs\n"

msgid "internal error: 'fun' must be a function"
msgstr "error interno: 'fun' debe ser una función"

msgid "internal error: 'rho' should be an environment"
msgstr "error interno: 'rho' debería ser un entorno"

msgid "%s: running for input length %<PRIu64>, hasna %d, narm %d\n"
msgstr "%s: corriendo para longitud de entrada %<PRIu64>, hasna %d, narm %d\n"

msgid "%s: Unable to allocate memory for cumsum"
msgstr "%s: No se puede asignar memoria para cumsum"

msgid "%s: Unable to allocate memory for cum NA counter"
msgstr "%s: No se puede asignar memoria para el contador de NA cumulativo"

msgid "%s: running in parallel for input length %<PRIu64>, hasna %d, narm %d\n"
msgstr ""
"%s: ejecutándose en paralelo para la longitud de entrada %<PRIu64>, hasna "
"%d, narm %d\n"

msgid "x must be a vector of type double currently"
msgstr "'x' debe ser un vector de tipo double actualmente"

msgid "nth=%d, nBatch=%d\n"
msgstr "nth=%d, nBatch=%d\n"

msgid "Range = [%g,%g]\n"
msgstr "Range = [%g,%g]\n"

msgid "Cannot yet handle negatives."
msgstr "Aún no no se pueden manejar valores negativos."

msgid "maxBit=%d; MSBNbits=%d; shift=%d; MSBsize=%zu\n"
msgstr "maxBit=%d; MSBNbits=%d; shift=%d; Size MSB=%zu\n"

msgid ""
"counts is %dMB (%d pages per nBatch=%d, batchSize=%<PRIu64>, lastBatchSize="
"%<PRIu64>)\n"
msgstr ""
"el recuento es %dMB (%d páginas por nBatch=%d, batchSize=%<PRIu64>, "
"lastBatchSize=%<PRIu64>)\n"

msgid "Internal error: counts[nBatch-1][MSBsize-1] != length(x)"
msgstr "Error interno: counts[nBatch-1][MSBsize-1] != length(x)"

msgid "Top 20 MSB counts: "
msgstr "Los 20 principales recuentos de MSB: "

msgid "%<PRId64> "
msgstr "%<PRId64> "

msgid "\n"
msgstr "\n"

msgid "Reduced MSBsize from %zu to "
msgstr "MSBsize reducido de %zu a "

msgid "%zu by excluding 0 and 1 counts\n"
msgstr "%zu excluyendo los recuentos 0 y 1\n"

msgid ""
"OpenMP %d did not assign threads to iterations monotonically. Please search "
"Stack Overflow for this message."
msgstr ""
"OpenMP %d no asignó hilos a iteraciones de forma monótona. Busque en Stack "
"Overflow para este mensaje."

msgid "Unable to allocate working memory"
msgstr "No se puede asignar memoria de trabajo"

msgid "%d: %.3f (%4.1f%%)\n"
msgstr "%d: %.3f (%4.1f%%)\n"

msgid "buffMB=%d outside [1,1024]"
msgstr "buffMB=%d fuera del rango [1,1024]"

msgid ""
"eol must be 1 or more bytes (usually either \\n or \\r\\n) but is length %d"
msgstr ""
"fin de línea (eol) debe tener 1 o más bytes (normalmente \\n o \\r\\n) pero "
"su longitud es %d"

msgid "Column writers: "
msgstr "Escritores de columnas: "

msgid "%d "
msgstr "%d "

msgid "... "
msgstr "... "

msgid ""
"\n"
"args.doRowNames=%d args.rowNames=%p args.rowNameFun=%d doQuote=%d args.nrow="
"%<PRId64> args.ncol=%d eolLen=%d\n"
msgstr ""
"\n"
"args.doRowNames=%d args.rowNames=%p args.rowNameFun=%d doQuote=%d args.nrow="
"%<PRId64> args.ncol=%d eolLen=%d\n"

msgid "Internal error: type %d has no max length method implemented"
msgstr ""
"Error interno: el tipo %d no tiene implementado ningún método de longitud "
"máxima"

msgid "maxLineLen=%<PRIu64>. Found in %.3fs\n"
msgstr "maxLineLen=%<PRIu64>. Encontrado en %.3fs\n"

msgid ""
"%s: '%s'. Failed to open existing file for writing. Do you have write "
"permission to it? Is this Windows and does another process such as Excel "
"have it open?"
msgstr ""
"%s: '%s'. No se pudo abrir el archivo existente para escribirlo. ¿Tiene "
"permiso de escritura? ¿Está usted en Windows y lo tiene abierto otro proceso "
"como Excel?"

msgid ""
"%s: '%s'. Unable to create new file for writing (it does not exist already). "
"Do you have permission to write here, is there space on the disk and does "
"the path exist?"
msgstr ""
"%s: '%s'. No se puede crear un nuevo archivo para escribir (y no existía "
"previamente). ¿Tiene permiso para escribir aquí, hay espacio en el disco y "
"existe la ruta?"

msgid ""
"Compression in fwrite uses zlib library. Its header files were not found at "
"the time data.table was compiled. To enable fwrite compression, please "
"reinstall data.table and study the output for further guidance."
msgstr ""
"La compresión en fwrite usa la biblioteca zlib. Sus archivos de encabezado "
"no se encontraron en el momento en que se compiló data.table. Para habilitar "
"la compresión fwrite, reinstale data.table y estudie el resultado para "
"obtener más orientación."

msgid "Writing bom (%s), yaml (%d characters) and column names (%s) ... "
msgstr ""
"Escribiendo bom (%s), yaml (%d caracteres) y nombres de columnas (%s)... "

msgid "Unable to allocate %zu MiB for header: %s"
msgstr "No se pueden asignar %zu MiB para el encabezado: %s"

msgid "Can't allocate gzip stream structure"
msgstr "No se puede asignar la estructura de flujo gzip"

msgid "Unable to allocate %zu MiB for zbuffer: %s"
msgstr "No se puede asignar %zu MiB para zbuffer: %s"

msgid "Compress gzip error: %d"
msgstr "Error al comprimir gzip: %d"

msgid "%s: '%s'"
msgstr "%s: '%s'"

msgid "done in %.3fs\n"
msgstr "hecho en %.3fs\n"

msgid "No data rows present (nrow==0)\n"
msgstr "No hay filas de datos presentes (nrow==0)\n"

msgid ""
"Writing %<PRId64> rows in %d batches of %d rows (each buffer size %dMB, "
"showProgress=%d, nth=%d)\n"
msgstr ""
"Escribiendo %<PRId64> filas en %d lotes de %d filas (cada tamaño de búfer "
"%dMB, showProgress=%d, nth=%d)\n"

msgid "zbuffSize=%d returned from deflateBound\n"
msgstr "zbuffSize=%d devuelto desde deflateBound\n"

msgid ""
"Unable to allocate %zu MB * %d thread buffers; '%d: %s'. Please read ?fwrite "
"for nThread, buffMB and verbose options."
msgstr ""
"No se pueden asignar %zu MB * %d búferes de hilos; '%d:%s'. Lea ?fwrite para "
"conocer las opciones nThread, buffMB y detalladas."

msgid ""
"Unable to allocate %zu MB * %d thread compressed buffers; '%d: %s'. Please "
"read ?fwrite for nThread, buffMB and verbose options."
msgstr ""
"No se pueden asignar %zu MB * %d búferes comprimidos de hilos; '%d:%s'. Lea ?"
"fwrite para conocer las opciones nThread, buffMB y detalladas."

msgid ""
"zlib %s (zlib.h %s) deflate() returned error %d with z_stream->msg==\"%s\" "
"Z_FINISH=%d Z_BLOCK=%d. %s"
msgstr ""
"zlib %s (zlib.h %s) deflate() devolvió el error %d con z_stream->msg==\"%s\" "
"Z_FINISH=%d Z_BLOCK=%d. %s"

msgid ""
"Please include the full output above and below this message in your data."
"table bug report."
msgstr ""
" Incluya el resultado completo arriba y debajo de este mensaje en su informe "
"de error de data.table."

msgid ""
"Please retry fwrite() with verbose=TRUE and include the full output with "
"your data.table bug report."
msgstr ""
"Vuelva a intentar fwrite() con verbose=TRUE e incluya el resultado completo "
"con su informe de error de data.table."

msgid "Internal error: col passed to getMaxCategLen is missing levels"
msgstr "Error interno: a la columna pasada a getMaxCategLen le faltan niveles"

msgid "Internal error: getMaxListItemLen should have caught this up front."
msgstr ""
"Error interno: getMaxListItemLen debería haber detectado esto desde el "
"principio."

msgid ""
"Row %<PRId64> of list column is type '%s' - not yet implemented. fwrite() "
"can write list columns containing items which are atomic vectors of type "
"logical, integer, integer64, double, complex and character."
msgstr ""
"La fila %<PRId64> de la columna de la lista es del tipo '%s'; aún no está "
"implementada. fwrite() puede escribir columnas de lista que contengan "
"elementos que sean vectores atómicos de tipo lógico, entero, entero64, "
"doble, complejo y de carácter."

msgid ""
"Internal error: row %<PRId64> of list column has no max length method "
"implemented"
msgstr ""
"Error interno: la fila %<PRId64> de la columna de la lista no tiene "
"implementado ningún método de longitud máxima"

msgid ""
"fwrite must be passed an object of type list; e.g. data.frame, data.table"
msgstr ""
"a fwrite se le debe pasar un objeto de tipo lista; p.ej. data.frame, data."
"table"

msgid "fwrite was passed an empty list of no columns. Nothing to write."
msgstr "a fwrite se le pasó una lista vacía sin columnas. Nada que escribir."

msgid ""
"Column %d's length (%d) is not the same as column 1's length (%<PRId64>)"
msgstr ""
"La longitud de la columna %d (%d) no es la misma que la longitud de la "
"columna 1 (%<PRId64>)"

msgid "Column %d's type is '%s' - not yet implemented in fwrite."
msgstr "El tipo de columna %d es '%s'; aún no se ha implementado en fwrite."

msgid ""
"input has specific integer rownames but their length (%lld) != nrow ("
"%<PRId64>)"
msgstr ""
"la entrada tiene nombres de filas enteros específicos pero su longitud ("
"%lld) != nrow (%<PRId64>)"

msgid ""
"No list columns are present. Setting sep2='' otherwise quote='auto' would "
"quote fields containing sep2.\n"
msgstr ""
"No hay columnas de lista presentes. Se establece sep2='', de lo contrario "
"quote='auto' entrecomillaría los campos que contienen sep2.\n"

msgid ""
"If quote='auto', fields will be quoted if the field contains either sep ("
"'%c') or sep2 ('%c') because column %d is a list column.\n"
msgstr ""
"Si quote='auto', los campos se entrecomillarán si el campo contiene sep ("
"'%c') o sep2 ('%c') porque la columna %d es una columna de lista.\n"

msgid ""
"sep ('%c'), sep2 ('%c') and dec ('%c') must all be different. Column %d is a "
"list column."
msgstr ""
"sep ('%c'), sep2 ('%c') y dec ('%c') deben ser todos diferentes. La columna "
"%d es una columna de lista."

msgid "%s is not an integer vector"
msgstr "%s no es un vector entero"

msgid "irowsArg is neither an integer vector nor NULL"
msgstr "irowsArg no es un vector entero ni NULL"

msgid "length(f)=%d != length(l)=%d"
msgstr "length(f)=%d != length(l)=%d"

msgid "o has length %d but sum(l)=%d"
msgstr "o tiene longitud %d pero sum(l)==%d"

msgid "Internal error: o's maxgrpn attribute mismatches recalculated maxgrpn"
msgstr ""
"Error interno: el atributo maxgrpn de o no coincide con el maxgrpn "
"recalculado"

msgid ""
"Internal error: nrow=%d  ngrp=%d  nbit=%d  bitshift=%d  highSize=%zu  nBatch="
"%zu  batchSize=%zu  lastBatchSize=%zu\n"
msgstr ""
"Error interno: nrow=%d ngrp=%d nbit=%d bitshift=%d highSize=%zu nBatch=%zu "
"loteSize=%zu lastBatchSize=%zu\n"

msgid "gforce initial population of grp took %.3f\n"
msgstr "gforce población inicial de grp tomó %.3f\n"

msgid ""
"Internal error: Failed to allocate counts or TMP when assigning g in gforce"
msgstr ""
"Error interno: No se pudieron asignar recuentos o TMP al asignar g en gforce"

msgid "gforce assign high and low took %.3f\n"
msgstr "asignación gforce high y low tomó %.3f\n"

msgid "gforce eval took %.3f\n"
msgstr "la evaluación de gforce tomó %.3f\n"

msgid "gather took ... "
msgstr "recopilación tomó... "

msgid "gather implemented for INTSXP, REALSXP, and CPLXSXP but not '%s'"
msgstr ""
"recopilación implementada para INTSXP, REALSXP y CPLXSXP pero no para '%s'"

msgid "%.3fs\n"
msgstr "%.3fs\n"

msgid "%s is not meaningful for factors."
msgstr "%s no tiene sentido en factores."

msgid "This gsum (narm=%s) took ... "
msgstr "Este gsum (narm=%s) tomó... "

msgid "nrow [%d] != length(x) [%d] in %s"
msgstr "nrow [%d] != length(x) [%d] en %s"

msgid ""
"The sum of an integer column for a group was more than type 'integer' can "
"hold so the result has been coerced to 'numeric' automatically for "
"convenience."
msgstr ""
"La suma de una columna de enteros para un grupo era mayor de lo que el tipo "
"'integer' puede contener, por lo que el resultado se ha coercionado a "
"'^n^u^m^e^ r^i^c' automáticamente para mayor conveniencia."

msgid ""
"Type '%s' is not supported by GForce %s. Either add the prefix %s or turn "
"off GForce optimization using options(datatable.optimize=1)"
msgstr ""
"El tipo '%s' no es compatible con GForce %s. Agregue el prefijo %s o "
"desactive la optimización de GForce usando options(datatable.optimize=1)"

msgid "This gmean took (narm=%s) ... "
msgstr "Este gmean tomó (narm=%s)... "

msgid "Unable to allocate %d * %zu bytes for non-NA counts in gmean na.rm=TRUE"
msgstr ""
"No se pueden asignar %d * %zu bytes para recuentos que no son de NA en gmean "
"na.rm=TRUE"

msgid ""
"Type '%s' not supported by GForce mean (gmean). Either add the prefix base::"
"mean(.) or turn off GForce optimization using options(datatable.optimize=1)"
msgstr ""
"Tipo '%s' no admitido por función 'mean' de GForce (gmean). Agregue el "
"prefijo base::mean(.) o desactive la optimización de GForce usando "
"options(datatable.optimize=1)"

msgid ""
"GForce min/max can only be applied to columns, not .SD or similar. To find "
"min/max of all items in a list such as .SD, either add the prefix base::min(."
"SD) or turn off GForce optimization using options(datatable.optimize=1). "
"More likely, you may be looking for 'DT[,lapply(.SD,min),by=,.SDcols=]'"
msgstr ""
"GForce min/max solo se puede aplicar a columnas, no a .SD o similares. Para "
"encontrar el mínimo/máximo de todos los elementos en una lista como .SD, "
"agregue el prefijo base::min(.SD) o desactive la optimización de GForce "
"usando opciones (datatable.optimize=1). Lo más probable es que esté buscando "
"'DT[,lapply(.SD,min),by=,.SDcols=]'"

msgid "Type 'complex' has no well-defined min/max"
msgstr "El tipo 'complex' no tiene un mínimo/máximo bien definido"

msgid ""
"GForce median can only be applied to columns, not .SD or similar. To find "
"median of all items in a list such as .SD, either add the prefix stats::"
"median(.SD) or turn off GForce optimization using options(datatable."
"optimize=1). More likely, you may be looking for 'DT[,lapply(.SD,median),"
"by=,.SDcols=]'"
msgstr ""
"La mediana ('median()') de GForce solo se puede aplicar a columnas, no a .SD "
"o similares. Para encontrar la mediana de todos los elementos en una lista "
"como .SD, agregue el prefijo stats::median(.SD) o desactive la optimización "
"de GForce usando options(datatable.optimize=1). Lo más probable es que esté "
"buscando 'DT[,lapply(.SD,median),by=,.SDcols=]'"

msgid "Internal error: gfirstlast headw should only be true when w>1"
msgstr "Error interno: gfirstlast headw solo debe ser verdadero cuando w>1"

msgid "Internal error: unanticipated case in gfirstlast first=%d w=%d headw=%d"
msgstr "Error interno: caso inesperado en gfirstlast first=%d w=%d headw=%d"

msgid ""
"Type '%s' is not supported by GForce head/tail/first/last/`[`. Either add "
"the namespace prefix (e.g. utils::head(.)) or turn off GForce optimization "
"using options(datatable.optimize=1)"
msgstr ""
"El tipo '%s' no es compatible con GForce head/tail/first/last/`[`. Agregue "
"el prefijo del espacio de nombres (por ejemplo, utils::head(.)) o desactive "
"la optimización de GForce usando options(datatable.optimize=1)"

msgid ""
"Internal error, gtail is only implemented for n>0. This should have been "
"caught before. please report to data.table issue tracker."
msgstr ""
"Error interno, gtail solo se implementa para n>0. Esto debería haberse "
"detectado antes. informe al rastreador de problemas de data.table."

msgid ""
"Internal error, `g[` (gnthvalue) is only implemented single value subsets "
"with positive index, e.g., .SD[2]. This should have been caught before. "
"please report to data.table issue tracker."
msgstr ""
"Error interno, `g[` (gnthvalue) solo se implementan subconjuntos de valores "
"únicos con índice positivo, por ejemplo, .SD[2]. Esto debería haberse "
"detectado antes. informe al rastreador de problemas de data.table."

msgid ""
"GForce var/sd can only be applied to columns, not .SD or similar. For the "
"full covariance matrix of all items in a list such as .SD, either add the "
"prefix stats::var(.SD) (or stats::sd(.SD)) or turn off GForce optimization "
"using options(datatable.optimize=1). Alternatively, if you only need the "
"diagonal elements, 'DT[,lapply(.SD,var),by=,.SDcols=]' is the optimized way "
"to do this."
msgstr ""
"GForce var/sd solo se puede aplicar a columnas, no a .SD o similares. Para "
"obtener la matriz de covarianza completa de todos los elementos en una lista "
"como .SD, agregue el prefijo stats::var(.SD) (o stats::sd(.SD)) o desactive "
"la optimización de GForce usando opciones(datatable.optimize =1). "
"Alternativamente, si solo necesita los elementos diagonales, 'DT[,lapply(.SD,"
"var),by=,.SDcols=]' es la forma optimizada de hacerlo."

msgid ""
"GForce prod can only be applied to columns, not .SD or similar. To multiply "
"all items in a list such as .SD, either add the prefix base::prod(.SD) or "
"turn off GForce optimization using options(datatable.optimize=1). More "
"likely, you may be looking for 'DT[,lapply(.SD,prod),by=,.SDcols=]'"
msgstr ""
"GForce prod solo se puede aplicar a columnas, no a .SD o similares. Para "
"multiplicar todos los elementos en una lista como .SD, agregue el prefijo "
"base::prod(.SD) o desactive la optimización de GForce usando "
"options(datatable.optimize=1). Lo más probable es que esté buscando 'DT[,"
"lapply(.SD,prod),by=,.SDcols=]'"

msgid "Unable to allocate %d * %zu bytes for gprod"
msgstr "No se puede asignar %d * %zu bytes para gprod"

msgid "Internal error: nrow [%d] != length(x) [%d] in %s"
msgstr "Error interno: nrow [%d] != length(x) [%d] en %s"

msgid ""
"Internal error: invalid type for gshift(), should have been caught before. "
"please report to data.table issue tracker"
msgstr ""
"Error interno: tipo no válido para gshift(), debería haberse detectado "
"antes. informe al rastreador de problemas de data.table"

msgid "Internal error: n must be integer"
msgstr "Error interno: n debe ser un número entero"

msgid "Item %d of n is NA"
msgstr "El elemento %d de n es NA"

msgid ""
"Type '%s' is not supported by GForce gshift. Either add the namespace prefix "
"(e.g. data.table::shift(.)) or turn off GForce optimization using "
"options(datatable.optimize=1)"
msgstr ""
"El tipo '%s' no es compatible con GForce gshift. Agregue el prefijo del "
"espacio de nombres (por ejemplo, data.table::shift(.)) o desactive la "
"optimización de GForce usando options(datatable.optimize=1)"

msgid "x must be an integer vector"
msgstr "'x' debe ser un vector entero"

msgid ""
"Internal error: invalid type for convertDate(), should have been caught "
"before. please report to data.table issue tracker"
msgstr ""
"Error interno: tipo no válido para convertDate(), debería haberse detectado "
"antes. informe al rastreador de problemas de data.table"

msgid ""
"Internal error: invalid type for convertDate, should have been caught "
"before. please report to data.table issue tracker"
msgstr ""
"Error interno: tipo no válido para convertDate, debería haberse detectado "
"antes. informe al rastreador de problemas de data.table"

msgid ""
"Internal error: invalid value for 'mult'; this should have been caught "
"before. please report to data.table issue tracker"
msgstr ""
"Error interno: valor no válido para 'mult'; esto debería haberse detectado "
"antes. informe al rastreador de problemas de data.table"

msgid ""
"Internal error: invalid value for 'type'; this should have been caught "
"before. please report to data.table issue tracker"
msgstr ""
"Error interno: valor no válido para 'type'; esto debería haberse detectado "
"antes. informe al rastreador de problemas de data.table"

msgid "Internal error: unknown type in mult=%d in lookup: %d"
msgstr "Error interno: tipo desconocido en mult=%d en la búsqueda: %d"

msgid "Internal error: unknown mult in lookup: %d"
msgstr "Error interno: búsqueda múltiple desconocida: %d"

msgid "First pass on calculating lengths in lookup ... done in %8.3f seconds\n"
msgstr ""
"Primera pasada para calcular longitudes en la búsqueda... realizado en %8.3f "
"segundos\n"

msgid "Second pass on allocation in lookup ... done in %8.3f seconds\n"
msgstr ""
"Segunda pasada de asignación en la búsqueda... realizada en %8.3f segundos\n"

msgid "Internal error: unknown type lookup should have been caught earlier: %d"
msgstr ""
"Error interno: la búsqueda de tipo desconocido debería haberse detectado "
"antes: %d"

msgid ""
"Internal error: unknown type in mult=%d in lookup should have been caught "
"earlier: %d"
msgstr ""
"Error interno: el tipo desconocido en mult=%d en la búsqueda debería haberse "
"detectado antes: %d"

msgid "Final step in generating lookup ... done in %8.3f seconds\n"
msgstr "Pasada final para generar la búsqueda... realizado en %8.3f segundos\n"

msgid "Internal error: unknown type in mult=ALL in overlaps: %d"
msgstr "Error interno: tipo desconocido en mult=ALL en superposiciones: %d"

msgid ""
"First pass on calculating lengths in overlaps ... done in %8.3f seconds\n"
msgstr ""
"Primera pasada para calcular longitudes en superposiciones... realizada en "
"%8.3f segundos\n"

msgid "Internal error: unknown type in mult=%d in overlaps: %d"
msgstr "Error interno: tipo desconocido en mult=%d en superposiciones: %d"

msgid "Internal error: unknown mult in overlaps: %d"
msgstr "Error interno: superposiciones múltiples desconocidas: %d"

msgid "Final step, fetching indices in overlaps ... done in %8.3f seconds\n"
msgstr ""
"Paso final, buscar índices en superposiciones... hecho en %8.3f segundos\n"

msgid ""
"Pointers are %zu bytes, greater than 8. We have not tested on any "
"architecture greater than 64bit yet."
msgstr ""
"Los punteros son %zu bytes, mayores que 8. Aún no hemos probado ninguna "
"arquitectura mayor que 64 bits."

msgid "... failed. Please forward this message to maintainer('data.table')."
msgstr "... falló. Envíe este mensaje a: `mantainer('data.table')`."

msgid "Checking NA_INTEGER [%d] == INT_MIN [%d] %s"
msgstr "Comprobando NA_INTEGER [%d] == INT_MIN [%d] %s"

msgid "Checking NA_INTEGER [%d] == NA_LOGICAL [%d] %s"
msgstr "Comprobando NA_INTEGER [%d] == NA_LOGICAL [%d] %s"

msgid "Checking sizeof(%s) [%zu] is %d %s"
msgstr "Comprobando que sizeof(%s) [%zu] es %d %s"

msgid "Checking sizeof(pointer) [%zu] is 4 or 8 %s"
msgstr "Comprobando que sizeof(pointer) [%zu] es 4 u 8 %s"

msgid "Checking sizeof(SEXP) [%zu] == sizeof(pointer) [%zu] %s"
msgstr "Comprobando sizeof(SEXP) [%zu] == sizeof(puntero) [%zu] %s"

msgid "Checking LENGTH(allocVector(INTSXP,2)) [%d] is 2 %s"
msgstr "Comprobando LENGTH(allocVector(INTSXP,2)) [%d] es 2 %s"

msgid "Checking TRUELENGTH(allocVector(INTSXP,2)) [%lld] is 0 %s"
msgstr "Comprobando que TRUELENGTH(allocVector(INTSXP,2)) [%lld] es 0 %s"

msgid "Checking memset(&i,0,sizeof(int)); i == (int)0 %s"
msgstr "Comprobando memset(&i,0,sizeof(int)); i == (int)0 %s"

msgid "Checking memset(&ui, 0, sizeof(unsigned int)); ui == (unsigned int)0 %s"
msgstr ""
"Comprobando memset(&ui, 0, sizeof(unsigned int)); ui == (unsigned int)0 %s"

msgid "Checking memset(&d, 0, sizeof(double)); d == (double)0.0 %s"
msgstr "Comprobando memset(&d, 0, sizeof(double)); d == (doble)0.0 %s"

msgid "Checking memset(&ld, 0, sizeof(long double)); ld == (long double)0.0 %s"
msgstr ""
"Comprobando memset(&ld, 0, sizeof(long double)); ld == (long double)0.0 %s"

msgid "The ascii character '/' is not just before '0'"
msgstr "El carácter ascii '/' no está justo antes del '0'"

msgid "The C expression (uint_fast8_t)('/'-'0')<10 is true. Should be false."
msgstr ""
"La expresión C (uint_fast8_t)('/'-'0')<10 es verdadera. Debería ser falsa."

msgid "The ascii character ':' is not just after '9'"
msgstr "El carácter ascii ':' no está justo después del '9'"

msgid "The C expression (uint_fast8_t)('9'-':')<10 is true. Should be false."
msgstr ""
"La expresión C (uint_fast8_t)('9'-':')<10 es verdadera. Debería ser falsa."

msgid "Conversion of NA_INT64 via double failed %<PRId64>!=%<PRId64>"
msgstr "Conversión de NA_INT64 mediante doble error %<PRId64>!=%<PRId64>"

msgid "NA_INT64_D (negative -0.0) is not == 0.0."
msgstr "NA_INT64_D (negativo -0,0) no es == 0,0."

msgid "NA_INT64_D (negative -0.0) is not ==-0.0."
msgstr "NA_INT64_D (negativo -0.0) no es ==-0.0."

msgid "ISNAN(NA_INT64_D) is TRUE but should not be"
msgstr "ISNAN(NA_INT64_D) es TRUE pero no debería serlo"

msgid "isnan(NA_INT64_D) is TRUE but should not be"
msgstr "isnan(NA_INT64_D) es TRUE pero no debería serlo"

msgid "PRINTNAME(install(\"integer64\")) has returned %s not %s"
msgstr "PRINTNAME(install(\"integer64\")) ha devuelto %s no %s"

msgid "verbose option must be length 1 non-NA logical or integer"
msgstr ""
"la opción detallada debe tener una longitud de 1, lógica o entera no NA"

msgid ".Last.value in namespace is not a length 1 integer"
msgstr ".Last.value en el espacio de nombres no es un entero de longitud 1"

msgid ""
"'x' argument is atomic vector, in-place update is supported only for list/"
"data.table"
msgstr ""
" El argumento 'x' es un vector atómico, la actualización in situ solo se "
"admite para list/data.table"

msgid "'x' argument must be numeric type, or list/data.table of numeric types"
msgstr ""
"'x' argumento debe ser de tipo numérico, o lista/datos.tabla de tipos "
"numéricos"

msgid "fill must be a vector of length 1 or a list of length of x"
msgstr "el relleno debe ser un vector de longitud 1 o una lista de longitud x"

msgid "internal error: 'fill' should be recycled as list already"
msgstr "error interno: 'fill' ya debería reciclarse como lista"

msgid "%s: parallel processing of %d column(s) took %.3fs\n"
msgstr "%s: el procesamiento paralelo de %d columnas tomó %.3fs\n"

msgid ""
"Ignoring invalid %s==\"%s\". Not an integer >= 1. Please remove any "
"characters that are not a digit [0-9]. See ?data.table::setDTthreads."
msgstr ""
"Ignorando %s no válidos==\"%s\". No es un número entero >= 1. Elimine los "
"caracteres que no sean un dígito [0-9]. Consulte ?data.table::setDTthreads."

msgid ""
"Ignoring invalid R_DATATABLE_NUM_PROCS_PERCENT==%d. If used it must be an "
"integer between 2 and 100. Default is 50. See ?setDTtheads."
msgstr ""
"Ignorando R_DATATABLE_NUM_PROCS_PERCENT==%d no válido. Si se utiliza, debe "
"ser un número entero entre 2 y 100. El valor predeterminado es 50. Consulte ?"
"setDTtheads."

msgid ""
"This installation of data.table has not been compiled with OpenMP support.\n"
msgstr ""
"Esta instalación de data.table no ha sido compilada con soporte OpenMP.\n"

msgid "  OpenMP version (_OPENMP)       %d\n"
msgstr " Versión OpenMP (_OPENMP) %d\n"

msgid "  omp_get_num_procs()            %d\n"
msgstr " omp_get_num_procs() %d\n"

msgid "  R_DATATABLE_NUM_PROCS_PERCENT  %s\n"
msgstr " R_DATATABLE_NUM_PROCS_PERCENT %s\n"

msgid "  R_DATATABLE_NUM_THREADS        %s\n"
msgstr " R_DATATABLE_NUM_THREADS %s\n"

msgid "  R_DATATABLE_THROTTLE           %s\n"
msgstr " R_DATATABLE_THROTTLE %s\n"

msgid "  omp_get_thread_limit()         %d\n"
msgstr " omp_get_thread_limit() %d\n"

msgid "  omp_get_max_threads()          %d\n"
msgstr " omp_get_max_threads() %d\n"

msgid "  OMP_THREAD_LIMIT               %s\n"
msgstr " OMP_THREAD_LIMIT %s\n"

msgid "  OMP_NUM_THREADS                %s\n"
msgstr " OMP_NUM_THREADS %s\n"

msgid "  RestoreAfterFork               %s\n"
msgstr " RestoreAfterFork %s\n"

msgid ""
"  data.table is using %d threads with throttle==%d. See ?setDTthreads.\n"
msgstr ""
" data.table está usando %d hilos con aceleración==%d. Consulte ?setDTthreads."
"\n"

msgid ""
"restore_after_fork= must be TRUE, FALSE, or NULL (default). "
"getDTthreads(verbose=TRUE) reports the current setting.\n"
msgstr ""
"restore_after_fork= debe ser TRUE, FALSE o NULL (predeterminado). "
"getDTthreads(verbose=TRUE) informa la configuración actual.\n"

msgid "'throttle' must be a single number, non-NA, and >=1"
msgstr "'throttle' debe ser un número único, que no sea NA y >=1"

msgid ""
"threads= must be either NULL or a single number >= 0. See ?setDTthreads."
msgstr "threads= debe ser NULL o un solo número >= 0. Consulte ?setDTthreads."

msgid "Internal error: percent= must be TRUE or FALSE at C level"
msgstr "Error interno: porcentaje= debe ser TRUE o FALSE en el nivel C"

msgid ""
"Internal error: threads==%d should be between 2 and 100 (percent=TRUE at C "
"level)."
msgstr ""
"Error interno: threads==%d debe estar entre 2 y 100 (porcentaje=TRUE en el "
"nivel C)."

msgid ""
"Attempting to substitute '%s' element with object of type '%s' but it has to "
"be 'symbol' type when substituting name of the call argument, functions 'as."
"name' and 'I' can be used to work out proper substitution, see ?substitute2 "
"examples."
msgstr ""
"Intentando sustituir el elemento '%s' con un objeto de tipo '%s' pero tiene "
"que ser del tipo 'symbol' al sustituir el nombre del argumento de llamada, "
"las funciones  'as.name' y 'I' se pueden utilizar para realizar una "
"sustitución adecuada; consulte los ejemplos de ?substitute2."

msgid "use.names= should be TRUE, FALSE, or not used (\"check\" by default)"
msgstr "use.names= debe ser TRUE, FALSE o no usarse (\"check\" por defecto)"

msgid ""
"Input to rbindlist must be a list. This list can contain data.tables, data."
"frames or plain lists."
msgstr ""
"La entrada a rbindlist debe ser una lista. Esta lista puede contener data."
"tables, data.frames o listas simples."

msgid "Internal error: rbindlist.c idcol is not a single string"
msgstr "Error interno <rbindlist.c> idcol no es una sola cadena"

msgid "Item %d of input is not a data.frame, data.table or list"
msgstr ""
"El elemento %d de la entrada no es un data.frame, data.table o una lista"

msgid ""
"Item %d has %d columns, inconsistent with item %d which has %d columns. To "
"fill missing columns use fill=TRUE."
msgstr ""
"El elemento %d tiene %d columnas, lo que es inconsistente con el elemento %d "
"que tiene %d columnas. Para completar las columnas que faltan, utilice "
"fill=TRUE."

msgid "Item %d has %d columns but %d column names. Invalid object."
msgstr ""
"El elemento %d tiene %d columnas pero %d nombres de columna. Objeto no "
"válido."

msgid ""
"Column %d of item %d is length %d inconsistent with column %d which is "
"length %d. Only length-1 columns are recycled."
msgstr ""
"La columna %d del elemento %d tiene una longitud %d inconsistente con la "
"columna %d, que tiene una longitud %d. Sólo se reciclan las columnas de "
"longitud 1."

msgid ""
"Column %d ['%s'] of item %d is length 0. This (and %d other%s like it) has "
"been filled with NA (NULL for list columns) to make each item uniform."
msgstr ""
"La columna %d ['%s'] del elemento %d tiene una longitud de 0. Esta (y %d "
"otras %s similares) se ha llenado con NA (NULL para las columnas de la "
"lista) para que cada elemento sea uniforme."

msgid ""
"Total rows in the list is %<PRId64> which is larger than the maximum number "
"of rows, currently %d"
msgstr ""
"El total de filas en la lista es %<PRId64> que es mayor que el número máximo "
"de filas, actualmente %d"

msgid "use.names=TRUE but no item of input list has any names"
msgstr ""
"use.names=TRUE pero ningún elemento de la lista de entrada tiene ningún "
"nombre"

msgid ""
"Failed to allocate upper bound of %<PRId64> unique column names "
"[sum(lapply(l,ncol))]"
msgstr ""
"No se pudo asignar el límite superior de %<PRId64> nombres de columna únicos "
"[sum(lapply(l,ncol))]"

msgid "Failed to allocate nuniq=%d items working memory in rbindlist.c"
msgstr ""
"Error al asignar memoria de trabajo de elementos nuniq=%d en <rbindlist.c>"

msgid "Failed to allocate ncol=%d items working memory in rbindlist.c"
msgstr ""
"Error al asignar ncol=%d memoria de trabajo de elementos en <rbindlist.c>"

msgid ""
"Internal error: usenames==NA but fill=TRUE. usenames should have been set to "
"TRUE earlier with warning."
msgstr ""
"Error interno: usenames==NA pero fill=TRUE. los nombres de uso deberían "
"haberse configurado en TRUE antes con una advertencia."

msgid ""
" use.names='check' (default from v1.12.2) emits this message and proceeds as "
"if use.names=FALSE for  backwards compatibility. See news item 5 in v1.12.2 "
"for options to control this message."
msgstr ""
" use.names='check' (predeterminado desde v1.12.2) emite este mensaje y "
"procede como si use.names=FALSE para compatibilidad con versiones "
"anteriores. Consulte ítem 5 en NEWS de v1.12.2 para conocer las opciones "
"para controlar este mensaje."

msgid ""
"Internal error: could not find the first column name not present in earlier "
"item"
msgstr ""
"Error interno: no se pudo encontrar el nombre de la primera columna que no "
"está presente en el elemento anterior"

msgid ""
"Column %d ['%s'] of item %d is missing in item %d. Use fill=TRUE to fill "
"with NA (NULL for list columns), or use.names=FALSE to ignore column names.%s"
msgstr ""
"Falta la columna %d ['%s'] del elemento %d en el elemento %d. Use fill=TRUE "
"para completar con NA (NULL para columnas de lista), o use.names=FALSE para "
"ignorar los nombres de columnas.%s"

msgid ""
"Internal error: usenames==NA but an out-of-order name has been found in an "
"item with no names or the first item. [%d]"
msgstr ""
"Error interno: usenames==NA pero se encontró un nombre desordenado en un "
"elemento sin nombres o en el primer elemento. [%d]"

msgid ""
"Column %d ['%s'] of item %d appears in position %d in item %d. Set use."
"names=TRUE to match by column name, or use.names=FALSE to ignore column "
"names.%s"
msgstr ""
"La columna %d ['%s'] del elemento %d aparece en la posición %d en el "
"elemento %d. Establezca use.names=TRUE para que coincida con el nombre de la "
"columna, o use.names=FALSE para ignorar los nombres de las columnas.%s"

msgid ""
"options()$datatable.rbindlist.check is set but is not a single string. See "
"news item 5 in v1.12.2."
msgstr ""
"options()$datatable.rbindlist.check está configurado pero no es una sola "
"cadena. Ver ítem 5 en NEWS en v1.12.2."

msgid ""
"options()$datatable.rbindlist.check=='%s' which is not 'message'|'warning'|"
"'error'|'none'. See news item 5 in v1.12.2."
msgstr ""
"options()$datatable.rbindlist.check=='%s' que no es 'message'|'warning'|"
"'error'|'none'. Ver ítem 5 en NEWS v1.12.2."

msgid ""
"Column %d of item %d has type 'factor' but has no levels; i.e. malformed."
msgstr ""
"La columna %d del elemento %d tiene el tipo 'factor' pero no tiene niveles; "
"es decir, está mal formada."

msgid ""
"Class attribute on column %d of item %d does not match with column %d of "
"item %d."
msgstr ""
"El atributo de clase en la columna %d del elemento %d no coincide con la "
"columna %d del elemento %d."

msgid ""
"Internal error: column %d of result is determined to be integer64 but "
"maxType=='%s' != REALSXP"
msgstr ""
"Error interno: se determinó que la columna %d del resultado es integer64 "
"pero maxType=='%s'!= REALSXP"

msgid ""
"Failed to allocate working memory for %d ordered factor levels of result "
"column %d"
msgstr ""
"No se pudo asignar la memoria de trabajo para %d niveles de factores "
"ordenados de la columna de resultados %d"

msgid ""
"Column %d of item %d is an ordered factor but level %d ['%s'] is missing "
"from the ordered levels from column %d of item %d. Each set of ordered "
"factor levels should be an ordered subset of the first longest. A regular "
"factor will be created for this column."
msgstr ""
"La columna %d del elemento %d es un factor ordenado pero el nivel %d ['%s'] "
"falta en los niveles ordenados de la columna %d del elemento %d. Cada "
"conjunto de niveles de factores ordenados debe ser un subconjunto ordenado "
"del primero más largo. Se creará un factor regular para esta columna."

msgid ""
"Column %d of item %d is an ordered factor with '%s'<'%s' in its levels. But "
"'%s'<'%s' in the ordered levels from column %d of item %d. A regular factor "
"will be created for this column due to this ambiguity."
msgstr ""
"La columna %d del ítem %d es un factor ordenado con '%s'<'%s' en sus "
"niveles. Pero '%s'<'%s' en los niveles ordenados de la columna %d del "
"elemento %d. Debido a esta ambigüedad, se creará un factor regular para esta "
"columna."

msgid ""
"Failed to allocate working memory for %d factor levels of result column %d "
"when reading item %d of item %d"
msgstr ""
"No se pudo asignar la memoria de trabajo para %d niveles de factor de la "
"columna de resultados %d al leer el elemento %d del elemento %d"

msgid "Column %d of item %d: %s"
msgstr "Columna %d del elemento %d: %s"

msgid "Item %d of list is type '%s' which isn't yet supported (SIZEOF=%zu)"
msgstr ""
"El elemento %d de la lista es del tipo '%s' que aún no está soportado "
"(SIZEOF=%zu)"

msgid ""
"Column %d is length %d which differs from length of column 1 (%d). Invalid "
"data.table."
msgstr ""
"La columna %d tiene una longitud %d que difiere de la longitud de la columna "
"1 (%d). data.table no válido."

msgid ""
"reorder accepts vectors but this non-VECSXP is type '%s' which isn't yet "
"supported (SIZEOF=%zu)"
msgstr ""
"reorder acepta vectores pero este no-VECSXP es del tipo '%s' que aún no está "
"soportado (SIZEOF=%zu)"

msgid ""
"Internal error in reorder.c: cannot reorder an ALTREP vector. Please see "
"NEWS item 2 in v1.11.4 and report this as a bug."
msgstr ""
"Error interno <reorder.c>: no se puede reordenar un vector ALTREP. Consulte "
"NEWS ítem 2 en v1.11.4 e informe esto como un error."

msgid "order must be an integer vector"
msgstr "el orden debe ser un vector entero"

msgid "nrow(x)[%d]!=length(order)[%d]"
msgstr "nrow(x)[%d]!=length(order)[%d]"

msgid ""
"Item %d of order (%d) is either NA, out of range [1,%d], or is duplicated. "
"The new order must be a strict permutation of 1:n"
msgstr ""
"El elemento %d del pedido (%d) es NA, está fuera del rango [1,%d] o está "
"duplicado. El nuevo orden debe ser una permutación estricta de 1:n"

msgid "dt passed to setcolorder has no names"
msgstr "dt pasado a setcolorder no tiene nombres"

msgid "Internal error: dt passed to setcolorder has %d columns but %d names"
msgstr ""
"Error interno: dt pasado a setcolorder tiene %d columnas pero %d nombres"

msgid ""
"shift input must not be matrix or array, consider wrapping it into data."
"table() or c()"
msgstr ""
"la entrada de desplazamiento no debe ser una matriz o array, considere "
"incluirla en data.table() o c()"

msgid ""
"type '%s' passed to shift(). Must be a vector, list, data.frame or data.table"
msgstr ""
"Tipo '%s' pasado a shift(). Debe ser un vector, una lista, un data.frame o "
"una data.table."

msgid ""
"Internal error: invalid type for shift(), should have been caught before. "
"please report to data.table issue tracker"
msgstr ""
"Error interno: tipo no válido para shift(), debería haberse detectado antes. "
"informe al rastreador de problemas de data.table"

msgid "Internal error: k must be integer"
msgstr "Error interno: k debe ser un número entero"

msgid "dt_win_snprintf test %d failed: %s"
msgstr "prueba dt_win_snprintf %d falló: %s"

msgid "dt_win_snprintf test %d failed: %d"
msgstr "prueba dt_win_snprintf %d falló: %d"

msgid "Internal error: subsetVectorRaw length(ans)==%d n=%d"
msgstr "Error interno: subsetVectorRaw length(ans)==%d n=%d"

msgid ""
"Internal error: column type '%s' not supported by data.table subset. All "
"known types are supported so please report as bug."
msgstr ""
"Error interno: el tipo de columna '%s' no es compatible con subset() de data."
"table. Se admiten todos los tipos conocidos, así que infórmelo como error."

msgid "Internal error. 'idx' is type '%s' not 'integer'"
msgstr "Error interno. 'idx' es tipo '%s', no 'integer'"

msgid ""
"Internal error. 'maxArg' is type '%s' and length %d, should be an integer "
"singleton"
msgstr ""
"Error interno. 'maxArg' es del tipo '%s' y de longitud %d, debe ser un "
"singleton entero"

msgid "Internal error: allowOverMax must be TRUE/FALSE"
msgstr "Error interno: permitirOverMax debe ser TRUE/FALSE"

msgid "Internal error. max is %d, must be >= 0."
msgstr "Error interno. max es %d, debe ser >= 0."

msgid "Internal error: allowNAArg must be TRUE/FALSE"
msgstr "Error interno: permitirNAArg debe ser TRUE/FALSE"

msgid ""
"Item %d of i is %d and item %d is %d. Cannot mix positives and negatives."
msgstr ""
"El elemento %d de 'i' es %d y el elemento %d es %d. No se pueden mezclar "
"valores positivos y negativos."

msgid "Item %d of i is %d and item %d is NA. Cannot mix negatives and NA."
msgstr ""
"El elemento %d de 'i' es %dy el elemento %d es NA. No se pueden mezclar "
"negativos y NA."

msgid ""
"Item %d of i is %d but there are only %d rows. Ignoring this and %d more "
"like it out of %d."
msgstr ""
"El elemento %d de 'i' es %d pero solo hay %d filas. Ignorando este y otros "
"%d similares de un total de %d."

msgid ""
"Item %d of i is %d which removes that item but that has occurred before. "
"Ignoring this dup and %d other dups."
msgstr ""
"El elemento %d de 'i' es %d que elimina ese elemento pero que ya ocurrió "
"antes. Ignorando este duplicado y %d otro(s) duplicado(s)."

msgid "Column %d is NULL; malformed data.table."
msgstr "La columna %d es NULL; data.table con formato incorrecto."

msgid "Column %d ['%s'] is a data.frame or data.table; malformed data.table."
msgstr ""
"La columna %d ['%s'] es un data.frame o data.table; data.table con formato "
"incorrecto."

msgid ""
"Column %d ['%s'] is length %d but column 1 is length %d; malformed data."
"table."
msgstr ""
"La columna %d ['%s'] tiene una longitud %d pero la columna 1 tiene una "
"longitud %d; data.table con formato incorrecto."

msgid "Item %d of cols is %d which is outside the range [1,ncol(x)=%d]"
msgstr ""
"El elemento %d de columnas es %d que está fuera del rango [1,ncol(x)=%d]"

msgid ""
"Internal error: NULL can not be subset. It is invalid for a data.table to "
"contain a NULL column."
msgstr ""
"Error interno: NULL no puede ser sub-agrupado. No es válido que una data."
"table contenga una columna NULL."

msgid ""
"Internal error: CsubsetVector is internal-use-only but has received "
"negatives, zeros or out-of-range"
msgstr ""
"Error interno: CsubsetVector es de uso interno únicamente pero ha recibido "
"negativos, ceros o está fuera de rango"

msgid "l must be a list."
msgstr "'l' debe ser una lista."

msgid "ignore.empty should be logical TRUE/FALSE."
msgstr "ignore.empty debe ser lógico TRUE/FALSE."

msgid ""
"keep.names should be either NULL, or the name of the first column of the "
"result in which to place the names of the input"
msgstr ""
"keep.names debe ser NULL o el nombre de la primera columna del resultado en "
"la que colocar los nombres de la entrada"

msgid "fill must be a length 1 vector, such as the default NA"
msgstr "'fill' debe ser un vector de longitud 1, como el NA predeterminado"

msgid "list.cols should be logical TRUE/FALSE."
msgstr "list.cols debe tener el valor lógico TRUE/FALSE."

msgid "Item %d of list input is not either an atomic vector, or a list"
msgstr ""
"El elemento %d de la entrada de lista no es un vector atómico ni una lista"

msgid "internal error: status, nx, nk must be integer"
msgstr "error interno: status, nx, nk debe/n ser de tipo entero"

msgid "Internal error: uniqlist has not been passed a list of columns"
msgstr "Error interno: a uniqlist no se le ha pasado una lista de columnas"

msgid "Internal error: uniqlist has been passed a non-integer order"
msgstr "Error interno: a uniqlist se le ha pasado un orden no entero"

msgid "Internal error: uniqlist has been passed a length-0 order"
msgstr "Error interno: a uniqlist se le ha pasado un pedido de longitud 0"

msgid "Internal error: uniqlist has been passed length(order)==%d but nrow==%d"
msgstr "Error interno: se ha pasado uniqlist length(order)==%d pero nrow==%d"

msgid "Input argument 'x' to 'uniqlengths' must be an integer vector"
msgstr "El argumento de entrada 'x' a 'uniqlengths' debe ser un vector entero"

msgid ""
"Input argument 'n' to 'uniqlengths' must be an integer vector of length 1"
msgstr ""
"El argumento de entrada 'n' a 'uniqlengths' debe ser un vector entero de "
"longitud 1"

msgid "cols must be an integer vector with length >= 1"
msgstr "cols debe ser un vector entero con longitud >= 1"

msgid "Item %d of cols is %d which is outside the range [1,length(l)=%d]"
msgstr ""
"El elemento %d de columnas es %d que está fuera del rango [1,length(l)=%d]"

msgid ""
"All elements to input list must be of same length. Element [%d] has length "
"%<PRIu64> != length of first element = %<PRIu64>."
msgstr ""
"Todos los elementos para ingresar la lista deben tener la misma longitud. El "
"elemento [%d] tiene una longitud %<PRIu64> != longitud del primer elemento = "
"%<PRIu64>."

msgid "Internal error: nestedid was not passed a list length 1 or more"
msgstr ""
"Error interno: a 'nestedid' no se le pasó una longitud de lista de 1 o más"

msgid "Internal error: nrows[%d]>0 but ngrps==0"
msgstr "Error interno: nrows[%d]>0 pero ngrps==0"

msgid "x is not a logical vector"
msgstr "'x' no es un vector lógico"

msgid "Unsupported type '%s' passed to allNA()"
msgstr "Tipo no admitido '%s' pasado a allNA()"

msgid "'x' argument must be data.table compatible"
msgstr " El argumento 'x' debe ser compatible con data.table"

msgid ""
"argument specifying columns is type 'double' and one or more items in it are "
"not whole integers"
msgstr ""
"el argumento que especifica las columnas es del tipo 'double' y uno o más "
"elementos que contiene no son números enteros"

msgid ""
"argument specifying columns received non-existing column(s): cols[%d]=%d"
msgstr ""
"argumento que especifica columnas recibidas columna(s) no existentes: cols"
"[%d]=%d"

msgid "'x' argument data.table has no names"
msgstr "argumento 'x' de tipo data.table no tiene nombres"

msgid ""
"argument specifying columns received non-existing column(s): cols[%d]='%s'"
msgstr ""
"argumento que especifica columnas recibió columnas no existentes: cols[%d]="
"'%s'"

msgid "argument specifying columns must be character or numeric"
msgstr ""
"el argumento que especifica las columnas debe ser de caracteres o numérico"

msgid "argument specifying columns received duplicate column(s)"
msgstr "argumento que especifica columnas recibió columna(s) duplicada(s)"

msgid "Internal error: type '%s' not supported in %s"
msgstr "Error interno: tipo '%s' no admitido en %s"

msgid "Internal error: copyAsPlain returning ALTREP for type '%s'"
msgstr "Error interno: copyAsPlain devuelve ALTREP para el tipo '%s'"

msgid "Found and copied %d column%s with a shared memory address\n"
msgstr ""
"Encontrada(s) y copiada(s) %d columnas%s con una dirección de memoria "
"compartida\n"

msgid "'x' is not atomic"
msgstr "'x' no es atómico"

msgid "'x' must not be matrix or array"
msgstr "'x' no debe ser matriz o array"

msgid "input must not be matrix or array"
msgstr "la entrada no debe ser una matriz o array"

msgid "copy=false and input already of expected type and class %s[%s]\n"
msgstr "copy=FALSE y entrada ya del tipo y clase esperados %s[%s]\n"

msgid "Coercing %s[%s] into %s[%s]\n"
msgstr "Forzando tipo %s[%s] a %s[%s]\n"

msgid "zlib header files were not found when data.table was compiled"
msgstr ""
"No se encontraron archivos de encabezado zlib cuando se compiló data.table"

msgid "len must be an integer vector"
msgstr "len debe ser un vector entero"

msgid "x and len must be the same length"
msgstr "'x' y 'len' deben tener la misma longitud"

msgid ""
"Join results in more than 2^31 rows (internal vecseq reached physical "
"limit). Very likely misspecified join. Check for duplicate key values in i "
"each of which join to the same group in x over and over again. If that's ok, "
"try by=.EACHI to run j for each group to avoid the large allocation. "
"Otherwise, please search for this error message in the FAQ, Wiki, Stack "
"Overflow and data.table issue tracker for advice."
msgstr ""
"Resultados del join en más de 2^31 filas (el vecseq interno alcanzó el "
"límite físico). Es muy probable que se haya especificado mal una unión. "
"Compruebe si hay valores clave duplicados en i, cada uno de los cuales se "
"une al mismo grupo en x una y otra vez. Si está bien, intente by=.EACHI "
"ejecutar 'j' para cada grupo para evitar una asignación demasiado grande. De "
"lo contrario, busque este mensaje de error en Preguntas frecuentes (FAQ), "
"Wiki, Stack Overflow y rastreador de problemas de data.table para obtener "
"asesoramiento."

msgid "clamp must be a double vector length 1"
msgstr "'clamp' debe ser un vector doble de longitud 1"

msgid "clamp must be positive"
msgstr "'clamp' debe ser positivo"

msgid ""
"Join results in %d rows; more than %d = nrow(x)+nrow(i). Check for duplicate "
"key values in i each of which join to the same group in x over and over "
"again. If that's ok, try by=.EACHI to run j for each group to avoid the "
"large allocation. If you are sure you wish to proceed, rerun with allow."
"cartesian=TRUE. Otherwise, please search for this error message in the FAQ, "
"Wiki, Stack Overflow and data.table issue tracker for advice."
msgstr ""
"Resultados del join en %d filas; más de %d = nrow(x)+nrow(i). Compruebe si "
"hay valores clave duplicados en i, cada uno de los cuales se une al mismo "
"grupo en x una y otra vez. Si está bien, intente by=.EACHI para ejecutar 'j' "
"para cada grupo y evitar así una gran asignación. Si está seguro de que "
"desea continuar, vuelva a ejecutar con enable.cartesian=TRUE. De lo "
"contrario, busque este mensaje de error en Preguntas frecuentes (FAQ), Wiki, "
"Stack Overflow y rastreador de problemas de data.table para obtener "
"asesoramiento."

msgid "Attribute name must be a character vector of length 1"
msgstr "El nombre del atributo debe ser un vector de caracteres de longitud 1"

msgid ""
"Internal structure doesn't seem to be a list. Can't set class to be 'data."
"table' or 'data.frame'. Use 'as.data.table()' or 'as.data.frame()' methods "
"instead."
msgstr ""
"La estructura interna no parece ser una lista. No se puede configurar la "
"clase para que sea 'data.table' o 'data.frame'. Utilice los métodos 'as.data."
"table()' o 'as.data.frame()' en su lugar."

msgid "First argument to setlistelt must be a list()"
msgstr "El primer argumento de setlistelt debe ser una lista"

msgid "Second argument to setlistelt must a length 1 integer vector"
msgstr ""
"El segundo argumento para setlistelt debe ser un vector entero de longitud 1"

msgid "i (%d) is outside the range of items [1,%d]"
msgstr "i (%d) está fuera del rango de elementos [1,%d]"

msgid "x isn't a VECSXP"
msgstr "'x' no es un VECSXP"

msgid ""
"dim.data.table expects a data.table as input (which is a list), but seems to "
"be of type %s"
msgstr ""
"dim.data.table espera un data.table como entrada (que es una lista), pero "
"parece ser del tipo %s"
