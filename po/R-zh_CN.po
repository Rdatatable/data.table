msgid ""
msgstr ""
"Project-Id-Version: data.table 1.12.5\n"
"POT-Creation-Date: 2023-12-28 12:46+0000\n"
"PO-Revision-Date: 2019-11-16 18:37+0800\n"
"Last-Translator: Xianying Tan <shrektan@126.com>\n"
"Language-Team: Mandarin\n"
"Language: Mandarin\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: AllS4.R:2
#, c-format
msgid "data.table package loaded. When developing don't load package"
msgstr "data.table包已载入, 开发时无需载入"

#: IDateTime.R:101
#, c-format
msgid ""
"Internal error -- difftime objects may not be added to IDate, but Ops "
"dispatch should have intervened to prevent this"
msgstr ""
"内部错误 -- 'difftime'对象可能不能被添加到IDate类型但是正确操作应该防止此行为"
"发生"

#: IDateTime.R:107
#, c-format
msgid "binary + is not defined for \"IDate\" objects"
msgstr "没有为\"IDate\" 对象定义的'+'操作"

#: IDateTime.R:114
#, c-format
msgid "can only subtract from \"IDate\" objects"
msgstr "只能从\"IDate\"对象中减去"

#: IDateTime.R:117
#, c-format
msgid "Internal error: storage mode of IDate is somehow no longer integer"
msgstr "内部错误： IDate的存储模式不为整型"

#: IDateTime.R:119
#, c-format
msgid "unary - is not defined for \"IDate\" objects"
msgstr "没有为\"IDate\" 对象定义的一元的'-'操作"

#: IDateTime.R:121
#, c-format
msgid ""
"Internal error -- difftime objects may not be subtracted from IDate, but Ops "
"dispatch should have intervened to prevent this"
msgstr ""
"内部错误 -- 不能与IDate类型中减去'difftime'对象但是正确操作应该防止此行为发生"

#: IDateTime.R:309
#, c-format
msgid "Valid options for ms are 'truncate', 'nearest', and 'ceil'."
msgstr "'ms'有效的选项为'truncate', 'nearest', 或 'ceil'."

#: as.data.table.R:86
#, c-format
msgid ""
"as.data.table.array method should only be called for arrays with 3+ "
"dimensions; use the matrix method for 2-dimensional arrays"
msgstr ""
"请只对3维或以上的数组使用as.data.table.array方法对二维数组请使用matrix方法"

#: as.data.table.R:88
#, c-format
msgid ""
"Argument 'value.name' must be scalar character, non-NA and at least one "
"character"
msgstr "参数'value.name'必须为标量字符或non-NA至少包含一个字符"

#: as.data.table.R:90
#, c-format
msgid "Argument 'sorted' must be scalar logical and non-NA"
msgstr "参数'sorted'必须为标量逻辑或non-NA"

#: as.data.table.R:92
#, c-format
msgid "Argument 'na.rm' must be scalar logical and non-NA"
msgstr "参数'na.rm'必须为标量逻辑或non-NA"

#: as.data.table.R:94
#, c-format
msgid "Please provide either 'key' or 'sorted', but not both."
msgstr "请提供参数'key'或'sorted',但不可同时提供"

#: as.data.table.R:108
#, c-format
msgid ""
"Argument 'value.name' should not overlap with column names in result: %s"
msgstr "参数'value.name'不能与结果中已有列名重复: %s"

#: as.data.table.R:140
#, c-format
msgid ""
"POSIXlt column type detected and converted to POSIXct. We do not recommend "
"use of POSIXlt at all because it uses 40 bytes to store one date."
msgstr ""
"检测到使用了POSIXlt类型的列， 并转成POSIXctdata.table不建议使用POSIXlt对象, "
"因为其使用40字节来存储一个日期"

#: as.data.table.R:181
#, c-format
msgid "Item %d has %d rows but longest item has %d; recycled with remainder."
msgstr "第 %d 项有 %d 行，但最长的一项只有 %d 行；将循环补齐剩余项。"

#: as.data.table.R:196
#, c-format
msgid "A column may not be called .SD. That has special meaning."
msgstr "无法将列命名为 .SD，因为 .SD 为特殊符号。"

#: as.data.table.R:210
#, c-format
msgid "class must be length 1"
msgstr "class 的长度必须为 1"

#: between.R:3
#, c-format
msgid "between has been passed an argument x of type logical"
msgstr "传入 between 的参数 x 为逻辑（logical）型"

#: between.R:13 between.R:15
#, c-format
msgid ""
"'between' function the 'x' argument is a POSIX class while '%s' was not, "
"coercion to POSIX failed with: %s"
msgstr ""
"'between' 中的 'x' 参数为 POSIX 类，而 '%s' 并不是，将其强制转换成 POSIX 时失败：%s"

#: between.R:27
#, c-format
msgid ""
"'between' lower= and upper= are both POSIXct but have different tzone "
"attributes: %s. Please align their time zones."
msgstr ""
"'between' 中的 lower= 和 upper= 均为 POSIXct 类型但却有不同的时区属性"
"（tzone）：%s。请将它们的时区调整一致。"

#: between.R:31
#, c-format
msgid ""
"'between' arguments are all POSIXct but have mismatched tzone attributes: "
"%s. The UTC times will be compared."
msgstr "'between' 的参数均为 POSIXct 类型但时区属性（tzone）不匹配："
"%s。将使用 UTC 时间进行比较。"

#: between.R:36
#, c-format
msgid "trying to use integer64 class when 'bit64' package is not installed"
msgstr "试图使用 intger64 类型但 'bit64' 包尚未安装"

#: between.R:48
#, c-format
msgid ""
"Not yet implemented NAbounds=TRUE for this non-numeric and non-character type"
msgstr ""
"对这种非数值（numeric）和非字符（character）的类型，尚未实现 NAbounds=TRUE 的"
"功能"

#: between.R:49
#, c-format
msgid "Some lower>upper for this non-numeric and non-character type"
msgstr ""
"对于该非数值（numeric）和非字符（character）类型的输入，存在一部分下界"
"（lower）> 上界（upper）的情况"

#: between.R:63
#, c-format
msgid "Perhaps you meant %s?"
msgstr "或许你想用的是 %s？"

#: between.R:64
#, c-format
msgid ""
"RHS has length() %d; expecting length 2. %sThe first element should be the "
"lower bound(s); the second element should be the upper bound(s)."
msgstr ""
"右侧（RHS）的长度为 %d；期望长度为 2。%s第一个元素应为下界；第二个元素应为上"
"界。"

#: bmerge.R:48 bmerge.R:49
#, c-format
msgid "%s is type %s which is not supported by data.table join"
msgstr "%s的类型为%s，该类型无法用于 data.table 的联接"

#: bmerge.R:52
#, c-format
msgid ""
"Attempting roll join on factor column when joining %s to %s. Only integer, "
"double or character columns may be roll joined."
msgstr ""
"联接%s与%s时试图滚动联接（roll join）因子类型（factor）的列。但只有整数"
"（integer）、双精度（double）或字符（character）类型的列可以使用滚动联接。"

#: bmerge.R:71
#, c-format
msgid ""
"Incompatible join types: %s (%s) and %s (%s). Factor columns must join to "
"factor or character columns."
msgstr ""
"不兼容的联结类型: %s (%s) 和 %s (%s)。 因子类型的列必须与因子类型或字符类型的"
"列才可以联结"

#: bmerge.R:90
#, c-format
msgid "Incompatible join types: %s (%s) and %s (%s)"
msgstr "不兼容的联结类型: %s (%s) 和 %s (%s)。"

#: bmerge.R:98
#, c-format
msgid ""
"Incompatible join types: %s is type integer64 but %s is type double and "
"contains fractions"
msgstr ""
"不兼容的联结类型: %s 是 integer64 类型的列但 %s 是有分数的双精度类型列。"

#: bmerge.R:153
#, c-format
msgid "roll is not implemented for non-equi joins yet."
msgstr "不等长联结还不能执行 roll "

#: bmerge.R:173
#, c-format
msgid "Column name '_nqgrp_' is reserved for non-equi joins."
msgstr "列名 '_nqgrp_' 是为不等长联结保留的"

#: data.table.R:63
#, c-format
msgid "key argument of data.table() must be character"
msgstr "data.table() 的key参数必须是字符"

#: data.table.R:132
#, c-format
msgid "Object '%s' not found. Perhaps you intended %s"
msgstr "对象 '%s' 不存在， 可能你打算 %s"

#: data.table.R:134
#, c-format
msgid "Object '%s' not found amongst %s"
msgstr "%2$s 中对象 '%1$s' 不存在"

#: data.table.R:157
#, c-format
msgid "verbose must be logical or integer"
msgstr "verbose必须是一个逻辑向量"

#: data.table.R:158
#, c-format
msgid "verbose must be length 1 non-NA"
msgstr "verbose 的长度必须是 1 和不NA"

#: data.table.R:166
#, c-format
msgid "Ignoring by/keyby because 'j' is not supplied"
msgstr "因为没有提供 j= ，所以忽略 by/keyby"

#: data.table.R:180
#, c-format
msgid "When by and keyby are both provided, keyby must be TRUE or FALSE"
msgstr "当 by 和 keyby 都提供的时候，keyby 必须是 TRUE 或 FALSE"

#: data.table.R:192
#, c-format
msgid ""
"When on= is provided but not i=, on= must be a named list or data.table|"
"frame, and a natural join (i.e. join on common names) is invoked. Ignoring "
"on= which is '%s'."
msgstr ""
"当提供 on= 而不提供 i= 的时候， on= 必须是带名称的 list 或者 data.table 或者 "
"data.frame，并且会调用自然联结（例如，按照共有名称联结），忽略 on= %s"

#: data.table.R:205
#, c-format
msgid ""
"i and j are both missing so ignoring the other arguments. This warning will "
"be upgraded to error in future."
msgstr "i 和 j 都缺少的时候忽略其他参数。将来此警告信息将升级为错误信息。"

#: data.table.R:209
#, c-format
msgid "mult argument can only be 'first', 'last' or 'all'"
msgstr "mult 参数只能赋值为 'first'， 'last' 或 'all'"

#: data.table.R:211
#, c-format
msgid ""
"roll must be a single TRUE, FALSE, positive/negative integer/double "
"including +Inf and -Inf or 'nearest'"
msgstr ""
"roll 必须是单个参数，例如 TRUE， FALSE, 正或负的 integer 或 double包括 "
"+Inf ， -Inf 或 'nearest'"

#: data.table.R:213
#, c-format
msgid "roll is '%s' (type character). Only valid character value is 'nearest'."
msgstr "roll 是 '%s'(字符类型)。 唯一有效的字符值是'nearest'。"

#: data.table.R:218
#, c-format
msgid "rollends must be a logical vector"
msgstr "rollends必须是一个逻辑向量"

#: data.table.R:219
#, c-format
msgid "rollends must be length 1 or 2"
msgstr "rollends 的长度必须是 1 或者 2"

#: data.table.R:227
#, c-format
msgid ""
"nomatch= must be either NA or NULL (or 0 for backwards compatibility which "
"is the same as NULL but please use NULL)"
msgstr "nomatch= 必须是 NA 或 NULL (或者在向后兼容的情形下为 0，这等同于 NULL但是请用 NULL)"

#: data.table.R:230
#, c-format
msgid "which= must be a logical vector length 1. Either FALSE, TRUE or NA."
msgstr "which= 必须是一个长度为 1 的逻辑向量。其取值为 FALSE，TRUE 或者 NA。"

#: data.table.R:231
#, c-format
msgid ""
"which==%s (meaning return row numbers) but j is also supplied. Either you "
"need row numbers or the result of j, but only one type of result can be "
"returned."
msgstr ""
"which==%s (表示行数会被返回) 但是 j 也被提供了。你可能需要行数或者是 j 的结果，但是只能"
"返回一种结果。"

#: data.table.R:232
#, c-format
msgid ""
"which=NA with nomatch=0|NULL would always return an empty vector. Please "
"change or remove either which or nomatch."
msgstr ""
"同时使用 which=NA 和 nomatch=0或NULL 会得到一个空向量。请改变或者是移除 which或 "
"nomatch 的取值"

#: data.table.R:233
#, c-format
msgid "j must be provided when with=FALSE"
msgstr "如果with=FALSE(假)，j必须要赋值"

#: data.table.R:273
#, c-format
msgid ""
"The symbol .. is invalid. The .. prefix must be followed by at least one "
"character."
msgstr "符号 .. 是无效的。前缀 .. 之后必须要有至少一个字符"

#: data.table.R:276
#, c-format
msgid ""
"Variable '..%s' does exist in calling scope though, so please just removed "
"the .. prefix from that variable name in calling scope."
msgstr "变量 '%s' 并不存在于调用环境中。所以请移除在调用环境中那个变量名字的..前缀"

#: data.table.R:280
#, c-format
msgid ""
"Variable '%s' is not found in calling scope. Looking in calling scope "
"because you used the .. prefix.%s"
msgstr "变量 '%s' 并没有存在于调用环境中。之所以在调用环境中寻找是因为你使用了..的前缀.%s"

#: data.table.R:282
#, c-format
msgid ""
"Both '%1$s' and '..%1$s' exist in calling scope. Please remove the '..%1$s' "
"variable in calling scope for clarity."
msgstr "'%1%s'和'..%1$s'均在当前调用环境中。为清晰起见，请移除在调用环境中名为"
"..%1$s' 的变量。"

#: data.table.R:288
#, c-format
msgid ""
"Internal error:  DT[, ..var] should be dealt with by the branch above now."
msgstr "内部错误: DT[, ..var]应该被分支处理中。"

#: data.table.R:290
#, c-format
msgid ""
"Variable '%s' is not found in calling scope. Looking in calling scope "
"because you set with=FALSE. Also, please use .. symbol prefix and remove "
"with=FALSE."
msgstr ""
"变量 '%s' 并没有存在于调用环境中。之所以在调用环境中搜索是因为你使用了with=FALSE。请"
"使用 .. 符号前缀并且移除 with=FALSE。"

#: data.table.R:298
#, c-format
msgid ""
"You have wrapped := with {} which is ok but then := must be the only thing "
"inside {}. You have something else inside {} as well. Consider placing the "
"{} on the RHS of := instead; e.g. DT[,someCol:={tmpVar1<-...;tmpVar2<-...;"
"tmpVar1*tmpVar2}"
msgstr ""
"用 {} 套用 := 可行，但是 {} 中只能有 := 。而你现在 {} 中还有其他的参数。请尝"
"试将 {} 置于 := 的RHS之上；比如，DT[,someCol:={tmpVar1<-...; tmpVar2<-...; "
"tmpVar1*tmpVar2}"

#: data.table.R:318
#, c-format
msgid ""
":= with keyby is only possible when i is not supplied since you can't setkey "
"on a subset of rows. Either change keyby to by or remove i"
msgstr ""
":=和keyby的组合只有在i没有赋值下才合理存在。因为你不能在一个行的子集调用"
"setkey。要么把keyby换成by或者是移除i"

#: data.table.R:320
#, c-format
msgid "nomatch isn't relevant together with :=, ignoring nomatch"
msgstr "nomatch 并不和 := 有任何的相关，将忽略nomatch"

#: data.table.R:376
#, c-format
msgid ""
"not-join '!' prefix is present on i but nomatch is provided. Please remove "
"nomatch."
msgstr ""
"not-join '!' 前缀在 i 中存在，但是 nomatch 也被提供了。需要移除nomatch。"

#: data.table.R:405
#, c-format
msgid ""
"Operator := detected in i, the first argument inside DT[...], but is only "
"valid in the second argument, j. Most often, this happens when forgetting "
"the first comma (e.g. DT[newvar := 5] instead of DT[ , new_var := 5]). "
"Please double-check the syntax. Run traceback(), and debugger() to get a "
"line number."
msgstr ""
"在 i， 即 DT[...] 中的第一个参数，中检测出操作符 := ，但该操作符仅在 j，即 "
"DT[...] 中的第二个参数中使用才有效。通常，该错误发生在忘记添加第一个逗号时 "
"（如错误地将 [DT , new_var := 5] 写作 DT[newvar := 5]）。请再次检查语法是否正"
"确。运行 trackback()，和 debugger() 来获取发生错误的行号。"

#: data.table.R:416
#, c-format
msgid "'%s' is not found in calling scope and it is not a column name either"
msgstr "'%s' 既不存在于调用环境中，也非列名。"

#: data.table.R:419
#, c-format
msgid ""
"'%s' is not found in calling scope, but it is a column of type %s. If you "
"wish to select rows where that column contains TRUE, or perhaps that column "
"contains row numbers of itself to select, try DT[(col)], DT[DT$col], or "
"DT[col==TRUE} is particularly clear and is optimized"
msgstr ""
"'%s' 并不存在于调用环境中，但是它是一个类型为 %s 的列。如果你想要选择包含 "
"TRUE 值的列中的行，或者选择本身包含行号的列中的行，尝试 DT[(col)]、"
"DT[DT$col]，或者 DT[col==TRUE]，它们表意非常清晰且效率高。"

#: data.table.R:422
#, c-format
msgid ""
"%s. When the first argument inside DT[...] is a single symbol (e.g. "
"DT[var]), data.table looks for var in calling scope."
msgstr ""
"%s。 当DT[...]的第一个参数是一个单个的符号(e.g. DT[var])，data.table会在调用环境中"
"搜寻var。"

#: data.table.R:434
#, c-format
msgid ""
"i is invalid type (matrix). Perhaps in future a 2 column matrix could return "
"a list of elements of DT (in the spirit of A[B] in FAQ 2.14). Please report "
"to data.table issue tracker if you'd like this, or add your comments to FR "
"#657."
msgstr ""
"i不是一个有效的类型(矩阵)。也许在以后一个包含两列的矩阵会返回包含一串元素的"
"DT (请参考问答集2.14的A[B])。如果你有需求，请将此问题汇报给data.table 问题追"
"踪器或者是在FR中留下你的想法"

#: data.table.R:457
#, c-format
msgid ""
"When i is a data.table (or character vector), the columns to join by must be "
"specified using 'on=' argument (see ?data.table), by keying x (i.e. sorted, "
"and, marked as sorted, see ?setkey), or by sharing column names between x "
"and i (i.e., a natural join). Keyed joins might have further speed benefits "
"on very large data due to x being sorted in RAM."
msgstr ""
"但i是一个 data.table (或者是字符向量)，必须使用 'on=' 参数指明参与连接的列 "
"(参见 ?data.table)，可以是keying x(比如，已排序过，和标记已排序过，请参见?"
"setkey)，或者是在x和i共用列的名字(比如，自然连接)。如果x有在内存被排序过，键"
"(keyed)连接的速度会在非常大的数据上有较明显的提高。"

#: data.table.R:465
#, c-format
msgid "Attempting to do natural join but no common columns in provided tables"
msgstr "尝试进行自然连接然而并没有找到表格中相同的列"

#: data.table.R:543
#, c-format
msgid "Internal error. Cannot by=.EACHI when joining to an index, yet"
msgstr "内部错误：目前尚无法对索引(index)使用by=.EACH命令"

#: data.table.R:546
#, c-format
msgid "Internal error. irows has length in by=.EACHI"
msgstr "内部错误：by=.EACHI 中 irows 有长度"

#: data.table.R:597
#, c-format
msgid "logical error. i is not a data.table, but 'on' argument is provided."
msgstr "逻辑错误。当 i 并非一个 data.table时，不应提供'on'参数"

#: data.table.R:601
#, c-format
msgid "i has evaluated to type %s. Expecting logical, integer or double."
msgstr "经计算 i 为 %s 类型。需要布尔类型，整型或浮点型。"

#: data.table.R:605
#, c-format
msgid ""
"internal error: notjoin and which=NA (non-matches), huh? please provide "
"reproducible example to issue tracker"
msgstr ""
"内部错误：notjoin 并且 which=NA (非匹配)？请提供可重现的例子给问题追踪器"
"（issue tracker）"

#: data.table.R:623
#, c-format
msgid ""
"i evaluates to a logical vector length %d but there are %d rows. Recycling "
"of logical i is no longer allowed as it hides more bugs than is worth the "
"rare convenience. Explicitly use rep(...,length=.N) if you really need to "
"recycle."
msgstr ""
"经计算 i 为长度为 %d 的逻辑向量，但数据框有 %d 行。循环补齐"
"循环补齐逻辑向量 i 的特性虽然在少数情况下使用方便，但这种行为会隐藏更多的 bug，"
"因此现已不被允许。若确实需要循环补齐，请直接使用 rep(...,length=.N)。"

#: data.table.R:626
msgid ""
"Please use nomatch=NULL instead of nomatch=0; see news item 5 in v1.12.0 "
"(Jan 2019)"
msgstr ""
"请使用 nomatch=NULL 而非 nomatch=0；参见 v1.12.0 (2019年1月) 中更新条目 5"

#: data.table.R:639
#, c-format
msgid "Internal error: notjoin but byjoin or !integer or nomatch==NA"
msgstr "内部错误。原因可能为：notjoin 而非 byjoin；非整数；nomatch 为空"

#: data.table.R:699
#, c-format
msgid ""
"with=FALSE together with := was deprecated in v1.9.4 released Oct 2014. "
"Please wrap the LHS of := with parentheses; e.g., DT[,(myVar):=sum(b),by=a] "
"to assign to column name(s) held in variable myVar. See ?':=' for other "
"examples. As warned in 2014, this is now a warning."
msgstr ""
"2014年10月发布的1.9.4版本中，with=FALSE 和 := 共用的用法已被弃用。请把 := 左"
"侧部分打上括号；例如，DT[,(myVar):=sum(b),by=a]对 myVar 中的列名进行赋值。输"
"入 ?':=' 参看其他的例子。正如2014年的版本中所说明的，现在这种用法会出现警告。"

#: data.table.R:702
#, c-format
msgid ""
"with=FALSE ignored, it isn't needed when using :=. See ?':=' for examples."
msgstr ""
"当使用 :=. 的时候，with=FALSE 是多余的，会被忽略。输入 ?':=' 参看例子。"

#: data.table.R:726
#, c-format
msgid "column(s) not removed because not found: %s"
msgstr "列未被删除因为不存在：%s"

#: data.table.R:740
#, c-format
msgid "column(s) not found: %s"
msgstr "列不存在: %s"

#: data.table.R:746
#, c-format
msgid "Item %d of j is %d which is outside the column number range [1,ncol=%d]"
msgstr "j 中的第 %d 项的数值为 %d，已超出列索引的范围内1,ncol=%d]"

#: data.table.R:749
#, c-format
msgid "j mixes positives and negatives"
msgstr "j 中同时存在正数和负数"

#: data.table.R:757
#, c-format
msgid ""
"When with=FALSE, j-argument should be of type logical/character/integer "
"indicating the columns to select."
msgstr "当 with=FALSE，参数 j 必须为布尔型/字符型/整型之一，表征要选择的列。"

#: data.table.R:771
#, c-format
msgid ""
"'by' contains .I but only the following are currently supported: by=.I, by=."
"(.I), by=c(.I), by=list(.I)"
msgstr ""
"'by' 包含 .I，但目前仅支持以下用法：by=.I、by=.(.I)、by=c(.I)、by=list(.I)"

#: data.table.R:795
#, c-format
msgid "by=c(...), key(...) or names(...) must evaluate to 'character'"
msgstr "by=c(...), key(...) 或 names(...) 只接受 'character' "

#: data.table.R:805
#, c-format
msgid ""
"'by' is a character vector length %d but one or more items include a comma. "
"Either pass a vector of column names (which can contain spaces, but no "
"commas), or pass a vector length 1 containing comma separated column names. "
"See ?data.table for other possibilities."
msgstr ""
"'by' 为长度为 %d 的字符串向量，但是其中一个或多个元素包含逗号。请传入一个由列"
"名组成的向量（可以包含空格，但是不能" "包含逗号），或传入一个长度为 1 的由逗"
"号分隔列名字符串入。可通过 ?data.table 查看其他可能选项。"

#: data.table.R:812
msgid "At least one entry of by is empty"
msgstr "至少有一个 by 的元素为空"

#: data.table.R:853
#, c-format
msgid "Internal error: irows isn't integer"
msgstr "内部错误：irows 不是整型"

#: data.table.R:887
#, c-format
msgid ""
"'by' appears to evaluate to column names but isn't c() or key(). Use "
"by=list(...) if you can. Otherwise, by=eval%s should work. This is for "
"efficiency so data.table can detect which columns are needed."
msgstr ""
"传递给 'by' 参数似乎是列名，但没有用 c() 或者 key() 函数。如若可以，请使用"
"by=list(...)。其他情况，by=eval(%s) 应该均可成功运行。执行上述检查是出于运行"
"效率原因，以确保 data.table 能够检测计算时所需使用的列。"

#: data.table.R:898
#, c-format
msgid ""
"'by' or 'keyby' must evaluate to a vector or a list of vectors (where 'list' "
"includes data.table and data.frame which are lists, too)"
msgstr ""
"'by' 或者 'keyby' 参数只接受一个向量或由向量组成的列表（这里 'list'包含 data."
"table 和 data.frame，这二者本质也是列表"

#: data.table.R:902
#, c-format
msgid ""
"Column or expression %d of 'by' or 'keyby' is type '%s' which is not "
"currently supported. If you have a compelling use case, please add it to "
"https://github.com/Rdatatable/data.table/issues/1597. As a workaround, "
"consider converting the column to a supported type, e.g. by=sapply(list_col, "
"toString), whilst taking care to maintain distinctness in the process."
msgstr ""
"列或表达式 %d 的 'by' 或 'keyby' 为 '%s' 类型，目前并不支持。如确实需要该功"
"能，请在 https://github.com/Rdatatable/data.table/issues/1597 中提出。"
"暂时的解决办法是，将列转换为支持的类型，例如 by=sapply(list_col, toString)，"
"同时请确保在转换后其值仍保持不同。"

#: data.table.R:906
#, c-format
msgid ""
"The items in the 'by' or 'keyby' list are length(s) %s. Each must be length "
"%d; the same length as there are rows in x (after subsetting if i is "
"provided)."
msgstr ""
"在'by'或'keyby'列表中的项长度为 %s 。每一项的长度须均为%d，即应与 x （或经 i "
"筛选后的子集）中所包含行数相同。"

#: data.table.R:940
#, c-format
msgid "Internal error: drop_dot passed %d items"
msgstr "内部错误：drop_dot 传入的参数有 %d"

#: data.table.R:959
#, c-format
msgid "Item %d of the .() or list() passed to j is missing"
msgstr "传递给j的 .() 或 list()中第%d项缺失"

#: data.table.R:965
#, c-format
msgid ""
"j may not evaluate to the same number of columns for each group; if you're "
"sure this warning is in error, please put the branching logic outside of "
"[ for efficiency"
msgstr ""
"j 在每个组中可能不会计算出相同的列数；如果您确定该警告信息是错误的，请将分支"
"逻辑放在 [ 之外以提高运行效率"

#: data.table.R:967
#, c-format
msgid ""
"Different branches of j expression produced different auto-named columns: "
"%s; using the most \"last\" names. If this was intentional (e.g., you know "
"only one branch will ever be used in a given query because the branch is "
"controlled by a function argument), please (1) pull this branch out of the "
"call; (2) explicitly provide missing defaults for each branch in all cases; "
"or (3) use the same name for each branch and re-name it in a follow-up call."
msgstr ""
"j 表达式的不同分支产生了不同的自动命名列：%s；将使用“最后”一个得到的名字。"
"如果这是有意为之（如，您知道在给定的查询中只有一个分支会被使用，因为该分支"
"由函数参数控制），请（1）将该分支从调用中分离出来；（2）在所有情况下为每个分"
"支提供缺失的默认值；或（3）为每个分支使用相同的名字，并在后续调用中重新命名。"

#: data.table.R:1030
#, c-format
msgid ""
"When .SDcols is a function, it is applied to each column; the output of this "
"function must be a non-missing boolean scalar signalling inclusion/exclusion "
"of the column. However, these conditions were not met for: %s"
msgstr ""
"当传入 .SDcols 的参数为一个方程时，该方程将应用于每一列，并须返回单个非缺失值"
"的布尔值指示该列是否应当被包含/排除。然而上述条件对如下列并不满足：%s"

#: data.table.R:1036
#, c-format
msgid ".SDcols missing at the following indices: %s"
msgstr ".SDcols 的如下位置为缺失值：%s"

#: data.table.R:1038
#, c-format
msgid ".SDcols is a logical vector length %d but there are %d columns"
msgstr ".SDcols 为长度为 %d 的逻辑向量，但共计只有 %d 列"

#: data.table.R:1044
#, c-format
msgid ".SDcols is numeric but has both +ve and -ve indices"
msgstr ".SDcols 为数值，但同时具有 +ve 和 -ve 索引"

#: data.table.R:1046
#, c-format
msgid ".SDcols is numeric but out of bounds [1, %d] at: %s"
msgstr ".SDcols 为数值但在 %2$s 超出了 [1, %1$d]"

#: data.table.R:1050
#, c-format
msgid ".SDcols should be column numbers or names"
msgstr ".SDcols 应为列数或是列名"

#: data.table.R:1052
#, c-format
msgid "Some items of .SDcols are not column names: %s"
msgstr ".SDcols 中的部份项目不是列名: %s"

#: data.table.R:1094
#, c-format
msgid ""
"This j doesn't use .SD but .SDcols has been supplied. Ignoring .SDcols. See ?"
"data.table."
msgstr "此处 j 不使用 .SD 但提供了 .SDcols ，因此忽略 .SDcols详见 ?data.table"

#: data.table.R:1110
#, c-format
msgid ""
".SD is locked. Using := in .SD's j is reserved for possible future use; a "
"tortuously flexible way to modify by group. Use := in j directly to modify "
"by group by reference."
msgstr ""
".SD 已锁定，在 .SD  的 j  中使用 := 进行分组修改是较不直观的方式此功能被保留"
"以供未来使用请直接在 j 中使用 := 依照引用进行分组修改"

#: data.table.R:1118 data.table.R:1130
#, c-format
msgid "In %s(col1=val1, col2=val2, ...) form, all arguments must be named."
msgstr "在 %s(col1=val1, col2=val2, ...) 中，所有参数必须被指名"

#: data.table.R:1135
#, c-format
msgid ""
"LHS of := must be a symbol, or an atomic vector (column names or positions)."
msgstr ":= 的 LHS 必须是符号或是原子向量(列名或是列的位置)"

#: data.table.R:1140
#, c-format
msgid ""
"LHS of := appears to be column positions but are outside [1,ncol] range. New "
"columns can only be added by name."
msgstr ":= 的 LHS 是列的位置但超出了 [1,ncol] 的范围新列只能以名称的方式新增"

#: data.table.R:1143
#, c-format
msgid ""
"LHS of := isn't column names ('character') or positions ('integer' or "
"'numeric')"
msgstr ":= 的 LHS 不是列名('字符')或列的位置('整数'或'数值')"

#: data.table.R:1174
#, c-format
msgid ""
"Invalid .internal.selfref detected and fixed by taking a (shallow) copy of "
"the data.table so that := can add this new column by reference. At an "
"earlier point, this data.table has been copied by R (or was created manually "
"using structure() or similar). Avoid names<- and attr<- which in R currently "
"(and oddly) may copy the whole data.table. Use set* syntax instead to avoid "
"copying: ?set, ?setnames and ?setattr. If this message doesn't help, please "
"report your use case to the data.table issue tracker so the root cause can "
"be fixed or this message improved."
msgstr ""
"侦测到无效的 .internal.selfref ，已藉由获取 data.table 的(浅层)副本的方式修复"
"以便 := 能利用引用加入新列在过去的某个时间点，此 data.table 已被 R 复制(或是"
"以 structure()等方式手动生成)请避免 names<- 与 attr<- 等目前(与偶发)可能会在 "
"R 中复制整个data.table的操作请改用 set* 语法以避免复制，详见 ?set、?setnames "
"及 ?setattr如果以上讯息无法提供帮助，请回报你的案例至 data.table 问题追踪以助"
"于修复根本原因或改进本讯息"

#: data.table.R:1205
#, c-format
msgid ""
"Cannot assign to an under-allocated recursively indexed list -- L[[i]][,:=] "
"syntax is only valid when i is length 1, but its length is %d"
msgstr ""
"无法指定配置不足的递归索引列表-- L[[i]][,:=] 语法只有在 i 长度为1时有效，但它"
"的長度是 %d"

#: data.table.R:1207
#, c-format
msgid "Internal error -- item '%s' not found in names of list"
msgstr "内部错误 -- 未能在列表名称中找到名为 '%s' 的项"

#: data.table.R:1236 data.table.R:1249
#, c-format
msgid "Internal error -- column(s) not found: %s"
msgstr "内部错误 -- 找不到此列: %s"

#: data.table.R:1261
#, c-format
msgid ""
"strptime() usage detected and wrapped with as.POSIXct(). This is to minimize "
"the chance of assigning POSIXlt columns, which use 40+ bytes to store one "
"date (versus 8 for POSIXct). Use as.POSIXct() (which will call strptime() as "
"needed internally) to avoid this warning."
msgstr ""
"侦测到使用 strptime() ，已用 as.POSIXct() 包裹这么做是为了尽量避免列被指定为 "
"POSIXltPOSIXlt用40个以上的位元组储存日期(相较于 POSIXct 只用8位元组)请使用 "
"as.POSIXct() 以避免本警告 (此函数会根据需求在内部调用 strptime())"

#: data.table.R:1278
#, c-format
msgid ""
"Variable '%s' is not found in calling scope. Looking in calling scope "
"because this symbol was prefixed with .. in the j= parameter."
msgstr ""
"未能在调用环境中找到变量 '%s'。在调用环境中查询该变量的原因是因为在 j= 的传入参"
"数中该符号以 .. 为前缀。"

#: data.table.R:1290
#, c-format
msgid "Internal error: xcolAns does not pass checks: %d/%d/%d/%s"
msgstr "内部错误 : xcolAns 无法通过检查: %d/%d/%d/%s"

#: data.table.R:1300
#, c-format
msgid ""
"Internal error: irows is NULL when making join result at R level. Should no "
"longer happen now we use CsubsetDT earlier."
msgstr ""
"内部错误 : 在 R 生成连接结果时，irows为 NULL 我们已使用了 CsubsetDT，现在不应"
"该再发生了"

#: data.table.R:1364
#, c-format
msgid ""
"j (the 2nd argument inside [...]) is a single symbol but column name '%1$s' "
"is not found. If you intended to select columns using a variable in calling "
"scope, please try DT[, ..%1$s]. The .. prefix conveys one-level-up similar "
"to a file system path."
msgstr ""
"j（在 [...] 中的第二个参数）是单一符号，但未找到列名 '%1$s'。如果你打算在调用"
"环境中使用变量选择列，请尝试 DT[, ..%1$s]。.. 前缀表示上一级，类似于文件系统"
"路径。"

#: data.table.R:1419
#, c-format
msgid ""
"Internal error: j has created a data.table result containing a NULL column"
msgstr "内部错误 : j 创建了一个有列为 NULL 的 data.table"

#: data.table.R:1429
#, c-format
msgid ""
"The column '.N' can't be grouped because it conflicts with the special .N "
"variable. Try setnames(DT,'.N','N') first."
msgstr ""
"无法对 '.N' 列进行分组，因为与 data.table 特有的 .N 变量冲突请先尝试 "
"setnames(DT,'.N','N')"

#: data.table.R:1430
#, c-format
msgid ""
"The column '.I' can't be grouped because it conflicts with the special .I "
"variable. Try setnames(DT,'.I','I') first."
msgstr ""
"无法对 '.I' 列进行分组，因为与 data.table 特有的 .I 变量冲突请先尝试 "
"setnames(DT,'.I','I')"

#: data.table.R:1457
#, c-format
msgid "logical error. i is not data.table, but mult='all' and 'by'=.EACHI"
msgstr "逻辑错误: i 不是data.table，但 mult='all' 及 'by'=.EACHI"

#: data.table.R:1480
#, c-format
msgid "Internal error: by= is missing"
msgstr "内部错误 : 缺少 by="

#: data.table.R:1521
#, c-format
msgid "Internal error: byindex not the index name"
msgstr "内部错误 : byindex 不是索引(index)名称"

#: data.table.R:1524
#, c-format
msgid "Internal error: byindex not found"
msgstr "内部错误 : 找不到 byindex"

#: data.table.R:1797
#, c-format
msgid ""
"Unable to optimize call to mean() and could be very slow. You must name 'na."
"rm' like that otherwise if you do mean(x,TRUE) the TRUE is taken to mean "
"'trim' which is the 2nd argument of mean. 'trim' is not yet optimized."
msgstr ""
"无法优化对 mean() 的调用，这可能导致运行非常缓慢您必须使用 na.rm=TRUE，否则如"
"果您直接使用 mean(x,TRUE)会被认定为 trim=TRUE，trim 是 mean() 中尚未被优化的"
"第二顺位参数"

#: data.table.R:1834
#, c-format
msgid "Internal error: length(irows)!=length(o__)"
msgstr "内部错误：length(irows)!=length(o__)"

#: data.table.R:1935
#, c-format
msgid ""
"The setkey() normally performed by keyby= has been skipped (as if by= was "
"used) because := is being used together with keyby= but the keyby= contains "
"some expressions. To avoid this warning, use by= instead, or provide "
"existing column names to keyby=."
msgstr ""
"因为`:=`与`keyby=`一起使用且`keyby=`含有表达式, 所以代码跳过了一般`keyby=`会"
"执行的`setkey()` -- 代码只执行了`by=`。若要避免此警告, 请使用`by=`, 或者提供"
"`keyby=`现有的列名"

#: data.table.R:1950
#, c-format
msgid "Internal error: jvnames is length %d but ans is %d and bynames is %d"
msgstr "内部错误：jvnames 长度为 %d，但是 ans 长度为 %d 且 bynames 为 %d"

#: data.table.R:2020
#, c-format
msgid "rownames and rownames.value cannot both be used at the same time"
msgstr "rownames和rownames.value 不能同时使用"

#: data.table.R:2025
#, c-format
msgid ""
"length(rownames)==%d but nrow(DT)==%d. The rownames argument specifies a "
"single column name or number. Consider rownames.value= instead."
msgstr "length(rownames)==%d 但 nrow(DT)==%d。 rownames参数为单一列名或单一数值。请考虑使用`rownames.values=`。"

#: data.table.R:2029
#, c-format
msgid ""
"length(rownames)==0 but should be a single column name or number, or NULL"
msgstr ""
"行名长度为零，`length(rownames)==0`，但应该为单一列名，单一数值，或NULL"

#: data.table.R:2033
#, c-format
msgid ""
"rownames is TRUE but key has multiple columns %s; taking first column x[,1] "
"as rownames"
msgstr "rownames 为 TRUE但键(key)为多个列 %s；将使用第一列 x[,1] 为行名。"

#: data.table.R:2043
#, c-format
msgid "'%s' is not a column of x"
msgstr "'%s' 不是x的一个列"

#: data.table.R:2049
#, c-format
msgid ""
"as.integer(rownames)==%d which is outside the column number range [1,"
"ncol=%d]."
msgstr "as.integer(rownames)==%d 不在列索引范围内 [1,ncol%d]。"

#: data.table.R:2054
#, c-format
msgid "length(rownames.value)==%d but should be nrow(x)==%d"
msgstr "length(rownames.value)==%d 但应该是 nrow(x)==%d"

#: data.table.R:2116
#, c-format
msgid ""
"Internal error: as.matrix.data.table length(X)==%d but a dimension is zero"
msgstr ""
"内部错误: as.matrix.data.table length(X)==%d 但有一个维度为零"

#: data.table.R:2152
#, c-format
msgid ""
"When i is a matrix in DT[i]<-value syntax, it doesn't make sense to provide j"
msgstr "当i以`DT[i]<-value`的形式出现，不需要提供j"

#: data.table.R:2162
#, c-format
msgid "j must be an atomic vector, see ?is.atomic"
msgstr "j必须是原子向量，请参考 ?is.atomic"

#: data.table.R:2163
#, c-format
msgid "NA in j"
msgstr "j里有NA"

#: data.table.R:2169
#, c-format
msgid "j must be vector of column name or positions"
msgstr "j 必须是列名(column name)或列位(column position)的向量"

#: data.table.R:2170
#, c-format
msgid ""
"Attempt to assign to column position greater than ncol(x). Create the column "
"by name, instead. This logic intends to catch (most likely) user errors."
msgstr ""
"试图指定至比ncol(x)还大的列位(column position)。请指定至列名(column name)。一"
"般来说用列名取代列位能解决大部分错误。"

#: data.table.R:2237
#, c-format
msgid ""
"data.table inherits from data.frame (from v1.5), but this data.table does "
"not. Has it been created manually (e.g. by using 'structure' rather than "
"'data.table') or saved to disk using a prior version of data.table?"
msgstr ""
"data.table继承自data.frame(v1.5)，但这个data.table并不是。请检查这个data."
"table是不是手动创建的（可能创建时使用了`structure()`而非`data.table()`),或者"
"是不是使用了更早的data.table版本创建后存到硬盘了。"

#: data.table.R:2246
#, c-format
msgid "attempting to assign invalid object to dimnames of a data.table"
msgstr "试图指定无效对象给data.table的维度名(dimnames)"

#: data.table.R:2247
#, c-format
msgid "data.tables do not have rownames"
msgstr "data.tables没有rownames"

#: data.table.R:2248 data.table.R:2626
#, c-format
msgid "Can't assign %d names to a %d-column data.table"
msgstr "无法将 %d 个名字赋值给一个包含 %d 列的 data.table"

#: data.table.R:2327
#, c-format
msgid "'subset' must evaluate to logical"
msgstr "'subset' 必须为logical"

#: data.table.R:2370
#, c-format
msgid "Argument 'invert' must be logical TRUE/FALSE"
msgstr " 'invert' 的参数是逻辑值，必须是 TRUE/FALSE"

#: data.table.R:2411
#, c-format
msgid "x argument must be a data.table"
msgstr "参数 x 必须是一个 data.table"

#: data.table.R:2416
#, c-format
msgid "group length is 0 but data nrow > 0"
msgstr "分组长度为0，但 data nrow > 0"

#: data.table.R:2418
#, c-format
msgid ""
"passing 'f' argument together with 'by' is not allowed, use 'by' when split "
"by column in data.table and 'f' when split by external factor"
msgstr ""
"不可同时指定参数 'f' 和参数 'by' ，当利用 data.table的纵列进行数据分割时,请使"
"用参数 'by'；当利用外部因子进行数据分割时，请使用参数 'f'"

#: data.table.R:2422
#, c-format
msgid "Either 'by' or 'f' argument must be supplied"
msgstr "必须提供参数 'by' 或参数 'f'"

#: data.table.R:2424
#, c-format
msgid "Column '.ll.tech.split' is reserved for split.data.table processing"
msgstr "为 split.data.table 进程，纵列 '.ll.tech.split' 被保存"

#: data.table.R:2425
#, c-format
msgid "Column '.nm.tech.split' is reserved for split.data.table processing"
msgstr "为 split.data.table 进程，纵列 '.nm.tech.split' 被保存"

#: data.table.R:2426
#, c-format
msgid "Argument 'by' must refer to column names in x"
msgstr "参数 'by' 只适用于 x 中的列名"

#: data.table.R:2427
#, c-format
msgid ""
"Argument 'by' must refer only to atomic-type columns, but the following "
"columns are non-atomic: %s"
msgstr "参数 'by' 只适用于原子类型的纵列，但现在关联的纵列不是原子类型: %s"

#: data.table.R:2557
#, c-format
msgid ""
"x is not a data.table|frame. Shallow copy is a copy of the vector of column "
"pointers (only), so is only meaningful for data.table|frame"
msgstr ""
"浅拷贝（shallow copy）只是列指针向量的拷贝，因此仅对 data.table或data.frame 有意义，而 x "
"不是 data.table或data.frame"

#: data.table.R:2566
#, c-format
msgid "setalloccol attempting to modify `*tmp*`"
msgstr "setalloccol 试图修改 '*tmp*'"

#: data.table.R:2601
#, c-format
msgid ""
"Input is a length=1 logical that points to the same address as R's global "
"value. Therefore the attribute has not been set by reference, rather on a "
"copy. You will need to assign the result back to a variable. See issue #1281."
msgstr ""
"输入值是一个指向与R全局值相同位置的长度为1的逻辑值。因此，该属性是通过副本，"
"而不是reference 的形式设置。您需要将结果分配回一个变量，参看 issue #1281"

#: data.table.R:2616
#, c-format
msgid "x is not a data.table or data.frame"
msgstr "x 不是 data.table 或 data.frame."

#: data.table.R:2618
#, c-format
msgid "x has %d columns but its names are length %d"
msgstr "x有%d列，但其列名的长度为%d"

#: data.table.R:2625
#, c-format
msgid "Passed a vector of type '%s'. Needs to be type 'character'."
msgstr "传入了一个类型为 '%s' 的向量。须为 'character' 类型。"

#: data.table.R:2638
#, c-format
msgid "'new' is not a character vector or a function"
msgstr "'new' 既不是特征向量也不是 function"

#: data.table.R:2640
#, c-format
msgid "NA in 'new' at positions %s"
msgstr "在 'new' 中有NA值 %s"

#: data.table.R:2641
#, c-format
msgid "Some duplicates exist in 'old': %s"
msgstr "在'old' 中存在重复名称: %s"

#: data.table.R:2643
#, c-format
msgid "'old' is type %s but should be integer, double or character"
msgstr "'old' 为 %s 类型，但只接受整型、浮点型或者字符串型"

#: data.table.R:2644
#, c-format
msgid "'old' is length %d but 'new' is length %d"
msgstr "'old' 长度为 %d 但 'new' 的长度为 %d"

#: data.table.R:2645
#, c-format
msgid "NA (or out of bounds) in 'old' at positions %s"
msgstr "NA(或超出界限)出现在'old' 的位置 %s"

#: data.table.R:2648
#, c-format
msgid ""
"Item %d of 'old' is '%s' which appears several times in column names. Just "
"the first will be changed. There are %d other items in 'old' that are also "
"duplicated in column names."
msgstr "'old' 中的第 %d 项 '%s' 在列名中重复出现。仅第一个会被修改。在 'old' "
"中仍有 %d 项在列名中重复出现。"

#: data.table.R:2656
#, c-format
msgid ""
"Items of 'old' not found in column names: %s. Consider skip_absent=TRUE."
msgstr "在 'old' 中未找到如下列名：%s。请考虑设置 skip_absent=TRUE。"

#: data.table.R:2666
#, c-format
msgid "Internal error: length(i)!=length(new)"
msgstr "内部错误:length(i)!=length(new)"

#: data.table.R:2695
#, c-format
msgid ""
"x has some duplicated column name(s): %s. Please remove or rename the "
"duplicate(s) and try again."
msgstr "x 中有如下重复的列名：%s。请移除或者重命名重复项后重试。"

#: data.table.R:2697
#, c-format
msgid "Provide either before= or after= but not both"
msgstr "提供 before= 或 after= ，但两者不能同时存在"

#: data.table.R:2699
#, c-format
msgid "before=/after= accept a single column name or number, not more than one"
msgstr "before=/after= 只接受一个列名或列号，不能多于一个"

#: data.table.R:2754
#, c-format
msgid "Input is %s but should be a plain list of items to be stacked"
msgstr "项是 %s 但应该叠加普通列表项"

#: data.table.R:2758
#, c-format
msgid ""
"idcol must be a logical or character vector of length 1. If logical TRUE the "
"id column will named '.id'."
msgstr ""
"idcol必须为逻辑型向量或长度为1的字符型向量.如果逻辑值为TRUEid 列会命名为'.id'"

#: data.table.R:2763
#, c-format
msgid "use.names=NA invalid"
msgstr "use.names=NA 无效赋值"

#: data.table.R:2765
#, c-format
msgid ""
"use.names='check' cannot be used explicitly because the value 'check' is new "
"in v1.12.2 and subject to change. It is just meant to convey default "
"behavior. See ?rbindlist."
msgstr ""
"请勿直接使用use.names='check'，因为值'check'为新增在v1.12.2中后续有所变化，仅"
"用表示默认模式详见 ?rbindlist"

#: data.table.R:2780
#, c-format
msgid ""
"Check that is.data.table(DT) == TRUE. Otherwise, :=, `:=`(...) and let(...) "
"are defined for use in j, once only and in particular ways. See help(\":=\")."
msgstr ""
"检查是否is.data.table(DT) == TRUE,否则,:=, `:=`(...), 和 let(...) 为被界定在j使用，仅一"
"次以特别的方式使用,详见help(\":=\")"

#: data.table.R:2786
#, c-format
msgid ""
"setDF only accepts data.table, data.frame or list of equal length as input"
msgstr "setDF仅允许data.table，data.frame或者同样长度的列表作为输入"

#: data.table.R:2787
#, c-format
msgid "rownames contains duplicates"
msgstr "行名含有重复"

#: data.table.R:2794 data.table.R:2805 data.table.R:2828
#, c-format
msgid "rownames incorrect length; expected %d names, got %d"
msgstr "行名长度不正确;需要 %d 名 受到 %d"

#: data.table.R:2813
#, c-format
msgid "All elements in argument 'x' to 'setDF' must be of same length"
msgstr "'setDF'中的参数'x'的所有元素必须同等长度"

#: data.table.R:2842
#, c-format
msgid "Cannot find symbol %s"
msgstr "无法找到符号 %s"

#: data.table.R:2849
#, c-format
msgid ""
"Cannot convert '%1$s' to data.table by reference because binding is locked. "
"It is very likely that '%1$s' resides within a package (or an environment) "
"that is locked to prevent modifying its variable bindings. Try copying the "
"object to your current environment, ex: var <- copy(var) and then using "
"setDT again."
msgstr ""
"无法通过引用直接将 '%1$s' 转换成 data.table，因其与所在环境已绑定。 这有很大"
"可能是因为 '%1$s' 存在于一个包（或环境）中，该包（或环境）已被锁定从而无法修"
"改其绑定的变量。可以尝试将该对象复制到你的现有环境中，如：var <- copy(var)"
"然后再运行 setDT。"

#: data.table.R:2856
#, c-format
msgid ""
"Some columns are a multi-column type (such as a matrix column): %s. setDT "
"will retain these columns as-is but subsequent operations like grouping and "
"joining may fail. Please consider as.data.table() instead which will create "
"a new column for each embedded column."
msgstr ""
"某些列为包含多列的类型（如矩阵列）：%s。setDT 会保留这些列，但后续的操作如分"
"组（grouping）和联接（joining）等操作可能会失败。请考虑使用 as.data.table() 因"
"为它会为每个内嵌列建立一个新列。"

#: data.table.R:2888
#, c-format
msgid ""
"Column %d is of POSIXlt type. Please convert it to POSIXct using as.POSIXct "
"and run setDT again. We do not recommend use of POSIXlt at all because it "
"uses 40 bytes to store one date."
msgstr ""
"第 %d 列属于 POSIXlt 类型。请使用 as.POSIXct 将其转换为 POSIXct 类型并再次运行"
"setDT。我们非常不推荐使用 POSIXlt 类型，因为它需使用 40 个字节来存储一个日期。"

#: data.table.R:2894
#, c-format
msgid ""
"All elements in argument 'x' to 'setDT' must be of same length, but the "
"profile of input lengths (length:frequency) is: %s\n"
"The first entry with fewer than %d entries is %d."
msgstr ""
"'setDT' 参数 'x' 中所有的元素均须为同一长度，但输入元素的长度频数表（长度:频"
"数）为：%s\n"
"x中第一个长度比 %d 少的元素为第 %d 项。"

#: data.table.R:2911
#, c-format
msgid ""
"Argument 'x' to 'setDT' should be a 'list', 'data.frame' or 'data.table'"
msgstr ""
"'setDT' 参数 'x' 应为一个列表（'list'），数据框（'data.frame'）或 'data."
"table'"

#: data.table.R:2926
#, c-format
msgid "Item '%s' not found in names of input list"
msgstr "元素 '%s' 不存在于输入列表的元素名中"

#: data.table.R:2951 data.table.R:2976
#, c-format
msgid "'prefix' must be NULL or a character vector of length 1."
msgstr "'prefix' 必须为 空（NULL）或者长度为 1 的字符向量。"

#: data.table.R:2954 data.table.R:2979
#, c-format
msgid "x is a single vector, non-NULL 'cols' doesn't make sense."
msgstr "x 是单个向量，非空的 'cols' 没有意义。"

#: data.table.R:2958 data.table.R:2983
#, c-format
msgid "x is a list, 'cols' cannot be 0-length."
msgstr "x 是一个列表（list），'cols' 长度不能为0。"

#: data.table.R:3092
#, c-format
msgid ""
"RHS of %s is length %d which is not 1 or nrow (%d). For robustness, no "
"recycling is allowed (other than of length 1 RHS). Consider %%in%% instead."
msgstr ""
"%s 的右手侧 (RHS) 长度为 %d, 其非 1 或 总行数 nrow (%d)。考虑到程序的稳健性，"
"只有在右侧元素长度为 1 的情况下，我们才会对之进行循环。考虑改用 %%in%% 。"

#: data.table.R:3120
#, c-format
msgid ""
"Internal error in .isFastSubsettable. Please report to data.table developers"
msgstr ".isFastSubsettable 产生了内部错误。请向 data.table 开发者报告"

#: data.table.R:3207
#, c-format
msgid ""
"'on' argument should be a named atomic vector of column names indicating "
"which columns in 'i' should be joined with which columns in 'x'."
msgstr ""
"'on' 参数应为一个有子项名字的原子列名向量，指明'i' 中的哪些列应与 'x' 中的哪"
"些列联接。"

#: data.table.R:3248
#, c-format
msgid ""
"Found more than one operator in one 'on' statement: %s. Please specify a "
"single operator."
msgstr "在一个 'on' 语句中出现了多个操作符（operator）：%s。请仅指定单个操作"
"符。"

#: data.table.R:3271
#, c-format
msgid ""
"'on' contains no column name: %s. Each 'on' clause must contain one or two "
"column names."
msgstr "'on' 语句中包含非列名的项：%s。每个'on' 语句中必须包含一个或两个列名。"

#: data.table.R:3273
#, c-format
msgid ""
"'on' contains more than 2 column names: %s. Each 'on' clause must contain "
"one or two column names."
msgstr "'on' 语句包含超过 2 个列名：%s。每个'on' 语句中必须包含一个或两个列名。"

#: data.table.R:3278
#, c-format
msgid "Invalid join operators %s. Only allowed operators are %s."
msgstr "无效联接操作符 %s。只允许如下操作符: %s。"

#: devel.R:16
#, c-format
msgid "There is no package %s in provided repository."
msgstr "所提供的资料库中不含包%s"

#: duplicated.R:7
#, c-format
msgid "'fromLast' must be TRUE or FALSE"
msgstr "'fromLast' 必须为 TRUE 或 FALSE"

#: duplicated.R:105
#, c-format
msgid "x must be an atomic vector or data.frames/data.tables"
msgstr "x 必须是原子向量或data.frame/data.table"

#: fcast.R:7
#, c-format
msgid "Using '%s' as value column. Use 'value.var' to override"
msgstr "用 '%s' 作为 value 列。可使用 'value.var' 修改"

#: fcast.R:20 fmelt.R:16
#, c-format
msgid ""
"The %1$s generic in data.table has been passed a %2$s, but data.table::%1$s "
"currently only has a method for data.tables. Please confirm your input is a "
"data.table, with setDT(%3$s) or as.data.table(%3$s). If you intend to use a "
"method from reshape2, try installing that package first, but do note that "
"reshape2 is superseded and is no longer actively developed."
msgstr ""
"data.table 中的 %1$s 泛型方法接收到了一个 %2$s 对象，但 data.table::%1$s 目前"
"只有一个针对 data.table 的方法。请确认你的输入是一个 data.table，或使用 "
"setDT(%3$s) 或 as.data.table(%3$s)。如果你想使用 reshape2 中的方法，请先安装"
"该包，但请注意 reshape2 已被其它包取代且不再积极开发。"

#: fcast.R:21
#, c-format
msgid ""
"The %1$s generic in data.table has been passed a %2$s and will attempt to "
"redirect to the relevant reshape2 method; please note that reshape2 is "
"superseded and is no longer actively developed, and this redirection is now "
"deprecated. Please do this redirection yourself like reshape2::%1$s(%3$s). "
"In the next version, this warning will become an error."
msgstr ""
"data.table 中的 %1$s 泛型方法接收到了一个 %2$s 对象，将尝试重定向使用"
"reshape2 包中相关的方法。请注意 reshape2 包已经被其实包取代且不再积极开发，"
"故该重定向目前也不推荐使用。请手动执行该重定向，如 reshape2::%1$s(%3$s)。"
"下一版本中，本警告将变成一个错误。"

#: fcast.R:31
#, c-format
msgid ""
"Invalid formula. Cast formula should be of the form LHS ~ RHS, for e.g., a + "
"b ~ c."
msgstr "无效的公式。所转换的公式的形式应为LHS ~ RHS，如a + b ~ c。"

#: fcast.R:36
#, c-format
msgid "data.table to cast must have unique column names"
msgstr "要转换的data.table必须具有唯一的列名"

#: fcast.R:60
#, c-format
msgid "value.var values %s are not found in 'data'."
msgstr "value.var 的值 %s 无法在 'data' 中找到。"

#: fcast.R:76
#, c-format
msgid ""
"When 'fun.aggregate' and 'value.var' are both lists, 'value.var' must be "
"either of length =1 or =length(fun.aggregate)."
msgstr ""
"当 'fun.aggregate' 和 'value.var' 同为 list时, 'value.var' 的长度必须为 1 或 "
"length(fun.aggregate)。"

#: fcast.R:109
#, c-format
msgid "'data' must be a data.table."
msgstr "'data' 必须为 data.table"

#: fcast.R:111
#, c-format
msgid "'drop' must be logical TRUE/FALSE"
msgstr "'drop' 必须为逻辑 TRUE/FALSE"

#: fcast.R:128
#, c-format
msgid "Column [%s] not found or of unknown type."
msgstr "列 [%s]] 无法找到或其类型未知。"

#: fcast.R:143
#, c-format
msgid "Columns specified in formula can not be of type list"
msgstr "在formula中指定的列不应为列表类型"

#: fcast.R:159
#, c-format
msgid "fun.aggregate is NULL, but found duplicate row/column combinations, so defaulting to length(). That is, the variables [[a, c]] used in 'formula' do not uniquely identify rows in the input 'data'. In such cases, 'fun.aggregate' is used to derive a single representative value for each combination in the output data.table, for example by summing or averaging (fun.aggregate=sum or fun.aggregate=mean, respectively). See ?dcast.data.table for more details."
msgstr "聚合函数缺失，将默认采用'length'"

#: fcast.R:165
msgid ""
"Aggregating function(s) should take vector inputs and return a single value "
"(length=1). However, function(s) returns length!=1. This value will have to "
"be used to fill any missing combinations, and therefore must be length=1. "
"Either override by setting the 'fill' argument explicitly or modify your "
"function to handle this case appropriately."
msgstr ""
"聚合函数应接收向量输入并返回单个值（长度为1）。然而，当前函数返回的长度不为1。"
"因为该单个值将用于填充任何缺失的组合，故必须为长度为1。你可以通过显式设置"
"'fill' 参数来覆盖该值，或修改你的函数以处理该情况。"

#: fcast.R:222
#, c-format
msgid "Internal error -- empty rhsnames in dcast; please report"
msgstr "内部错误：dcast 中 rhsnames 为空；请报告"

#: fmelt.R:17
#, c-format
msgid ""
"The %1$s generic in data.table has been passed a %2$s and will attempt to "
"redirect to the relevant reshape2 method; please note that reshape2 is "
"superseded and is no longer actively developed, and this redirection is now "
"deprecated. To continue using melt methods from reshape2 while both "
"libraries are attached, e.g. melt.list, you can prepend the namespace, i.e. "
"reshape2::%1$s(%3$s). In the next version, this warning will become an error."
msgstr ""
"data.table 中的 %1$s 泛型方法接收到了一个 %2$s 对象，将尝试重定向使用"
"reshape2 包中相关的方法。请注意 reshape2 包已经被其实包取代且不再积极开发，"
"故该重定向目前也不推荐使用。要在 data.table 和 reshape2 包同时载入的情况下"
"继续使用 reshape2 包中的 melt 方法，如 melt.list，你可指定命名空间，如"
"reshape2::%1$s(%3$s)。下一版本中，本警告将变成一个错误。"

#: fmelt.R:28
#, c-format
msgid "Input patterns must be of type character."
msgstr "输入的 patterns 必须是字符类型。"

#: fmelt.R:32
#, c-format
msgid "Pattern(s) not found: [%s]"
msgstr "未找到下列 pattern：[%s]"

#: fmelt.R:46
#, c-format
msgid ""
"each ... argument to measure must be either a symbol without argument name, "
"or a function with argument name, problems: %s"
msgstr ""
"measure 中的每个 ... 参数必须为无参数名的符号，或带有参数名的函数，问题：%s"

#: fmelt.R:54
#, c-format
msgid ""
"group names specified in ... conflict with measure argument names; please "
"fix by changing group names: %s"
msgstr ""
"在 ... 中指定的组名与 measure 参数名冲突；请通过修改组名来解决：%s"

#: fmelt.R:60
#, c-format
msgid ""
"each ... argument to measure must be a function with at least one argument, "
"problem: %s"
msgstr ""
"measure 中的每个 ... 参数必须为至少带有一个参数的函数，问题：%s"

#: fmelt.R:74
#, c-format
msgid ""
"both sep and pattern arguments used; must use either sep or pattern (not "
"both)"
msgstr ""
"同时使用了 sep 和 pattern 参数；必须使用 sep 或 pattern（不能同时使用）"

#: fmelt.R:77
#, c-format
msgid "multiple.keyword must be a character string with nchar>0"
msgstr "multiple.keyword 必须为一个字符长度大于0(nchar>0)的字符串"

#: fmelt.R:80
#, c-format
msgid "cols must be a character vector of column names"
msgstr "cols 必须是一个由列名组成的字符串向量"

#: fmelt.R:88
#, c-format
msgid "in measurev, %s must be named, problems: %s"
msgstr "在 measurev 中，%s 必须命名，问题：%s"

#: fmelt.R:94
#, c-format
msgid "%s should be uniquely named, problems: %s"
msgstr "%s 应命名唯一，问题：%s"

#: fmelt.R:99
#, c-format
msgid "number of %s =%d must be same as %s =%d"
msgstr "%s 的数量 =%d 必须与 %s 的数量 =%d 相同"

#: fmelt.R:106
#, c-format
msgid "pattern must be character string"
msgstr "pattern 必须是一个字符串"

#: fmelt.R:111
#, c-format
msgid ""
"pattern did not match any cols, so nothing would be melted; fix by changing "
"pattern"
msgstr ""
"pattern 未匹配到任何列，因此不会有任何列被融合；请通过修改 pattern 来解决"

#: fmelt.R:115
#, c-format
msgid ""
"pattern must contain at least one capture group (parenthesized sub-pattern)"
msgstr ""
"pattern 必须包含至少一个捕获组（括号子模式）"

#: fmelt.R:123
#, c-format
msgid "sep must be character string"
msgstr "sep 必须是一个字符串"

#: fmelt.R:129
#, c-format
msgid ""
"each column name results in only one item after splitting using sep, which "
"means that all columns would be melted; to fix please either specify melt on "
"all columns directly without using measure, or use a different sep/pattern "
"specification"
msgstr ""
"使用 sep 分割后，每个列名只产生一个条目，这意味着所有列都将被融合；请通过直接"
"指定所有列同时不使用 measure 来解决，或使用其他 sep/pattern 来解决"

#: fmelt.R:138
#, c-format
msgid ""
"number of unique column IDs =%d is less than number of melted columns =%d; "
"fix by changing pattern/sep"
msgstr ""
"唯一列 ID 的数量 =%d 少于融合的列数量 =%d；请通过修改 pattern/sep 来解决"

#: fmelt.R:148
#, c-format
msgid ""
"in the measurev fun.list, each non-NULL element must be a function with at "
"least one argument, problem: %s"
msgstr ""
"在 measurev 的 fun.list 中，每个非 NULL 元素必须为至少带有一个参数的函数，"
"问题：%s"

#: fmelt.R:152
#, c-format
msgid ""
"each conversion function must return an atomic vector with same length as "
"its first argument, problem: %s"
msgstr ""
"每个转换函数必须返回一个与其第一个参数长度相同的原子向量，问题：%s"

#: fmelt.R:155
#, c-format
msgid "%s conversion function returned vector of all NA"
msgstr "%s 转换函数返回了全为 NA 的向量"

#: fmelt.R:161
#, c-format
msgid ""
"number of unique groups after applying type conversion functions less than "
"number of groups, change type conversion"
msgstr ""
"应用类型转换函数后，唯一组数量少于组总数量，请修改类型转换函数"

#: fmelt.R:166
#, c-format
msgid ""
"%s column class=%s after applying conversion function, but must be character"
msgstr ""
"应用转换函数后，%s 列的类型=%s，但此处要求必须为字符串类型"

#: fmelt.R:170
#, c-format
msgid "%s is the only group; fix by creating at least one more group"
msgstr "%s 是唯一的组；请通过再创建至少一个组来解决"

#: fmelt.R:193
#, c-format
msgid "'data' must be a data.table"
msgstr "'data' 必须是一个 data.table"

#: fmelt.R:212
#, c-format
msgid ""
"'value.name' provided in both 'measure.vars' and 'value.name argument'; "
"value provided in 'measure.vars' is given precedence."
msgstr ""
"在 'measure.vars' 和 'value.name' 参数中都提供了 'value.name'；"
"将优先使用 'measure.vars' 中的值。"

#: fmelt.R:215
#, c-format
msgid "Please provide a name to each element of 'measure.vars'."
msgstr "请为 'measure.vars' 中的每个元素提供一个名称。"

#: foverlaps.R:3
#, c-format
msgid ""
"y and x must both be data.tables. Use `setDT()` to convert list/data.frames "
"to data.tables by reference or as.data.table() to convert to data.tables by "
"copying."
msgstr ""
"y 和 x 必须都是 data.table 对象。用 `setDT()` 可以把列表/数据框引用转换为  "
"data.table，或者用 as.data.table() 进行复制转换。"

#: foverlaps.R:9
#, c-format
msgid "maxgap must be a non-negative integer value of length 1"
msgstr "maxgap 必须是一个长度为1的非负整数"

#: foverlaps.R:11
#, c-format
msgid "minoverlap must be a positive integer value of length 1"
msgstr "minoverlap 必须是一个长度为1的正整数"

#: foverlaps.R:13
#, c-format
msgid "which must be a logical vector of length 1. Either TRUE/FALSE"
msgstr "which 必须是一个长度为1的逻辑向量（TRUE/FALSE）"

#: foverlaps.R:15
#, c-format
msgid "nomatch must either be NA or NULL"
msgstr "nomatch 必须是 NA 或 NULL"

#: foverlaps.R:20
#, c-format
msgid "maxgap and minoverlap arguments are not yet implemented."
msgstr "maxgap 和 minoverlap 参数还未实现。"

#: foverlaps.R:22
#, c-format
msgid ""
"y must be keyed (i.e., sorted, and, marked as sorted). Call setkey(y, ...) "
"first, see ?setkey. Also check the examples in ?foverlaps."
msgstr ""
"y 必须有键（key:已经排序并且标记为已排序）。请先用 setkey(y, ...) 设置主"
"键，可以参考 ?setkey 以及 ?foverlaps 中提供的例子。"

#: foverlaps.R:24
#, c-format
msgid ""
"'by.x' and 'by.y' should contain at least two column names (or numbers) each "
"- corresponding to 'start' and 'end' points of intervals. Please see ?"
"foverlaps and examples for more info."
msgstr ""
"'by.x' 和 'by.y' 每个应当包含至少两个列名（或序号），分别对应区间的起始点 "
"'start' 和 结束点 'end'。请参考 ?foverlaps 以及提供的例子。"

#: foverlaps.R:27
#, c-format
msgid ""
"Invalid numeric value for 'by.x'; it should be a vector with values 1 <= by."
"x <= length(x)"
msgstr ""
"无效的 'by.x' 数值，应该是一个向量，其中的值满足 1 <= by.x <= length(x)"

#: foverlaps.R:32
#, c-format
msgid ""
"Invalid numeric value for 'by.y'; it should be a vector with values 1 <= by."
"y <= length(y)"
msgstr "无效的 'by.y' 数值，应当满足 1 <= by.y <= length(y)"

#: foverlaps.R:36
#, c-format
msgid "A non-empty vector of column names or numbers is required for by.x"
msgstr "'by.x' 必须是一个非空向量，包含列名或者序号"

#: foverlaps.R:38
#, c-format
msgid "A non-empty vector of column names or numbers is required for by.y"
msgstr "'by.y'应该是具有列名或者数字非空向量"

#: foverlaps.R:40
#, c-format
msgid ""
"The first %d columns of y's key must be identical to the columns specified "
"in by.y."
msgstr "y 键中的前 %d 列必须与在 by.y 中指定的列一致。"

#: foverlaps.R:42
#, c-format
msgid "Elements listed in 'by.x' must be valid names in data.table x"
msgstr "'by.x'中的元素必须是有效名称对于data.table x"

#: foverlaps.R:44
#, c-format
msgid ""
"Duplicate columns are not allowed in overlap joins. This may change in the "
"future."
msgstr "搭接部分不允许出现重复列。这个要求可能会在未来有所调整。"

#: foverlaps.R:46
#, c-format
msgid ""
"length(by.x) != length(by.y). Columns specified in by.x should correspond to "
"columns specified in by.y and should be of same lengths."
msgstr "当by.x的长度不等于by.y时。by.x中指定的列应该与by.y中指定的列等长。"

#: foverlaps.R:48 foverlaps.R:50 merge.R:26 merge.R:27
#, c-format
msgid ""
"%s has some duplicated column name(s): %s. Please remove or rename the "
"duplicate(s) and try again."
msgstr "%s 中有如下重复的列名：%s。请移除或者重命名重复项后重试。"

#: foverlaps.R:56
#, c-format
msgid ""
"The last two columns in by.x should correspond to the 'start' and 'end' "
"intervals in data.table x and must be integer/numeric type."
msgstr ""
"'by.x'的最后两列应该与data.table x中的'开始'与'结尾'的间隔对应且必须是整数/"
"数字类型"

#: foverlaps.R:60 foverlaps.R:62 foverlaps.R:69 foverlaps.R:71
#, c-format
msgid ""
"NA values in data.table %s '%s' column: '%s'. All rows with NA values in the "
"range columns must be removed for foverlaps() to work."
msgstr "data.table %s 的 '%s' 列中存在缺失值：'%s'。若使 foverlaps() 运行，必"
"须删除指定范围列内所有包含NA值的行。"

#: foverlaps.R:63
#, c-format
msgid ""
"All entries in column '%s' should be <= corresponding entries in column '%s' "
"in data.table x."
msgstr "列 '%s' 中所有条目应该 <= data.table x 中列 '%s' 中对应的条目。"

#: foverlaps.R:66
#, c-format
msgid ""
"The last two columns in by.y should correspond to the 'start' and 'end' "
"intervals in data.table y and must be integer/numeric type."
msgstr ""
"'by.y'的最后两列应该与data.table y中的'开始'与'结尾'的间隔对应且必须是整数/"
"数字类型"

#: foverlaps.R:72
#, c-format
msgid ""
"All entries in column '%s' should be <= corresponding entries in column '%s' "
"in data.table y."
msgstr "列 '%s' 中所有条目应该 <= data.table y中列 '%s' 中对应的条目。"

#: foverlaps.R:77
#, c-format
msgid ""
"Some interval cols are of type POSIXct while others are not. Please ensure "
"all interval cols are (or are not) of POSIXct type"
msgstr ""
"一些间隔列的类型是POSIXct而有些不是。（因此）请确保所有间隔列都是或都不是"
"POSIXct类型"

#: foverlaps.R:83
#, c-format
msgid ""
"POSIXct interval cols have mixed timezones. Overlaps are performed on the "
"internal numerical representation of POSIXct objects (always in UTC epoch "
"time), therefore printed values may give the impression that values don't "
"overlap but their internal representations do Please ensure that POSIXct "
"type interval cols have identical 'tzone' attributes to avoid confusion."
msgstr ""
"POSIXct间隔列有混合的时区。POSIXct对象（始终以UTC纪元时间为准）以内部数字表现"
"形式展现为重叠，因此显示的值可能（使用户）留下'值是不会重叠，但其内部表现显示"
"显示却重叠'的印象，（所以）请确保POSIXct类型的间隔列具有相同的'时区'属性以避"
"免混乱。"

#: foverlaps.R:164 foverlaps.R:166 foverlaps.R:170
#, c-format
msgid "Not yet implemented"
msgstr "尚未实现"

#: foverlaps.R:169
#, c-format
msgid "maxgap > minoverlap. maxgap will have no effect here."
msgstr "最大空隙大于最小重叠，此处的最大空隙无效。"

#: frank.R:3
#, c-format
msgid "length(na.last) = 0"
msgstr "na.last长度等于0"

#: frank.R:5
#, c-format
msgid "length(na.last) > 1, only the first element will be used"
msgstr "当na.last长度大于1时，只会使用第一个元素"

#: frank.R:17
#, c-format
msgid "x is a single vector, non-NULL 'cols' doesn't make sense"
msgstr "x是单个向量，非NULL的'cols'没有意义"

#: frank.R:23
#, c-format
msgid "x is a list, 'cols' can not be 0-length"
msgstr "x是一个list, 'cols'不能为0长度"

#: frank.R:31
#, c-format
msgid ""
"Input column '..na_prefix..' conflicts with data.table internal usage; "
"please rename"
msgstr ""
"输入列 '..na_prefix..' 与 data.table 内部使用变量冲突，请重命名"

#: frank.R:46
#, c-format
msgid ""
"Input column '..stats_runif..' conflicts with data.table internal usage; "
"please rename"
msgstr ""
"输入列 '..stats_runif..' 与 data.table 内部使用变量冲突，请重命名"

#: fread.R:10
#, c-format
msgid "Used more than one of the arguments input=, file=, text= and cmd=."
msgstr "使用了超过一个参数, 包括input=, file=, text= 和 cmd=."

#: fread.R:22
#, c-format
msgid "Argument 'encoding' must be 'unknown', 'UTF-8' or 'Latin-1'."
msgstr "参数 'encoding' 必须为 'unknown', 'UTF-8' 或 'Latin-1'."

#: fread.R:40
#, c-format
msgid "'text=' is type %s but must be character."
msgstr "'text=' 为 %s 类型，但需要其必须为字符串类型。"

#: fread.R:53
#, c-format
msgid ""
"input= must be a single character string containing a file name, a system "
"command containing at least one space, a URL starting 'http[s]://', "
"'ftp[s]://' or 'file://', or, the input data itself containing at least one "
"\\n or \\r"
msgstr ""
"input= 必须是以下其中一种字符串: 一个文件名, 一个含有不少于一个空格的系统命"
"令, 以'http[s]://','ftp[s]://' 或 'file://' 开头的URL, 或是本身就包含至少一个"
"\\n 或 \\r的输入数据"

#: fread.R:58
#, c-format
msgid ""
"input= contains no \\n or \\r, but starts with a space. Please remove the "
"leading space, or use text=, file= or cmd="
msgstr ""
"input= 不包含 \\n 或 \\r, 但是开头有个空格请移除开头的空格, 或使用text=, "
"file= 或 cmd="

#: fread.R:62
#, c-format
msgid ""
"Taking input= as a system command because it contains a space ('%s'). If "
"it's a filename please remove the space, or use file= explicitly. A variable "
"is being passed to input= and when this is taken as a system command there "
"is a security concern if you are creating an app, the app could have a "
"malicious user, and the app is not running in a secure environment; e.g. the "
"app is running as root. Please read item 5 in the NEWS file for v1.11.6 for "
"more information and for the option to suppress this message."
msgstr ""
"因 input= 中包含空格（'%s'），故将其视为一个系统命令处理。如果其为文件名，"
"请将空格去除，或直接使用 file=。当一个变量被传给 input= 但其又被当作一个系"
"统命令来处理时，则存在一定的安全隐患：设想一下你在开发一个 app，而该 app 可"
"能存在恶意用户, 同时这个 app 运行在不安全的环境中，如该 app 被以 root 权限"
"运行。若需获取更多信息或了解哪一选项可禁止本信息，请阅读 v1.11.6 版本 NEWS "
"文件里面的第 5 条。"

#: fread.R:75
#, c-format
msgid ""
"file= must be a single character string containing a filename, or URL "
"starting 'http[s]://', 'ftp[s]://' or 'file://'"
msgstr ""
"file= 须为包含文件名的字符串，或以 'http[s]://'、'ftp[s]://' 或 'file://' 开头"
"的URL字符串。"

#: fread.R:80
#, c-format
msgid ""
"URL requires download.file functionalities from R >=3.2.2. You can still "
"manually download the file and fread the downloaded file."
msgstr ""
"URL 需要 R >=3.2.2 的 download.file 功能。不过你仍可手动下载该文件并使用"
"fread 来读取它。"

#: fread.R:91
#, c-format
msgid "File '%s' does not exist or is non-readable. getwd()=='%s'"
msgstr "文件 '%s' 不存在, 或不可读. getwd()=='%s'"

#: fread.R:92
#, c-format
msgid "File '%s' is a directory. Not yet implemented."
msgstr "文件 '%s' 是个目录。还没有编程实现。"

#: fread.R:94
#, c-format
msgid "File '%s' has size 0. Returning a NULL %s."
msgstr "文件 '%s' 的大小为0. 返回一个NULL %s."

#: fread.R:107
#, c-format
msgid ""
"Compressed files containing more than 1 file are currently not supported."
msgstr ""
"目前不支持包含多个文件的压缩文件。"

#: fread.R:119
#, c-format
msgid ""
"To read gz and bz2 files directly, fread() requires 'R.utils' package which "
"cannot be found. Please install 'R.utils' using 'install.packages('R."
"utils')'."
msgstr ""
"想要直接读取 gz 和 bz2 文件, fread() 需要 'R.utils' 包.请用 'install."
"packages('R.utils')'安装 'R.utils' 包."

#: fread.R:129
#, c-format
msgid ""
"'autostart' is now deprecated and ignored. Consider skip='string' or skip=n"
msgstr ""
"'autostart' 现在已经不再推荐使用且失效, 请考虑用 skip='string' 或 skip=n"

#: fread.R:131
#, c-format
msgid ""
"colClasses is type 'logical' which is ok if all NA but it has some TRUE or "
"FALSE values in it which is not allowed. Please consider the drop= or "
"select= argument instead. See ?fread."
msgstr ""
"colClasses 只能在全部是NA的情况下为逻辑变量. 请考虑使用 drop= 或 select= . 更"
"多信息请参照 ?fread"

#: fread.R:135
#, c-format
msgid "colClasses is not type list or character vector"
msgstr "colClasses 不是列表 (list) 或字符向量 (character vector)"

#: fread.R:140
#, c-format
msgid ""
"colClasses=\"NULL\" (quoted) is interpreted as colClasses=NULL (the default) "
"as opposed to dropping every column."
msgstr ""
"colClasses=\"NULL\" (带引号) 应该被视为 colClasses=NULL (默认情况)而不是弃掉"
"每个列"

#: fread.R:152
#, c-format
msgid "na.strings[%d]==\"%s\" consists only of whitespace, ignoring"
msgstr "na.strings[%d]==\"%s\" 仅包含空格, 已忽略"

#: fread.R:155
#, c-format
msgid ""
"%s. strip.white==TRUE (default) and \"\" is present in na.strings, so any "
"number of spaces in string columns will already be read as <NA>."
msgstr ""
"%s. na.strings 中包含 strip.white==TRUE (默认情况) 和 \"\", 因此(字符类型的)列中"
"的空格会被当作 <NA>."

#: fread.R:157
#, c-format
msgid ""
"%s. Since strip.white=TRUE (default), use na.strings=\"\" to specify that "
"any number of spaces in a string column should be read as <NA>."
msgstr ""
"%s. 因为 strip.white=TRUE (默认情况), 请使用 na.strings=\"\" 以使得(字符类型的)列"
"中的空格会被当作 <NA>."

#: fread.R:161
#, c-format
msgid ""
"%s. But strip.white=FALSE. Use strip.white=TRUE (default) together with na."
"strings=\"\" to turn any number of spaces in string columns into <NA>"
msgstr ""
"%s. 但是 strip.white=FALSE. 请使用 strip.white=TRUE (默认情况), 同时na."
"strings=\"\", 以使得(字符类型的)列中的空格转成 <NA>."

#: fread.R:167
#, c-format
msgid ""
"'data.table' relies on the package 'yaml' to parse the file header; please "
"add this to your library with install.packages('yaml') and try again."
msgstr ""
"'data.table' 依赖 'yaml' 包来分析文件头 (header)请使用 install."
"packages('yaml') 来安装然后再重试."

#: fread.R:171
#, c-format
msgid ""
"Combining a search string as 'skip' and reading a YAML header may not work "
"as expected -- currently, reading will proceed to search for 'skip' from the "
"beginning of the file, NOT from the end of the metadata; please file an "
"issue on GitHub if you'd like to see more intuitive behavior supported."
msgstr ""
"将搜索字符串作为 'skip' 参数的同时读取 YAML 文件头可能会出错 —— 目前读取文件"
"时, 将从文件的开头开始搜索 'skip', 而 不是 从元数据的结尾开始；如果你想要"
"fread 提供更直观的功能支持, 请在 GitHub 上提交一个 issue。"

#: fread.R:181
#, c-format
msgid ""
"Encountered <%s%s> at the first unskipped line (%d), which does not "
"constitute the start to a valid YAML header (expecting something matching "
"regex \"%s\"); please check your input and try again."
msgstr ""
"在第一个未被跳过的行 (%3$d) 中遇到 <%1$s%2$s>。它不是一个有效的 YAML 文件头的开头"
"（有效的开头应符合正则表达式 \"%4$s\"）；请检查你的输入并重试。"

#: fread.R:193
#, c-format
msgid ""
"Reached the end of the file before finding a completion to the YAML header. "
"A valid YAML header is bookended by lines matching the regex \"%s\". Please "
"double check the input file is a valid csvy."
msgstr ""
"至文件的结尾 YAML 文件头仍未结束。一个有效的 YAML 文件头是指符合正则表达式 "
"\"%s\"的行。请再次检查输入文件是否为一有效的 csvy 文件。"

#: fread.R:207
#, c-format
msgid "User-supplied 'header' will override that found in metadata."
msgstr "用户提供的'header'将覆盖元数据中的表头"

#: fread.R:225
#, c-format
msgid ""
"User-supplied column names in 'col.names' will override those found in YAML "
"metadata."
msgstr "用户在“col.names”中提供的列名将覆盖在YAML元数据中找到的列名"

#: fread.R:234
#, c-format
msgid ""
"colClasses dictated by user input and those read from YAML header are in "
"conflict (specifically, for column(s) [%s]); the proceeding assumes the user "
"input was an intentional override and will ignore the type(s) implied by the "
"YAML header; please exclude the column(s) from colClasses if this was "
"unintentional."
msgstr ""
"用户输入的 colClasses 和从 YAML 文件头中读取的 colClasses 冲突（冲突列为 [%s]"
"）；程序会假设用户输入是有意要覆盖 YAML 文件头，因此，YAML 文件头中的类型将被"
"忽略；如果这并非有意为之，请在 colClasses 中排除这些列。"

#: fread.R:255
#, c-format
msgid "User-supplied 'sep' will override that found in metadata."
msgstr "用户提供的“sep”将覆盖元数据中的分隔符"

#: fread.R:260
#, c-format
msgid "User-supplied 'quote' will override that found in metadata."
msgstr "用户提供的“quote”将覆盖元数据中的引号"

#: fread.R:265
#, c-format
msgid "User-supplied 'dec' will override that found in metadata."
msgstr "用户提供的“dec”将覆盖元数据中的小数点分隔符"

#: fread.R:269
#, c-format
msgid "User-supplied 'na.strings' will override that found in metadata."
msgstr "用户提供的“na.strings”将覆盖元数据中对默认值的预处理"

#: fread.R:317
#, c-format
msgid ""
"Column '%s' was requested to be '%s' but fread encountered the following "
"%s:\n"
"\t%s\n"
"so the column has been left as type '%s'"
msgstr ""
"列 '%s' 被指定为 '%s' 类型，但 fread 却遇到了以下"
"%s：\n"
"\t%s\n"
"故该列的类型将被定为 '%s'"

#: fread.R:340
#, c-format
msgid ""
"key argument of data.table() must be a character vector naming columns (NB: "
"col.names are applied before this)"
msgstr ""
"data.table()的key参数必须是字符向量命名的列（NB:col.names在这之前被使用过）"

#: fread.R:349
#, c-format
msgid ""
"index argument of data.table() must be a character vector naming columns "
"(NB: col.names are applied before this)"
msgstr ""
"data.table()的index参数必须是字符向量命名的列（NB:参数col.names在这之前被使用"
"过）"

#: fwrite.R:19
#, c-format
msgid "Argument 'encoding' must be '', 'UTF-8' or 'native'."
msgstr "参数 'encoding' 必须为 '', 'unknown', 'UTF-8' 或 'native'."

#: fwrite.R:24
#, c-format
msgid "dateTimeAs must be a single string"
msgstr "dataTimeAs 必须是单个字符串"

#: fwrite.R:26
#, c-format
msgid "dateTimeAs must be 'ISO','squash','epoch' or 'write.csv'"
msgstr "dateTimeAs 必须是 'ISO'，'squash'，'epoch' 或 'write.csv'"

#: fwrite.R:28
#, c-format
msgid "logicalAsInt has been renamed logical01. Use logical01 only, not both."
msgstr ""
"logicalAsInt 已重命名为 logical01。不要同时使用它们，仅使用 logical01。"

#: fwrite.R:30
#, c-format
msgid ""
"logicalAsInt has been renamed logical01 for consistency with fread. It works "
"fine for now but please change to logical01 at your convenience so we can "
"remove logicalAsInt in future."
msgstr ""
"logicalAsInt 参数已重命名为 logical01 参数以与 fread 保持一致。目前它可以正常"
"工作，但请在方便的时候将其改为 logical01，以便我们在未来删除 logicalAsInt 参数。"

#: fwrite.R:40
#, c-format
msgid "x being coerced from class: matrix to data.table"
msgstr "x 的类将强制从 matrix 转变为 data.table"

#: fwrite.R:79
#, c-format
msgid ""
"If you intended to overwrite the file at %s with an empty one, please use "
"file.remove first."
msgstr "若你想以一空白文件覆盖文件 %s，请先使用 file.remove。"

#: fwrite.R:80
#, c-format
msgid "Input has no columns; doing nothing.%s"
msgstr "输入没有列，不执行任何操作。%s"

#: fwrite.R:83
#, c-format
msgid "Input has no columns; creating an empty file at '%s' and exiting."
msgstr "输入中没有任何列，将创建一个空文件 '%s' 并退出。"

#: fwrite.R:90
#, c-format
msgid ""
"'data.table' relies on the package 'yaml' to write the file header; please "
"add this to your library with install.packages('yaml') and try again."
msgstr ""
"'data.table' 依赖于 'yaml' 包来写文件头；请运行 install.packages('yaml') 安"
"装 'yaml' 包后再试。"

#: groupingsets.R:7 groupingsets.R:25 groupingsets.R:47
#, c-format
msgid "Argument 'x' must be a data.table object"
msgstr "'x' 参数必须是一个 data.table 对象"

#: groupingsets.R:9 groupingsets.R:27 groupingsets.R:53
#, c-format
msgid ""
"Argument 'by' must be a character vector of column names used in grouping."
msgstr "'by' 参数必须是一个字符向量，向量的元素是列名，用于分组。"

#: groupingsets.R:11 groupingsets.R:29 groupingsets.R:59
#, c-format
msgid "Argument 'id' must be a logical scalar."
msgstr "'id' 参数必须是一个逻辑标量。"

#: groupingsets.R:31
#, c-format
msgid "Argument 'j' is required"
msgstr "参数 'j' 是必须的"

#: groupingsets.R:49
#, c-format
msgid ""
"Argument 'x' is a 0-column data.table; no measure to apply grouping over."
msgstr "'x' 参数是一个 0 列的 data.table；无法对其应用分组。"

#: groupingsets.R:51
#, c-format
msgid "Input data.table must not contain duplicate column names."
msgstr "作为输入的 data.table 对象不能含有重复的列名。"

#: groupingsets.R:55
#, c-format
msgid "Argument 'by' must have unique column names for grouping."
msgstr "'by' 参数用于分组，不可包含重复列名。"

#: groupingsets.R:57
#, c-format
msgid "Argument 'sets' must be a list of character vectors."
msgstr "'sets' 参数必须是一个字符向量的列表。"

#: groupingsets.R:62
#, c-format
msgid ""
"All columns used in 'sets' argument must be in 'by' too. Columns used in "
"'sets' but not present in 'by': %s"
msgstr ""
"在 'sets' 参数中应用的所有列也必须在 'by' 中。当前 'sets' 包含而 'by' 中不含"
"的列有：%s"

#: groupingsets.R:64
#, c-format
msgid ""
"When using `id=TRUE` the 'x' data.table must not have a column named "
"'grouping'."
msgstr "当使用 `id=TRUE` 时，data.table 'x' 不能包含名为 'grouping' 的列。"

#: groupingsets.R:66
#, c-format
msgid ""
"Character vectors in 'sets' list must not have duplicated column names "
"within a single grouping set."
msgstr "在单个分组中，'sets' 列表中的字符串向量不能有重复的列名。"

#: groupingsets.R:68
#, c-format
msgid ""
"'sets' contains a duplicate (i.e., equivalent up to sorting) element at "
"index %d; as such, there will be duplicate rows in the output -- note that "
"grouping by A,B and B,A will produce the same aggregations. Use "
"`sets=unique(lapply(sets, sort))` to eliminate duplicates."
msgstr ""
"'sets' 中第 %d 个输入中包含重复的元素（即排序结果相同），因此输出的结果中将"
"包含重复的行。请注意，按照 A、B 分组与按照 B、A 分组的结果是一样的。"
"可使用 `sets=unique(lapply(sets, sort))` 来消除重复项。"

#: groupingsets.R:73
#, c-format
msgid ""
"Expression passed to grouping sets function must not update by reference. "
"Use ':=' on results of your grouping function."
msgstr ""
"传递给分组相关函数的表达式不能通过引用更新。请在你的分组函数返回的结果中使用 "
"':=' 。"

#: groupingsets.R:80
#, c-format
msgid ""
"When using `id=TRUE` the 'j' expression must not evaluate to a column named "
"'grouping'."
msgstr "当 `id=TRUE` 时，'j' 表达式不能针对 'grouping' 列求值。"

#: groupingsets.R:82
#, c-format
msgid ""
"There exists duplicated column names in the results, ensure the column "
"passed/evaluated in `j` and those in `by` are not overlapping."
msgstr "结果中存在重复的列名，请确保 `j` 和 `by` 传递的列中没有发生重叠。"

#: groupingsets.R:92
#, c-format
msgid ""
"Using integer64 class columns require to have 'bit64' package installed."
msgstr "要在列中使用 integer64 类，需要先安装 'bit64' 包。"

#: last.R:38 last.R:79
#, c-format
msgid ""
"'xts' class passed to %s function but 'xts' is not available, you should "
"have 'xts' installed already"
msgstr "'xts'类对象传递给了%s方程，但是'xts'包不可用。您应首先安装'xts'包"

#: merge.R:4
#, c-format
msgid "Argument 'sort' should be logical TRUE/FALSE"
msgstr "参数 'sort' 应为逻辑值 TRUE 或 FALSE"

#: merge.R:6
#, c-format
msgid "Argument 'no.dups' should be logical TRUE/FALSE"
msgstr "参数 'no.dups' 应为逻辑值 TRUE 或 FALSE"

#: merge.R:18
#, c-format
msgid "Neither of the input data.tables to join have columns."
msgstr "用于联接的 data.table 输入中均不包含任何列。"

#: merge.R:20 merge.R:22
#, c-format
msgid "Input data.table '%s' has no columns."
msgstr "输入的 data.table '%s' 没有任何列。"

#: merge.R:31
#, c-format
msgid "`by.x` and `by.y` must be of same length."
msgstr "`by.x`和`by.y`必须是相同的长度。"

#: merge.R:33
#, c-format
msgid "Supplied both `by` and `by.x/by.y`. `by` argument will be ignored."
msgstr "参数`by`和`by.x/by.y`都提供了值。参数`by`的值会被忽略。"

#: merge.R:36
#, c-format
msgid "A non-empty vector of column names is required for `by.x` and `by.y`."
msgstr "`by.x`和`by.y`必须是非空的列名。"

#: merge.R:38
#, c-format
msgid "Elements listed in `by.x` must be valid column names in x."
msgstr "`by.x`中的列名必须是x的有效列。"

#: merge.R:40
#, c-format
msgid "Elements listed in `by.y` must be valid column names in y."
msgstr "`by.y`中的列名必须是y的有效列。"

#: merge.R:51
#, c-format
msgid "A non-empty vector of column names for `by` is required."
msgstr "`by`必须是非空的列名。"

#: merge.R:53
#, c-format
msgid "Elements listed in `by` must be valid column names in x and y"
msgstr "`by`中的列名必须是x和y的有效列"

#: merge.R:61
#, c-format
msgid "Unknown argument '%s' has been passed."
msgstr "传入了未知参数 '%s'。"

#: merge.R:64
#, c-format
msgid "Passed %d unknown and unnamed arguments."
msgstr "传入了 %d 个未知和未命名的参数。"

#: merge.R:128
#, c-format
msgid "column names %s are duplicated in the result"
msgstr "列名 %s 在结果中是重复的"

#: onAttach.R:23
#, c-format
msgid ""
"data.table %s IN DEVELOPMENT built %s%s using %d threads (see ?getDTthreads)."
msgstr ""
"正在开发中的 data.table %s，构建于 %s%s，使用了 %d 个线程（参见 ?getDTthreads）。"

#: onAttach.R:25
#, c-format
msgid "data.table %s using %d threads (see ?getDTthreads)."
msgstr "data.table %s，使用了 %d 个线程（参见 ?getDTthreads）。"

#: onAttach.R:26
#, c-format
msgid "Latest news: r-datatable.com"
msgstr "最新的消息：r-datatable.com"

#: onAttach.R:27
msgid "TRANSLATION CHECK"
msgstr "翻译检查"

#: onAttach.R:28
#, c-format
msgid ""
"**********\n"
"Running data.table in English; package support is available in English only. "
"When searching for online help, be sure to also check for the English error "
"message. This can be obtained by looking at the po/R-<locale>.po and po/"
"<locale>.po files in the package source, where the native language and "
"English error messages can be found side-by-side\n"
"**********"
msgstr ""
"**********\n"
"用中文执行data.table。软件包只提供英语支持。当在在线搜索帮助时，也要确保检查"
"英语错误信息。这个可以通过查看软件包源文件中的po/R-zh_CN.po和po/zh_CN.po文件"
"获得，这个文件可以并排找到母语和英语错误信息。\n"
"**********"

#: onAttach.R:30
#, c-format
msgid ""
"**********\n"
"This development version of data.table was built more than 4 weeks ago. "
"Please update: data.table::update_dev_pkg()\n"
"**********"
msgstr ""
"**********这个data.table的开发版本是在4个多星期之前构建的。请更新版本：data."
"table::update_dev_pkg()\n"
"**********"

#: onAttach.R:32
#, c-format
msgid ""
"**********\n"
"This installation of data.table has not detected OpenMP support. It should "
"still work but in single-threaded mode."
msgstr ""
"**********\n"
"data.table的安装未检测到OpenMP支持。在单线程模式下应该仍能运行"

#: onAttach.R:34
#, c-format
msgid ""
"This is a Mac. Please read https://mac.r-project.org/openmp/. Please engage "
"with Apple and ask them for support. Check r-datatable.com for updates, and "
"our Mac instructions here: https://github.com/Rdatatable/data.table/wiki/"
"Installation. After several years of many reports of installation problems "
"on Mac, it's time to gingerly point out that there have been no similar "
"problems on Windows or Linux.\n"
"**********"
msgstr ""
"此设备为 Mac。请阅读 https://mac.r-project.org/openmp/。请与 Apple 公司联系以"
"获取支持。查看 r-datatable.com 以获取更新，并参阅我们的 Mac 设备说明："
"https://github.com/Rdatatable/data.table/wiki/Installation在 Mac 上出现相关安"
"装问题的报告已数年之久，需要指出的是在 Windows 或 Linux 平台上一般不存在类似"
"问题。\n"
"**********"

#: onAttach.R:36
#, c-format
msgid ""
"This is %s. This warning should not normally occur on Windows or Linux where "
"OpenMP is turned on by data.table's configure script by passing -fopenmp to "
"the compiler. If you see this warning on Windows or Linux, please file a "
"GitHub issue.\n"
"**********"
msgstr ""
"这是 %s。此警告一般不应出现在 Windows 或 Linux 平台中，因为data.table 的 configure "
"脚本中已通过向编译器传递 -fopenmp 参数启用了 OpenMP。如果你在 Windows 或 "
"Linux 平台中发现此警告，请在 GitHub 中提交 issue。"

#: onAttach.R:40
#, c-format
msgid ""
"**********\n"
"This data.table installation was compiled for R < 3.4.0 (Apr 2017) and is "
"known to leak memory. Please upgrade R and reinstall data.table to fix the "
"leak. Maintaining and testing code branches to support very old versions "
"increases development time so please do upgrade R. We intend to bump data."
"table's dependency from 8 year old R 3.1.0 (Apr 2014) to 5 year old R 3.4.0 "
"(Apr 2017).\n"
"**********"
msgstr ""
"**********\n"
"该 data.table 使用 R < 3.4.0（2017年4月）进行编译，已知会存在内存泄露问题。请"
"升级R 后重新安装 data.table 以修复内存泄露问题。维护和测试支持旧版本的代码分支会"
"增加开发时间，所以请升级 R。我们打算将 data.table 的依赖从 8 年前的 R 3.1.0（"
"2014年4月）升级到 5 年前的 R 3.4.0（2017年4月）。\n"
"**********"

#: onLoad.R:9
#, c-format
msgid ""
"Option 'datatable.nomatch' is defined but is now ignored. Please see note 11 "
"in v1.12.4 NEWS (Oct 2019), and note 14 in v1.14.2."
msgstr ""
"选项 'datatable.nomatch' 虽定义，但现在已被忽略。请参见 v1.12.4 NEWS（2019年10月）"
"的第11条说明，以及 v1.14.2 的第14条说明。"

#: onLoad.R:26
#, c-format
msgid ""
"The data_table.%s version (%s) does not match the package (%s). Please close "
"all R sessions to release the old %s and reinstall data.table in a fresh R "
"session. The root cause is that R's package installer can in some "
"unconfirmed circumstances leave a package in a state that is apparently "
"functional but where new R code is calling old C code silently: https://bugs."
"r-project.org/bugzilla/show_bug.cgi?id=17478. Once a package is in this "
"mismatch state it may produce wrong results silently until you next upgrade "
"the package. Please help by adding precise circumstances to 17478 to move "
"the status to confirmed. This mismatch between R and C code can happen with "
"any package not just data.table. It is just that data.table has added this "
"check."
msgstr ""
"data_table.%s版本(%s)和包不匹配版本(%s)。请关闭所有R会话以释放旧%s并在全新的R"
"会话中重新安装data.table。根本原因是R包安装程序可能在某些未经确认的条件下将包"
"置于显然可以正常工作的状态，但是新的R代码正在默默地调用旧的C代码：https://"
"bugs.r-project.org/bugzilla/show_bug.cgi?id=17478。一旦安装包处于这不匹配的状"
"态下，在您下次升级程序包之前，它可能会默默地产生错误的结果请提交具体的情况至"
"17478协助我们确认这个Bug。R和C代码之间的这种不匹配可能发生在任何包中，而不仅"
"仅是在data.table中。只是data.table添加了这个检查"

#: onLoad.R:30
#, c-format
msgid ""
"This is R %s but data.table has been installed using R %s. The major version "
"must match. Please reinstall data.table."
msgstr "当前 R 的版本为 %s，但 data.table 安装是使用的是 R %s 版本。R 主版本号"
"必须匹配。请重新安装 data.table。"

#: onLoad.R:95
#, c-format
msgid ""
"Option 'datatable.CJ.names' no longer has any effect, as promised for 4 "
"years. It is now ignored. Manually name `...` entries as needed if you still "
"prefer the old behavior."
msgstr ""
"选项 'datatable.CJ.names' 已经没有任何效果。这一变更早在 4 年前就已决定。现在"
"该选项已被忽略。如果你仍倾向于旧的行为，请按需手动命名 `...` 条目。"

#: onLoad.R:100
#, c-format
msgid "Unexpected base R behaviour: list(x) has copied x"
msgstr "意外的base R行为：list(x)已经复制了x"

#: onLoad.R:108
#, c-format
msgid "Unexpected base R behaviour: names<- has copied column contents"
msgstr "意外的base R行为：names<- 已复制列内容"

#: onLoad.R:118
#, c-format
msgid ""
"Unexpected base R behaviour: DF[2,2]<- did not copy column 2 which was "
"assigned to"
msgstr "意外的base R行为：DF[2,2]<- 没有复制第二列它被分配给"

#: onLoad.R:119
#, c-format
msgid ""
"Unexpected base R behaviour: DF[2,2]<- copied the first column which was not "
"assigned to, too"
msgstr "意外的base R行为：DF[2,2]<-复制了第一列的内容，它也没有被分配给"

#: onLoad.R:121
#, c-format
msgid "Unexpected base R behaviour: DF[2,2]<- has not copied address(DF)"
msgstr "意外的base R行为：DF[2,2]<- 还没有复制address(DF)"

#: openmp-utils.R:3
#, c-format
msgid "Provide either threads= or percent= but not both"
msgstr "提供threads=或percent=，但不能两者都提供"

#: openmp-utils.R:4
#, c-format
msgid "percent= is provided but is length %d"
msgstr "提供了percent=，但为长度 %d"

#: openmp-utils.R:6
#, c-format
msgid "percent==%d but should be a number between 2 and 100"
msgstr "percent==%d 但应为2到100之间的数字"

#: print.data.table.R:17
#, c-format
msgid "Valid options for col.names are 'auto', 'top', and 'none'"
msgstr "对col.names有效的参数为'auto', 'top', and 'none'"

#: print.data.table.R:19
#, c-format
msgid "Valid options for trunc.cols are TRUE and FALSE"
msgstr "对trunc.cols有效的参数为TRUE和FALSE"

#: print.data.table.R:21
#, c-format
msgid "Column classes will be suppressed when col.names is 'none'"
msgstr "当col.names为'none'时，列的类型将被抑制"

#: print.data.table.R:146
#, c-format
msgid ""
"Internal structure doesn't seem to be a list. Possibly corrupt data.table."
msgstr "内部类型可能不是一个列表，该操作可能会损坏data.table"

#: programming.R:14 programming.R:40
#, c-format
msgid "'x' must be a list"
msgstr "'x' 必须是一个 list"

#: programming.R:22
#, c-format
msgid ""
"Character objects provided in the input are not scalar objects, if you need "
"them as character vector rather than a name, then wrap each into 'I' call: %s"
msgstr ""
"输入中所提供的字符串对象不是标量(长度为 1 )对象，如果您需要它们作为字符串向量而"
"非名称，请将每个对象放入到 'I' 调用中：%s"

#: programming.R:50
#, c-format
msgid "'env' must not be missing"
msgstr "必须提供 'env' 参数"

#: programming.R:56
#, c-format
msgid "'env' must be a list or an environment"
msgstr "'env' 必须为一列表或环境"

#: programming.R:63
#, c-format
msgid "'env' argument does not have names"
msgstr "参数 'env' 没有名"

#: programming.R:65
#, c-format
msgid "'env' argument has zero char names"
msgstr "'env' 参数的名字为零字符长度（即\"\"）"

#: programming.R:67
#, c-format
msgid "'env' argument has NA names"
msgstr "参数 'env' 有 NA 的名`"

#: programming.R:69
#, c-format
msgid "'env' argument has duplicated names"
msgstr "参数 'env' 的名含有重复"

#: setkey.R:3
#, c-format
msgid ""
"x may no longer be the character name of the data.table. The possibility was "
"undocumented and has been removed."
msgstr "x可能不再是data.table的名字。 该变化不被记录并且已经被删除"

#: setkey.R:23
#, c-format
msgid ""
"key(x)<-value is deprecated and not supported. Please change to use setkey() "
"with perhaps copy(). Has been warning since 2012."
msgstr ""
"key(x)<-value 已经废弃，不再支持。请改为使用 setkey()，也许还需配合 copy()。"
"本警告从 2012 年就已存。"

#: setkey.R:39
#, c-format
msgid "x is not a data.table"
msgstr "x不是一个data.table"

#: setkey.R:40
#, c-format
msgid ""
"cols is not a character vector. Please see further information in ?setkey."
msgstr "列不是一个字符类型的向量. 更多信息请查看?setkey."

#: setkey.R:41
#, c-format
msgid ""
"Setting a physical key on .SD is reserved for possible future use; to modify "
"the original data's order by group. Try setindex() instead. Or, set*(copy(."
"SD)) as a (slow) last resort."
msgstr ""
"在.SD设置一个物理的键(key)的功能被保留，以备未来的需求; 如需通过分组修改原数"
"据顺序请使用setindex(), 或者set*(copy(.SD))作为最终(该方式缓慢)的方法"

#: setkey.R:43
#, c-format
msgid ""
"cols is a character vector of zero length. Removed the key, but use NULL "
"instead, or wrap with suppressWarnings() to avoid this warning."
msgstr ""
"列为一个长度为0的字符串向量，请删除键值并使用NULL, 或者使用suppressWarnings()"
"来避免警告"

#: setkey.R:47
#, c-format
msgid "cols is the empty string. Use NULL to remove the key."
msgstr "列为一个空字符串，请使用NULL以删除键(key)值。"

#: setkey.R:48 setkey.R:277
#, c-format
msgid "cols contains some blanks."
msgstr "列中包含空白"

#: setkey.R:51 setkey.R:281
#, c-format
msgid "some columns are not in the data.table: %s"
msgstr "一些列不在data.table中：%s"

#: setkey.R:73 setkey.R:282
#, c-format
msgid ""
"x contains a column called '.xi'. Conflicts with internal use by data.table."
msgstr "x包含一个叫做'.xi'的列。这与data.table中使用的内部名称冲突"

#: setkey.R:76
#, c-format
msgid ""
"Column '%s' is type '%s' which is not supported as a key column type, "
"currently."
msgstr "列 '%s' 为 '%s' 类型，目前尚不支持该类型作为键列。"

#: setkey.R:78 setkey.R:287
#, c-format
msgid ""
"Internal error. 'cols' should be character at this point in setkey; please "
"report."
msgstr "内部错误： 目前在setkey中，'cols'应该是字符类型, 请报告"

#: setkey.R:125
#, c-format
msgid "Internal error: index '%s' exists but is invalid"
msgstr "内部错误 : 索引 '%s' 虽存在，但是无效"

#: setkey.R:157
#, c-format
msgid "x is vector but 'by' is supplied"
msgstr "x是一个向量， 但是参数'by'被提供"

#: setkey.R:167
#, c-format
msgid "x is a single vector, non-NULL 'by' doesn't make sense"
msgstr "x是一个单向量，非NULL的'by'参数不合理"

#: setkey.R:199
#, c-format
msgid "Attempting to order a 0-column data.table or data.frame."
msgstr "你正在试图对一个0列的data.table或者data.frame排序"

#: setkey.R:204
#, c-format
msgid ""
"The first item passed to [f]order is a plain list but there are more items. "
"It should be a data.table or data.frame."
msgstr ""
"传递给[f]order的第一个变量是一个简单的列表, 但此处有更多的项它需要是一个data."
"table或者data.frame"

#: setkey.R:221
#, c-format
msgid "Internal code should not be being called on type double"
msgstr "内部代码不应被调用给双精度类型"

#: setkey.R:229
#, c-format
msgid ""
"Input is not a vector of type double. New parallel sort has only been done "
"for double vectors so far. Using one thread."
msgstr ""
"输入一个并非双精度类型的向量。目前新的并行排序方法仅可应用于双精确度向量。将"
"使用单线程进行计算"

#: setkey.R:230
#, c-format
msgid ""
"New parallel sort has not been implemented for decreasing=TRUE so far. Using "
"one thread."
msgstr ""
"目前新的并行排序方法尚无法在decreasing=TRUE的条件下使用。将使用单线程进行计"
"算。"

#: setkey.R:231
#, c-format
msgid ""
"New parallel sort has not been implemented for vectors containing NA values "
"so far. Using one thread."
msgstr "目前新的并行排序方法尚无法用于包含缺失值的向量。将使用单线程。"

#: setkey.R:243 setkey.R:269
#, c-format
msgid "x must be a data.frame or data.table"
msgstr "x 必须为 data.frame 或 data.table"

#: setkey.R:271
#, c-format
msgid "na.last must be logical TRUE/FALSE"
msgstr "na.last 必须为逻辑 TRUE/FALSE"

#: setkey.R:272
#, c-format
msgid ""
"cols is not a character vector. Please see further information in ?setorder."
msgstr "cols并非一个字符向量。请参考 ?setorder以获得更多信息。"

#: setkey.R:274
#, c-format
msgid ""
"cols is a character vector of zero length. Use NULL instead, or wrap with "
"suppressWarnings() to avoid this warning."
msgstr ""
"cols为一长度为零的字符向量。请使用NULL代替，或将本函数使用suppressWarnings()"
"包裹以阻止该警告。"

#: setkey.R:285
#, c-format
msgid "Column '%s' is type '%s' which is not supported for ordering currently."
msgstr "列 '%s' 为 '%s' 类型，目前尚不支持使用该类型排序。"

#: setkey.R:329
#, c-format
msgid ""
"'sorted' is TRUE but element %d is non-atomic, which can't be sorted; try "
"setting sorted = FALSE"
msgstr "'sorted' 为 TRUE 但 %d 元素并非原子类型，无法排序。请尝试使用 "
"sorted = FALSE"

#: setkey.R:344
#, c-format
msgid ""
"Cross product of elements provided to CJ() would result in %.0f rows which "
"exceeds .Machine$integer.max == %d"
msgstr "CJ()中元素的叉积将产生 %.0f 行，已超过 .Machine$integer.max == %d"

#: setops.R:3 setops.R:40
#, c-format
msgid "x and y must both be data.tables"
msgstr "x 和 y 均需为 data.table"

#: setops.R:9
#, c-format
msgid "length(by.x) != length(by.y)"
msgstr "length(by.x) != length(by.y)"

#: setops.R:17
#, c-format
msgid ""
"When x's column ('%s') is character, the corresponding column in y ('%s') "
"should be factor or character, but found incompatible type '%s'."
msgstr ""
"当 x 的列('%s') 是字符，y 中相应的列 ('%s') 应该是因子或字符，然而此类型并不"
"兼容：'%s'."

#: setops.R:19
#, c-format
msgid ""
"When x's column ('%s') is factor, the corresponding column in y ('%s') "
"should be character or factor, but found incompatible type '%s'."
msgstr ""
"当 x 的列('%s') 是因子, y 中相应的列 ('%s') 应该是字符或因子，然而此类型并不"
"兼容：'%s'."

#: setops.R:21
#, c-format
msgid ""
"When x's column ('%s') is integer or numeric, the corresponding column in y "
"('%s') can not be character or logical types, but found incompatible type "
"'%s'."
msgstr ""
"当 x 的列('%s') 是整数或数值，y 中相应的列('%s') 不能是字符或逻辑类型，然而此"
"类型不兼容：'%s'."

#: setops.R:39
#, c-format
msgid "argument 'all' should be logical of length one"
msgstr "参数 'all' 应该是长度为 1 的逻辑型"

#: setops.R:41
#, c-format
msgid "x and y must have the same column names"
msgstr "x 和 y 的列名必须相同"

#: setops.R:42
#, c-format
msgid "x and y must have the same column order"
msgstr "x 和 y 的列顺序必须保持一致"

#: setops.R:45
#, c-format
msgid "unsupported column type(s) found in x or y: %s"
msgstr "找到不支持的列类型在 x 或 y: %s"

#: setops.R:53
#, c-format
msgid "Item %d of x is '%s' but the corresponding item of y is '%s'."
msgstr "x 中的第 %d 项为 '%s'，而 y 中对应的项为 '%s'。"

#: setops.R:55
#, c-format
msgid "None of the datasets should contain a column named '.seqn'"
msgstr "所有的数据集都不应该包含名为 '.seqn' 的列"

#: setops.R:146
#, c-format
msgid "Internal error: ncol(current)==ncol(target) was checked above"
msgstr "内部错误：ncol(current)==ncol(target) 之前已经检查"

#: setops.R:159 setops.R:170
#, c-format
msgid "Datasets have different %s. 'target': %s. 'current': %s."
msgstr "输入的数据拥有不同的%s。'target'：%s，'current'：%s。"

#: setops.R:161 setops.R:162
#, c-format
msgid "has no key"
msgstr "没有键列"

#: setops.R:172 setops.R:173
#, c-format
msgid "has no index"
msgstr "没有索引"

#: setops.R:190
#, c-format
msgid "None of the datasets to compare should contain a column named '.seqn'"
msgstr "所有参与比较的数据集都不应该包含名为 '.seqn' 的列"

#: setops.R:193
#, c-format
msgid ""
"Datasets to compare with 'ignore.row.order' must not have unsupported column "
"types: %s"
msgstr "与 'ignore.row.order' 进行比较的数据集，不能存在不支持的列类型：%s"

#: setops.R:195
#, c-format
msgid ""
"Argument 'tolerance' was forced to lowest accepted value `sqrt(."
"Machine$double.eps)` from provided %s"
msgstr ""
"参数 'tolerance' 被强制设定为最低接受值 `sqrt(.Machine$double.eps)`，此值来自"
"于 %s"

#: setops.R:208
#, c-format
msgid ""
"Duplicate rows in datasets, numeric columns and ignore.row.order cannot be "
"used with non 0 tolerance argument"
msgstr ""
"数据集中的重复行、数字列和 ignore.row.order 都不能与非 0 的容差（tolerance）"
"参数同时使用"

#: setops.R:222
#, c-format
msgid ""
"Factor columns and ignore.row.order cannot be used with non 0 tolerance "
"argument"
msgstr "因子列和 ignore.row.order 都不能与非 0 的容差（tolerance）参数同时使用"

#: setops.R:266
#, c-format
msgid "Internal error: factor type mismatch should have been caught earlier"
msgstr "内部错误：此时不匹配的因子类型应已被发现"

#: shift.R:3
msgid "Provided argument fill="
msgstr "提供的 fill= 参数"

#: shift.R:3
msgid "will be ignored since type='shift'."
msgstr "将被忽略，因为 type='shift'。"

#: tables.R:46
#, c-format
msgid "order.col='%s' not a column name of info"
msgstr "order.col='%s' 并非info的一个列名"

#: test.data.table.R:17
#, c-format
msgid "data.table package is loaded. Unload or start a fresh R session."
msgstr "data.table 包已被加载。请将其卸载或启动一个新的 R 会话。"

#: test.data.table.R:33
#, c-format
msgid ""
"script must end with '.Rraw'. If a file ending '.Rraw.bz2' exists, that will "
"be found and used."
msgstr ""
"脚本文件名必须以 '.Rraw' 结尾。如果以 'Rraw.bz2' 结尾的文件存在，其也将被使"
"用。"

#: test.data.table.R:63
#, c-format
msgid "Neither %s nor %s exist in %s"
msgstr "%3$s 中 %1$s 也 %2$s 不存在"

#: test.data.table.R:114
msgid "object '%s' not found"
msgstr "未找到 '%s' 对象"

#: test.data.table.R:138
#, c-format
msgid ""
"memtest intended for Linux. Step through data.table:::rss() to see what went "
"wrong."
msgstr "memtest 仅适用于 Linux。请逐步执行 data.table:::rss() 以查看错误原因。"

#: test.data.table.R:176
#, c-format
msgid "Failed in %s after test %s before the next test() call in %s"
msgstr "测试于 %s 后失败，失败发生在测试 %s 之后、下一 test() 之前、调用 %s 时"

#: test.data.table.R:186
#, c-format
msgid "%d error(s) out of %d. Search %s for test number(s) %s. Duration: %s."
msgstr "%2$d 中共产生 %1$d 个错误。搜索 %3$s 以定位测试编号 %4$s。用时：%5$s。"

#: test.data.table.R:199
#, c-format
msgid "Timings count mismatch: %d vs %d"
msgstr "计时不一致: %d 对 %d"

#: test.data.table.R:312
#, c-format
msgid ""
"Test %s is invalid: when error= is provided it does not make sense to pass y "
"as well"
msgstr "%s 无效：当使用了error=，不应再输入y"

#: timetaken.R:3
#, c-format
msgid "Use started.at=proc.time() not Sys.time() (POSIXt and slow)"
msgstr "使用started.at=proc.time()而非Sys.time() (返回POSIXt类型，处理较慢)"

#: transpose.R:7
#, c-format
msgid "make.names='%s' not found in names of input"
msgstr "make.names='%s' 不存在于输入的名字里"

#: transpose.R:12
#, c-format
msgid "make.names=%d is out of range [1,ncol=%d]"
msgstr "make.names=%d 不在以下区间[1,ncol=%d]"

#: transpose.R:28
#, c-format
msgid "'names' must be TRUE/FALSE or a character vector."
msgstr "'names'必须为TRUE/FALSE，或一个字符（character）向量。"

#: transpose.R:34
#, c-format
msgid "'keep' should contain integer values between %d and %d."
msgstr "'keep'所含整数值应在 %d 和 %d 间"

#: transpose.R:51
#, c-format
msgid "The argument 'type.convert' does not support empty list."
msgstr "参数 'type.convert' 不支持空列表。"

#: transpose.R:57
#, c-format
msgid ""
"When the argument 'type.convert' contains an unnamed element, it is expected "
"to be the last element and should be a function. More than one unnamed "
"element is not allowed unless all elements are functions with length equal "
"to %d (the length of the transpose list or 'keep' argument if it is "
"specified)."
msgstr ""
"当参数 'type.convert' 包含一个未命名元素时，此元素应为最后一个元素，且应为一"
"个函数。不允许包含多个未命名元素，除非所有元素都为函数，且所有元素的总个数为"
"%d（即输入列表转置后的长度或 'keep' 参数指定的长度）。"

#: transpose.R:66
#, c-format
msgid ""
"When the argument 'type.convert' contains transpose list indices, it should "
"be a named list of non-missing integer values (with no duplicate) except the "
"last element that should be unnamed if it is a function."
msgstr ""
"当参数 'type.convert' 包含转置列表的索引时，它应该为一个命名列表，其中仅包含"
"非缺失的整数值（且无重复）。除非该列表的最后一个元素是一个函数，这时该元素应"
"未命名。"

#: transpose.R:68
#, c-format
msgid ""
"When the argument 'type.convert' contains transpose list indices, they "
"should be integer values contained in the argument 'keep' (if it is "
"specified) or be between %d and %d (if it is not). But '%s' is/are not "
"contained in '%s'."
msgstr ""
"当参数 'type.convert' 包含转置列表的索引时，它们应该是参数 'keep' （如果"
"提供了的话）中的整数值，或者（如果 'keep' 没有指定的话）应介于 %d 和 %d 之间。"
"但 '%s' 并不包含在 '%s' 中。"

#: transpose.R:74
#, c-format
msgid ""
"In the argument 'type.convert', '%s' was ignored because all elements in the "
"transpose list or elements corrisponding to indices specified in the 'keep' "
"argument have already been converted."
msgstr ""
"忽略参数 'type.convert' 中的 '%s'，因为转置列表中的所有元素或参数 'keep'"
"中索引对应的元素已经被转换。"

#: transpose.R:83
#, c-format
msgid ""
"The argument 'type.convert' should be TRUE/FALSE, a function, a list of "
"functions, or a named list of pairs 'fun=indices' with optionally one "
"unnamed element (a function) but an object of type '%s' was provided."
msgstr ""
"参数 'type.convert' 应为 TRUE/FALSE、一个函数、一个包含函数的列表，或一个包含"
"元素 'fun=indices' (函数=索引) 的命名列表，其中可以有一个未命名元素（必须为一"
"个函数），但当前输入中提供了一个类型为 '%s' 的对象。"

#: transpose.R:88
#, c-format
msgid "length(names) (= %d) is not equal to length(%s) (= %d)."
msgstr "length(names) (= %d) 并不等于 length(%s) (= %d)。"

#: uniqlist.R:12
#, c-format
msgid "l not type list"
msgstr "l并非列表（list）类型"

#: utils.R:18
#, c-format
msgid "Argument 'nan' must be length 1"
msgstr "参数 'nan' 的长度必须为 1"

#: utils.R:21
#, c-format
msgid "Argument 'nan' must be NA or NaN"
msgstr "参数 'nan' 必须为 NA 或 NaN"

#: utils.R:32
msgid "Internal error: use endsWithAny instead of base::endsWith"
msgstr "内部错误：使用 endsWithAny 而非 base::endsWith"

#: utils.R:43 utils.R:52
#, c-format
msgid "x not boolean"
msgstr "x并非布尔值"

#: utils.R:63
#, c-format
msgid ""
"Some columns are type 'integer64' but package bit64 is not installed. Those "
"columns will print as strange looking floating point data. There is no need "
"to reload the data. Simply install.packages('bit64') to obtain the integer64 "
"print method and print the data again."
msgstr ""
"有些列的类型是64 位整数类型（'integer64')但bit64包并没有安装。这些列会被显示"
"成看起来有些奇怪的浮点型数据。然而并不需要重新载入这些数据，只需运行 install."
"packages('bit64') 来获取显示integer64类型的打印方法，再重新打印该数据即可。"

#: xts.R:3
#, c-format
msgid "keep.rownames must be length 1"
msgstr "keep.rownames 的长度必须为 1"

#: xts.R:4
#, c-format
msgid "keep.rownames must not be NA"
msgstr "keep.rownames 不可为 NA"

#: xts.R:10
#, c-format
msgid ""
"Input xts object should not have '%s' column because it would result in "
"duplicate column names. Rename '%s' column in xts or use `keep.rownames` to "
"change the index column name."
msgstr ""
"输入的xts对象不能含有'%s'列，因这会导致出现重复的列名。请尝试重新命名xts中"
"的'%s'列或者使用`keep.rownames`并手动添加index为另外的列"

#: xts.R:20
#, c-format
msgid ""
"data.table must have a time based column in first position, use "
"`setcolorder` function to change the order, or see ?timeBased for supported "
"types"
msgstr ""
"data.table的首列必须为一个以时间为基础的列，请使用`setcolorder`方程来改变它的"
"顺序，或者通过?timeBased来查看支持的类型"

#: xts.R:24
#, c-format
msgid "Following columns are not numeric and will be omitted: %s"
msgstr "以下的列并非数值类型，将被忽略：%s"

#: print.data.table.R:51
msgid "Index: %s\n"
msgid_plural "Indices: %s\n"
msgstr[0] "索引(index): %s\n"
