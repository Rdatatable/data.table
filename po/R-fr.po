msgid ""
msgstr ""
"Project-Id-Version: data.table 1.16.99\n"
"POT-Creation-Date: 2025-12-13 17:01+0000\n"
"PO-Revision-Date: 2025-12-16 16:20+0100\n"
"Last-Translator: Christian Wiat <w9204-rs@yahoo.com>\n"
"Language-Team: \n"
"Language: fr\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=2; plural=(n > 1);\n"
"X-Generator: Poedit 2.4.2\n"

#: AllS4.R:2
#, c-format
msgid "data.table package loaded. When developing don't load package"
msgstr ""
"package data.table chargé. En cours de développement, ne pas charger le "
"package"

#: IDateTime.R:108
#, c-format
msgid "binary + is not defined for \"IDate\" objects"
msgstr "l'opérateur binaire + n'est pas défini pour les objets \"IDate\""

#: IDateTime.R:115
#, c-format
msgid "can only subtract from \"IDate\" objects"
msgstr "seule la soustraction est autorisée sur les objets \"IDate\""

#: IDateTime.R:120
#, c-format
msgid "unary - is not defined for \"IDate\" objects"
msgstr "l'opérateur unaire - n'est pas défini sur les objets \"IDate\""

#: IDateTime.R:316
#, c-format
msgid "Valid options for ms are 'truncate', 'nearest', and 'ceil'."
msgstr "Les options valides pour ms sont 'truncate', 'nearest', et 'ceil'."

#: as.data.table.R:89
#, c-format
msgid ""
"as.data.table.array method should only be called for arrays with 3+ "
"dimensions; use the matrix method for 2-dimensional arrays"
msgstr ""
"la méthode as.data.table.array ne doit être appelée que pour les tableaux de "
"dimension 3+ ; Utiliser la méthode matrix pour les tableaux de dimension 2"

#: as.data.table.R:91
#, c-format
msgid ""
"Argument 'value.name' must be scalar character, non-NA and at least one "
"character"
msgstr ""
"L'argument 'value.name' doit être un caractère scalaire, pas NA et d'au "
"moins un caractère"

#: as.data.table.R:93
#, c-format
msgid "Argument 'sorted' must be scalar logical and non-NA"
msgstr ""
"L'argument 'sorted' doit être un scalaire, un booléen et différent de NA"

#: as.data.table.R:95
#, c-format
msgid "Argument 'na.rm' must be scalar logical and non-NA"
msgstr ""
"L'argument 'na.rm' doit être un scalaire, un booléen et différent de NA"

#: as.data.table.R:97
#, c-format
msgid "Please provide either 'key' or 'sorted', but not both."
msgstr "Utiliser 'key' ou 'sorted' mais pas les deux simultanément."

#: as.data.table.R:111
#, c-format
msgid ""
"Argument 'value.name' should not overlap with column names in result: %s"
msgstr ""
"L'argument 'value.name' ne doit pas recouvrir le nom des colonnes dans le "
"résultat : %s"

#: as.data.table.R:161
#, c-format
msgid ""
"POSIXlt column type detected and converted to POSIXct. We do not recommend "
"use of POSIXlt at all because it uses 40 bytes to store one date."
msgstr ""
"Le type de colonne POSIXlt a été détecté et converti en POSIXct. Nous ne "
"recommandons pas l'utilisation de POSIXlt car il utilise 40 octets pour "
"stocker une date."

#: as.data.table.R:206
#, c-format
msgid "Item %d has %d rows but longest item has %d; recycled with remainder."
msgstr ""
"L'élément %d a %d lignes mais l'élément le plus long en a %d ; Il est "
"recyclé avec le reste."

#: as.data.table.R:221
#, c-format
msgid "A column may not be called .SD. That has special meaning."
msgstr ""
"Une colonne ne peut pas s'appeler .SD. Ceci a une signification particulière."

#: as.data.table.R:247
#, c-format
msgid "class must be length 1"
msgstr "la classe doit être de longueur 1"

#: between.R:3
#, c-format
msgid "between has been passed an argument x of type logical"
msgstr "'between' contient un argument x booléen"

#: between.R:13 between.R:15
#, c-format
msgid ""
"The 'x' argument of the 'between' function is POSIXct while '%s' was not, "
"coercion to POSIXct failed with: %s"
msgstr ""
"L'argument 'x' de la fonction 'between' est POSIXct alors que '%s' ne l'est "
"pas, échec de la conversion automatique en POSIXct avec : %s"

#: between.R:24
#, c-format
msgid ""
"'between' lower= and upper= are both POSIXct but have different tzone "
"attributes: %s. Please align their time zones."
msgstr ""
"'between' lower= et upper= sont tous deux traduits en POSIXct mais leurs "
"attributs ‘tzone’ sont différents : %s. Veuillez aligner leur fuseau horaire."

#: between.R:27
#, c-format
msgid ""
"'between' arguments are all POSIXct but have mismatched tzone attributes: "
"%s. The UTC times will be compared."
msgstr ""
"les arguments 'between' sont tous POSIXct mais les attributs tzone associés "
"ne correspondent pas : %s. La comparaison se fera sur le temps UTC."

#: between.R:32
#, c-format
msgid "trying to use integer64 class when 'bit64' package is not installed"
msgstr ""
"utilisation de la classe integer64 alors que le package 'bit64' n'est pas "
"installé"

#: between.R:43
msgid ""
"optimised between not available for this data type, fallback to slow R "
"routine"
msgstr ""
"between optimisé non disponible pour ce type de donnée, repli vers laroutine "
"R lente"

#: between.R:44
#, c-format
msgid ""
"Not yet implemented NAbounds=TRUE for this non-numeric and non-character type"
msgstr ""
"NAbounds=TRUE n'est pas encore implémenté pour ce type non numérique et non "
"caractère"

#: between.R:45
#, c-format
msgid "Some lower>upper for this non-numeric and non-character type"
msgstr ""
"Certains inférieurs sont plus grands que les supérieurs (lower>upper) pour "
"ce type non numérique et non caractère"

#: between.R:59
#, c-format
msgid "Perhaps you meant %s?"
msgstr "Peut-être vouliez-vous dire %s ?"

#: between.R:60
#, c-format
msgid ""
"RHS has length() %d; expecting length 2. %sThe first element should be the "
"lower bound(s); the second element should be the upper bound(s)."
msgstr ""
"Le membre de droite a pour longueur %d au lieu de 2 attendu. %s Le premier "
"élément représente la ou les borne(s) inférieure(s) ; Le second élément "
"représente la ou les borne(s) supérieure(s)."

#: between.R:73
msgid "forderv(query) took ..."
msgstr "forderv(query) a pris ..."

#: between.R:86
msgid "Generating final logical vector ..."
msgstr "Génération du vecteur final de booléens ..."

#: between.R:88 bmerge.R:205 bmerge.R:209 bmerge.R:216 data.table.R:516
msgid "done in %s"
msgstr "fait dans %s"

#: bmerge.R:21
msgid "Coercing %s column %s%s to type %s to match type of %s%s."
msgstr ""
"Conversion forcée de la colonne %s %s%s vers le type %s pour correspondre au "
"type de %s%s."

#: bmerge.R:34
#, c-format
msgid ""
"Attempting roll join on factor column when joining x.%s to i.%s. Only "
"integer, double or character columns may be roll joined."
msgstr ""
"Tentative de jointure par roulement sur une colonne de facteurs lors de la "
"jointure de x.%s à i.%s. Seules les colonnes de nombres entiers, de nombres "
"doubles ou de caractères peuvent être jointes par roulement."

#: bmerge.R:72 bmerge.R:73
#, c-format
msgid "%s is type %s which is not supported by data.table join"
msgstr ""
"%s est de type %s qui n'est pas pris en charge pour une jointure data.table"

#: bmerge.R:77
msgid "Matching %s factor levels to %s factor levels."
msgstr "Correspondance des niveaux de facteurs %s avec ceux de %s."

#: bmerge.R:86
msgid "Matching character column %s to factor levels in %s."
msgstr ""
"Correspondance de la colonne de caractères %s avec les niveaux de facteurs "
"de %s."

#: bmerge.R:93
#, c-format
msgid ""
"Incompatible join types: %s (%s) and %s (%s). Factor columns must join to "
"factor or character columns."
msgstr ""
"Types de jointures incompatibles : %s (%s) et %s (%s). Les colonnes de "
"facteurs doivent être jointes à des colonnes de facteurs ou de caractères."

#: bmerge.R:96
msgid "%s has same type (%s) as %s. No coercion needed."
msgstr "%s a le même type (%s) que %s. Pas de conversion."

#: bmerge.R:102 bmerge.R:106
msgid "(all-NA)"
msgstr "(tous-NA)"

#: bmerge.R:109
#, c-format
msgid "Incompatible join types: %s (%s) and %s (%s)"
msgstr "Types incompatibles pour la jointure : %s (%s) et %s (%s)"

#: bmerge.R:115
msgid "(which has integer64 representation, e.g. no fractions)"
msgstr "(qui est représenté en integer64, c'est à dire sans fraction)"

#: bmerge.R:117
#, c-format
msgid ""
"Incompatible join types: %s is type integer64 but %s is type double and "
"cannot be coerced to integer64 (e.g. has fractions)"
msgstr ""
"Types de jointures incompatibles : %s est de type integer64 mais %s est de "
"type double et ne peut pas être converti en integer64 (il contient des "
"fractions)"

#: bmerge.R:137
msgid "(which contains no fractions)"
msgstr "(qui ne contient pas de fraction)"

#: bmerge.R:149
msgid "(which contains fractions)"
msgstr "(qui contient des fractions)"

#: bmerge.R:152
msgid "(for join)"
msgstr "(pour la jointure)"

#: bmerge.R:170
msgid "on= matches existing key, using key"
msgstr "on= correspond à une clé existante, cette clé est utilisée"

#: bmerge.R:175
msgid "on= matches existing index, using index"
msgstr "on= correspond à un indice existant, cet indice est utilisé"

#: bmerge.R:180
msgid "Calculated ad hoc index in %s"
msgstr "Indice calculé correspondant de %s"

#: bmerge.R:191
msgid "Non-equi join operators detected ..."
msgstr "Opérateurs détectés pour une jointure non-equi ..."

#: bmerge.R:192
#, c-format
msgid "roll is not implemented for non-equi joins yet."
msgstr "roll n'est pas encore implémenté avec des jointure non-equi."

#: bmerge.R:193
msgid "forder took ..."
msgstr "forder a pris ..."

#: bmerge.R:202
msgid "Generating group lengths ..."
msgstr "Génération des longueurs de groupe ..."

#: bmerge.R:207
msgid "Generating non-equi group ids ..."
msgstr "Génération des id des groupes non-equi ..."

#: bmerge.R:212
#, c-format
msgid "Column name '_nqgrp_' is reserved for non-equi joins."
msgstr "Le nom de colonne '_nqgrp_' est réservé pour les jointures non-equi."

#: bmerge.R:213
msgid "Recomputing forder with non-equi ids ..."
msgstr "Recalcul de forder avec les id non-equi ..."

#: bmerge.R:222
msgid "Starting bmerge ..."
msgstr "Début du bmerge ..."

#: bmerge.R:224
msgid "bmerge done in %s"
msgstr "fin du bmerge dans %s"

#: cedta.R:77
msgid ""
"cedta decided '%s' wasn't data.table aware. Here is call stack with [[1L]] "
"applied:"
msgstr ""
"cedta a décidé que '%s' ne reconnaissait pas data.table. Voici la pile des "
"appels en appliquant [[1L]] :"

#: data.table.R:55
#, c-format
msgid "key argument of data.table() must be character"
msgstr "l'argument key de data.table() doit être une chaîne de caractères"

#: data.table.R:123
#, c-format
msgid "Object '%s' not found. Perhaps you intended %s"
msgstr "Objet '%s' non trouvé. Peut-être vous vouliez dire %s"

#: data.table.R:125
#, c-format
msgid "Object '%s' not found amongst %s"
msgstr "Objet '%s' non trouvé parmi %s"

#: data.table.R:134
#, c-format
msgid ""
"Invalid set* operation on a recursive index L[[i]] where i has length %d. "
"Chain [[ instead."
msgstr ""
"Opération set* non valide sur un indice récursif L[[i]] où i a pour longueur "
"%d. Chaîner [[ à la place."

#: data.table.R:139
#, c-format
msgid "Item '%s' not found in names of input list"
msgstr "Élément '%s' non trouvé parmi les noms de la liste d'entrée"

#: data.table.R:159
#, c-format
msgid ""
"[ was called on a data.table in an environment that is not data.table-aware "
"(i.e. cedta()), but '%s' was used, implying the owner of this call really "
"intended for data.table methods to be called. See vignette('datatable-"
"importing') for details on properly importing data.table."
msgstr ""
"[ a été appelé sur un data.table dans un environnement qui n'est pas "
"compatible avec data.table (i.e. cedta()), mais '%s' a été utilisé, ce qui "
"implique que le propriétaire de cet appel avait vraiment l'intention "
"d'appeler des méthodes data.table. Voir la vignette('datatable-importing') "
"pour plus de détails sur l’importation correcte de data.table."

#: data.table.R:170
#, c-format
msgid "verbose must be logical or integer"
msgstr "verbose doit être soit un booléen, soit un entier"

#: data.table.R:171
#, c-format
msgid "verbose must be length 1 non-NA"
msgstr "verbose doit être de longueur 1 et différent de NA"

#: data.table.R:179
#, c-format
msgid "Ignoring by/keyby because 'j' is not supplied"
msgstr "L'argument by ou keyby est ignoré car 'j' n'est pas fourni"

#: data.table.R:193
#, c-format
msgid "When by and keyby are both provided, keyby must be TRUE or FALSE"
msgstr ""
"Si by et keyby sont fournis simultanément, keyby doit être TRUE ou FALSE"

#: data.table.R:196 data.table.R:261 data.table.R:351
msgid "Argument '%s' after substitute: %s"
msgstr "Argument '%s' après substitution : %s"

#: data.table.R:205
#, c-format
msgid ""
"When on= is provided but not i=, on= must be a named list or data.table|"
"frame, and a natural join (i.e. join on common names) is invoked. Ignoring "
"on= which is '%s'."
msgstr ""
"Lorsque on= est fourni mais pas i=, on= doit être une liste nommée ou un "
"data.table|frame, et une jointure naturelle (c'est-à-dire une jointure sur "
"les noms communs) est invoquée. La valeur de on= qui est '%s' est ignorée."

#: data.table.R:218
#, c-format
msgid ""
"i and j are both missing so ignoring the other arguments. This warning will "
"be upgraded to error in future."
msgstr ""
"i et j sont tous les deux absents, donc les autres arguments sont ignorés. "
"Cet avertissement deviendra une erreur à l'avenir."

#: data.table.R:222
#, c-format
msgid "mult argument can only be 'first', 'last', 'all' or 'error'"
msgstr "l'argument mult ne peut valoir que 'first', 'last', 'all' ou 'error'"

#: data.table.R:224
#, c-format
msgid ""
"roll must be a single TRUE, FALSE, positive/negative integer/double "
"including +Inf and -Inf or 'nearest'"
msgstr ""
"roll doit être une seule valeur TRUE, FALSE, un entier ou un double, positif "
"ou négatif, +Inf, -Inf ou 'nearest' compris"

#: data.table.R:226
#, c-format
msgid "roll is '%s' (type character). Only valid character value is 'nearest'."
msgstr ""
"roll vaut '%s' (de type caractère). La seule chaîne valide est 'nearest'."

#: data.table.R:231
#, c-format
msgid "rollends must be a logical vector"
msgstr "rollends doit être un vecteur de booléens"

#: data.table.R:232
#, c-format
msgid "rollends must be length 1 or 2"
msgstr "rollends doit être de longueur 1 ou 2"

#: data.table.R:240
#, c-format
msgid ""
"nomatch= must be either NA or NULL (or 0 for backwards compatibility which "
"is the same as NULL but please use NULL)"
msgstr ""
"nomatch= doit valoir soit NA, soit NULL (ou 0 pour la compatibilité arrière "
"qui équivaut à NULL, mais utiliser NULL dorénavant)"

#: data.table.R:243
#, c-format
msgid "which= must be a logical vector length 1. Either FALSE, TRUE or NA."
msgstr ""
"which= doit être un vecteur de booléens de longueur 1. Valeur FALSE, TRUE ou "
"NA."

#: data.table.R:244
#, c-format
msgid ""
"which==%s (meaning return row numbers) but j is also supplied. Either you "
"need row numbers or the result of j, but only one type of result can be "
"returned."
msgstr ""
"which==%s (renvoie des numéros de ligne) mais j est également fourni. Vous "
"avez besoin soit des numéros de ligne, soit du résultat de j, mais un seul "
"type de résultat peut être renvoyé."

#: data.table.R:245
#, c-format
msgid ""
"which=NA with nomatch=0|NULL would always return an empty vector. Please "
"change or remove either which or nomatch."
msgstr ""
"which=NA avec nomatch=0|NULL renverrait toujours un vecteur vide. Veuillez "
"modifier ou supprimer soit which, soit nomatch."

#: data.table.R:246
#, c-format
msgid "j must be provided when with=FALSE"
msgstr "j doit être fourni quand with=FALSE"

#: data.table.R:247
#, c-format
msgid "%s must be TRUE or FALSE"
msgstr "%s doit être TRUE ou FALSE"

#: data.table.R:290
#, c-format
msgid ""
"The symbol .. is invalid. The .. prefix must be followed by at least one "
"character."
msgstr ""
"Le symbole .. n'est pas valide. Le préfixe .. doit être suivi d'au moins un "
"caractère."

#: data.table.R:294
#, c-format
msgid ""
"Variable '..%s' does exist in calling scope though, so please just removed "
"the .. prefix from that variable name in calling scope."
msgstr ""
"La variable '..%s' existe dans la portée de l'appelant, il suffit donc de "
"supprimer le préfixe .. de ce nom de variable dans la portée de l'appelant."

#: data.table.R:298
#, c-format
msgid ""
"Variable '%s' is not found in calling scope. Looking in calling scope "
"because you used the .. prefix.%s"
msgstr ""
"La variable '%s' n'est pas visible dans le contexte de l'appelant désigné "
"par le préfixe .. .%s"

#: data.table.R:300
#, c-format
msgid ""
"Both '%1$s' and '..%1$s' exist in calling scope. Please remove the '..%1$s' "
"variable in calling scope for clarity."
msgstr ""
"'%1$s' et '..%1$s' sont tous deux visibles dans le contexte de l'appelant. "
"Veuillez supprimer la variable '..%1$s' de ce contexte pour clarifier."

#: data.table.R:308
#, c-format
msgid ""
"Variable '%s' is not found in calling scope. Looking in calling scope "
"because you set with=FALSE. Also, please use .. symbol prefix and remove "
"with=FALSE."
msgstr ""
"La variable '%s' n'est pas visible dans le contexte de l'appelant désigné "
"par with=FALSE. Utilisez alors le préfixe de symbole .. et supprimez "
"with=FALSE."

#: data.table.R:316
#, c-format
msgid ""
"Invalid use of `:=` inside `{}`. `:=` must be the only expression inside `{}"
"` when used in `j`. Instead of: DT[{tmp1 <- ...; tmp2 <- ...; someCol := "
"tmp1 * tmp2}], Use: DT[, someCol := {tmp1 <- ...; tmp2 <- ...; tmp1 * tmp2}]"
msgstr ""
"Utilisation de `:=` dans `{}` non autorisée. `:=` doit être la seule "
"expression dans `{}` quand utilisé dans `j`. Au lieu de : DT[{tmp1 <- ...; "
"tmp2 <- ...; someCol := tmp1 * tmp2}], utiliser : DT[, someCol := {tmp1 "
"<- ...; tmp2 <- ...; tmp1 * tmp2}]"

#: data.table.R:334
#, c-format
msgid ""
":= with keyby is only possible when i is not supplied since you can't setkey "
"on a subset of rows. Either change keyby to by or remove i"
msgstr ""
":= avec keyby n'est accepté que si i n'est pas fourni parce que setkey sur "
"un sous-ensemble de lignes n'est pas possible. Modifiez soit keyby en by, ou "
"supprimez i"

#: data.table.R:336
#, c-format
msgid "nomatch isn't relevant together with :=, ignoring nomatch"
msgstr "nomatch n'est pas pertinent avec with :=, nomatch est ignoré"

#: data.table.R:392
#, c-format
msgid ""
"not-join '!' prefix is present on i but nomatch is provided. Please remove "
"nomatch."
msgstr ""
"le préfixe de non-jointure '!' est présent sur i mais nomatch est fourni. "
"Supprimer nomatch."

#: data.table.R:420
#, c-format
msgid ""
"Operator := detected in i, the first argument inside DT[...], but is only "
"valid in the second argument, j. Most often, this happens when forgetting "
"the first comma (e.g. DT[newvar := 5] instead of DT[ , new_var := 5]). "
"Please double-check the syntax. Run traceback(), and debugger() to get a "
"line number."
msgstr ""
"L'opérateur := est présent dans i, le premier argument de DT[...], mais "
"n'est valide que dans le second argument, j. Le plus souvent, cela se "
"produit lorsqu'on oublie la première virgule (par exemple, DT[newvar := 5] "
"au lieu de DT[ , new_var := 5]). Veuillez vérifier la syntaxe. Exécuter "
"traceback(), et debugger() pour obtenir un numéro de ligne."

#: data.table.R:430
#, c-format
msgid "'%s' is not found in calling scope and it is not a column name either"
msgstr ""
"'%s' n'est pas visible dans le contexte de l'appelant et ce n'est pas non "
"plus un nom de colonne"

#: data.table.R:433
#, c-format
msgid ""
"'%s' is not found in calling scope, but it is a column of type %s. If you "
"wish to select rows where that column contains TRUE, or perhaps that column "
"contains row numbers of itself to select, try DT[(col)], DT[DT$col], or "
"DT[col==TRUE] is particularly clear and is optimized"
msgstr ""
"'%s' n'est pas visible dans le contexte de l'appelant, mais c'est une "
"colonne de type %s. Si vous souhaitez sélectionner des lignes pour "
"lesquelles cette colonne vaut TRUE, ou peut-être que cette colonne contient "
"ses propres numéros de lignes à sélectionner, essayez DT[(col)], DT[DT$col], "
"ou DT[col==TRUE] qui est particulièrement clair et optimisé"

#: data.table.R:436
#, c-format
msgid ""
"%s. When the first argument inside DT[...] is a single symbol (e.g. "
"DT[var]), data.table looks for var in calling scope."
msgstr ""
"%s. Lorsque le premier argument de DT[...] est un symbole unique (par "
"exemple DT[var]), data.table cherche var dans le contexte de l'appelant."

#: data.table.R:448
#, c-format
msgid ""
"i is invalid type (matrix). Perhaps in future a 2 column matrix could return "
"a list of elements of DT (in the spirit of A[B] in FAQ 2.14). Please report "
"to data.table issue tracker if you'd like this, or add your comments to FR "
"#657."
msgstr ""
"i a un type non valide (matrice). Peut-être qu'à l'avenir, une matrice à 2 "
"colonnes pourrait renvoyer une liste d'éléments de DT (dans l'esprit de A[B] "
"de la FAQ 2.14). Veuillez rapporter ce problème dans le gestionnaire de "
"tickets (issues tracker) de data.table si vous le souhaitez, ou ajouter vos "
"commentaires à FR #657."

#: data.table.R:471
#, c-format
msgid ""
"When i is a data.table (or character vector), the columns to join by must be "
"specified using the 'on=' argument (see ?data.table); by keying x (i.e., x "
"is sorted and marked as such, see ?setkey); or by using 'on = .NATURAL' to "
"indicate using the shared column names between x and i (i.e., a natural "
"join). Keyed joins might have further speed benefits on very large data due "
"to x being sorted in RAM."
msgstr ""
"Lorsque i est un data.table (ou un vecteur de chaînes de caractères), les "
"colonnes à joindre doivent être spécifiées à l'aide de l'argument "
"'on=' (voir ?data.table), par l'attribution d'une clé à x (c'est-à-dire x "
"trié, et, marqué comme trié, voir ?setkey), ou en utilisant 'on = .NATURAL' "
"pour indiquer l'utilisation de noms de colonnes partagées entre x et i "
"(c'est-à-dire, une jointure naturelle). Les jointures avec clé peuvent avoir "
"des avantages supplémentaires en termes de rapidité sur des données très "
"volumineuses car x est trié en mémoire vive."

#: data.table.R:479
#, c-format
msgid "Attempting to do natural join but no common columns in provided tables"
msgstr ""
"Aucune colonne commune dans les tables fournies pour réaliser la jointure "
"naturelle"

#: data.table.R:482
msgid "Joining but 'x' has no key, natural join using all 'x' columns"
msgstr ""
"Jointure mais 'x' n'a pas de clé, jointure naturelle en utilisant toutes les "
"colonnes 'x'"

#: data.table.R:484
msgid "Joining but 'x' has no key, natural join using: %s"
msgstr "Jointure mais 'x' n'a pas de clé, jointure naturelle en utilisant : %s"

#: data.table.R:513
msgid "not-join called with 'by=.EACHI'; Replacing !i with i=setdiff_(x,i) ..."
msgstr ""
"non jointure appelée avec 'by=.EACHI'; !i est remplacé par i=setdiff_(x,"
"i) ..."

#: data.table.R:544
msgid "Constructing irows for '!byjoin || nqbyjoin' ..."
msgstr "Construction de irows pour '!byjoin || nqbyjoin' ..."

#: data.table.R:558 mergelist.R:124
#, c-format
msgid ""
"Joining resulted in many-to-many join. Perform quality check on your data, "
"use mult!='all', or set 'datatable.join.many' option to TRUE to allow rows "
"explosion."
msgstr ""
"Jointure faite de plusieurs à plusieurs. Refaire un contrôle sur la qualité "
"des données, utiliser mult!='all', ou initialiser l'option 'datatable.join."
"many' à TRUE pour permettre l'explosion des lignes."

#: data.table.R:596
msgid "Reorder irows for 'mult==\"all\" && !allGrp1' ..."
msgstr "Réarranger irows pour 'mult==\"all\" && !allGrp1' ..."

#: data.table.R:608
msgid "Reordering %d rows after bmerge done in ..."
msgstr "Réarrangement de %d lignes suite à bmerge dans ..."

#: data.table.R:625
#, c-format
msgid "logical error. i is not a data.table, but 'on' argument is provided."
msgstr ""
"erreur logique. i n'est pas un data.table, mais l'argument 'on' est fourni."

#: data.table.R:629
#, c-format
msgid "i has evaluated to type %s. Expecting logical, integer or double."
msgstr ""
"i a pour type %s alors qu'un booléen, un entier ou un double est attendu."

#: data.table.R:651
#, c-format
msgid ""
"i evaluates to a logical vector length %d but there are %d rows. Recycling "
"of logical i is no longer allowed as it hides more bugs than is worth the "
"rare convenience. Explicitly use rep(...,length=.N) if you really need to "
"recycle."
msgstr ""
"i représente un vecteur logique de longueur %d mais il y a %d lignes. Le "
"recyclage du vecteur logique i n'est plus autorisé, car il cache plus "
"souvent des bogues qu'il n'en vaut la peine. Utiliser explicitement rep(...,"
"length=.N) si vous avez vraiment besoin de recycler ce vecteur."

#: data.table.R:654
#, c-format
msgid ""
"Please use nomatch=NULL instead of nomatch=0; see news item 5 in v1.12.0 "
"(Jan 2019)"
msgstr ""
"Veuillez utiliser nomatch=NULL au lieu de nomatch=0; voir l'élément 5 des "
"news v1.12.0 (janvier 2019)"

#: data.table.R:669
msgid "Inverting irows for notjoin done in ..."
msgstr "Inversion de irows pour notjoin faite dans ..."

#: data.table.R:725
#, c-format
msgid "`:=` is only supported under with=TRUE, see ?`:=`."
msgstr "`:=` n'est reconnu que si with=TRUE, voir ?`:=`."

#: data.table.R:767
#, c-format
msgid "Item %d of j is %d which is outside the column number range [1,ncol=%d]"
msgstr ""
"L'élément %d de j vaut %d qui n'est pas dans l'intervalle des indices de "
"colonne [1,ncol=%d]"

#: data.table.R:770
#, c-format
msgid "j mixes positives and negatives"
msgstr "j mélange les valeurs positives et négatives"

#: data.table.R:778
#, c-format
msgid ""
"When with=FALSE, j-argument should be of type logical/character/integer "
"indicating the columns to select."
msgstr ""
"Lorsque with=FALSE, l’argument j doit être de type boléen/caractère/entier "
"indiquant les colonnes à sélectionner."

#: data.table.R:792
#, c-format
msgid ""
"'by' contains .I but only the following are currently supported: by=.I, by=."
"(.I), by=c(.I), by=list(.I)"
msgstr ""
"'by' contient .I qui n'autorisé que pour : by=.I, by=.(.I), by=c(.I), "
"by=list(.I)"

#: data.table.R:816
#, c-format
msgid "by=c(...), key(...) or names(...) must evaluate to 'character'"
msgstr "by=c(...), key(...) ou names(...) doivent être de type 'character'"

#: data.table.R:826
#, c-format
msgid ""
"'by' is a character vector length %d but one or more items include a comma. "
"Either pass a vector of column names (which can contain spaces, but no "
"commas), or pass a vector length 1 containing comma separated column names. "
"See ?data.table for other possibilities."
msgstr ""
"'by' est un vecteur de caractères de longueur %d mais un ou plusieurs "
"éléments contiennent une virgule. Passer un vecteur de noms de colonnes "
"(pouvant contenir des espaces, mais pas de virgule), ou un vecteur de "
"longueur 1 contenant des noms de colonnes séparés par une virgule. Voir ?"
"data.table pour d'autres possibilités."

#: data.table.R:833
#, c-format
msgid "At least one entry of by is empty"
msgstr "Au moins une valeur de by est vide"

#: data.table.R:860
msgid "by index '%s' but that index has 0 length. Ignoring."
msgstr "par indice '%s' mais cet indice a pour longueur 0. Ignoré."

#: data.table.R:883
msgid "i clause present and columns used in by detected, only these subset: %s"
msgstr ""
"la clause i est présente et les colonnes utilisées dans by existent, "
"uniquement ce sous-ensemble : %s"

#: data.table.R:886
msgid ""
"i clause present but columns used in by not detected. Having to subset all "
"columns before evaluating 'by': '%s'"
msgstr ""
"la clause i est présente mais les colonnes utilisées dans by n'ont pas été "
"trouvées. Ils faut disposer des sous-ensembles de toutes les colonnes avant "
"d'évaluer avec 'by': '%s'"

#: data.table.R:908
#, c-format
msgid ""
"'by' appears to evaluate to column names but isn't c() or key(). Use "
"by=list(...) if you can. Otherwise, by=eval%s should work. This is for "
"efficiency so data.table can detect which columns are needed."
msgstr ""
"'by' semble représenter des noms de colonnes mais n'est pas c() ni key(). "
"Utiliser by=list(...) si vous le pouvez. Sinon, by=eval%s doit fonctionner. "
"C'est à data.table de détecter les colonnes nécessaires pour un traitement "
"efficace."

#: data.table.R:919
#, c-format
msgid ""
"'by' or 'keyby' must evaluate to a vector or a list of vectors (where 'list' "
"includes data.table and data.frame which are lists, too)"
msgstr ""
"'by' ou 'keyby' doit correspondre à un vecteur ou à une liste de vecteurs "
"(où 'list' inclut data.table et data.frame qui sont également des listes)"

#: data.table.R:923
#, c-format
msgid ""
"Column or expression %d of 'by' or 'keyby' is type '%s' which is not "
"currently supported. If you have a compelling use case, please add it to "
"https://github.com/Rdatatable/data.table/issues/1597. As a workaround, "
"consider converting the column to a supported type, e.g. by=sapply(list_col, "
"toString), whilst taking care to maintain distinctness in the process."
msgstr ""
"La colonne ou l'expression %d de 'by' ou 'keyby' est de type '%s' qui n'est "
"pas pris en charge actuellement. Si vous avez un cas d'utilisation "
"convaincant, veuillez l'ajouter sur https://github.com/Rdatatable/data.table/"
"issues/1597. Comme solution de contournement, envisagez de convertir la "
"colonne en un type pris en charge, par exemple by=sapply(list_col, "
"toString), tout en veillant à maintenir la distinction dans le processus."

#: data.table.R:951
msgid ""
"by-expression '%s' is not named, and the auto-generated name '%s' clashed "
"with variable(s) in j. Therefore assigning the entire by-expression as name."
msgstr ""
"l'expression by '%s' n'est pas nommée, et le nom auto-généré '%s' est en "
"conflit avec les variables de j. L'expression by entière est assignée par "
"nom."

#: data.table.R:985
#, c-format
msgid "Item %d of the .() or list() passed to j is missing"
msgstr "L'élément %d de .() ou de list() passé à j est absent"

#: data.table.R:991
#, c-format
msgid ""
"j may not evaluate to the same number of columns for each group; if you're "
"sure this warning is in error, please put the branching logic outside of "
"[ for efficiency"
msgstr ""
"j peut ne pas évaluer le même nombre de colonnes pour chaque groupe ; si "
"vous êtes sûr que cet avertissement est une erreur, veuillez placer la "
"logique de branchement en dehors de [ pour plus d'efficacité"

#: data.table.R:993
#, c-format
msgid ""
"Different branches of j expression produced different auto-named columns: "
"%s; using the most \"last\" names. If this was intentional (e.g., you know "
"only one branch will ever be used in a given query because the branch is "
"controlled by a function argument), please (1) pull this branch out of the "
"call; (2) explicitly provide missing defaults for each branch in all cases; "
"or (3) use the same name for each branch and re-name it in a follow-up call."
msgstr ""
"Différentes branches de l'expression j ont produit différentes colonnes auto-"
"nommées : %s ; Les derniers noms connus sont utilisés. Si cela était "
"intentionnel (par exemple, vous savez qu'une seule branche sera utilisée "
"dans une requête donnée parce que la branche est contrôlée par un argument "
"de fonction), veuillez (1) retirer cette branche de l'appel ; (2) fournir "
"explicitement les valeurs par défaut manquantes pour chaque branche dans "
"tous les cas ; ou (3) utiliser le même nom pour chaque branche et la "
"renommer dans un appel ultérieur."

#: data.table.R:1063
#, c-format
msgid ""
"When .SDcols is a function, it is applied to each column; the output of this "
"function must be a non-missing boolean scalar signalling inclusion/exclusion "
"of the column. However, these conditions were not met for: %s"
msgstr ""
"Quand .SDcols est une fonction, elle est appliquée à chaque colonne ; La "
"sortie de cette fonction doit être un scalaire booléen présent indiquant "
"l'inclusion ou l'exclusion de la colonne. Néanmoins ces conditions ne sont "
"pas satisfaite pour : %s"

#: data.table.R:1069
#, c-format
msgid ".SDcols missing at the following indices: %s"
msgstr ".SDcols est absent aux indices suivants : %s"

#: data.table.R:1071
#, c-format
msgid ".SDcols is a logical vector of length %d but there are %d columns"
msgstr ""
".SDcols est un vecteur de booléens de longueur %d mais il y a %d colonnes"

#: data.table.R:1077
#, c-format
msgid ".SDcols is numeric but has both +ve and -ve indices"
msgstr ".SDcols est numérique mais comporte à la fois des indices +ve et -ve"

#: data.table.R:1079
#, c-format
msgid ".SDcols is numeric but out of bounds [1, %d] at: %s"
msgstr ".SDcols est numérique mais hors de l'intervalle [1, %d] à : %s"

#: data.table.R:1083
#, c-format
msgid ".SDcols should be column numbers or names"
msgstr ".SDcols doit fournir des numéros de colonnes ou des noms"

#: data.table.R:1085
#, c-format
msgid "Some items of .SDcols are not column names: %s"
msgstr "Certains éléments de .SDcols ne sont pas des noms de colonnes : %s"

#: data.table.R:1098
msgid ""
"'(m)get' found in j. ansvars being set to all columns. Use .SDcols or a "
"single j=eval(macro) instead. Both will detect the columns used which is "
"important for efficiency.\n"
"Old ansvars: %s"
msgstr ""
"'(m)get' trouvé dans j. ansvars initialisé à toutes les colonnes. Utiliser à "
"la place .SDcols ou un seul j=eval(macro) . Les deux vont détecter les "
"colonnes utilisées ce qui est important pour les performances.\n"
"Ancien ansvars : %s"

#: data.table.R:1118
msgid "New ansvars: %s"
msgstr "Nouveau ansvars : %s"

#: data.table.R:1127
#, c-format
msgid ""
"This j doesn't use .SD but .SDcols has been supplied. Ignoring .SDcols. See ?"
"data.table."
msgstr ""
"Ce j n'utilise pas .SD mais .SDcols qui a été fourni. .SDcols est ignoré. "
"Voir ?data.table."

#: data.table.R:1130
msgid "Detected that j uses these columns: %s"
msgstr "Trouvé que j utillise les colonnes suivantes : %s"

#: data.table.R:1143
#, c-format
msgid ""
".SD is locked. Using := in .SD's j is reserved for possible future use; a "
"tortuously flexible way to modify by group. Use := in j directly to modify "
"by group by reference."
msgstr ""
".SD est verrouillé. L'utilisation de := dans j de .SD est réservée pour une "
"utilisation future possible ; une manière un peu tordue de modifier par "
"groupe. Utiliser := dans j directement pour modifier par groupe et par "
"référence."

#: data.table.R:1154
#, c-format
msgid "In %s(col1=val1, col2=val2, ...) form, all arguments must be named."
msgstr ""
"Dans la forme %s(col1=val1, col2=val2, ...), tous les arguments doivent être "
"nommés."

#: data.table.R:1177
#, c-format
msgid ""
"In %s(col1=val1, col2=val2, ...) form, all arguments must be named, but the "
"last argument has no name. Did you forget a trailing comma?"
msgstr ""
"Dans la forme %s(col1=val1, col2=val2, ...), tous les arguments doivent être "
"nommés, cependant le dernier argument n’a pas de nom. Avez-vous oublié une "
"virgule à la fin ?"

#: data.table.R:1179
#, c-format
msgid ""
"In %s(col1=val1, col2=val2, ...) form, all arguments must be named, but "
"these arguments lack names: %s."
msgstr ""
"Dans la forme %s(col1=val1, col2=val2, ...), tous les arguments doivent être "
"nommés, mais les arguments suivants n’ont pas de nom : %s."

#: data.table.R:1186
#, c-format
msgid ""
"LHS of := must be a symbol, or an atomic vector (column names or positions)."
msgstr ""
"Le membre gauche de := doit être un symbole, ou un vecteur atomique (noms de "
"colonnes ou positions)."

#: data.table.R:1191
#, c-format
msgid ""
"LHS of := appears to be column positions but are outside [1,ncol] range. New "
"columns can only be added by name."
msgstr ""
"Le membre gauche de := semble être des positions de colonnes mais elles sont "
"en dehors de l'intervalle [1,ncol] . Ajouter les nouvelles colonnes par nom "
"uniquement."

#: data.table.R:1193
#, c-format
msgid ""
"LHS of := isn't column names ('character') or positions ('integer' or "
"'numeric')"
msgstr ""
"Le membre gauche de := ne correspond pas à des noms de colonnes "
"('character') ni à des positions ('integer' ou 'numeric')"

#: data.table.R:1209
msgid ""
"No rows match i. No new columns to add so not evaluating RHS of :=\n"
"Assigning to 0 row subset of %d rows"
msgstr ""
"Aucune ligne ne correspond à i. Aucune nouvelle colonne à ajouter donc pas "
"d'évaluation du membre de droite de :=\n"
"Initialisation à 0 sous-ensemble de lignes des %d lignes"

#: data.table.R:1225
#, c-format
msgid ""
"A shallow copy of this data.table was taken so that := can add or remove %d "
"columns by reference. At an earlier point, this data.table was copied by R "
"(or was created manually using structure() or similar). Avoid names<- and "
"attr<- which in R currently (and oddly) may copy the whole data.table. Use "
"set* syntax instead to avoid copying: ?set, ?setnames and ?setattr. It's "
"also not unusual for data.table-agnostic packages to produce tables affected "
"by this issue. If this message doesn't help, please report your use case to "
"the data.table issue tracker so the root cause can be fixed or this message "
"improved."
msgstr ""
"Une copie (shallow) du data.table a été utilisée afin que := puisse ajouter "
"ou supprimer %d colonnes par référence. Ce data.table a été copié "
"antérieurement par R (ou a été créé manuellement en utilisant structure() ou "
"similaire). Évitez names<- et attr<- qui, dans R, peuvent actuellement (et "
"bizarrement) copier tout le data.table. Utilisez plutôt la syntaxe set* à la "
"place pour éviter la copie : ?set, ?setnames et ?setattr. Il est aussi "
"fréquent que les packages qui ne reconnaissent pas les data.tables génèrent "
"des tables concernées par ce problème. Si ce message ne vous aide pas, "
"veuillez rapporter votre cas d'utilisation dans le gestionnaire de tickets "
"de data.table (issue tracker) afin que la cause première puisse être "
"corrigée ou que ce message soit amélioré."

#: data.table.R:1285
#, c-format
msgid ""
"Variable '%s' is not found in calling scope. Looking in calling scope "
"because this symbol was prefixed with .. in the j= parameter."
msgstr ""
"La variable '%s' n'est pas visible dans le contexte de l'appelant désigné "
"par le préfixe .. du symbole dans le paramètre j= ."

#: data.table.R:1358
#, c-format
msgid ""
"j (the 2nd argument inside [...]) is a single symbol but column name '%1$s' "
"is not found. If you intended to select columns using a variable in calling "
"scope, please try DT[, ..%1$s]. The .. prefix conveys one-level-up similar "
"to a file system path."
msgstr ""
"j (le deuxième argument à l'intérieur de [...]) est un symbole unique mais "
"le nom de la colonne '%1$s' n'est pas trouvé. Si vous souhaitez sélectionner "
"des colonnes à l'aide d'une variable dans la portée de l'appelant, essayez "
"DT[, ..%1$s]. Le préfixe .. indique un niveau supérieur similaire à celui "
"d'un chemin d'accès pour un système de fichiers."

#: data.table.R:1408
msgid ""
"Growing vector of column pointers from truelength %d to %d. A shallow copy "
"has been taken, see ?setalloccol. Only a potential issue if two variables "
"point to the same data (we can't yet detect that well) and if not you can "
"safely ignore this. To avoid this message you could setalloccol() first, "
"deep copy first using copy(), wrap with suppressWarnings() or increase the "
"'datatable.alloccol' option."
msgstr ""
"Vecteur croissant des pointeurs de colonnes de truelength %d à %d. Une copie "
"(shallow) a été faite, voir ?setalloccol. Il reste seulement un problème "
"potentiel quand deux variables pointent sur les mêmes données (il n'est pas "
"encore possible de détecter cela correctement) mais vous pouvez l'ignorer si "
"ce n'est pas le cas. Pour éviter ce message utilisez d'abord setalloccol(), "
"puis copiez le tout avec copy(), encadrez avec suppressWarnings() ou "
"augmentez l'option 'datatable.alloccol'."

#: data.table.R:1410
msgid ""
"Note that the shallow copy will assign to the environment from which := was "
"called. That means for example that if := was called within a function, the "
"original table may be unaffected."
msgstr ""
"Noter que la copie (shallow) sera fonction de l'environnement dans lequel := "
"a été appelé. Ce qui signifie par exemple que si := est appelé d'une "
"fonction, il est possible que la table originale ne soit pas modifiée."

#: data.table.R:1495
#, c-format
msgid ""
"The column '.N' can't be grouped because it conflicts with the special .N "
"variable. Try setnames(DT,'.N','N') first."
msgstr ""
"La colonne '.N' ne peut pas être groupée car elle est en conflit avec la "
"variable spéciale .N variable. Essayer d'abord setnames(DT,'.N','N') ."

#: data.table.R:1496
#, c-format
msgid ""
"The column '.I' can't be grouped because it conflicts with the special .I "
"variable. Try setnames(DT,'.I','I') first."
msgstr ""
"La colonne '.I' ne peut pas être groupée car elle est en conflit avec la "
"variable spéciale .I . Essayez d'abord setnames(DT,'.I','I')."

#: data.table.R:1515
msgid ""
"Note: forcing units=\"secs\" on implicit difftime by group; call difftime "
"explicitly to choose custom units"
msgstr ""
"Note : forçage de units=\"secs\" pour le difftime implicite par groupe; "
"appeler difftime directement pour adapter les unités personnalisées"

#: data.table.R:1524
#, c-format
msgid "logical error. i is not a data.table, but mult='all' and 'by'=.EACHI"
msgstr ""
"erreur logique. i n'est pas un data.table, mais mult='all' et 'by'=.EACHI"

#: data.table.R:1551
msgid "Finding groups using forderv ..."
msgstr "Chercher les groupes avec forderv ..."

#: data.table.R:1565 data.table.R:1597
msgid "Finding group sizes from the positions (can be avoided to save RAM) ..."
msgstr ""
"Recherche de la taille des groupes à partir des positions (peut être évité "
"pour économiser la RAM) ..."

#: data.table.R:1573
msgid "Getting back original order ..."
msgstr "Revenir à l'ordre original ..."

#: data.table.R:1585
msgid "Finding groups using uniqlist on key ..."
msgstr "Recherche de groupes en utilisant uniqlist sur la clé ..."

#: data.table.R:1589
msgid "Finding groups using uniqlist on index '%s' ..."
msgstr "Recherche de groupes en utilisant uniqlist sur l'indice '%s' ..."

#: data.table.R:1808
msgid "lapply optimization changed j from '%s' to '%s'"
msgstr "l'optimisation lapply a modifié j de '%s' en '%s'"

#: data.table.R:1810
msgid "lapply optimization is on, j unchanged as '%s'"
msgstr "l'optimisation lapply est active, j reste '%s' non modifié"

#: data.table.R:1819 data.table.R:1843
msgid "GForce optimized j to '%s' (see ?GForce)"
msgstr "GForce a optimisé j à '%s' (voir ?GForce)"

#: data.table.R:1844
msgid ""
"GForce is on, but not activated for this query; left j unchanged (see ?"
"GForce)"
msgstr ""
"GForce est actif mais ne concerne pas cette requête; j reste inchangé (voir ?"
"GForce)"

#: data.table.R:1863
#, c-format
msgid ""
"Unable to optimize call to mean() and could be very slow. You must name 'na."
"rm' like that otherwise if you do mean(x,TRUE) the TRUE is taken to mean "
"'trim' which is the 2nd argument of mean. 'trim' is not yet optimized."
msgstr ""
"Impossible d'optimiser l'appel à mean() et risque d'être très lent. Vous "
"devez nommer 'na.rm' comme cela, sinon si vous faites mean(x,TRUE), TRUE est "
"considéré comme signifiant 'trim' qui est le deuxième argument de mean. "
"'trim' n'est pas encore optimisé."

#: data.table.R:1867
msgid "Old mean optimization changed j from '%s' to '%s'"
msgstr "L'ancienne optimisation de la moyenne a modifié j de '%s' en '%s'"

#: data.table.R:1869
msgid "Old mean optimization is on, left j unchanged."
msgstr ""
"L'ancienne optimisation de la moyenne est active, j n'a pas été modifié."

#: data.table.R:1879
msgid "All optimizations are turned off"
msgstr "Toutes les optimisations sont désactivées"

#: data.table.R:1880
msgid "Optimization is on but left j unchanged (single plain symbol): '%s'"
msgstr ""
"L'optimisation est active mais a laissé j inchangé (symbole simple seul) : "
"'%s'"

#: data.table.R:1909
msgid "Making each group and running j (GForce %s) ..."
msgstr "Création de chaque groupe et exécution de j (GForce %s) ..."

#: data.table.R:2005
msgid "setkey() after the := with keyby= ..."
msgstr "setkey() après le := avec keyby= ..."

#: data.table.R:2009
#, c-format
msgid ""
"The setkey() normally performed by keyby= has been skipped (as if by= was "
"used) because := is being used together with keyby= but the keyby= contains "
"some expressions. To avoid this warning, use by= instead, or provide "
"existing column names to keyby=."
msgstr ""
"Le setkey() normalement exécuté par keyby= a été ignoré (comme si by= était "
"utilisé) parce que := est utilisé avec keyby=, mais keyby= contient des "
"expressions. Pour éviter cet avertissement, utilisez by= à la place, ou "
"fournissez des noms de colonnes existantes à keyby=."

#: data.table.R:2035
msgid "setkey() afterwards for keyby=.EACHI ..."
msgstr "setkey() après, quand keyby=.EACHI ..."

#: data.table.R:2144
#, c-format
msgid "rownames and rownames.value cannot both be used at the same time"
msgstr "rownames et rownames.value ne peuvent pas être utilisés simultanément"

#: data.table.R:2147
#, c-format
msgid ""
"length(rownames)==%d but nrow(DT)==%d. The rownames argument specifies a "
"single column name or number. Consider rownames.value= instead."
msgstr ""
"length(rownames)==%d mais nrow(DT)==%d. L'argument rownames spécifie un nom "
"de colonne unique ou un nombre. Remplacez par rownames.value= ."

#: data.table.R:2151
#, c-format
msgid ""
"length(rownames)==0 but should be a single column name or number, or NULL"
msgstr ""
"length(rownames)==0 mais doit être un nom de vecteur colonne, ou un nombre, "
"ou NULL"

#: data.table.R:2155
#, c-format
msgid ""
"rownames is TRUE but key has multiple columns %s; taking first column x[,1] "
"as rownames"
msgstr ""
"rownames vaut TRUE mais la clé a plusieurs colonnes %s ; Seule la première "
"colonne x[,1] est utilisée pour le nom des lignes"

#: data.table.R:2165
#, c-format
msgid "'%s' is not a column of x"
msgstr "'%s' n'est pas une colonne de x"

#: data.table.R:2171
#, c-format
msgid ""
"as.integer(rownames)==%d which is outside the column number range [1,ncol="
"%d]."
msgstr ""
"as.integer(rownames)==%d est en dehors de l'intervalle des numéros de "
"colonne [1,ncol=%d]."

#: data.table.R:2176
#, c-format
msgid "length(rownames.value)==%d but should be nrow(x)==%d"
msgstr "length(rownames.value)==%d mais devrait être nrow(x)==%d"

#: data.table.R:2272
#, c-format
msgid ""
"When i is a matrix in DT[i]<-value syntax, it doesn't make sense to provide j"
msgstr ""
"Si i est une matrice, dans la syntaxe DT[i]<-valeur, fournir j n'a pas de "
"sens"

#: data.table.R:2282
#, c-format
msgid "j must be an atomic vector, see ?is.atomic"
msgstr "j doit être un vecteur atomique, voir ?is.atomic"

#: data.table.R:2283
#, c-format
msgid "NA in j"
msgstr "NA trouvé dans j"

#: data.table.R:2289
#, c-format
msgid "j must be vector of column name or positions"
msgstr "j doit être un vecteur de noms de colonnes ou de positions"

#: data.table.R:2290
#, c-format
msgid ""
"Attempt to assign to column position greater than ncol(x). Create the column "
"by name, instead. This logic intends to catch (most likely) user errors."
msgstr ""
"Tentative d'accès à une colonne située au-delà de ncol(x). À la place, créez "
"la colonne par nom. Cette logique permet d'intercepter les erreurs "
"utilisateur (le plus souvent)."

#: data.table.R:2357
#, c-format
msgid ""
"data.table inherits from data.frame (from v1.5), but this data.table does "
"not. Has it been created manually (e.g. by using 'structure' rather than "
"'data.table') or saved to disk using a prior version of data.table?"
msgstr ""
"data.table hérite de data.frame (à partir de la version 1.5), mais pas ce "
"data.table. A-t-il été créé manuellement (par exemple en utilisant "
"'structure' plutôt que 'data.table') ou sauvegardé sur disque à l'aide d'une "
"version antérieure de data.table ?"

#: data.table.R:2366
#, c-format
msgid "attempting to assign invalid object to dimnames of a data.table"
msgstr "assignation d'un objet non valide à dimnames d'une data.table"

#: data.table.R:2367
#, c-format
msgid "data.tables do not have rownames"
msgstr "les data.tables n'ont pas de rownames"

#: data.table.R:2368 data.table.R:2752
#, c-format
msgid "Can't assign %d names to a %d-column data.table"
msgstr "Impossible d'assigner %d noms à une data.table de %d colonne(s)"

#: data.table.R:2432
#, c-format
msgid "'subset' must evaluate to logical"
msgstr "'subset' doit représenter une valeur booléenne"

#: data.table.R:2475
#, c-format
msgid "Argument 'invert' must be logical TRUE/FALSE"
msgstr "L'argument 'invert' doit être un booléen TRUE / FALSE"

#: data.table.R:2521
#, c-format
msgid "group length is 0 but data nrow > 0"
msgstr "la longueur du groupe est 0 mais pour les données, nrow > 0"

#: data.table.R:2523
#, c-format
msgid ""
"passing 'f' argument together with 'by' is not allowed, use 'by' when split "
"by column in data.table and 'f' when split by external factor"
msgstr ""
"le passage de l'argument 'f' en même temps que 'by' n'est pas autorisé, "
"utilisez 'by' pour la division par colonne dans data.table et 'f' pour la "
"division par facteur externe"

#: data.table.R:2531
#, c-format
msgid "Either 'by' or 'f' argument must be supplied"
msgstr "Fournir un seul argument 'by' ou 'f' mais pas les deux"

#: data.table.R:2533
#, c-format
msgid "Column '.ll.tech.split' is reserved for split.data.table processing"
msgstr ""
"La colonne '.ll.tech.split' est réservée au traitement de split.data.table"

#: data.table.R:2534
#, c-format
msgid "Column '.nm.tech.split' is reserved for split.data.table processing"
msgstr ""
"La colonne '.nm.tech.split' est réservée au traitement de split.data.table"

#: data.table.R:2535
#, c-format
msgid "Argument 'by' must refer to column names in x"
msgstr "L'argument 'by' doit se rapporter aux noms des colonnes dans x"

#: data.table.R:2536
#, c-format
msgid ""
"Argument 'by' must refer only to atomic-type columns, but the following "
"columns are non-atomic: %s"
msgstr ""
"L'argument 'by' doit faire référence uniquement à des colonnes de type "
"atomique, mais les colonnes suivantes ne le sont pas : %s"

#: data.table.R:2583
msgid "Processing split.data.table with: %s"
msgstr "Traitement de split.data.table avec : %s"

#: data.table.R:2683
#, c-format
msgid ""
"x is not a data.table|frame. Shallow copy is a copy of the vector of column "
"pointers (only), so is only meaningful for data.table|frame"
msgstr ""
"x n'est pas un data.table|frame. Shallow copy est une copie du vecteur de "
"pointeurs de colonnes (uniquement), et n'a donc de sens que pour un data."
"table|frame"

#: data.table.R:2692
#, c-format
msgid "setalloccol attempting to modify `*tmp*`"
msgstr "setalloccol essaie de modifier `*tmp*`"

#: data.table.R:2727
#, c-format
msgid ""
"Input is a length=1 logical that points to the same address as R's global "
"value. Therefore the attribute has not been set by reference, rather on a "
"copy. You will need to assign the result back to a variable. See issue #1281."
msgstr ""
"L'entrée est un booléen de longueur 1 pointant vers la même adresse que la "
"valeur globale de R. C'est pourquoi l'attribut n'a pas été initialisé par "
"référence mais plutôt par copie. Vous devrez donc assigner le résultat à une "
"variable. Voir le tickets (issues) numéro #1281."

#: data.table.R:2742
#, c-format
msgid "x is not a data.table or data.frame"
msgstr "x n'est pas une data.table ni un data.frame"

#: data.table.R:2744
#, c-format
msgid "x has %d columns but its names are length %d"
msgstr "x a %d colonnes mais les noms sont de longueur %d"

#: data.table.R:2751
#, c-format
msgid "Passed a vector of type '%s'. Needs to be type 'character'."
msgstr "Passage d'un vecteur de type '%s'. Doit être de type 'character'."

#: data.table.R:2764
#, c-format
msgid "'new' is not a character vector or a function"
msgstr "'new' n’est pas un vecteur de chaîne de caractères ni une fonction"

#: data.table.R:2766
#, c-format
msgid "NA in 'new' at positions %s"
msgstr "NA est présent dans 'new' aux positions %s"

#: data.table.R:2767
#, c-format
msgid "Some duplicates exist in 'old': %s"
msgstr "Présence de certains doublons dans 'old' : %s"

#: data.table.R:2769
#, c-format
msgid "'old' is type %s but should be integer, double or character"
msgstr ""
"'old' est de type %s mais doit être un entier, un double ou de type "
"'character'"

#: data.table.R:2770
#, c-format
msgid "'old' is length %d but 'new' is length %d"
msgstr "'old' est de longueur %d et 'new' est de longueur %d"

#: data.table.R:2771
#, c-format
msgid "NA (or out of bounds) in 'old' at positions %s"
msgstr "NA (ou valeurs hors limites) trouvées dans 'old' aux positions %s"

#: data.table.R:2774
#, c-format
msgid ""
"Item %d of 'old' is '%s' which appears several times in column names. Just "
"the first will be changed. There are %d other items in 'old' that are also "
"duplicated in column names."
msgstr ""
"L'élément %d de 'old' est '%s' et apparait plusieurs fois dans les noms des "
"colonnes. Seul le premier sera modifié. Il reste %d autres éléments dans "
"'old' qui sont également dupliqués dans les noms des colonnes."

#: data.table.R:2782
#, c-format
msgid ""
"Items of 'old' not found in column names: %s. Consider skip_absent=TRUE."
msgstr ""
"Eléments de 'old' non trouvés parmi les noms de colonnes : %s. Veuillez "
"utiliser skip_absent=TRUE."

#: data.table.R:2823
#, c-format
msgid "Provide either before= or after= but not both"
msgstr "Fournir before= ou after= mais pas les deux simultanément"

#: data.table.R:2825
#, c-format
msgid "before=/after= accept a single column name or number, not more than one"
msgstr ""
"before= ou after= n'acceptent qu'un seul nom de colonne ou nombre et pas plus"

#: data.table.R:2882
#, c-format
msgid "Input is %s but should be a plain list of items to be stacked"
msgstr "L'entrée est %s mais doit être une liste d'éléments à empiler"

#: data.table.R:2886
#, c-format
msgid ""
"idcol must be a logical or character vector of length 1. If logical TRUE the "
"id column will named '.id'."
msgstr ""
"idcol doit être un vecteur booléen ou un vecteur de caractères de longueur "
"1. Si la valeur logique est TRUE, la colonne id sera nommée '.id'."

#: data.table.R:2891
#, c-format
msgid "use.names=NA invalid"
msgstr "use.names=NA non valide"

#: data.table.R:2893
#, c-format
msgid ""
"use.names='check' cannot be used explicitly because the value 'check' is new "
"in v1.12.2 and subject to change. It is just meant to convey default "
"behavior. See ?rbindlist."
msgstr ""
"use.names='check' ne peut être utilisé explicitement car la valeur 'check' "
"est nouvelle en v1.12.2 et peut changer à l'avenir. Elle est présente juste "
"pour garder le comportement par défaut. Voir ?rbindlist."

#: data.table.R:2908
#, c-format
msgid ""
"Check that is.data.table(DT) == TRUE. Otherwise, `:=` is defined for use in "
"j, once only and in particular ways. See help(\":=\", \"data.table\"). A "
"common reason for this error is allocating a new column in `j` and using `<-"
"` instead of `:=`; e.g., `DT[, new_col <- 1]` should be `DT[, new_col := "
"1]`. Another is using `:=` in a multi-statement `{...}` block; please use `:"
"=` as the only statement in `j`."
msgstr ""
"Vérifier que is.data.table(DT) == TRUE. Sinon, `:=` est défini pour être "
"utilisé dans j, une fois seulement et dans des cas particuliers. Voir "
"help(\":=\", \"data.table\"). Une cause commune pour cette erreur est "
"l'allocation d'une nouvelle colonne dans `j` et l'utilisation de `<-` au "
"lieu de `:=`; par exemple, `DT[, new_col <- 1]` doit être `DT[, new_col := "
"1]`. Une autre raison est l'utilisation de `:=` dans un bloc d'instructions "
"multiples `{...}`; veuillez utiliser `:=` comme instruction unique dans `j`."

#: data.table.R:2925
#, c-format
msgid ""
"setDF only accepts data.table, data.frame or list of equal length as input"
msgstr ""
"setDF n'accepte en entrée que des types data.table, data.frame ou des listes "
"d'égale longeur"

#: data.table.R:2926
#, c-format
msgid "rownames contains duplicates"
msgstr "doublons présents dans rownames"

#: data.table.R:2933 data.table.R:2944 data.table.R:2967
#, c-format
msgid "rownames incorrect length; expected %d names, got %d"
msgstr "longueur incorrecte de rownames ; %d noms attendus, %d sont fournis"

#: data.table.R:2952
#, c-format
msgid "All elements in argument 'x' to 'setDF' must be of same length"
msgstr ""
"Tous les éléments de l'argument 'x' de 'setDF' doivent avoir la même longueur"

#: data.table.R:2981
#, c-format
msgid "Cannot find symbol %s"
msgstr "Symbole %s non trouvé"

#: data.table.R:2988
#, c-format
msgid ""
"Cannot convert '%1$s' to data.table by reference because binding is locked. "
"It is very likely that '%1$s' resides within a package (or an environment) "
"that is locked to prevent modifying its variable bindings. Try copying the "
"object to your current environment, ex: var <- copy(var) and then using "
"setDT again."
msgstr ""
"Impossible de convertir '%1$s' en data.table par référence car le lien est "
"verrouillé. Il est très probable que '%1$s' se trouve dans un package (ou un "
"environnement) qui est verrouillé pour empêcher la modification de ses "
"objets. Essayez de copier l'objet dans votre environnement actuel, ex : var "
"<- copy(var) et utilisez ensuite setDT à nouveau."

#: data.table.R:3042
#, c-format
msgid ""
"Argument 'x' to 'setDT' should be a 'list', 'data.frame' or 'data.table'"
msgstr ""
"L'argument 'x' de 'setDT' doit être de type 'list', 'data.frame' ou 'data."
"table'"

#: data.table.R:3075 data.table.R:3100
#, c-format
msgid "'prefix' must be NULL or a character vector of length 1."
msgstr ""
"'prefix' doit être NULL ou un vecteur de chaîne de caractères de longueur 1."

#: data.table.R:3078 data.table.R:3103
#, c-format
msgid "x is a single vector, non-NULL 'cols' doesn't make sense."
msgstr "x est un vecteur unique, donc 'cols' non NULL n'a pas de sens."

#: data.table.R:3082 data.table.R:3107
#, c-format
msgid "x is a list, 'cols' cannot be 0-length."
msgstr "x est une liste, 'cols' ne peut avoir une longueur 0."

#: data.table.R:3262
#, c-format
msgid ""
"It looks like you re-used `:=` in argument %d a functional assignment call "
"-- use `=` instead: %s(col1=val1, col2=val2, ...)"
msgstr ""
"Il semble que vous avez réutilisé `:=` dans l'argument %d d'un appel "
"d'assignation de fonction -- utiliser `=` à la place de %s(col1=val1, "
"col2=val2, ...)"

#: data.table.R:3328
#, c-format
msgid ""
"RHS of %s is length %d which is not 1 or nrow (%d). For robustness, no "
"recycling is allowed (other than of length 1 RHS). Consider %%in%% instead."
msgstr ""
"Le membre de droite de %s a pour longueur %d au lieu de 1 ou nrow (%d) "
"attendu. Pour la robustesse, aucun recyclage n'est autorisé (autre que sur "
"une longueur de 1 du membre de droite). Essayez %%in%% à la place."

#: data.table.R:3360
msgid ""
"Subsetting optimization disabled because the cross-product of RHS values "
"exceeds 1e4, causing memory problems."
msgstr ""
"L'optimisation des sous-ensembles est désactivée car le produit croisé des "
"valeurs du membre de droite dépasse 1e4, ce qui cause des problèmes de "
"mémoire."

#: data.table.R:3378
msgid "Optimized subsetting with key %s"
msgstr "Sous-ensembles optimisés par clé %s"

#: data.table.R:3397 data.table.R:3409
msgid "Optimized subsetting with index '%s'"
msgstr "Sous-ensembles optimisés par indice '%s'"

#: data.table.R:3404
msgid "Creating new index '%s'"
msgstr "Création de nouvel indice '%s'"

#: data.table.R:3405
msgid "Creating index %s done in ..."
msgstr "Création de l'indice '%s' faite dans ..."

#: data.table.R:3438
#, c-format
msgid ""
"'on' argument should be a named atomic vector of column names indicating "
"which columns in 'i' should be joined with which columns in 'x'."
msgstr ""
"l'argument 'on' doit être un vecteur atomique nommé composé de noms de "
"colonnes indiquant quelle colonne de 'i' doit être jointe à quelle colonne "
"de 'x'."

#: data.table.R:3479
#, c-format
msgid ""
"Found more than one operator in one 'on' statement: %s. Please specify a "
"single operator."
msgstr ""
"Plus d'un opérateur trouvé dans une déclaration 'on' : %s. Veuillez "
"spécifier un seul opérateur."

#: data.table.R:3502
#, c-format
msgid ""
"'on' contains no column name: %s. Each 'on' clause must contain one or two "
"column names."
msgstr ""
"'on' n'a pas de nom de colonne : %s. Chaque clause 'on' doit contenir un ou "
"deux noms de colonnes."

#: data.table.R:3504
#, c-format
msgid ""
"'on' contains more than 2 column names: %s. Each 'on' clause must contain "
"one or two column names."
msgstr ""
"la clause 'on' contient plus de 2 noms de colonnes : %s. Chaque clause 'on' "
"doit contenir un ou deux noms de colonnes."

#: data.table.R:3509
#, c-format
msgid "Invalid join operators %s. Only allowed operators are %s."
msgstr ""
"Opérateurs de jointure non valides %s. Les seuls opérateurs autorisés sont "
"%s."

#: devel.R:16
#, c-format
msgid "There is no package %s in provided repository."
msgstr "Package %s non trouvé dans le dépôt fourni."

#: devel.R:30
msgid ""
"No revision information found in DESCRIPTION file for %s package. Make sure "
"that '%s' is correct field in PACKAGES file in your package repository '%s'. "
"Otherwise package will be re-installed every time, proceeding to "
"installation."
msgstr ""
"Aucun information de version n'a été trouvée dans le fichier DESCRIPTION "
"pour le paquet %s. Assurez-vous que '%s' est un champ correct dans le "
"fichier PACKAGES de votre dépôt de paquets '%s'. Sinon le paquet sera "
"renouvelé et installé à chaque fois."

#: devel.R:39
msgid "R %s package has been updated to %s (%s)"
msgstr "Le package R %s a été mis à jour en %s (%s)"

#: devel.R:41
msgid "R %s package is up-to-date at %s (%s)"
msgstr "Le package R %s est à jour en %s (%s)"

#: devel.R:53
msgid ""
"Git revision is not available. Most likely data.table was installed from "
"CRAN or local archive.\n"
"Git revision is available when installing from our repositories 'https://"
"Rdatatable.gitlab.io/data.table' and 'https://Rdatatable.github.io/data."
"table'."
msgstr ""
"La révision Git n'est pas disponible. Probablement data.table a été installé "
"de CRAN ou d'une archive locale.\n"
"La révision Git est disponible quand l'installation se fait à partir de nos "
"dépôts 'https://Rdatatable.gitlab.io/data.table' et 'https://Rdatatable."
"github.io/data.table'."

#: duplicated.R:7
#, c-format
msgid "'fromLast' must be TRUE or FALSE"
msgstr "'fromLast' doit être TRUE ou FALSE"

#: duplicated.R:105
#, c-format
msgid "x must be an atomic vector or a data.frame/data.table"
msgstr "x doit être un vecteur atomique ou un data.frame / data.table"

#: fcast.R:7
#, c-format
msgid "Using '%s' as value column. Use 'value.var' to override"
msgstr ""
"'%s' est utilisé comme colonne de valeurs. Utiliser 'value.var' pour "
"redéfinir"

#: fcast.R:17
#, c-format
msgid ""
"The %1$s generic in data.table has been passed a %2$s, but data.table::%1$s "
"currently only has a method for data.tables. Please confirm your input is a "
"data.table, with setDT(%3$s) or as.data.table(%3$s). If you intend to use a "
"method from reshape2, try installing that package first, but do note that "
"reshape2 is superseded and is no longer actively developed."
msgstr ""
"Le générique %1$s dans data.table a été transmis à un %2$s, mais data."
"table: :%1$s n'a actuellement qu'une méthode pour data.tables. Veuillez "
"confirmer que votre entrée est un data.table, avec setDT(%3$s) ou as.data."
"table(%3$s). Si vous avez l'intention d'utiliser une méthode de reshape2, "
"essayez d'installer ce package en premier, mais notez que reshape2 est "
"dépassé et n'est plus activement développé."

#: fcast.R:24
#, c-format
msgid ""
"Invalid formula. Cast formula should be of the form LHS ~ RHS, for e.g., a + "
"b ~ c."
msgstr ""
"Formule non valide. La formule du cast s'écrit : membre gauche ~ membre "
"droit, par exemple : a + b ~ c."

#: fcast.R:31
#, c-format
msgid "data.table to cast must have unique column names"
msgstr ""
"cast impossible si les noms de colonnes ne sont pas uniques dans la data."
"table"

#: fcast.R:76
#, c-format
msgid "value.var values %s are not found in 'data'."
msgstr "valeurs %s de value.var absentes dans 'data'."

#: fcast.R:92
#, c-format
msgid ""
"When 'fun.aggregate' and 'value.var' are both lists, 'value.var' must be "
"either of length =1 or =length(fun.aggregate)."
msgstr ""
"Si 'fun.aggregate' et 'value.var' sont tous deux des listes, 'value.var' "
"doit avoir une longueur =1 ou =length(fun.aggregate)."

#: fcast.R:125
#, c-format
msgid "'data' must be a data.table."
msgstr "'data' doit être une data.table."

#: fcast.R:127
#, c-format
msgid "'drop' must be logical TRUE/FALSE"
msgstr "'drop' doit être un booléen TRUE / FALSE"

#: fcast.R:129
#, c-format
msgid "Argument 'value.var.in.dots' should be logical TRUE/FALSE"
msgstr "L'argument ‘value.var.in.dots’ doit être un booléen TRUE/FALSE"

#: fcast.R:131
#, c-format
msgid ""
"Arguments 'value.var.in.LHSdots', 'value.var.in.RHSdots' should be logical "
"TRUE/FALSE"
msgstr ""
"Les arguments 'value.var.in.LHSdots', 'value.var.in.RHSdots' doivent être "
"des booléens TRUE/FALSE"

#: fcast.R:148
#, c-format
msgid "Column [%s] not found or of unknown type."
msgstr "La colonne [%s] est absente ou de type inconnu."

#: fcast.R:163
#, c-format
msgid "Columns specified in formula can not be of type list"
msgstr ""
"Les colonnes spécifiées dans la formule ne peuvent pas avoir le type liste"

#: fcast.R:178
#, c-format
msgid ""
"'fun.aggregate' is NULL, but found duplicate row/column combinations, so "
"defaulting to length(). That is, the variables %s used in 'formula' do not "
"uniquely identify rows in the input 'data'. In such cases, 'fun.aggregate' "
"is used to derive a single representative value for each combination in the "
"output data.table, for example by summing or averaging (fun.aggregate=sum or "
"fun.aggregate=mean, respectively). Check the resulting table for values "
"larger than 1 to see which combinations were not unique. See ?dcast.data."
"table for more details."
msgstr ""
"'fun.aggregate' est NULL, mais des combinaisons de lignes/colonnes "
"dupliquées sont rencontrées, donc par défaut length() est utilisé. En "
"d'autres termes, les variables %s utilisées dans 'formula' n'identifient pas "
"de manière unique les lignes dans les données d'entrée 'data'. Dans ce cas, "
"'fun.aggregate' est utilisé pour dériver une valeur représentative unique "
"pour chaque combinaison dans la 'data.table' de sortie, par exemple en "
"faisant la somme ou la moyenne (fun.aggregate=sum ou fun.aggregate=mean, "
"respectivement). Vérifiez que le tableau résultant contient des valeurs "
"supérieures à 1 pour voir quelles combinaisons n'étaient pas uniques. Voir ?"
"dcast.data.table pour plus de détails."

#: fcast.R:188
msgid ""
"Aggregating functions should take a vector as input and return a single "
"value (length=1), but they do not, so the result is undefined. Please fix by "
"modifying your function so that a single value is always returned."
msgstr ""
"Les fonctions d'agrégation devraient prendre un vecteur en entrée et "
"renvoyer une seule valeur (longueur=1), mais elles ne le font pas, ce qui "
"donne un résultat indéfini. Veuillez corriger en modifiant votre fonction de "
"manière à ce qu'une seule valeur soit toujours renvoyée."

#: fmelt.R:12
#, c-format
msgid ""
"The %1$s generic in data.table has been passed a %2$s and will attempt to "
"redirect to the relevant reshape2 method; please note that reshape2 is "
"superseded and is no longer actively developed, and this redirection is now "
"deprecated. To continue using melt methods from reshape2 while both packages "
"are attached, e.g. melt.list, you can prepend the namespace, i.e. reshape2::"
"%1$s(%3$s). In the next version, this warning will become an error."
msgstr ""
"Le générique %1$s dans data.table a reçu un %2$s et tentera de rediriger "
"vers la méthode reshape2 correspondante ; veuillez noter que reshape2 est "
"remplacé et n'est plus activement développé, et que cette redirection est "
"maintenant obsolète. Pour continuer à utiliser les méthodes 'melt' de "
"reshape2 alors que les deux packages sont attachés, par exemple 'melt.list', "
"vous pouvez préfixer avec l'espace de noms, c'est-à-dire reshape2: :"
"%1$s(%3$s). Dans la prochaine version, cet avertissement deviendra une "
"erreur."

#: fmelt.R:19 fmelt.R:73
#, c-format
msgid "cols must be a character vector of column names"
msgstr "cols doit être un vecteur de chaînes de caractères de noms de colonnes"

#: fmelt.R:24
#, c-format
msgid "Input patterns must be of type character."
msgstr "Les motifs d'entrée doivent être de type chaînes de caractères."

#: fmelt.R:42
#, c-format
msgid ""
"each ... argument to measure must be either a symbol without argument name, "
"or a function with argument name, problems: %s"
msgstr ""
"chaque argument ... à mesurer doit être soit un symbole sans nom d'argument, "
"soit une fonction avec nom d'argument, problèmes : %s"

#: fmelt.R:50
#, c-format
msgid ""
"group names specified in ... conflict with measure argument names; please "
"fix by changing group names: %s"
msgstr ""
"les noms de groupes spécifiés dans ... sont en conflit avec les noms des "
"arguments de mesure ; veuillez corriger en changeant les noms de groupes : %s"

#: fmelt.R:56
#, c-format
msgid ""
"each ... argument to measure must be a function with at least one argument, "
"problem: %s"
msgstr ""
"chaque argument ... à mesurer doit être une fonction avec au moins un "
"argument, problème : %s"

#: fmelt.R:67
#, c-format
msgid ""
"both sep and pattern arguments used; must use either sep or pattern (not "
"both)"
msgstr ""
"vous utilisez à la fois les arguments sep et pattern ; Choisir entre sep ou "
"pattern (mais pas les deux)"

#: fmelt.R:70
#, c-format
msgid "multiple.keyword must be a character string with nchar>0"
msgstr "multiple.keyword doit être une chaîne de caractères avec nchar>0"

#: fmelt.R:81
#, c-format
msgid "in measurev, elements of fun.list must be named, problems: %s"
msgstr ""
"dans measurev, les éléments de fun.list doivent avoir un nom, problèmes : %s"

#: fmelt.R:84
#, c-format
msgid "elements of fun.list should be uniquely named, problems: %s"
msgstr "les éléments de fun.list doivent avoir un nom unique, problèmes : %s"

#: fmelt.R:89
#, c-format
msgid "pattern must be character string"
msgstr "le motif doit être une chaîne de caractères"

#: fmelt.R:94
#, c-format
msgid ""
"pattern did not match any cols, so nothing would be melted; fix by changing "
"pattern"
msgstr ""
"le motif ne correspondait à aucune colonne, donc rien n'aurait été fait "
"(melt) ; corrigez en changeant de motif"

#: fmelt.R:98
#, c-format
msgid ""
"pattern must contain at least one capture group (parenthesized sub-pattern)"
msgstr ""
"le motif doit contenir au moins un groupe de capture (sous-motif entre "
"parenthèses)"

#: fmelt.R:101
#, c-format
msgid ""
"number of elements of fun.list (%d) must be the same as the number of "
"capture groups in pattern (%d)"
msgstr ""
"le nombre d'éléments de fun.list (%d) doit être le même que le nombre de "
"groupes de capture dans les motifs (%d)"

#: fmelt.R:109
#, c-format
msgid "sep must be character string"
msgstr "sep doit être une chaîne de caractères"

#: fmelt.R:115
#, c-format
msgid ""
"each column name results in only one item after splitting using sep, which "
"means that all columns would be melted; to fix please either specify melt on "
"all columns directly without using measure, or use a different sep/pattern "
"specification"
msgstr ""
"chaque nom de colonne ne donne qu'un seul élément après séparation à l'aide "
"de 'sep', ce qui signifie que toutes les colonnes seraient fusionnées ; pour "
"résoudre ce problème, veuillez spécifier la fusion (melt) sur toutes les "
"colonnes directement sans utiliser la mesure, ou utiliser une spécification "
"sep/motif différente"

#: fmelt.R:118
#, c-format
msgid ""
"number of elements of fun.list (%d) must be the same as the max number of "
"items after splitting column names (%d)"
msgstr ""
"le nombre d'éléments de fun.list (%d) doit être le même que le nombre "
"maximum d'éléments après avoir partagé les noms de colonnes (%d)"

#: fmelt.R:125
#, c-format
msgid "measured columns should be uniquely named, problems: %s"
msgstr "les colonnes mesurées doivent avoir un nom unique, problèmes : %s"

#: fmelt.R:129
#, c-format
msgid ""
"number of unique column IDs =%d is less than number of melted columns =%d; "
"fix by changing pattern/sep"
msgstr ""
"le nombre d'ID de colonnes uniques =%d est inférieur au nombre de colonnes "
"fusionnées =%d ; corrigez en changeant le motif ou sep"

#: fmelt.R:139
#, c-format
msgid ""
"in the measurev fun.list, each non-NULL element must be a function with at "
"least one argument, problem: %s"
msgstr ""
"dans la mesurev fun.list, chaque élément non NULL doit être une fonction "
"avec au moins un argument, problème : %s"

#: fmelt.R:143
#, c-format
msgid ""
"each conversion function must return an atomic vector with same length as "
"its first argument, problem: %s"
msgstr ""
"chaque fonction de conversion doit renvoyer un vecteur atomique de même "
"longueur que son premier argument, problème : %s"

#: fmelt.R:146
#, c-format
msgid "%s conversion function returned vector of all NA"
msgstr ""
"la fonction de conversion %s a renvoyé un vecteur ne contenant que des NA"

#: fmelt.R:152
#, c-format
msgid ""
"number of unique groups after applying type conversion functions less than "
"number of groups, change type conversion"
msgstr ""
"nombre de groupes uniques après application des fonctions de conversion de "
"type inférieur au nombre de groupes, modifier la conversion de type"

#: fmelt.R:157
#, c-format
msgid ""
"%s column class=%s after applying conversion function, but must be character"
msgstr ""
"colonne %s class=%s après avoir appliqué les fonctions de conversion, mais "
"doivent être des chaînes de caractères"

#: fmelt.R:161
#, c-format
msgid "%s is the only group; fix by creating at least one more group"
msgstr ""
"%s est le seul groupe ; Corrigez en créant au moins un groupe supplémentaire"

#: fmelt.R:184
#, c-format
msgid "'data' must be a data.table"
msgstr "'data' doit être une data.table"

#: fmelt.R:207
#, c-format
msgid ""
"'value.name' provided in both 'measure.vars' and 'value.name argument'; "
"value provided in 'measure.vars' is given precedence."
msgstr ""
"'value.name' est fourni à la fois dans 'measure.vars' et 'value.name "
"argument' ; La valeur de 'measure.vars' prévaut."

#: fmelt.R:210
#, c-format
msgid "Please provide a name to each element of 'measure.vars'."
msgstr "Veuillez fournir un nom pour chaque élément de 'measure.vars'."

#: fmelt.R:221
msgid ""
"Duplicate column names found in molten data.table. Setting unique names "
"using 'make.names'"
msgstr ""
"Doublons trouvés dans le nom des colonnes après fusion du data.table. Noms "
"rendus uniques avec 'make.names'"

#: foverlaps.R:3
#, c-format
msgid ""
"y and x must both be data.tables. Use `setDT()` to convert list/data.frames "
"to data.tables by reference or as.data.table() to convert to data.tables by "
"copying."
msgstr ""
"y et x doivent tous deux être des data.tables. Utilisez `setDT()` pour "
"convertir des list/data.frames en data.tables par référence ou as.data."
"table() pour convertir en data.tables par copie."

#: foverlaps.R:9
#, c-format
msgid "maxgap must be a non-negative integer value of length 1"
msgstr "maxgap doit être un entier positif ou nul de longueur 1"

#: foverlaps.R:11
#, c-format
msgid "minoverlap must be a positive integer value of length 1"
msgstr "minorverlap doit être un entier positif ou nul de longueur 1"

#: foverlaps.R:13
#, c-format
msgid "which must be a logical vector of length 1. Either TRUE/FALSE"
msgstr ""
"which doit être un vecteur de booléens de longueur 1. Soit TRUE ou FALSE"

#: foverlaps.R:15
#, c-format
msgid "nomatch must either be NA or NULL"
msgstr "nomatch doit valoir soit NA soit NULL"

#: foverlaps.R:20
#, c-format
msgid "maxgap and minoverlap arguments are not yet implemented."
msgstr "les arguments maxgap et minoverlap ne sont pas encore implémentés."

#: foverlaps.R:22
#, c-format
msgid ""
"y must be keyed (i.e., sorted, and, marked as sorted). Call setkey(y, ...) "
"first, see ?setkey. Also check the examples in ?foverlaps."
msgstr ""
"y doit être transformé en 'key' (c'est-à-dire trié, et, marqué comme étant "
"trié). Appelez d'abord setkey(y, ...), voir ?setkey. Consultez également les "
"exemples dans ?foverlaps."

#: foverlaps.R:24
#, c-format
msgid ""
"'by.x' and 'by.y' should contain at least two column names (or numbers) each "
"- corresponding to 'start' and 'end' points of intervals. Please see ?"
"foverlaps and examples for more info."
msgstr ""
"'by.x' et 'by.y' doivent contenir chacun au moins deux noms de colonnes (ou "
"leurs indices) - correspondant aux bornes 'start' et 'end' des intervalles. "
"Voir ?foverlaps et les exemples pour plus d'information."

#: foverlaps.R:27
#, c-format
msgid ""
"Invalid numeric value for 'by.x'; it should be a vector with values 1 <= by."
"x <= length(x)"
msgstr ""
"Valeur numérique non valide pour 'by.x' ; Doit être un vecteur de valeurs 1 "
"<= by.x <= length(x)"

#: foverlaps.R:32
#, c-format
msgid ""
"Invalid numeric value for 'by.y'; it should be a vector with values 1 <= by."
"y <= length(y)"
msgstr ""
"Valeur numérique non valide pour 'by.y' ; Doit être un vecteur de valeurs 1 "
"<= by.y <= length(y)"

#: foverlaps.R:36
#, c-format
msgid "A non-empty vector of column names or numbers is required for by.x"
msgstr ""
"Un vecteur non vide de noms de colonnes ou d’indices (nombres) est "
"nécessaire pour by.x"

#: foverlaps.R:38
#, c-format
msgid "A non-empty vector of column names or numbers is required for by.y"
msgstr ""
"Un vecteur non vide de noms de colonnes ou d’indices (nombres) est "
"nécessaire pour by.y"

#: foverlaps.R:40
#, c-format
msgid ""
"The first %d columns of y's key must be identical to the columns specified "
"in by.y."
msgstr ""
"Les %d premières colonnes de la clé de y doivent être identiques aux "
"colonnes spécifiées dans by.y."

#: foverlaps.R:42
#, c-format
msgid "Elements listed in 'by.x' must be valid names in data.table x"
msgstr ""
"Les éléments listés dans 'by.x' doivent être des noms valides de la data."
"table x"

#: foverlaps.R:44
#, c-format
msgid ""
"Duplicate columns are not allowed in overlap joins. This may change in the "
"future."
msgstr ""
"Les colonnes dupliquées ne sont pas autorisées pour la jointure avec "
"recouvrement. Ceci peut changer à l'avenir."

#: foverlaps.R:46
#, c-format
msgid ""
"length(by.x) != length(by.y). Columns specified in by.x should correspond to "
"columns specified in by.y and should be of same lengths."
msgstr ""
"length(by.x) != length(by.y). Les colonnes spécifiées dans by.x doivent "
"correspondre aux colonnes spécifiées dans by.y et être de même longueur."

#: foverlaps.R:57
#, c-format
msgid ""
"The last two columns in by.x should correspond to the 'start' and 'end' "
"intervals in data.table x and must be integer/numeric type."
msgstr ""
"Les deux dernières colonnes de by.x doivent correspondre à l'intervalle "
"'start' et 'end' de la data.table x et doivent être de type entier ou "
"numérique."

#: foverlaps.R:61 foverlaps.R:63 foverlaps.R:70 foverlaps.R:72
#, c-format
msgid ""
"NA values in data.table %s '%s' column: '%s'. All rows with NA values in the "
"range columns must be removed for foverlaps() to work."
msgstr ""
"Valeurs NA présentes dans la data.table %s colonne '%s’ : '%s'. Toutes les "
"lignes avec des valeurs NA dans l'intervalle des colonnes doivent être "
"supprimées avant d’exécuter foverlaps()."

#: foverlaps.R:64
#, c-format
msgid ""
"All entries in column '%s' should be <= corresponding entries in column '%s' "
"in data.table x."
msgstr ""
"Toutes les entrées de la colonne '%s' doivent être <= aux entrées "
"correspondantes de la colonne '%s' de la data.table x."

#: foverlaps.R:67
#, c-format
msgid ""
"The last two columns in by.y should correspond to the 'start' and 'end' "
"intervals in data.table y and must be integer/numeric type."
msgstr ""
"Les deux dernières colonnes de by.y doivent correspondre aux intervalles de "
"'start' et 'end' de la data.table y et doivent être de type entier/numérique."

#: foverlaps.R:73
#, c-format
msgid ""
"All entries in column '%s' should be <= corresponding entries in column '%s' "
"in data.table y."
msgstr ""
"Toutes les entrées de la colonne '%s' doivent être <= aux entrées "
"correspondantes de la colonne '%s' de la data.table y."

#: foverlaps.R:78
#, c-format
msgid ""
"Some interval cols are of type POSIXct while others are not. Please ensure "
"all interval cols are (or are not) of POSIXct type"
msgstr ""
"Certains interval cols sont de type POSIXct et d'autres non. Veuillez vous "
"assurer que tous les 'interval cols' sont (ou ne sont pas) de type POSIXct"

#: foverlaps.R:84
#, c-format
msgid ""
"POSIXct interval cols have mixed timezones. Overlaps are performed on the "
"internal numerical representation of POSIXct objects (always in UTC epoch "
"time), therefore printed values may give the impression that values don't "
"overlap but their internal representations do Please ensure that POSIXct "
"type interval cols have identical 'tzone' attributes to avoid confusion."
msgstr ""
"Les colonnes d'intervalles POSIXct ont des fuseaux horaires différents. Les "
"chevauchements sont effectués sur la représentation numérique interne des "
"objets POSIXct (toujours en temps UTC), par conséquent les valeurs imprimées "
"peuvent donner l'impression que les valeurs ne se chevauchent pas mais leurs "
"représentations internes le font. Veuillez vous assurer que les colonnes "
"d'intervalle de type POSIXct ont des attributs 'tzone' identiques afin "
"d'éviter toute confusion."

#: foverlaps.R:132
msgid "unique() + setkey() operations done in ..."
msgstr "opérations unique() + setkey() faites dans ..."

#: foverlaps.R:158
msgid "binary search(es) done in ..."
msgstr "recherche(s) binaire(s) faite(s) dans ..."

#: foverlaps.R:165 foverlaps.R:167 foverlaps.R:171
#, c-format
msgid "Not yet implemented"
msgstr "Non encore implémenté"

#: foverlaps.R:170
#, c-format
msgid "maxgap > minoverlap. maxgap will have no effect here."
msgstr "maxgap > minoverlap. maxgap n'a pas de conséquence ici."

#: frank.R:3
#, c-format
msgid "length(na.last) = 0"
msgstr "length(na.last) = 0"

#: frank.R:5
#, c-format
msgid "length(na.last) > 1, only the first element will be used"
msgstr "length(na.last) > 1, seul le premier élément sera utilisé"

#: frank.R:17
#, c-format
msgid "x is a single vector, non-NULL 'cols' doesn't make sense"
msgstr "x est un vecteur colonne, les 'cols' non NULL n'ont pas de sens"

#: frank.R:23
#, c-format
msgid "x is a list, 'cols' can not be 0-length"
msgstr "x est une liste, 'cols' ne peut pas avoir une longueur 0"

#: frank.R:31
#, c-format
msgid ""
"Input column '..na_prefix..' conflicts with data.table internal usage; "
"please rename"
msgstr ""
"La colonne d'entrée '..na_prefix..' est en conflit avec l'utilisation "
"interne de data.table ; Veuillez la renommer"

#: frank.R:46
#, c-format
msgid ""
"Input column '..stats_runif..' conflicts with data.table internal usage; "
"please rename"
msgstr ""
"La colonne d'entrée '..stats_runif..' est en conflit avec l'utilisation "
"interne de data.table ; Veuillez la renommer"

#: fread.R:12
#, c-format
msgid "Used more than one of the arguments input=, file=, text= and cmd=."
msgstr ""
"Plusieurs occurrences d'un des arguments suivants input=, file=, text=, cmd=."

#: fread.R:25
#, c-format
msgid "Argument 'encoding' must be 'unknown', 'UTF-8' or 'Latin-1'."
msgstr "L'argument 'encoding' doit être 'unknown', 'UTF-8' ou 'Latin-1'."

#: fread.R:34
#, c-format
msgid "comment.char= must be a single non-NA character."
msgstr "comment.char= doit être un seul caractère non NA."

#: fread.R:47
#, c-format
msgid "'text=' is type %s but must be character."
msgstr "'text=' est de type %s mais doit être de type 'character'."

#: fread.R:60
#, c-format
msgid ""
"input= must be a single character string containing a file name, a system "
"command containing at least one space, a URL starting 'http[s]://', "
"'ftp[s]://' or 'file://', or, the input data itself containing at least one "
"\\n or \\r"
msgstr ""
"input= doit être une seule chaîne de caractères contenant un nom de fichier, "
"une commande système contenant au moins une espace, une URL commençant par "
"'http[s]://', 'ftp[s]://' ou 'file://', ou les données d'entrée elles-mêmes "
"contenant au moins un \\n ou \\r"

#: fread.R:65
#, c-format
msgid ""
"input= contains no \\n or \\r, but starts with a space. Please remove the "
"leading space, or use text=, file= or cmd="
msgstr ""
"input= ne contient ni \\n, ni \\r, mais commence par une espace. Veuillez "
"supprimer l'espace qui précède ou utiliser text=, file= ou cmd="

#: fread.R:69
#, c-format
msgid ""
"Taking input= as a system command because it contains a space ('%s'). If "
"it's a filename please remove the space, or use file= explicitly. A variable "
"is being passed to input= and when this is taken as a system command there "
"is a security concern if you are creating an app, the app could have a "
"malicious user, and the app is not running in a secure environment; e.g. the "
"app is running as root. Please read item 5 in the NEWS file for v1.11.6 for "
"more information and for the option to suppress this message."
msgstr ""
"Le contenu de l’argument input= est considéré comme une commande système "
"parce qu'il contient une espace ('%s'). S'il s'agit d'un nom de fichier, "
"supprimez l'espace ou utilisez explicitement file=. Une variable est passée "
"à input= et lorsque cela est pris comme une commande système, il y a un "
"problème de sécurité si vous créez une application. L’application pourrait "
"alors être détournée par un utilisateur malveillant, si elle ne s'exécute "
"pas dans un environnement sécurisé, par exemple si l'application s'exécute "
"en tant que root. Veuillez lire le point 5 dans le fichier NEWS pour la "
"v1.11.6 pour plus d'informations et pour l'option permettant de supprimer ce "
"message."

#: fread.R:80
#, c-format
msgid ""
"External command failed with exit code %d. This can happen when the disk is "
"full in the temporary directory ('%s'). See ?fread for the tmpdir argument."
msgstr ""
"Echec de la commande externe avec le code retour %d. Ceci peut se produire "
"si le disque est plein avec le répertoire temporaire ('%s'). Voir ?fread "
"pour l'argument tmpdir."

#: fread.R:86
#, c-format
msgid ""
"file= must be a single character string containing a filename, or URL "
"starting 'http[s]://', 'ftp[s]://' or 'file://'"
msgstr ""
"file= doit être une seule chaîne de caractères contenant un nom de fichier "
"ou une URL commençant par 'http[s]://', 'ftp[s]://' or 'file://'"

#: fread.R:99
#, c-format
msgid "File '%s' does not exist or is non-readable. getwd()=='%s'"
msgstr "Fichier '%s' absent ou non accessible en lecture. getwd()=='%s'"

#: fread.R:100
#, c-format
msgid "File '%s' is a directory. Not yet implemented."
msgstr "Le fichier '%s' est un répertoire. Ceci n’est pas encore implémenté."

#: fread.R:102
#, c-format
msgid "File '%s' has size 0. Returning a NULL %s."
msgstr "Le fichier '%s' a pour taille 0. Renvoi de %s NULL."

#: fread.R:114
#, c-format
msgid ""
"Compressed files containing more than 1 file are currently not supported."
msgstr ""
"Les fichiers compressés contenant plusieurs fichiers ne sont pas reconnus "
"actuellement."

#: fread.R:124
#, c-format
msgid ""
"To read %s files directly, fread() requires 'R.utils' package which cannot "
"be found. Please install 'R.utils' using 'install.packages('R.utils')'."
msgstr ""
"Pour lire directement les fichiers %s, fread() a besoin du package 'R.utils' "
"qui n'a pas été trouvé. Veuillez installer 'R.utils' via 'install."
"packages('R.utils')'."

#: fread.R:127
#, c-format
msgid ""
"Reading compressed files in fread requires R.utils version 2.13.0 or higher. "
"Please upgrade R.utils."
msgstr ""
"La lecture des fichiers compressés avec fread nécessite d'avoir R.utils "
"version 2.13.0 ou plus récent. Veuillez mettre à jour R.utils."

#: fread.R:134
#, c-format
msgid ""
"R.utils::decompressFile failed to decompress file '%s':\n"
"  %s\n"
". This can happen when the disk is full in the temporary directory ('%s'). "
"See ?fread for the tmpdir argument."
msgstr ""
"R.utils::decompressFile a échoué dans la décompression du fichier '%s':\n"
"  %s\n"
". Ceci peut se produire si le disque est plein, avec le répertoire "
"temporaire ('%s'). Voir ?fread pour l'argument tmpdir."

#: fread.R:143
#, c-format
msgid ""
"colClasses is type 'logical' which is ok if all NA but it has some TRUE or "
"FALSE values in it which is not allowed. Please consider the drop= or "
"select= argument instead. See ?fread."
msgstr ""
"colClasses est de type booléen, ce qui est acceptable si toutes les valeurs "
"sont NA, mais il contient des valeurs TRUE ou FALSE, ce qui n'est pas "
"autorisé. Veuillez considérer l'argument drop= ou select= à la place. Voir ?"
"fread."

#: fread.R:147
#, c-format
msgid "colClasses is not type list or character vector"
msgstr ""
"colClasses n'est ni du type liste ni un vecteur de chaînes de caractères"

#: fread.R:152
#, c-format
msgid ""
"colClasses=\"NULL\" (quoted) is interpreted as colClasses=NULL (the default) "
"as opposed to dropping every column."
msgstr ""
"colClasses=\"NULL\" (avec des guillemets) est interprété comme "
"colClasses=NULL (la valeur par défaut) contrairement à la suppression de "
"toutes les colonnes."

#: fread.R:164
#, c-format
msgid "na.strings[%d]==\"%s\" consists only of whitespace, ignoring"
msgstr "na.strings[%d]==\"%s\" n'est formé que d'espaces, il est ignoré"

#: fread.R:167
#, c-format
msgid ""
"%s. Since strip.white=TRUE (default), use na.strings=\"\" to specify that "
"any number of spaces in a string column should be read as <NA>."
msgstr ""
"%s. Parce que strip.white=TRUE (valeur par défaut), utilisez na.strings=\"\" "
"pour spécifier que toute suite d'espaces d'une colonne de chaînes doit être "
"lue comme <NA>."

#: fread.R:169
#, c-format
msgid ""
"%s. strip.white==TRUE (default) and \"\" is present in na.strings, so any "
"number of spaces in string columns will already be read as <NA>."
msgstr ""
"%s. strip.white==TRUE (par défault) et \"\" est présent dans na.strings, "
"donc toute suite d'espaces dans les colonnes de chaînes de caractères est "
"déjà lue comme étant <NA>."

#: fread.R:173
#, c-format
msgid ""
"%s. But strip.white=FALSE. Use strip.white=TRUE (default) together with na."
"strings=\"\" to turn any number of spaces in string columns into <NA>"
msgstr ""
"%s. Mais strip.white=FALSE. Utiliser strip.white=TRUE (par défaut) avec na."
"strings=\"\" pour transformer les suites d'espaces en <NA> dans les colonnes "
"de chaînes de caractères"

#: fread.R:180
#, c-format
msgid ""
"'data.table' relies on the package 'yaml' to parse the file header; please "
"add this to your library with install.packages('yaml') and try again."
msgstr ""
"'data.table' dépend du package 'yaml' pour analyser l'entête du fichier ; "
"Veuillez l’ajouter dans votre bibliothèque avec install.packages('yaml') et "
"recommencer."

#: fread.R:184
#, c-format
msgid ""
"Combining a search string as 'skip' and reading a YAML header may not work "
"as expected -- currently, reading will proceed to search for 'skip' from the "
"beginning of the file, NOT from the end of the metadata; please file an "
"issue on GitHub if you'd like to see more intuitive behavior supported."
msgstr ""
"La combinaison d'une chaîne de recherche comme 'skip' et la lecture d'un "
"entête YAML peuvent ne pas fonctionner comme prévu -- actuellement, la "
"lecture va rechercher 'skip' à partir du début du fichier, PAS à partir de "
"la fin des métadonnées ; Veuillez renseigner ce problème sur GitHub si vous "
"souhaitez qu'un comportement plus intuitif soit pris en charge."

#: fread.R:194
#, c-format
msgid ""
"Encountered <%s%s> at the first unskipped line (%d), which does not "
"constitute the start to a valid YAML header (expecting something matching "
"regex \"%s\"); please check your input and try again."
msgstr ""
"<%s%s> trouvé à la première ligne non sautée (%d), ce qui ne constitue pas "
"le début d'un entête YAML valide (on s'attendait à quelque chose "
"correspondant à l'expression régulière \"%s\") ; veuillez vérifier votre "
"entrée et réessayer."

#: fread.R:206
#, c-format
msgid ""
"Reached the end of the file before finding a completion to the YAML header. "
"A valid YAML header is bookended by lines matching the regex \"%s\". Please "
"double check the input file is a valid csvy."
msgstr ""
"La fin du fichier est atteinte avant de trouver la fin de l'entête YAML. Un "
"entête YAML valide est complété par des lignes correspondant à l'expression "
"régulière \"%s\". Veuillez bien vérifier que le fichier d'entrée est un csvy "
"valide."

#: fread.R:217
msgid ""
"Processed %d lines of YAML metadata with the following top-level fields: %s"
msgstr ""
"Traitement de %d lignes de métadonnées YAML avec les champs de niveau "
"supérieur suivants : %s"

#: fread.R:220
#, c-format
msgid "User-supplied 'header' will override that found in metadata."
msgstr ""
"Le 'header' fourni par l'utilisateur redéfinira celui trouvé dans les "
"métadonnées."

#: fread.R:238
#, c-format
msgid ""
"User-supplied column names in 'col.names' will override those found in YAML "
"metadata."
msgstr ""
"Les noms de colonnes fournis par l'utilisateur dans 'col.names' remplaceront "
"ceux trouvés dans les métadonnées YAML."

#: fread.R:247
#, c-format
msgid ""
"colClasses dictated by user input and those read from YAML header are in "
"conflict (specifically, for column(s) [%s]); the proceeding assumes the user "
"input was an intentional override and will ignore the type(s) implied by the "
"YAML header; please exclude the column(s) from colClasses if this was "
"unintentional."
msgstr ""
"les colClasses imposées par les entrées de l'utilisateur et celles lues dans "
"l'entête YAML sont en conflit (en particulier, pour la/les colonne(s) "
"[%s]) ; La procédure suppose que la proposition de l'utilisateur est une "
"modification intentionnelle et ignore le(s) type(s) défini(s) par l'entête "
"YAML ; veuillez exclure la/les colonne(s) des colClasses si cela n'est pas "
"intentionnel."

#: fread.R:268
#, c-format
msgid "User-supplied 'sep' will override that found in metadata."
msgstr ""
"Le 'sep' fourni par l'utilisateur redéfinira celui trouvé dans les "
"métadonnées."

#: fread.R:273
#, c-format
msgid "User-supplied 'quote' will override that found in metadata."
msgstr ""
"Le 'quote' fourni par l'utilisateur redéfinira celui trouvé dans les "
"métadonnées."

#: fread.R:278
#, c-format
msgid "User-supplied 'dec' will override that found in metadata."
msgstr ""
"Le 'dec' fourni par l'utilisateur redéfinira celui trouvé dans les "
"métadonnées."

#: fread.R:282
#, c-format
msgid "User-supplied 'na.strings' will override that found in metadata."
msgstr ""
"Le 'na.strings' fourni par l'utilisateur redéfinira celui trouvé dans les "
"métadonnées."

#: fread.R:334
msgid ""
"Column '%s' was requested to be '%s' but fread encountered the following "
"warning:\n"
"\t%s\n"
"so the column has been left as type '%s'"
msgstr ""
"La colonne '%s' devait être '%s' mais fread a reçu l'avertissement "
"suivant :\n"
"\t%s\n"
"la colonne a donc été laissée dans le type '%s'"

#: fread.R:336
msgid ""
"Column '%s' was requested to be '%s' but fread encountered the following "
"error:\n"
"\t%s\n"
"so the column has been left as type '%s'"
msgstr ""
"La colonne '%s' devait être '%s' mais fread a reçu l'erreur suivante :\n"
"\t%s\n"
"la colonne a donc été laissée dans le type '%s'"

#: fread.R:363
#, c-format
msgid ""
"key argument of data.table() must be a character vector naming columns (NB: "
"col.names are applied before this)"
msgstr ""
"l'argument clé de data.table() doit être un vecteur de caractères nommant "
"les colonnes (NB : col.names est appliqué avant cela)"

#: fread.R:371
#, c-format
msgid ""
"index argument of data.table() must be a character vector naming columns "
"(NB: col.names are applied before this)"
msgstr ""
"l'argument index de data.table() doit être un vecteur de chaînes de "
"caractères qui nomme les colonnes (NB: col.names est appliqué avant)"

#: froll.R:30
#, c-format
#| msgid "class must be length 1"
msgid "n must be non 0 length"
msgstr "n doit avoir une longueur différente de 0"

#: froll.R:32
#, c-format
msgid "'partial' cannot be used together with align='center'"
msgstr "'partial' ne peut pas être utilisé avec align='center'"

#: froll.R:35
#, c-format
msgid "'partial' does not support variable length of columns in x"
msgstr ""
"'partial' ne prend pas en charge les colonnes de longueur variable dans x"

#: froll.R:37
#, c-format
msgid "'partial' does not support variable nrow of data.tables in x"
msgstr "'partial' ne prend pas en charge les nrow de data.table dans x"

#: froll.R:48
#, c-format
msgid "n must be an integer, list is accepted for adaptive TRUE"
msgstr "n doit être un entier, une liste est acceptée pour adaptive TRUE"

#: froll.R:50 froll.R:62
#, c-format
msgid "n must be an integer vector or a list of integer vectors"
msgstr "n doit être un vecteur d'entiers ou une liste de vecteurs d'entiers"

#: froll.R:52
msgid ""
"partial2adaptive: froll partial=TRUE trimming n and redirecting to "
"adaptive=TRUE"
msgstr ""
"partial2adaptive: froll partial=TRUE supprime n et redirige vers "
"adaptive=TRUE"

#: froll.R:64
#, c-format
msgid "adaptive windows provided in n must not to have different lengths"
msgstr ""
"les fenêtres adaptive fournies dans n ne doivent pas avoir des longueurs "
"différentes"

#: froll.R:66
#, c-format
msgid ""
"length of n argument must be equal to number of observations provided in x"
msgstr ""
"la longueur de l'argument n doit être égale au nombre d'observations "
"fournies dans x"

#: froll.R:68
#, c-format
msgid "length of vectors in x must match to length of adaptive window in n"
msgstr ""
"la longueur des vecteurs dans x doit correspondre à la longueur de la "
"fenêtre adaptive dans n"

#: froll.R:70
msgid "partial2adaptive: froll adaptive=TRUE and partial=TRUE trimming n"
msgstr "partial2adaptive : froll adaptive=TRUE et partial=TRUE supprime n"

#: froll.R:86
#, c-format
msgid ""
"internal error: misuse of make.roll.names, n must be numeric for !adaptive"
msgstr ""
"erreur interne : utilisation inappropriée de make.roll.names, n doit être "
"numérique pour !adaptive"

#: froll.R:92
#, c-format
msgid ""
"internal error: misuse of make.roll.names, non-null length 0 n is not "
"possible for !adaptive"
msgstr ""
"erreur interne : utilisation inappropriée de make.roll.names, non null de "
"longueur 0 n n'est pas autorisé avec !adaptive"

#: froll.R:106
#, c-format
msgid ""
"internal error: make.roll.names call should have been escaped in frollapply "
"during 'unpack atomic input'"
msgstr ""
"erreur interne : l'appel à make.roll.names doit être échappé dans frollapply "
"pendant la décompression atomique de l'entrée"

#: froll.R:110
#, c-format
msgid "internal error: make.roll.names generated names of wrong length"
msgstr ""
"erreur interne : make.roll.names a généré des noms de mauvaise longueur"

#: froll.R:118
#, c-format
msgid "'x' must be of a numeric type"
msgstr "'x' doit être de type numérique"

#: froll.R:122 froll.R:127
#, c-format
msgid "'n' must be an integer"
msgstr "'n' doit être un entier"

#: froll.R:132
#, c-format
msgid "'n' must be non 0 length"
msgstr "'n' doit avoir une longueur différente de 0"

#: froll.R:134
#, c-format
#| msgid "maxgap and minoverlap arguments are not yet implemented."
msgid "'align' other than 'right' has not yet been implemented"
msgstr "'align' différent de 'right' n'a pas encore été implémenté"

#: froll.R:136 froll.R:138 mergelist.R:61
#, c-format
msgid "'%s' must be TRUE or FALSE"
msgstr "'%s' doit valoir TRUE ou FALSE"

#: froll.R:157 froll.R:158
#, c-format
msgid "hasNA is deprecated, use has.nf instead"
msgstr "hasNA est obsolète, remplacer par has.nf"

#: froll.R:183
msgid "froll: adaptive=TRUE && align='left' pre-processing for align='right'"
msgstr "froll : adaptive=TRUE && align='left' prétraitement pour align='right'"

#: froll.R:191
msgid "froll: adaptive=TRUE && align='left' post-processing from align='right'"
msgstr "froll : adaptive=TRUE && align='left' post-traitement de align='right'"

#: frollapply.R:130
#, c-format
msgid "'x' is deprecated in frollapply, use 'X' instead"
msgstr "'x' est obsolète dans frollapply, utiliser 'X' à la place"

#: frollapply.R:134
#, c-format
msgid "'n' is deprecated in frollapply, use 'N' instead"
msgstr "'n' est obsolète dans frollapply, utiliser 'N' à la place"

#: frollapply.R:138
#, c-format
#| msgid "'fromLast' must be TRUE or FALSE"
msgid "'by.column' must be TRUE or FALSE"
msgstr "'by.column' doit valoir TRUE ou FALSE"

#: frollapply.R:140
#, c-format
#| msgid "'fromLast' must be TRUE or FALSE"
msgid "'adaptive' must be TRUE or FALSE"
msgstr "'adaptive' doit valoir TRUE ou FALSE"

#: frollapply.R:142
#, c-format
msgid "'partial' must be TRUE or FALSE"
msgstr "'partial' doit valoir TRUE ou FALSE"

#: frollapply.R:144
#, c-format
#| msgid "%s must be TRUE or FALSE"
msgid "'give.names' must be TRUE or FALSE"
msgstr "'give.names' doit valoir TRUE ou FALSE"

#: frollapply.R:146
#, c-format
#| msgid "%s must be TRUE or FALSE"
msgid "'simplify' must be TRUE or FALSE or a function"
msgstr "'simplify' doit valoir TRUE ou FALSE ou être une fonction"

#: frollapply.R:170
#, c-format
msgid ""
"frollapply by.column=TRUE requires 'X' argument to be atomic or a list of "
"those"
msgstr ""
"frollapply by.column=TRUE nécessite que l'argument 'X' soit atomique ou une "
"liste d'atomiques"

#: frollapply.R:182
#, c-format
msgid ""
"frollapply by.column=FALSE, when provided a list in 'X' then all vectors "
"must have equal lengths, like data.frame"
msgstr ""
"frollapply by.column=FALSE, quand une liste est fournie dans 'X'  tous les "
"vecteurs doivent avoir la même longueur, comme le data.frame"

#: frollapply.R:191
#, c-format
msgid ""
"frollapply by.column=FALSE got vectorized input in 'X', list of data.frames/"
"data.tables, but not all columns of data.frames/data.tables are atomic"
msgstr ""
"frollapply by.column=FALSE récupère l'entrée vectorisée dans 'X', la liste "
"des data.frame ou des data.table, mais toutes les colonnes des data.frame ou "
"des data.table ne sont pas atomiques"

#: frollapply.R:197
#, c-format
msgid ""
"frollapply by.column=FALSE supports vectorized input in 'X' as a list of "
"data.frames/data.tables, not a list of lists. Turn nested lists into data."
"frames/data.table and retry."
msgstr ""
"frollapply by.column=FALSE accepte les entrées vectorisées dans 'X' en tant "
"que liste de data.frame ou data.table et non pas de liste de listes. "
"Transformez les listes imbriquées en data.frame ou en data.table respectifs "
"et ressayez."

#: frollapply.R:199
#, c-format
msgid ""
"frollapply by.column=FALSE got list in 'X' but it is not valid one. If "
"intent is to pass a list as non-vectorized input, but a single object to "
"apply function to, then the list must have all its vectors atomic. For a "
"vectorized input, passing multiple objects to apply function to, it must be "
"a list of data.frames/data.tables."
msgstr ""
"frollapply by.column=FALSE récupère la liste dans 'X' mais elle n'est pas "
"valide. Si l'intention est de passer une liste comme entrée non vectorisée, "
"mais un objet unique auquel appliquer la fonction, alors la liste ne doit "
"avoir que des vecteurs atomiques. Avec une entrée vectorisée, pour passer "
"des objets multiples auxquels appliquer la fonction, il faut une liste de "
"data.frame ou de data.table."

#: frollapply.R:202
#, c-format
msgid ""
"frollapply by.column=FALSE requires 'X' argument to be a data.table/data."
"frame or a list of equal length vectors. For vectorized input can be a list "
"of data.frames/data.tables, but not a list of lists. All columns/vectors "
"must be atomic."
msgstr ""
"frollapply by.column=FALSE nécessite que l'argument 'X' soit un data.table "
"ou un data.frame ou une liste de vecteurs d'égale longueur. Pour une entrée "
"vectorisée c'est soit une liste de data.frame ou de data.table, mais pas une "
"liste de listes. Toutes les colonnes ou les vecteurs doivent être atomiques."

#: frollapply.R:206
#, c-format
msgid "'N' must be non 0 length"
msgstr "'N' doit avoir une longueur différente de 0"

#: frollapply.R:209
#, c-format
msgid "'N' must be an integer, list is accepted for adaptive TRUE"
msgstr "'N' doit être un entier, une liste est acceptée pour adaptive TRUE"

#: frollapply.R:211
#, c-format
msgid "'N' must be an integer"
msgstr "'N' doit être un entier"

#: frollapply.R:216 frollapply.R:227 frollapply.R:241
#, c-format
msgid "'N' must be non-negative integer values (>= 0)"
msgstr "'N' doit avoir des valeurs positives ou nulles (>= 0)"

#: frollapply.R:220
#, c-format
msgid ""
"adaptive rolling function can only process 'X' having equal length of "
"elements; If you want to call rolling function on list having variable "
"length of elements call it for each field separately"
msgstr ""
"la fonction adaptive par roulement ne peut traiter que 'X' avec un nombre "
"égal d'éléments; si vous souhaitez utiliser une liste dont la longueur varie "
"en fonction du nombre d'éléments, vous devez appeler la fonction pour chaque "
"champ séparément"

#: frollapply.R:223 frollapply.R:233
#, c-format
msgid ""
"length of integer vector(s) provided as list to 'N' argument must be equal "
"to number of observations provided in 'X'"
msgstr ""
"la longueur des vecteurs d'entiers fournie en tant que liste dans l'argument "
"'N' doit être égale au nombre d'observations fournies dans 'X'"

#: frollapply.R:235
#, c-format
msgid "adaptive windows provided in 'N' must not to have different lengths"
msgstr ""
"les fenêtres adaptive fournies dans 'N' ne doivent pas avoir des longueurs "
"différentes"

#: frollapply.R:237 frollapply.R:245
#, c-format
msgid "'N' must be an integer vector or list of integer vectors"
msgstr "'N' doit être un vecteur d'entiers ou une liste de vecteurs d'entiers"

#: frollapply.R:257
#, c-format
msgid "using adaptive TRUE and align 'center' is not implemented"
msgstr ""
"l'utilisation de adaptive TRUE avec align 'center' n'est pas implémentée"

#: frollapply.R:262
msgid ""
"frollapply: adaptive=TRUE && align='left' pre-processing for align='right'"
msgstr ""
"frollapply : adaptive=TRUE && align='left' pré-traitement pour align='right'"

#: frollapply.R:319
msgid ""
"frollapply calling parallel::mccollect to collect results from forked "
"processes raised an error.\n"
"%s"
msgstr ""
"frollapply appelle parallel::mccollect pour récupérer le résultat des "
"processus dérivés qui ont émis une erreur.\n"
"%s"

#: frollapply.R:320
msgid ""
"frollapply internal call to parallel::mccollect raised a warning, FUN "
"warnings should have been suppressed by parallel.\n"
"%s"
msgstr ""
"frollapply l'appel interne à parallel::mccollect a émis un avertissement, "
"les avertissements FUN auraient dû être supprimés par le parallèlisme.\n"
"%s"

#: frollapply.R:322
msgid ""
"frollapply completed successfully but raised an error when attempting to "
"simplify results using user specified function in 'simplify' argument. Be "
"sure to provide 'fill' argument matching the type and shape of results "
"returned by the your function. Use simplify=FALSE to obtain a list instead.\n"
"%s"
msgstr ""
"frollapply s'est terminé avec succès mais a émis une erreur lors de la "
"tentative pour simplifier les résultats en utilisant la fonction utilisateur "
"spécifiée dans l'argument 'simplify'. Vérifiez que vous avez fourni "
"l'argument 'fill' avec le type et la forme correspondant aux résultats "
"renvoyés par votre fonction. Utiliser simplify=FALSE pour obtenir une liste "
"à la place.\n"
"%s"

#: frollapply.R:323
msgid ""
"frollapply completed successfully but raised a warning when attempting to "
"simplify results using user specified function in 'simplify' argument. Be "
"sure to provide 'fill' argument matching the type and shape of results "
"returned by the your function. Use simplify=FALSE to obtain a list instead.\n"
"%s"
msgstr ""
"frollapply s'est terminé avec succès mais a émis un avertissement lors de la "
"tentative pour simplifier les résultats en utilisant la fonction utilisateur "
"spécifiée dans l'argument 'simplify'. Vérifiez que vous avez fourni "
"l'argument 'fill' avec le type et la forme correspondant aux résultats "
"renvoyés par votre fonction. Utiliser simplify=FALSE pour obtenir une liste "
"à la place.\n"
"%s"

#: frollapply.R:325
msgid ""
"frollapply completed successfully but raised an error when attempting to "
"simplify results using our internal 'simplifylist' function. Be sure to "
"provide 'fill' argument matching the type and shape of results returned by "
"the your function. Use simplify=FALSE to obtain a list instead. If you "
"believe your results could be automatically simplified please submit your "
"use case as new issue in our issue tracker.\n"
"%s"
msgstr ""
"frollapply s'est terminé avec succès mais a émis une erreur lors de la "
"tentative pour simplifier les résultats en utilisant notre fonction interne "
"'simplifylist'. Vérifiez que vous avez fourni l'argument 'fill' avec le type "
"et la forme correspondant aux résultats renvoyés par la fonction. Utiliser "
"simplify=FALSE pour obtenir une liste à la place. Si vous pensez que vos "
"résultats peuvent être simplifiés automatiquement, déposez vos cas "
"d'utilisation en tant que nouveau sujet dans le suivi des problèmes.\n"
"%s"

#: frollapply.R:326
msgid ""
"frollapply completed successfully but raised a warning when attempting to "
"simplify results using our internal 'simplifylist' function. Be sure to "
"provide 'fill' argument matching the type and shape of results returned by "
"the your function. Use simplify=FALSE to obtain a list instead. If you "
"believe your results could be automatically simplified please submit your "
"use case as new issue in our issue tracker.\n"
"%s"
msgstr ""
"frollapply s'est terminé avec succès mais a émis un avertissement lors de la "
"tentative pour simplifier les résultats en utilisant notre fonction interne "
"'simplifylist'. Vérifiez que vous avez fourni l'argument 'fill' avec le type "
"et la forme correspondant aux résultats renvoyés par la fonction. Utiliser "
"simplify=FALSE pour obtenir une liste à la place. Si vous pensez que vos "
"résultats peuvent être simplifiés automatiquement, déposez vos cas "
"d'utilisation en tant que nouveau sujet dans le suivi des problèmes.\n"
"%s"

#: frollapply.R:332
msgid "frollapply running on single CPU thread"
msgstr "frollapply s'exécute sur un seul thread du CPU"

#: frollapply.R:348
msgid ""
"frollapply run on %d CPU threads throttled to %d threads, input length %d"
msgstr ""
"frollapply s'exécute sur %d threads CPU limités à %d threads, entrée de "
"longueur %d"

#: frollapply.R:350
msgid "frollapply running on %d CPU threads"
msgstr "frollapply s'exécute sur %d threads du CPU"

#: frollapply.R:409 frollapply.R:433
#, c-format
msgid ""
"frollapply received an error(s) when evaluating FUN:\n"
"%s"
msgstr ""
"frollapply a reçu les erreurs suivantes en évaluant FUN :\n"
"%s"

#: fwrite.R:20
#, c-format
msgid "Argument 'encoding' must be '', 'UTF-8' or 'native'."
msgstr "L'argument 'encoding' doit être '', 'UTF-8' ou 'native'."

#: fwrite.R:33
#, c-format
msgid "x being coerced from class: matrix to data.table"
msgstr "conversion automatique de classe pour x : matrix vers data.table"

#: fwrite.R:67
msgid "Appending to existing file so setting bom=FALSE and yaml=FALSE"
msgstr "Ajout au fichier existant ce qui initialise bom=FALSE et yaml=FALSE"

#: fwrite.R:80
#, c-format
msgid ""
"If you intended to overwrite the file at %s with an empty one, please use "
"file.remove first."
msgstr ""
"Si vous souhaitiez écraser le fichier %s par un fichier vide, utilisez "
"d'abord file.remove."

#: fwrite.R:81
#, c-format
msgid "Input has no columns; doing nothing.%s"
msgstr "L'entrée n'a pas de colonne ; aucune action réalisée. %s"

#: fwrite.R:84
#, c-format
msgid "Input has no columns; creating an empty file at '%s' and exiting."
msgstr ""
"L'entrée n'a pas de colonne ; Création d'un fichier vide à '%s' et sortie."

#: fwrite.R:92
#, c-format
msgid ""
"'data.table' relies on the package 'yaml' to write the file header; please "
"add this to your library with install.packages('yaml') and try again."
msgstr ""
"'data.table' dépend du package 'yaml' pour écrire l'entête du fichier ; "
"Veuillez l’ajouter à votre bibliothèque avec install.packages('yaml') et "
"recommencer."

#: groupingsets.R:7 groupingsets.R:25 groupingsets.R:47
#, c-format
msgid "Argument 'x' must be a data.table object"
msgstr "L'argument 'x' doit être un objet data.table"

#: groupingsets.R:9 groupingsets.R:27 groupingsets.R:53
#, c-format
msgid ""
"Argument 'by' must be a character vector of column names used in grouping."
msgstr ""
"L'argument 'by' doit être un vecteur de chaînes de caractères composé de "
"noms de colonnes utilisées pour le groupement."

#: groupingsets.R:11 groupingsets.R:29 groupingsets.R:59
#, c-format
msgid "Argument 'id' must be a logical scalar."
msgstr "L'argument 'id' doit être un scalaire booléen."

#: groupingsets.R:31
#, c-format
msgid "Argument 'j' is required"
msgstr "L'argument 'j' est obligatoire"

#: groupingsets.R:49
#, c-format
msgid ""
"Argument 'x' is a 0-column data.table; no measure to apply grouping over."
msgstr ""
"L'argument 'x' est une data.table à 0 colonne ; Aucune possibilité de "
"groupement."

#: groupingsets.R:51
#, c-format
msgid "Input data.table must not contain duplicate column names."
msgstr ""
"L'entrée data.table ne doit pas contenir de noms de colonnes dupliqués."

#: groupingsets.R:55
#, c-format
msgid "Argument 'by' must have unique column names for grouping."
msgstr ""
"L'argument 'by' doit avoir des noms de colonnes uniques pour le groupement."

#: groupingsets.R:57
#, c-format
msgid "Argument 'sets' must be a list of character vectors."
msgstr ""
"L'argument 'sets' doit être une liste de vecteurs de chaînes de caractères."

#: groupingsets.R:63
#, c-format
msgid ""
"Argument 'label', if not NULL, must be a scalar or a named list of scalars."
msgstr ""
"L'argument 'label' quand il n'est pas NULL doit être un scalaire ou un liste "
"nommée de scalaires."

#: groupingsets.R:65
#, c-format
msgid ""
"When argument 'label' is a list, all of the list elements must be named."
msgstr ""
"Quand l'argument 'label' est une liste, tous les éléments de la liste "
"doivent être nommés."

#: groupingsets.R:67
#, c-format
msgid ""
"When argument 'label' is a list, the element names must not contain "
"duplicates."
msgstr ""
"Quand l'argument 'label' est une liste, il ne doit pas y avoir de doublons "
"dans les noms d'éléments."

#: groupingsets.R:70
#, c-format
msgid ""
"All columns used in 'sets' argument must be in 'by' too. Columns used in "
"'sets' but not present in 'by': %s"
msgstr ""
"Toutes les colonnes utilisées dans l'argument 'sets' doivent également "
"figurer dans 'by'. Colonnes utilisées dans 'sets' mais non présentes dans "
"'by' : %s"

#: groupingsets.R:72
#, c-format
msgid ""
"When using `id=TRUE` the 'x' data.table must not have a column named "
"'grouping'."
msgstr ""
"Lorsqu'on utilise `id=TRUE`, le data.table 'x' ne doit pas avoir de colonne "
"nommée 'grouping'."

#: groupingsets.R:74
#, c-format
msgid ""
"Character vectors in 'sets' list must not have duplicated column names "
"within a single grouping set."
msgstr ""
"Les vecteurs de chaînes de caractères de la liste 'sets' ne doivent pas "
"avoir de noms de colonnes dupliqués au sein d'un même ensemble de "
"regroupement."

#: groupingsets.R:76
#, c-format
msgid ""
"'sets' contains a duplicate (i.e., equivalent up to sorting) element at "
"index %d; as such, there will be duplicate rows in the output -- note that "
"grouping by A,B and B,A will produce the same aggregations. Use "
"`sets=unique(lapply(sets, sort))` to eliminate duplicates."
msgstr ""
"'sets' contient un élément dupliqué (c'est-à-dire équivalent lors du tri) à "
"l'index %d ; Il y aura donc des lignes dupliquées dans la sortie -- notez "
"que le regroupement par A,B et B,A produira les mêmes agrégations. Utiliser "
"`sets=unique(lapply(sets, sort))` pour éliminer les doublons."

#: groupingsets.R:82
#, c-format
msgid ""
"When argument 'label' is a list, all element names must be (1) in 'by', or "
"(2) the first element of the class in the data.table 'x' of a variable in "
"'by', or (3) one of %s. Element names not satisfying this condition: %s"
msgstr ""
"Quand l'argument 'label' est une liste, tous les noms d'éléments doivent "
"être (1) dans 'by', ou (2) être le premier élément de la classe du data."
"table 'x' d'une variable dans 'by', ou (3) un de %s. Noms des éléments qui "
"ne satisfont pas cette condition : %s"

#: groupingsets.R:92
#, c-format
msgid "%s (label: %s; data: %s)"
msgstr "%s (libellé : %s; données : %s)"

#: groupingsets.R:96
#, c-format
msgid ""
"When argument 'label' is a list, the class of each 'label' element with name "
"in 'by' must match the class of the corresponding column of the data.table "
"'x'. Class mismatch for: %s"
msgstr ""
"Quand l'argument 'label' est une liste, la classe de chaque élément 'label' "
"dont le nom est dans 'by' doit correspondre à la classe de la colonne "
"correspondante du data.table 'x'. Classes sans correspondance : %s"

#: groupingsets.R:100
#, c-format
msgid "(label name: %s; label class[1]: %s)"
msgstr "(nom du libellé : %s; classe du libellé[1] : %s)"

#: groupingsets.R:103
#, c-format
msgid ""
"When argument 'label' is a list, the name of each element of 'label' not in "
"'by' must match the first element of the class of the element value. "
"Mismatches: %s"
msgstr ""
"Quand l'argument 'label' est une liste, le noms de chaque élément de 'label' "
"qui n'est pas dans 'by' doit correspondre au premier élément de la classe de "
"la valeur de cet élément. Différences : %s"

#: groupingsets.R:110
#, c-format
msgid ""
"Expression passed to grouping sets function must not update by reference. "
"Use ':=' on results of your grouping function."
msgstr ""
"L'expression transmise à la fonction de regroupement des ensembles ne doit "
"pas être mise à jour par référence. Utilisez ':=' sur les résultats de votre "
"fonction de regroupement."

#: groupingsets.R:121
#, c-format
msgid ""
"When using `id=TRUE` the 'j' expression must not evaluate to a column named "
"'grouping'."
msgstr ""
"Lors de l'utilisation de `id=TRUE`, l'expression 'j' ne doit pas être "
"évaluée à une colonne nommée 'grouping'."

#: groupingsets.R:123
#, c-format
msgid ""
"There exists duplicated column names in the results, ensure the column "
"passed/evaluated in `j` and those in `by` are not overlapping."
msgstr ""
"Le résultat comporte des doublons parmi les noms de colonnes, vérifier que "
"les colonnes passées ou évaluées dans 'j' et celles du 'by' ne se recouvrent "
"pas."

#: groupingsets.R:146
#, c-format
msgid "%s (label: %s)"
msgstr "%s (libellé : %s)"

#: groupingsets.R:147
#, c-format
msgid ""
"For the following variables, the 'label' value was already in the data: %s"
msgstr ""
"Pour les variables suivantes, la valeur de 'label' était déjà dans les "
"données : %s"

#: groupingsets.R:154
#, c-format
msgid ""
"Using integer64 class columns require to have 'bit64' package installed."
msgstr ""
"L'utilisation de colonnes de classe integer64 nécessite d'avoir installé le "
"package 'bit64'."

#: helpers.R:6
#, c-format
msgid "argument 'sort' must be TRUE or FALSE"
msgstr "l'argument 'sort' doit valoir TRUE ou FALSE"

#: helpers.R:8
#, c-format
#| msgid "'fromLast' must be TRUE or FALSE"
msgid "argument 'rev' must be TRUE or FALSE"
msgstr "l'argument 'rev' doit valoir TRUE ou FALSE"

#: helpers.R:17
#, c-format
msgid ".selfref.ok expects data.table class object."
msgstr ".selfref.ok attend un objet de classe data.table."

#: last.R:11 last.R:16 last.R:24 last.R:29 last.R:33 last.R:41 last.R:52
#: last.R:57 last.R:65 last.R:70 last.R:74 last.R:82
msgid "%s: using %s: %s"
msgstr "%s : utilisant %s : %s"

#: last.R:39 last.R:80
#, c-format
msgid ""
"'xts' class passed to %s function but 'xts' is not available, you should "
"have 'xts' installed already"
msgstr ""
"la classe 'xts' est passée à la fonction %s mais le package 'xts' n'est pas "
"présent; 'xts' doit être installé auparavant"

#: merge.R:4
#, c-format
msgid "Argument 'sort' should be logical TRUE/FALSE"
msgstr "L'argument 'sort' doit être un booléen TRUE ou FALSE"

#: merge.R:6
#, c-format
msgid "Argument 'no.dups' should be logical TRUE/FALSE"
msgstr "L'argument 'no.dups' doit être un booléen TRUE ou FALSE"

#: merge.R:18
#, c-format
msgid "Neither of the input data.tables to join have columns."
msgstr "Lors de la jointure, aucune des data.tables d'entrée n'a de colonne."

#: merge.R:20 merge.R:22
#, c-format
msgid "Input data.table '%s' has no columns."
msgstr "La data.table d'entrée '%s' n'a pas de colonne."

#: merge.R:32
#, c-format
msgid "`by.x` and `by.y` must be of same length."
msgstr "'by.x' et 'by.y' doivent avoir la même longueur."

#: merge.R:34
#, c-format
msgid "Supplied both `by` and `by.x`/`by.y`. `by` argument will be ignored."
msgstr ""
"'by' et 'by.x'/'by.y' sont présents simultanément, l'argument 'by' est "
"ignoré."

#: merge.R:37
#, c-format
msgid "A non-empty vector of column names is required for `by.x` and `by.y`."
msgstr ""
"'by.x' et 'by.y' doivent être des vecteurs non vides comportant des noms de "
"colonnes."

#: merge.R:39 merge.R:42 merge.R:56 merge.R:59
#, c-format
msgid "The following columns listed in `%s` are missing from %s: %s"
msgstr "Les colonnes suivantes listées dans `%s` ne figurent pas dans %s : %s"

#: merge.R:54
#, c-format
msgid "A non-empty vector of column names for `by` is required."
msgstr "'by' doit être un vecteur non vide de noms de colonnes."

#: merge.R:116
#, c-format
msgid "column names %s are duplicated in the result"
msgstr "noms de colonnes en doublon %s dans le résultat"

#: merge.R:146
#, c-format
msgid "merge.data.table() received %s and %s, all of which will be ignored: %s"
msgstr "merge.data.table() a reçu %s et %s, ils seront tous ignorés : %s"

#: mergelist.R:52
#, c-format
msgid "'x' must be data.table"
msgstr "'x' doit être un data.table"

#: mergelist.R:54
#, c-format
msgid "'on' must be character column names of 'x' argument"
msgstr ""
"'on' doit être un vecteur de chaînes de caractères de noms de colonnes de "
"l'argument 'x'"

#: mergelist.R:59
#, c-format
msgid ""
"'cols' must be non-zero length, non-NA, integer or character columns of 'x' "
"argument"
msgstr ""
"'cols' doit être une liste de longueur différente de zéro, non NA, de "
"colonnes d'entiers ou de caractères de l'argument 'x'"

#: mergelist.R:98
#, c-format
msgid "cross join must be used with zero-length on, mult='all', join.many=TRUE"
msgstr ""
"la jointure croisée doit être utilisée en validant zero-length et avec "
"mult='all', join.many=TRUE"

#: mergelist.R:104
#, c-format
msgid "'on' must be non-zero length character vector"
msgstr ""
"'on' doit être un vecteur de chaînes de caractères de longueur différente de "
"0"

#: mergelist.R:106
#, c-format
msgid "semi and anti joins must be used with mult!='all'"
msgstr "les jointures semi et anti doivent être utilisées avec mult!='all'"

#: mergelist.R:157
#, c-format
msgid "'on' is missing and necessary key is not present"
msgstr "'on' est absent ainsi que la clé obligatoire"

#: mergelist.R:160 mergelist.R:162
#, c-format
msgid ""
"'on' argument specifies columns to join %s that are not present in %s table "
"%s"
msgstr ""
"l'argument 'on' indique les colonnes à joindre %s qui ne sont pas dans la "
"table %s de %s"

#: mergelist.R:206
#, c-format
msgid ""
"merge result has duplicated column names %s, use 'cols' argument or rename "
"columns in 'l' tables"
msgstr ""
"le résultat de la fusion contient des noms de colonnes dupliqués %s, "
"utilisez l'argument 'cols' ou renommez les colonnes dans les tables 'l'"

#: mergelist.R:266 mergelist.R:304
#, c-format
msgid "'%s' must be a list"
msgstr "'%s' doit être une liste"

#: mergelist.R:268
#, c-format
msgid "Every element of 'l' list must be data.table objects"
msgstr "Chaque élément de la liste 'l' doit être un objet data.table"

#: mergelist.R:270
#, c-format
msgid "Tables in 'l' must all have columns, but these entries have 0: %s"
msgstr ""
"Les tables dans 'l' doivent toutes avoir des colonnes, mais ces entrées en "
"ont 0 : %s"

#: mergelist.R:272
#, c-format
msgid ""
"Column names in individual 'l' entries must be unique, but these have some "
"duplicates: %s"
msgstr ""
"Les noms de colonne dans les entrées individuelles 'l' doivent être uniques, "
"mais des doublons sont présents : %s"

#: mergelist.R:279
msgid "mergelist: merging %d table(s), took %.3fs"
msgstr "mergelist: la fusion de %d table(s) a pris %.3fs"

#: mergelist.R:286
#, c-format
msgid ""
"'join.many' must be TRUE or FALSE, or a list of such whose length must be "
"length(l)-1L"
msgstr ""
"'join.many' doit valoir TRUE ou FALSE, ou être une liste de ceux-ci et avoir "
"pour longueur length(l)-1L"

#: mergelist.R:293
#, c-format
msgid ""
"'mult' must be one of [error, all, first, last] or NULL, or a list of such "
"whose length must be length(l)-1L"
msgstr ""
"'mult' doit être une valeur parmi [error, all, first, last] ou NULL, ou une "
"liste de ceux-ci et avoir pour longueur length(l)-1L"

#: mergelist.R:298
#, c-format
msgid ""
"'how' must be one of [left, inner, full, right, semi, anti, cross], or a "
"list of such whose length must be length(l)-1L"
msgstr ""
"'how' doit être une valeur parmi [left, inner, full, right, semi, anti, "
"cross], ou une liste de ceux-ci et avoir pour longueur length(l)-1L"

#: mergelist.R:306
#, c-format
msgid "'cols' must be same length as 'l' (%d != %d)"
msgstr "'cols' doit être de la même longueur que 'l' (%d != %d)"

#: mergelist.R:309
#, c-format
msgid ""
"'cols' must be a list of non-zero length, non-NA, non-duplicated, character "
"vectors, or eventually NULLs (all columns)"
msgstr ""
"'cols' doit être une liste de longueur différente de zéro, non NA, non "
"dupliquée, de vecteurs de caractères, ou éventuellesment de valeurs NULL "
"(toutes les colonnes)"

#: mergelist.R:311
#, c-format
msgid "'cols' specify columns not present in corresponding table"
msgstr "'cols' utilise des colonnes absentes dans la table correspondante"

#: mergelist.R:320
#, c-format
msgid ""
"'on' must be non-NA, non-duplicated, character vector, or a list of such "
"which length must be length(l)-1L"
msgstr ""
"'on' doit être non NA, non dupliqué, un vecteur de caractères, ou une liste "
"de ceux-ci et avoir pour longueur length(l)-1L"

#: mergelist.R:343
msgid "mergelist: merging %d tables, took %.3fs"
msgstr "mergelist : fusion de %d tables, a pris %.3fs"

#: onAttach.R:23
#, c-format
msgid ""
"data.table %s IN DEVELOPMENT built %s%s using %d threads (see ?getDTthreads)."
msgstr ""
"data.table %s EN DEVELOPPEMENT build %s%s utilisant %d threads (voir ?"
"getDTthreads)."

#: onAttach.R:25
#, c-format
msgid "data.table %s using %d threads (see ?getDTthreads)."
msgstr "data.table %s utilise %d threads (voir ?getDTthreads)."

#: onAttach.R:26
#, c-format
msgid "Latest news: r-datatable.com"
msgstr "Dernières actualités : r-datatable.com"

#: onAttach.R:27
msgid "TRANSLATION CHECK"
msgstr "CONTROLE DE TRADUCTION"

#: onAttach.R:29
#, c-format
msgid ""
"**********\n"
"Running data.table in English; package support is available in English only. "
"When searching for online help, be sure to also check for the English error "
"message. This can be obtained by looking at the po/R-<locale>.po and po/"
"<locale>.po files in the package source, where the native language and "
"English error messages can be found side-by-side.%s\n"
"**********"
msgstr ""
"**********\n"
"Exécution de data.table en anglais ; l'aide du package n'est disponible "
"qu'en anglais. Lorsque vous recherchez de l'aide en ligne, veillez à "
"vérifier également le message d'erreur en anglais. Pour ce faire, consultez "
"les fichiers po/R-<locale>.po et po/<locale>.po dans le source du package, "
"où les messages d'erreur en langue native et ceux en anglais figurent côte à "
"côte.%s\n"
"**********"

#: onAttach.R:30
msgid ""
"You can also try calling Sys.setLanguage('en') prior to reproducing the "
"error message."
msgstr ""
"Vous pouvez aussi essayer d'appeler Sys.setLanguage('en') avant de "
"reproduire le message d'erreur."

#: onAttach.R:34
#, c-format
msgid ""
"**********\n"
"This development version of data.table was built more than 4 weeks ago. "
"Please update: data.table::update_dev_pkg()\n"
"**********"
msgstr ""
"**********\n"
"Cette version de développement de data.table a été construite il y a plus de "
"4 semaines. Veuillez mettre à jour : data.table::update_dev_pkg()\n"
"**********"

#: onAttach.R:36
#, c-format
msgid ""
"**********\n"
"This installation of data.table has not detected OpenMP support. It should "
"still work but in single-threaded mode."
msgstr ""
"**********\n"
"Cette installation de data.table n'a pas détecté le support OpenMP. Elle "
"devrait fonctionner, mais en mode monotâche."

#: onAttach.R:38
#, c-format
msgid ""
"This is a Mac. Please read https://mac.r-project.org/openmp/. Please engage "
"with Apple and ask them for support. Check r-datatable.com for updates, and "
"our Mac instructions here: https://github.com/Rdatatable/data.table/wiki/"
"Installation. After several years of many reports of installation problems "
"on Mac, it's time to gingerly point out that there have been no similar "
"problems on Windows or Linux.\n"
"**********"
msgstr ""
"Il s'agit d'un Mac. Veuillez lire https://mac.r-project.org/openmp/. "
"Contactez Apple et demandez-lui de mieux supporter OpenMP. Consultez r-"
"datable.com pour les mises à jour, et nos instructions pour Mac ici : "
"https://github.com/Rdatatable/data.table/wiki/Installation. Après plusieurs "
"années de rapports faisant état de problèmes d'installation sur Mac, il est "
"temps de souligner avec insistance qu'il n'y a pas eu de problèmes "
"similaires sous Windows ou Linux.\n"
"**********"

#: onAttach.R:40
#, c-format
msgid ""
"This is %s. This warning should not normally occur on Windows or Linux where "
"OpenMP is turned on by data.table's configure script by passing -fopenmp to "
"the compiler. If you see this warning on Windows or Linux, please file a "
"GitHub issue.\n"
"**********"
msgstr ""
"Il s'agit de %s. Cet avertissement ne doit pas se produire normalement sous "
"Windows ou Linux où OpenMP est activé par le script de configuration de data."
"table en passant -fopenmp au compilateur. Si vous voyez cet avertissement "
"sous Windows ou Linux, veuillez reporter le problème dans le gestionnaire de "
"tickets (issue tracker) sur GitHub.\n"
"**********"

#: onLoad.R:5
#, c-format
msgid ""
"Option 'datatable.nomatch' is defined but is now ignored. Please see note 11 "
"in v1.12.4 NEWS (Oct 2019), and note 14 in v1.14.2."
msgstr ""
"L'option 'datatable.nomatch' est définie mais est désormais ignorée. Voir la "
"note 11 dans la v1.12.4 NEWS (Oct 2019), et la note 14 dans la v1.14.2."

#: onLoad.R:21
#, c-format
msgid ""
"The data_table.%s version (%s) does not match the package (%s). Please close "
"all R sessions to release the old %s and reinstall data.table in a fresh R "
"session. Prior to R version 3.6.0 patched, R's package installer could leave "
"a package in an apparently functional state where new R code was calling old "
"C code silently: https://bugs.r-project.org/bugzilla/show_bug.cgi?id=17478. "
"Once a package is in this mismatch state it may produce wrong results "
"silently until you next upgrade the package. This mismatch between R and C "
"code can happen with any package not just data.table. It is just that data."
"table has added this check."
msgstr ""
"La data_table.%s version (%s) ne correspond pas au package (%s). Veuillez "
"fermer toutes les sessions R pour libérer l'ancien %s et réinstaller data."
"table dans une nouvelle session R. Avant la version 3.6.0 corrigée de R, "
"l'installeur de paquets de R pouvait laisser un paquet dans un état "
"apparemment fonctionnel où le nouveau code R appelait l'ancien code C de "
"manière silencieuse : https://bugs.r-project.org/bugzilla/show_bug.cgi?"
"id=17478. Dès qu'un paquet se trouve dans cet état incohérent il peut "
"produire de mauvais résultats silencieusement jusqu'à la nouvelle mise à "
"jour du paquet. Ce problème entre le code C et R peut se produire avec "
"n'importe quel paquet et pas seulement data.table. C'est juste que data."
"table a implémenté ce contrôle."

#: onLoad.R:25
#, c-format
msgid ""
"This is R %s but data.table has been installed using R %s. The major version "
"must match. Please reinstall data.table."
msgstr ""
"Il s'agit de R %s mais data.table a été installé avec R %s. La version "
"majeure doit correspondre. Veuillez réinstaller data.table."

#: onLoad.R:103
#, c-format
msgid "Unexpected base R behaviour: list(x) has copied x"
msgstr "Comportement inattendu de R de base : list(x) a recopié x"

#: onLoad.R:111
#, c-format
msgid "Unexpected base R behaviour: names<- has copied column contents"
msgstr ""
"Comportement inattendu de R de base : names<- a recopié le contenu de la "
"colonne"

#: onLoad.R:121
#, c-format
msgid ""
"Unexpected base R behaviour: DF[2,2]<- did not copy column 2 which was "
"assigned to"
msgstr ""
"Comportement inattendu de la base R : DF[2,2]<- n'a pas copié la colonne 2 "
"qui était assignée à"

#: onLoad.R:122
#, c-format
msgid ""
"Unexpected base R behaviour: DF[2,2]<- copied the first column which was not "
"assigned to, too"
msgstr ""
"Comportement inattendu de la base R : DF[2,2]<- a copié la première colonne "
"qui n'a pas non plus été affectée à"

#: onLoad.R:124
#, c-format
msgid "Unexpected base R behaviour: DF[2,2]<- has not copied address(DF)"
msgstr ""
"Comportement inattendu de R de base : DF[2,2]<- n'a pas copié address(DF)"

#: openmp-utils.R:3
#, c-format
msgid "Provide either threads= or percent= but not both"
msgstr "Utiliser threads= ou percent= mais pas les deux simultanément"

#: openmp-utils.R:4
#, c-format
msgid "percent= is provided but is length %d"
msgstr "percent= est fournit mais sa longueur est %d"

#: openmp-utils.R:6
#, c-format
msgid "percent==%d but should be a number between 2 and 100"
msgstr "percent==%d mais doit être un nombre entre 2 et 100"

#: print.data.table.R:19
#, c-format
msgid "Valid options for col.names are 'auto', 'top', and 'none'"
msgstr "Les options valides pour col.names sont 'auto', 'top', ou 'none'"

#: print.data.table.R:21
#, c-format
msgid "Valid options for trunc.cols are TRUE and FALSE"
msgstr "Les options valides pour trunc.cols sont TRUE ou FALSE"

#: print.data.table.R:24
#, c-format
msgid "Column classes will be suppressed when col.names is 'none'"
msgstr "Les classes des colonnes seront supprimées si col.names est 'none'"

#: print.data.table.R:48
msgid "Key: <%s>"
msgstr "Clé : <%s>"

#: print.data.table.R:58
msgid "Null %s (0 rows and 0 cols)"
msgstr "Valeur nulle de %s  (0 ligne et 0 colonne)"

#: print.data.table.R:60
msgid "Empty %s (%d rows and %d cols)"
msgstr "%s est vide (%d ligne et %d colonne)"

#: print.data.table.R:161
#, c-format
msgid ""
"Internal structure doesn't seem to be a list. Possibly corrupt data.table."
msgstr ""
"La structure interne ne correspond pas à une liste. La data.table est "
"éventuellement corrompue."

#: programming.R:14 programming.R:40
#, c-format
msgid "'x' must be a list"
msgstr "'x' doit être une liste"

#: programming.R:22
#, c-format
msgid ""
"Character objects provided in the input are not scalar objects, if you need "
"them as character vector rather than a name, then wrap each into 'I' call: %s"
msgstr ""
"Les objets caractères fournis en entrée ne sont pas des objets scalaires, si "
"vous avez besoin d'un vecteur de caractères plutôt que d'un nom, encadrez "
"chacun d'eux dans un appel 'I' : %s"

#: programming.R:50
#, c-format
msgid "'env' must not be missing"
msgstr "'env' doit être fourni"

#: programming.R:56
#, c-format
msgid "'env' must be a list or an environment"
msgstr "'env' doit être une liste ou un environnement"

#: programming.R:63
#, c-format
msgid "'env' argument does not have names"
msgstr "il manque les noms dans l'argument 'env'"

#: programming.R:65
#, c-format
msgid "'env' argument has zero char names"
msgstr "L’argument 'env' contient des noms à zéro caractère"

#: programming.R:67
#, c-format
msgid "'env' argument has NA names"
msgstr "l'argument 'env' comporte des noms à NA"

#: programming.R:69
#, c-format
msgid "'env' argument has duplicated names"
msgstr "l'argument 'env' contient des noms dupliqués"

#: rowwiseDT.R:4
#, c-format
msgid ""
"Must provide at least one column (use `name=`). See ?rowwiseDT for details"
msgstr ""
"Une colonne au moins doit être fournie (utiliser `name=`). Voir ?rowwiseDT "
"pour les détails"

#: rowwiseDT.R:7
#, c-format
msgid "Named arguments must be empty"
msgstr "Les arguments nommés doivent être vides"

#: rowwiseDT.R:9
#, c-format
msgid "Header must be the first N arguments"
msgstr "L'entête doit être les N premiers arguments"

#: rowwiseDT.R:15
#, c-format
msgid ""
"There are %d columns but the number of cells is %d, which is not an integer "
"multiple of the columns"
msgstr ""
"Il y a %d colonnes mais le nombre de cellules est %d et n'est pas un "
"multiple entier du nombre de colonnes"

#: setkey.R:3
#, c-format
msgid ""
"x may no longer be the character name of the data.table. The possibility was "
"undocumented and has been removed."
msgstr ""
"x ne peut plus être le nom sous forme de chaîne de caractère de data.table. "
"Cette possibilité n'était pas documentée et a été supprimée."

#: setkey.R:34
#, c-format
msgid "x is not a data.table"
msgstr "x n'est pas une data.table"

#: setkey.R:35
#, c-format
msgid ""
"cols is not a character vector. Please see further information in ?setkey."
msgstr ""
"cols n'est pas un vecteur de chaînes de caractères. Voir les informations "
"supplémentaires dans ?setkey."

#: setkey.R:36
#, c-format
msgid ""
"Setting a physical key on .SD is reserved for possible future use; to modify "
"the original data's order by group. Try setindex() instead. Or, set*(copy(."
"SD)) as a (slow) last resort."
msgstr ""
"La définition d'une clé physique sur .SD est réservée à une utilisation "
"future possible, pour modifier l'ordre des données d'origine par groupe. "
"Essayez plutôt setindex(), ou encore, set*(copy(.SD)) en dernier recours "
"(lent)."

#: setkey.R:38
#, c-format
msgid ""
"cols is a character vector of zero length. Removed the key, but use NULL "
"instead, or wrap with suppressWarnings() to avoid this warning."
msgstr ""
"cols est un vecteur de chaînes de caractères de longueur zéro. Supprimer la "
"clé à remplacer par NULL, ou encadrer le code dans suppressWarnings() pour "
"éviter cet avertissement."

#: setkey.R:42
#, c-format
msgid "cols is the empty string. Use NULL to remove the key."
msgstr "cols est une chaîne vide. Utiliser NULL pour supprimer la clé."

#: setkey.R:43 setkey.R:265
#, c-format
msgid "cols contains some blanks."
msgstr "cols contient des blancs."

#: setkey.R:46 setkey.R:269
#, c-format
msgid "some columns are not in the data.table: %s"
msgstr "certaines colonnes n'appartiennent pas à la data.table : %s"

#: setkey.R:54 setkey.R:270
#, c-format
msgid ""
"x contains a column called '.xi'. Conflicts with internal use by data.table."
msgstr ""
"x contient une colonne appelée '.xi'. Ceci entre en conflit avec "
"l'utilisation interne de data.table."

#: setkey.R:57
#, c-format
msgid ""
"Column '%s' is type '%s' which is not supported as a key column type, "
"currently."
msgstr ""
"La colonne '%s' a pour type '%s' qui n'est pas reconnu actuellement comme "
"type de clé de colonne."

#: setkey.R:65
msgid "forder took %.03f sec"
msgstr "forder a pris %.03f sec"

#: setkey.R:77
msgid "reorder took %s"
msgstr "reorder a pris %s"

#: setkey.R:79
msgid "x is already ordered by these columns, no need to call reorder"
msgstr "x est déjà classé suivant ces colonnes, l'appel de reorder est inutile"

#: setkey.R:132
#, c-format
msgid "x is vector but 'by' is supplied"
msgstr "x est un vecteur mais 'by' est fourni"

#: setkey.R:148
#, c-format
msgid "x is a single vector, non-NULL 'by' doesn't make sense"
msgstr "x est un vecteur colonne, 'by' non NULL n'a pas de sens"

#: setkey.R:160
#, c-format
msgid ""
"data.table has no support for sorting by method='%s'. Use base::order(), not "
"order(), if you really need this."
msgstr ""
"data.table ne prend pas en charge le tri avec method='%s'. Utiliser base::"
"order(), et non pas order() si vous en avez réellement besoin."

#: setkey.R:181
#, c-format
msgid "Attempting to order a 0-column data.table or data.frame."
msgstr ""
"Tentative de tri d'une data.table ou d'un data.frame qui n'a pas de colonne."

#: setkey.R:186
#, c-format
msgid ""
"The first item passed to [f]order is a plain list but there are more items. "
"It should be a data.table or data.frame."
msgstr ""
"Le premier élément transmis à [f]order est une simple liste, mais il y a "
"d'autres éléments. Il faut un data.table ou un data.frame."

#: setkey.R:194
#, c-format
msgid "Mixing '-' with vector decreasing= is not supported."
msgstr "Il n'est pas possible d'utiliser '-' avec decreasing= pour un vecteur."

#: setkey.R:195
#, c-format
msgid "decreasing= has length %d applied to sorting %d columns."
msgstr "decreasing= a pour longueur %d appliquée au tri de %d colonnes."

#: setkey.R:211
#, c-format
msgid "Internal code should not be being called on type double"
msgstr "Le code interne ne doit pas être appelé avec un type double"

#: setkey.R:218
#, c-format
msgid ""
"Input is not a vector of type double. New parallel sort has only been done "
"for double vectors so far. Using one thread."
msgstr ""
"L'entrée n'est pas un vecteur de type double. Le nouveau tri parallèle n'a "
"été implémenté que pour les vecteurs de doubles jusqu'à présent. Utilisation "
"d'un seul thread."

#: setkey.R:219
#, c-format
msgid ""
"New parallel sort has not been implemented for decreasing=TRUE so far. Using "
"one thread."
msgstr ""
"Le nouveau tri parallèle n'a pas été implémenté pour decreasing=TRUE jusqu'à "
"présent. Utilisation d'un seul thread."

#: setkey.R:220
#, c-format
msgid ""
"New parallel sort has not been implemented for vectors containing NA values "
"so far. Using one thread."
msgstr ""
"Le nouveau tri parallèle n'a pas été implémenté pour les vecteurs contenant "
"des valeurs NA jusqu'à présent. Utilisation d'un seul thread."

#: setkey.R:231 setkey.R:257
#, c-format
msgid "x must be a data.frame or data.table"
msgstr "x doit être un data.frame ou une data.table"

#: setkey.R:259
#, c-format
msgid "na.last must be logical TRUE/FALSE"
msgstr "na.last doit être un booléen TRUE ou FALSE"

#: setkey.R:260
#, c-format
msgid ""
"cols is not a character vector. Please see further information in ?setorder."
msgstr ""
"cols n'est pas un vecteur de chaînes de caractères. Voir les informations "
"supplémentaires dans ?setorder."

#: setkey.R:262
#, c-format
msgid ""
"cols is a character vector of zero length. Use NULL instead, or wrap with "
"suppressWarnings() to avoid this warning."
msgstr ""
"cols est un vecteur de caractères de longueur nulle. Utilisez NULL à la "
"place, ou utilisez suppressWarnings() pour éviter cet avertissement."

#: setkey.R:273
#, c-format
msgid "Column '%s' is type '%s' which is not supported for ordering currently."
msgstr ""
"La colonne '%s' a pour type '%s' qui n'est pas reconnu actuellement pour le "
"classement."

#: setkey.R:317
#, c-format
msgid ""
"'sorted' is TRUE but element %d is non-atomic, which can't be sorted; try "
"setting sorted = FALSE"
msgstr ""
"'sorted' vaut TRUE mais l'élément %d n'est pas atomique, on ne peut donc pas "
"le trier ; Essayez sorted = FALSE"

#: setkey.R:332
#, c-format
msgid ""
"Cross product of elements provided to CJ() would result in %.0f rows which "
"exceeds .Machine$integer.max == %d"
msgstr ""
"Le produit croisé des éléments fournis à CJ() donnerait %.0f lignes, ce qui "
"dépasse .Machine$integer.max == %d"

#: setops.R:3 setops.R:40
#, c-format
msgid "x and y must both be data.tables"
msgstr "x et y doivent être tous deux des data.tables"

#: setops.R:17
#, c-format
msgid ""
"When x's column ('%s') is character, the corresponding column in y ('%s') "
"should be factor or character, but found incompatible type '%s'."
msgstr ""
"Lorsqu’une colonne de x ('%s') est de type caractère, la colonne "
"correspondante de y ('%s') doit être de type facteur ou caractère, mais le "
"type actuel '%s' n'est pas compatible."

#: setops.R:19
#, c-format
msgid ""
"When x's column ('%s') is factor, the corresponding column in y ('%s') "
"should be character or factor, but found incompatible type '%s'."
msgstr ""
"Lorsque la colonne de x ('%s') est un facteur, la colonne correspondante "
"dans y ('%s') doit aussi être de type caractère ou facteur, mais un type "
"incompatible '%s' est rencontré."

#: setops.R:21
#, c-format
msgid ""
"When x's column ('%s') is integer or numeric, the corresponding column in y "
"('%s') can not be character or logical types, but found incompatible type "
"'%s'."
msgstr ""
"Lorsque la colonne de x ('%s') est entière ou numérique, la colonne "
"correspondante dans y ('%s') ne peut pas être de type caractère ou booléen, "
"mais le type incompatible '%s' est rencontré."

#: setops.R:39
#, c-format
msgid "argument 'all' should be logical of length one"
msgstr "l'argument 'all' doit être un booléen de longueur unitaire"

#: setops.R:41
#, c-format
msgid "x and y must have the same column names"
msgstr "x et y doivent avoir les mêmes noms de colonnes"

#: setops.R:42
#, c-format
msgid "x and y must have the same column order"
msgstr "x et y doivent avoir les colonnes dans le même ordre"

#: setops.R:55
#, c-format
msgid "Item %d of x is '%s' but the corresponding item of y is '%s'."
msgstr "L'élément %d de x est '%s' mais l'élément correspondant de y est '%s'."

#: setops.R:57
#, c-format
msgid "None of the datasets should contain a column named '.seqn'"
msgstr "Aucun jeu de données ne doit contenir de colonne nommée '.seqn'"

#: setops.R:162
msgid "Datasets have different keys"
msgstr "Les jeux de données ont des clés différentes"

#: setops.R:163 setops.R:164
msgid "has no key"
msgstr "n’a pas de clé"

#: setops.R:173
msgid "Datasets have different indices"
msgstr "Les jeux de données ont des indices différents"

#: setops.R:174 setops.R:175
msgid "has no index"
msgstr "n’a pas d’index"

#: setops.R:192
#, c-format
msgid "None of the datasets to compare should contain a column named '.seqn'"
msgstr ""
"Aucun des jeux de données à comparer ne doit contenir de colonne nommée '."
"seqn'"

#: setops.R:195
#, c-format
msgid ""
"Datasets to compare with 'ignore.row.order' must not have unsupported column "
"types: %s"
msgstr ""
"Les jeux de données à comparer avec 'ignore.row.order' ne doivent pas avoir "
"de types de colonnes non supportés : %s"

#: setops.R:197
#, c-format
msgid ""
"Argument 'tolerance' was forced to lowest accepted value `sqrt(.Machine"
"$double.eps)` from provided %s"
msgstr ""
"L'argument 'tolerance' a été forcé à la plus petite valeur acceptable `sqrt(."
"Machine$double.eps)` de %s fourni"

#: setops.R:210
#, c-format
msgid ""
"Duplicate rows in datasets, numeric columns and ignore.row.order cannot be "
"used with non 0 tolerance argument"
msgstr ""
"Les doublons dans les lignes des jeux de données, les colonnes numériques et "
"ignore.row.order ne peuvent pas être utilisés avec un argument de tolérance "
"différent de 0"

#: setops.R:224
#, c-format
msgid ""
"Factor columns and ignore.row.order cannot be used with non 0 tolerance "
"argument"
msgstr ""
"Les colonnes de type facteur et ignore.row.order ne peuvent pas être "
"utilisés avec un argument de tolérance différent de 0"

#: shift.R:3
#, c-format
msgid "Provided argument fill=%s will be ignored since type='cyclic'."
msgstr "L'argument fourni fill=%s sera ignoré puisque le type='cyclique'."

#: tables.R:31
msgid "No objects of class data.table exist in %s"
msgstr "Il n'y a pas d'objet de classe data.table dans %s"

#: tables.R:46
#, c-format
msgid "order.col='%s' not a column name of info"
msgstr "order.col='%s' n'est pas un nom de colonne de info"

#: tables.R:59
msgid "Total: %sMB using %s"
msgstr "Total : %sMo en utilisant %s"

#: test.data.table.R:23
#, c-format
msgid "data.table package is loaded. Unload or start a fresh R session."
msgstr ""
"le package data.table est chargé. Déchargez-le ou redémarrez une nouvelle "
"session R."

#: test.data.table.R:39
#, c-format
msgid ""
"script must end with '.Rraw'. If a file ending '.Rraw.bz2' exists, that will "
"be found and used."
msgstr ""
"le script doit se terminer par '.Rraw'. Si un fichier se terminant par '."
"Rraw.bz2' existe, il sera trouvé et utilisé."

#: test.data.table.R:69
#, c-format
msgid "Neither %s nor %s exist in %s"
msgstr "Ni %s, ni %s n’est trouvé dans %s"

#: test.data.table.R:121
msgid "test.data.table() running: %s"
msgstr "test.data.table() est en cours : %s"

#: test.data.table.R:125
msgid "object '%s' not found"
msgstr "objet '%s' introuvable"

#: test.data.table.R:128
msgid ""
"**** This R session's language is not English. Each test will still check "
"that the correct number of errors and/or\n"
"**** warnings are produced. However, to test the text of each error/warning "
"too, please restart R with LANGUAGE=en"
msgstr ""
"**** La langue de cette session R n'est pas l'anglais. Chaque test va encore "
"vérifier que le nombre correct d'erreurs et (ou\n"
"**** d'avertissements) est produit. Néanmoins, pour tester le texte de "
"chaque erreur (ou avertissement) veuillez redémarrer R avec LANGUAGE=en"

#: test.data.table.R:148
msgid ""
"***\n"
"*** memtest=%d. This should be the first call in a fresh R_GC_MEM_GROW=0 R "
"session for best results. Ctrl-C now if not.\n"
"***"
msgstr ""
"***\n"
"*** memtest=%d. Ceci doit être le premier appel dans une nouvelle "
"R_GC_MEM_GROW=0 session R pour de meilleurs résultats. Faire Ctrl-C "
"mainenant si ce n'est pas le cas.\n"
"***"

#: test.data.table.R:149
#, c-format
msgid ""
"memtest intended for Linux. Step through data.table:::rss() to see what went "
"wrong."
msgstr ""
"memtest est prévu pour Linux. Investiguer à l'aide de data.table:::rss() "
"pour localiser le problème."

#: test.data.table.R:203
#, c-format
msgid "Attempt to subset to %d tests matching '%s' failed, running full suite."
msgstr ""
"La tentative de création d’un sous-ensemble de %d tests correspondant à '%s' "
"a échoué, la suite complète est en cours d'exécution."

#: test.data.table.R:208
msgid "Running %d of %d tests matching '%s'"
msgstr "Exécution de %d sur %d tests correspondant à '%s'"

#: test.data.table.R:278
#, c-format
msgid "Failed in %s after test %s before the next test() call in %s"
msgstr "Echec dans %s après le test %s avant l'appel suivant de test() dans %s"

#: test.data.table.R:306
#, c-format
msgid ""
"Tests succeeded, but non-test code caused warnings. Search %s for tests "
"shown above."
msgstr ""
"Tests réussis mais du code non testé a émis des avertissements. Rechercher "
"%s dans les tests affichés ci-dessus."

#: test.data.table.R:316
#, c-format
msgid "Timings count mismatch: %d vs %d"
msgstr "Différence dans les délais enregistrés : %d versus %d"

#: test.data.table.R:318
msgid "10 longest running tests took %ds (%d%% of %ds)"
msgstr ""
"Les 10 tests qui s'exécutent le plus longtemps ont pris %ds (%d%% de %ds)"

#: test.data.table.R:324
msgid "10 largest RAM increases (MiB); see plot for cumulative effect (if any)"
msgstr ""
"Les 10 plus grandes augmentations de RAM (Mio); voir le graphique pour "
"l'effet cumulatif (s'il existe)"

#: test.data.table.R:334
msgid "All %d tests (last %.8g) in %s completed ok in %s"
msgstr "Tous les %d tests (derniers %.8g) de %s ont réussi dans %s"

#: test.data.table.R:430
msgid "Running test id %s"
msgstr "Exécution du test id %s"

#: test.data.table.R:448
#, c-format
msgid ""
"Test %s is invalid: when error= is provided it does not make sense to pass y "
"as well"
msgstr ""
"Le test %s n 'est pas valide : Si error= est fourni alors il n'a pas de sens "
"dans ce cas"

#: test.data.table.R:493
msgid "Test id %s is not in increasing order"
msgstr "Test id %s n'est pas dans l'ordre croissant"

#: test.data.table.R:510
msgid ""
"Test %s produced %d %ss but expected %d\n"
"%s\n"
"%s"
msgstr ""
"Test %s a produit %d %ss alors que l'on en attendait %d\n"
"%s\n"
"%s"

#: test.data.table.R:518
msgid ""
"Test %s didn't produce the correct %s:\n"
"Expected: %s\n"
"Observed: %s"
msgstr ""
"Test %s n'a pas fourni le %s correct :\n"
"Attendu : %s\n"
"Observé : %s"

#: test.data.table.R:527
msgid "Output captured before unexpected warning/error/message:"
msgstr ""
"Sortie juste avant l'avertissement, l'erreur ou le message non attendu :"

#: test.data.table.R:538
msgid "Test %s did not produce correct output:"
msgstr "Test %s n'a pas généré la sortie correcte :"

#: test.data.table.R:539
msgid "Expected: <<%s>>"
msgstr "Attendu : <<%s>>"

#: test.data.table.R:540 test.data.table.R:552
msgid "Observed: <<%s>>"
msgstr "Observé : <<%s>>"

#: test.data.table.R:542
msgid "Expected (raw): <<%s>>"
msgstr "Attendu (brut) : <<%s>>"

#: test.data.table.R:543 test.data.table.R:555
msgid "Observed (raw): <<%s>>"
msgstr "Observé (brut) : <<%s>>"

#: test.data.table.R:550
msgid "Test %s produced output but should not have:"
msgstr "Test %s a généré des sorties alors qu'il n'aurait pas dû :"

#: test.data.table.R:551
msgid "Expected absent (case insensitive): <<%s>>"
msgstr "Attendu et absent (non sensible à la casse) : <<%s>>"

#: test.data.table.R:554
msgid "Expected absent (raw): <<%s>>"
msgstr "Attendu et absent (brut) : <<%s>>"

#: test.data.table.R:570
msgid "Test %s ran without errors but selfrefok(%s) is FALSE"
msgstr "Test %s exécuté sans erreur mais selfrefok(%s) vaut FALSE"

#: test.data.table.R:595
msgid "Test %s ran without errors but failed check that x equals y:"
msgstr "Test %s exécuté sans erreur mais avec échec du contrôle x égale y :"

#: test.data.table.R:600
msgid "First %d of %d (type '%s'):"
msgstr "Premier %d sur %d (type '%s') :"

#: test.data.table.R:605
msgid "Non-ASCII string detected, raw representation:"
msgstr "Chaîne de caractères non ASCII détectée, représentation brute :"

#: timetaken.R:3
#, c-format
msgid "Use started.at=proc.time() not Sys.time() (POSIXt and slow)"
msgstr ""
"Utiliser started.at=proc.time() et non pas Sys.time() (POSIXt et plus lent)"

#: transpose.R:7
#, c-format
msgid "make.names='%s' not found in names of input"
msgstr "make.names='%s' non trouvé parmi les noms d'entrée"

#: transpose.R:12
#, c-format
msgid "make.names=%d is out of range [1,ncol=%d]"
msgstr "make.names=%d hors limites [1,ncol=%d]"

#: transpose.R:28
#, c-format
msgid "'names' must be TRUE/FALSE or a character vector."
msgstr ""
"'names' doit être TRUE ou FALSE ou un vecteur de chaînes de caractères."

#: transpose.R:34
#, c-format
msgid "'keep' should contain integer values between %d and %d."
msgstr "'keep' doit contenir des valeurs entières entre %d et %d."

#: transpose.R:51
#, c-format
msgid "The argument 'type.convert' does not support empty list."
msgstr "L'argument 'type.convert' n'accepte pas de liste vide."

#: transpose.R:57
#, c-format
msgid ""
"When the argument 'type.convert' contains an unnamed element, it is expected "
"to be the last element and should be a function. More than one unnamed "
"element is not allowed unless all elements are functions with length equal "
"to %d (the length of the transpose list or 'keep' argument if it is "
"specified)."
msgstr ""
"Lorsque l'argument 'type.convert' contient un élément non nommé, il est "
"censé être le dernier élément et doit être une fonction. Plus d'un élément "
"non nommé n'est pas autorisé, sauf si tous les éléments sont des fonctions "
"de longueur égale à %d (la longueur de la liste de transpositions ou de "
"l'argument 'keep' s'il est spécifié)."

#: transpose.R:66
#, c-format
msgid ""
"When the argument 'type.convert' contains transpose list indices, it should "
"be a named list of non-missing integer values (with no duplicate) except the "
"last element that should be unnamed if it is a function."
msgstr ""
"Lorsque l'argument 'type.convert' contient des indices de liste de "
"transposition, il doit être une liste nommée de valeurs entières sans valeur "
"manquante (et sans doublons), à l'exception du dernier élément qui ne doit "
"pas être nommé s'il s'agit d'une fonction."

#: transpose.R:68
#, c-format
msgid ""
"When the argument 'type.convert' contains transpose list indices, they "
"should be integer values contained in the argument 'keep' (if it is "
"specified) or be between %d and %d (if it is not). But '%s' is/are not "
"contained in '%s'."
msgstr ""
"Lorsque l'argument 'type.convert' contient des indices de liste de "
"transposition, ceux-ci doivent être des valeurs entières contenues dans "
"l'argument 'keep' (s'il est spécifié) ou comprises entre %d et %d (s'il ne "
"l'est pas). Mais '%s' n’est/ne sont pas contenu(e)s dans '%s'."

#: transpose.R:74
#, c-format
msgid ""
"In the argument 'type.convert', '%s' was ignored because all elements in the "
"transpose list or elements corresponding to indices specified in the 'keep' "
"argument have already been converted."
msgstr ""
"Dans l'argument 'type.convert', '%s' a été ignoré parce que tous les "
"éléments de la liste de transposition ou les éléments correspondant aux "
"indices spécifiés dans l'argument 'keep' ont déjà été convertis."

#: transpose.R:83
#, c-format
msgid ""
"The argument 'type.convert' should be TRUE/FALSE, a function, a list of "
"functions, or a named list of pairs 'fun=indices' with optionally one "
"unnamed element (a function) but an object of type '%s' was provided."
msgstr ""
"L'argument 'type.convert' doit être TRUE/FALSE, une fonction, une liste de "
"fonctions ou une liste nommée de paires 'fun=indices' avec éventuellement un "
"élément non nommé (une fonction), mais un objet de type '%s' a été fourni."

#: transpose.R:88
#, c-format
msgid "length(names) (= %d) is not equal to length(%s) (= %d)."
msgstr "length(names) (= %d) est différent de length(%s) (= %d)."

#: uniqlist.R:11
#, c-format
msgid "l not type list"
msgstr "l n'est pas de type 'list'"

#: utils.R:19
#, c-format
msgid "Argument 'nan' must be length 1"
msgstr "L'argument 'nan' doit être de longueur 1"

#: utils.R:22
#, c-format
msgid "Argument 'nan' must be NA or NaN"
msgstr "L'argument 'nan' doit être NA ou NaN"

#: utils.R:32
msgid "Internal error in"
msgstr "Erreur interne dans"

#: utils.R:35
msgid "Please report to the data.table issues tracker."
msgstr ""
"Veuillez signaler l'erreur au gestionnaire de tickets (issue tracker) de "
"data.table."

#: utils.R:79 utils.R:88
#, c-format
msgid "x not boolean"
msgstr "x n'est pas un booléen"

#: utils.R:99
#, c-format
msgid ""
"Some columns are type 'integer64' but package bit64 is not installed. Those "
"columns will print as strange looking floating point data. There is no need "
"to reload the data. Simply install.packages('bit64') to obtain the integer64 "
"print method and print the data again."
msgstr ""
"Certaines colonnes sont de type 'integer64' mais le package bit64 n'est pas "
"installé. Ces colonnes s'afficheront sous la forme de données en virgule "
"flottante à l'aspect étrange. Il n'est pas nécessaire de recharger les "
"données. Il suffit d'installer.packages('bit64') pour obtenir la méthode "
"d'impression integer64 et imprimer à nouveau les données."

#: xts.R:4
#, c-format
msgid "keep.rownames must be length 1"
msgstr "keep.rownames doit être de longueur 1"

#: xts.R:5
#, c-format
msgid "keep.rownames must not be NA"
msgstr "keep.rownames ne peut pas être NA"

#: xts.R:11
#, c-format
msgid ""
"Input xts object should not have '%s' column because it would result in "
"duplicate column names. Rename '%s' column in xts or use `keep.rownames` to "
"change the index column name."
msgstr ""
"L'objet xts d'entrée ne doit pas avoir de colonne '%s' car cela entraînerait "
"une duplication des noms de colonnes. Renommez la colonne '%s' dans l'objet "
"xts ou utilisez `keep.rownames` pour changer le nom de la colonne d'index."

#: xts.R:21
#, c-format
msgid ""
"data.table must have a time based column in first position, use "
"`setcolorder` function to change the order, or see ?timeBased for supported "
"types"
msgstr ""
"data.table doit avoir une colonne basée sur le temps en première position, "
"utiliser la fonction `setcolorder` pour changer l'ordre, ou voir ?timeBased "
"pour les types pris en charge"

#: xts.R:25
#, c-format
msgid "Following columns are not numeric and will be omitted: %s"
msgstr "Les colonnes suivantes ne sont pas numériques et seront omises : %s"

#: bmerge.R:219
msgid "  Found %d non-equi group ...\n"
msgid_plural "  Found %d non-equi groups ...\n"
msgstr[0] "  %d groupe non-equi trouvé ...\n"
msgstr[1] "    %d groupes non-equi trouvés ...\n"

#: data.table.R:745
msgid "column not removed because not found: %s"
msgid_plural "columns not removed because not found: %s"
msgstr[0] "colonne non supprimée car absente : %s"
msgstr[1] "colonnes non supprimées car absentes : %s"

#: data.table.R:760
msgid "column not found: %s"
msgid_plural "columns not found: %s"
msgstr[0] "colonne absente : %s"
msgstr[1] "colonnes absentes : %s"

#: data.table.R:928
msgid ""
"The item in the 'by' or 'keyby' list is length %s. Each must be length %d; "
"the same length as there are rows in x (after subsetting if i is provided)."
msgid_plural ""
"The items in the 'by' or 'keyby' list have lengths %s. Each must be length "
"%d; the same length as there are rows in x (after subsetting if i is "
"provided)."
msgstr[0] ""
"L'élément de la liste ‘by’ ou ‘keyby’ a pour longueur %s. Il doit être de "
"longueur %d ; la même longueur que celle des lignes de x (après le sous-"
"ensemble si i est fourni)."
msgstr[1] ""
"Les éléments de la liste ‘by’ ou ‘keyby’ sont de longueur %s. Chacun d'entre "
"eux doit être de longueur %d ; la même longueur que celle des lignes de x "
"(après le sous-ensemble si i est fourni)."

#: fmelt.R:27
msgid "Pattern not found: [%s]"
msgid_plural "Patterns not found: [%s]"
msgstr[0] "Motif non trouvé : [%s]"
msgstr[1] "Motifs non trouvés : [%s]"

#: fread.R:354
msgid "stringsAsFactors=%s converted %d column: %s\n"
msgid_plural "stringsAsFactors=%s converted %d columns: %s\n"
msgstr[0] "stringsAsFactors=%s a converti %d colonne : %s\n"
msgstr[1] "stringsAsFactors=%s a converti %d colonnes : %s\n"

#: merge.R:131
msgid ""
"merge.data.table() received %d unnamed argument in '...' which will be "
"ignored."
msgid_plural ""
"merge.data.table() received %d unnamed arguments in '...' which will be "
"ignored."
msgstr[0] ""
"merge.data.table() a reçu %d argument non nommé dans '...' qui sera ignoré."
msgstr[1] ""
"merge.data.table() a reçu %d arguments non nommés dans '...' qui seront "
"ignorés."

#: merge.R:138
msgid ""
"merge.data.table() received %d unknown keyword argument which will be "
"ignored: %s"
msgid_plural ""
"merge.data.table() received %d unknown keyword arguments which will be "
"ignored: %s"
msgstr[0] ""
"merge.data.table() a reçu %d mot-clé d'argument non reconnu qui sera "
"ignoré : %s"
msgstr[1] ""
"merge.data.table() a reçu %d mots-clés d'arguments non reconnus qui seront "
"ignorés : %s"

#: merge.R:144
msgid "%d unnamed argument in '...'"
msgid_plural "%d unnamed arguments in '...'"
msgstr[0] "%d argument non nommé dans '...'"
msgstr[1] "%d arguments non nommés dans '...'"

#: merge.R:145
msgid "%d unknown keyword argument"
msgid_plural "%d unknown keyword arguments"
msgstr[0] "%d argument clé fourni est inconnu"
msgstr[1] "%d arguments clé fournis sont inconnus"

#: print.data.table.R:51
msgid "Index: %s\n"
msgid_plural "Indices: %s\n"
msgstr[0] "Indice : %s\n"
msgstr[1] "Indices : %s\n"

#: print.data.table.R:290
msgid "%d variable not shown: %s\n"
msgid_plural "%d variables not shown: %s\n"
msgstr[0] "%d variable non affichée : %s\n"
msgstr[1] "%d variables non affichées : %s\n"

#: setops.R:46
msgid "unsupported column type found in x or y: %s"
msgid_plural "unsupported column types found in x or y: %s"
msgstr[0] "type de colonne non supporté trouvé dans x ou y : %s"
msgstr[1] "types de colonnes non supportés trouvés dans x ou y : %s"

#: test.data.table.R:288
msgid "%d error out of %d. Search %s for test number %s. Duration: %s."
msgid_plural ""
"%d errors out of %d. Search %s for test numbers %s. Duration: %s."
msgstr[0] ""
"%d erreur sur %d. Recherche de %s pour le test numéro %s. Durée : %s."
msgstr[1] ""
"%d erreurs sur %d. Recherche de %s pour les tests numéros %s. Durée : %s."

#: test.data.table.R:298
msgid "Caught %d warning outside the test() calls:\n"
msgid_plural "Caught %d warnings outside the test() calls:\n"
msgstr[0] "%d avertissement détecté en dehors des appels à test() :\n"
msgstr[1] "%d avertissements détectés en dehors des appels à test() :\n"

#: utils.R:43
msgid ""
"%s has duplicated column name %s. Please remove or rename the duplicate and "
"try again."
msgid_plural ""
"%s has duplicated column names %s. Please remove or rename the duplicates "
"and try again."
msgstr[0] ""
"%s comporte plusieurs fois la colonne : %s. Veuillez supprimer le doublon ou "
"le renommer et recommencer."
msgstr[1] ""
"%s comporte des noms de colonnes dupliqués : %s. Veuillez supprimer les "
"doublons ou les renommer et recommencer."
