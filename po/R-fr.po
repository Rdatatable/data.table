msgid ""
msgstr ""
"Project-Id-Version: data.table 1.16.99\n"
"POT-Creation-Date: 2024-08-28 21:08+0000\n"
"PO-Revision-Date: 2024-09-04 13:53+0200\n"
"Last-Translator: Christian Wiat <w9204-rs@yahoo.com>\n"
"Language-Team: \n"
"Language: fr\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=2; plural=(n > 1);\n"
"X-Generator: Poedit 3.5\n"

#: AllS4.R:2
#, c-format
msgid "data.table package loaded. When developing don't load package"
msgstr ""
"package data.table chargé. En cours de développement, ne pas charger le package"

#: IDateTime.R:107
#, c-format
msgid "binary + is not defined for \"IDate\" objects"
msgstr "l'opérateur binaire + n'est pas défini pour les objets \"IDate\""

#: IDateTime.R:114
#, c-format
msgid "can only subtract from \"IDate\" objects"
msgstr "seule la soustraction est autorisée sur les objets \"IDate\""

#: IDateTime.R:119
#, c-format
msgid "unary - is not defined for \"IDate\" objects"
msgstr "l'opérateur unaire - n'est pas défini sur les objets \"IDate\""

#: IDateTime.R:309
#, c-format
msgid "Valid options for ms are 'truncate', 'nearest', and 'ceil'."
msgstr "Les options valides pour ms sont 'truncate', 'nearest', et 'ceil'."

#: as.data.table.R:86
#, c-format
msgid ""
"as.data.table.array method should only be called for arrays with 3+ "
"dimensions; use the matrix method for 2-dimensional arrays"
msgstr ""
"la méthode as.data.table.array ne doit être appelée que pour les tableaux de "
"dimension 3+ ; Utiliser la méthode matrix pour les tableaux de dimension 2"

#: as.data.table.R:88
#, c-format
msgid ""
"Argument 'value.name' must be scalar character, non-NA and at least one "
"character"
msgstr ""
"L'argument 'value.name' doit être un caractère scalaire, pas NA et d'au moins "
"un caractère"

#: as.data.table.R:90
#, c-format
msgid "Argument 'sorted' must be scalar logical and non-NA"
msgstr "L'argument 'sorted' doit être un scalaire, un booléen et différent de NA"

#: as.data.table.R:92
#, c-format
msgid "Argument 'na.rm' must be scalar logical and non-NA"
msgstr "L'argument 'na.rm' doit être un scalaire, un booléen et différent de NA"

#: as.data.table.R:94
#, c-format
msgid "Please provide either 'key' or 'sorted', but not both."
msgstr "Utiliser 'key' ou 'sorted' mais pas les deux simultanément."

#: as.data.table.R:108
#, c-format
msgid "Argument 'value.name' should not overlap with column names in result: %s"
msgstr ""
"L'argument 'value.name' ne doit pas recouvrir le nom des colonnes dans le "
"résultat : %s"

#: as.data.table.R:140
#, c-format
msgid ""
"POSIXlt column type detected and converted to POSIXct. We do not recommend use "
"of POSIXlt at all because it uses 40 bytes to store one date."
msgstr ""
"Le type de colonne POSIXlt a été détecté et converti en POSIXct. Nous ne "
"recommandons pas l'utilisation de POSIXlt car il utilise 40 octets pour "
"stocker une date."

#: as.data.table.R:181
#, c-format
msgid "Item %d has %d rows but longest item has %d; recycled with remainder."
msgstr ""
"L'élément %d a %d lignes mais l'élément le plus long en a %d ; Il est recyclé "
"avec le reste."

#: as.data.table.R:196
#, c-format
msgid "A column may not be called .SD. That has special meaning."
msgstr ""
"Une colonne ne peut pas s'appeler .SD. Ceci a une signification particulière."

#: as.data.table.R:210
#, c-format
msgid "class must be length 1"
msgstr "la classe doit être de longueur 1"

#: between.R:3
#, c-format
msgid "between has been passed an argument x of type logical"
msgstr "'between' contient un argument x booléen"

#: between.R:13 between.R:15
#, c-format
msgid ""
"'between' function the 'x' argument is a POSIX class while '%s' was not, "
"coercion to POSIX failed with: %s"
msgstr ""
"fonction 'between' l'argument 'x' est une classe POSIX alors que '%s' ne l'est "
"pas, échec de la conversion automatique en POSIX avec : %s"

#: between.R:27
#, c-format
msgid ""
"'between' lower= and upper= are both POSIXct but have different tzone "
"attributes: %s. Please align their time zones."
msgstr ""
"'between' lower= et upper= sont tous deux traduits en POSIXct mais leurs "
"attributs ‘tzone’ sont différents : %s. Veuillez aligner leur fuseau horaire."

#: between.R:31
#, c-format
msgid ""
"'between' arguments are all POSIXct but have mismatched tzone attributes: %s. "
"The UTC times will be compared."
msgstr ""
"les arguments 'between' sont tous POSIXct mais les attributs tzone associés ne "
"correspondent pas : %s. La comparaison se fera sur le temps UTC."

#: between.R:36
#, c-format
msgid "trying to use integer64 class when 'bit64' package is not installed"
msgstr ""
"utilisation de la classe integer64 alors que le package 'bit64' n'est pas "
"installé"

#: between.R:48
#, c-format
msgid ""
"Not yet implemented NAbounds=TRUE for this non-numeric and non-character type"
msgstr ""
"NAbounds=TRUE n'est pas encore implémenté pour ce type non numérique et non "
"caractère"

#: between.R:49
#, c-format
msgid "Some lower>upper for this non-numeric and non-character type"
msgstr ""
"Certains inférieurs sont plus grands que les supérieurs (lower>upper) pour ce "
"type non numérique et non caractère"

#: between.R:63
#, c-format
msgid "Perhaps you meant %s?"
msgstr "Peut-être vouliez-vous dire %s ?"

#: between.R:64
#, c-format
msgid ""
"RHS has length() %d; expecting length 2. %sThe first element should be the "
"lower bound(s); the second element should be the upper bound(s)."
msgstr ""
"Le membre de droite a pour longueur %d au lieu de 2 attendu. %s Le premier "
"élément représente la ou les borne(s) inférieure(s) ; Le second élément "
"représente la ou les borne(s) supérieure(s)."

#: bmerge.R:48 bmerge.R:49
#, c-format
msgid "%s is type %s which is not supported by data.table join"
msgstr ""
"%s est de type %s qui n'est pas pris en charge pour une jointure data.table"

#: bmerge.R:52
#, c-format
msgid ""
"Attempting roll join on factor column when joining %s to %s. Only integer, "
"double or character columns may be roll joined."
msgstr ""
"Tentative de jointure par roulement sur une colonne de facteurs lors de la "
"jointure de %s à %s. Seules les colonnes de nombres entiers, de nombres "
"doubles ou de caractères peuvent être jointes par roulement."

#: bmerge.R:71
#, c-format
msgid ""
"Incompatible join types: %s (%s) and %s (%s). Factor columns must join to "
"factor or character columns."
msgstr ""
"Types de jointures incompatibles : %s (%s) et %s (%s). Les colonnes de "
"facteurs doivent être jointes à des colonnes de facteurs ou de caractères."

#: bmerge.R:90
#, c-format
msgid "Incompatible join types: %s (%s) and %s (%s)"
msgstr "Types incompatibles pour la jointure : %s (%s) et %s (%s)"

#: bmerge.R:98
#, c-format
msgid ""
"Incompatible join types: %s is type integer64 but %s is type double and "
"contains fractions"
msgstr ""
"Types de jointures incompatibles : %s est de type integer64 mais %s est de "
"type double et contient des fractions"

#: bmerge.R:150
#, c-format
msgid "roll is not implemented for non-equi joins yet."
msgstr "roll n'est pas encore implémenté avec des jointure non-equi."

#: bmerge.R:170
#, c-format
msgid "Column name '_nqgrp_' is reserved for non-equi joins."
msgstr "Le nom de colonne '_nqgrp_' est réservé pour les jointures non-equi."

#: data.table.R:55
#, c-format
msgid "key argument of data.table() must be character"
msgstr "l'argument key de data.table() doit être une chaîne de caractères"

#: data.table.R:121
#, c-format
msgid "Object '%s' not found. Perhaps you intended %s"
msgstr "Objet '%s' non trouvé. Peut-être vous vouliez dire %s"

#: data.table.R:123
#, c-format
msgid "Object '%s' not found amongst %s"
msgstr "Objet '%s' non trouvé parmi %s"

#: data.table.R:139
#, c-format
msgid ""
"[ was called on a data.table in an environment that is not data.table-aware (i."
"e. cedta()), but '%s' was used, implying the owner of this call really "
"intended for data.table methods to be called. See vignette('datatable-"
"importing') for details on properly importing data.table."
msgstr ""
"[ a été appelé sur un data.table dans un environnement qui n'est pas "
"compatible avec data.table (i.e. cedta()), mais '%s' a été utilisé, ce qui "
"implique que le propriétaire de cet appel avait vraiment l'intention d'appeler "
"des méthodes data.table. Voir la vignette('datatable-importing') pour plus de "
"détails sur l’importation correcte de data.table."

#: data.table.R:150
#, c-format
msgid "verbose must be logical or integer"
msgstr "verbose doit être soit un booléen, soit un entier"

#: data.table.R:151
#, c-format
msgid "verbose must be length 1 non-NA"
msgstr "verbose doit être de longueur 1 et différent de NA"

#: data.table.R:159
#, c-format
msgid "Ignoring by/keyby because 'j' is not supplied"
msgstr "L'argument by ou keyby est ignoré car 'j' n'est pas fourni"

#: data.table.R:173
#, c-format
msgid "When by and keyby are both provided, keyby must be TRUE or FALSE"
msgstr "Si by et keyby sont fournis simultanément, keyby doit être TRUE ou FALSE"

#: data.table.R:185
#, c-format
msgid ""
"When on= is provided but not i=, on= must be a named list or data.table|frame, "
"and a natural join (i.e. join on common names) is invoked. Ignoring on= which "
"is '%s'."
msgstr ""
"Lorsque on= est fourni mais pas i=, on= doit être une liste nommée ou un data."
"table|frame, et une jointure naturelle (c'est-à-dire une jointure sur les noms "
"communs) est invoquée. La valeur de on= qui est '%s' est ignorée."

#: data.table.R:198
#, c-format
msgid ""
"i and j are both missing so ignoring the other arguments. This warning will be "
"upgraded to error in future."
msgstr ""
"i et j sont tous les deux absents, donc les autres arguments sont ignorés. Cet "
"avertissement deviendra une erreur à l'avenir."

#: data.table.R:202
#, c-format
msgid "mult argument can only be 'first', 'last' or 'all'"
msgstr "l'argument mult ne peut valoir que 'first', 'last' ou 'all'"

#: data.table.R:204
#, c-format
msgid ""
"roll must be a single TRUE, FALSE, positive/negative integer/double including "
"+Inf and -Inf or 'nearest'"
msgstr ""
"roll doit être une seule valeur TRUE, FALSE, un entier ou un double, positif "
"ou négatif, +Inf, -Inf ou 'nearest' compris"

#: data.table.R:206
#, c-format
msgid "roll is '%s' (type character). Only valid character value is 'nearest'."
msgstr ""
"roll vaut '%s' (de type caractère). La seule chaîne valide est 'nearest'."

#: data.table.R:211
#, c-format
msgid "rollends must be a logical vector"
msgstr "rollends doit être un vecteur de booléens"

#: data.table.R:212
#, c-format
msgid "rollends must be length 1 or 2"
msgstr "rollends doit être de longueur 1 ou 2"

#: data.table.R:220
#, c-format
msgid ""
"nomatch= must be either NA or NULL (or 0 for backwards compatibility which is "
"the same as NULL but please use NULL)"
msgstr ""
"nomatch= doit valoir soit NA, soit NULL (ou 0 pour la compatibilité "
"descendante qui équivaut à NULL, mais utiliser NULL dorénavant)"

#: data.table.R:223
#, c-format
msgid "which= must be a logical vector length 1. Either FALSE, TRUE or NA."
msgstr ""
"which= doit être un vecteur de booléens de longueur 1. Valeur FALSE, TRUE ou "
"NA."

#: data.table.R:224
#, c-format
msgid ""
"which==%s (meaning return row numbers) but j is also supplied. Either you need "
"row numbers or the result of j, but only one type of result can be returned."
msgstr ""
"which==%s (renvoie des numéros de ligne) mais j est également fourni. Vous "
"avez besoin soit des numéros de ligne, soit du résultat de j, mais un seul "
"type de résultat peut être renvoyé."

#: data.table.R:225
#, c-format
msgid ""
"which=NA with nomatch=0|NULL would always return an empty vector. Please "
"change or remove either which or nomatch."
msgstr ""
"which=NA avec nomatch=0|NULL renverrait toujours un vecteur vide. Veuillez "
"modifier ou supprimer soit which, soit nomatch."

#: data.table.R:226
#, c-format
msgid "j must be provided when with=FALSE"
msgstr "j doit être fourni quand with=FALSE"

#: data.table.R:227
#, c-format
msgid "%s must be TRUE or FALSE"
msgstr "%s doit être TRUE ou FALSE"

#: data.table.R:267
#, c-format
msgid ""
"The symbol .. is invalid. The .. prefix must be followed by at least one "
"character."
msgstr ""
"Le symbole .. n'est pas valide. Le préfixe .. doit être suivi d'au moins un "
"caractère."

#: data.table.R:270
#, c-format
msgid ""
"Variable '..%s' does exist in calling scope though, so please just removed "
"the .. prefix from that variable name in calling scope."
msgstr ""
"La variable '..%s' existe dans la portée de l'appelant, il suffit donc de "
"supprimer le préfixe .. de ce nom de variable dans la portée de l'appelant."

#: data.table.R:274
#, c-format
msgid ""
"Variable '%s' is not found in calling scope. Looking in calling scope because "
"you used the .. prefix.%s"
msgstr ""
"La variable '%s' n'est pas visible dans le contexte de l'appelant désigné par "
"le préfixe .. .%s"

#: data.table.R:276
#, c-format
msgid ""
"Both '%1$s' and '..%1$s' exist in calling scope. Please remove the '..%1$s' "
"variable in calling scope for clarity."
msgstr ""
"'%1$s' et '..%1$s' sont tous deux visibles dans le contexte de l'appelant. "
"Veuillez supprimer la variable '..%1$s' de ce contexte pour clarifier."

#: data.table.R:284
#, c-format
msgid ""
"Variable '%s' is not found in calling scope. Looking in calling scope because "
"you set with=FALSE. Also, please use .. symbol prefix and remove with=FALSE."
msgstr ""
"La variable '%s' n'est pas visible dans le contexte de l'appelant désigné par "
"with=FALSE. Utilisez alors le préfixe de symbole .. et supprimez with=FALSE."

#: data.table.R:292
#, c-format
msgid ""
"You have wrapped := with {} which is ok but then := must be the only thing "
"inside {}. You have something else inside {} as well. Consider placing the {} "
"on the RHS of := instead; e.g. DT[,someCol:={tmpVar1<-...;tmpVar2<-...;"
"tmpVar1*tmpVar2}"
msgstr ""
"L'opérateur := est entouré d’accolades {} ce qui est bien, mais ensuite := "
"doit être le seul élément dans {}. Or il y a autre chose également dans {} . "
"Déplacez plutôt les {} vers le membre droit de := ; par exemple DT[,someCol:"
"={tmpVar1<-...;tmpVar2<-...;tmpVar1*tmpVar2}"

#: data.table.R:310
#, c-format
msgid ""
":= with keyby is only possible when i is not supplied since you can't setkey "
"on a subset of rows. Either change keyby to by or remove i"
msgstr ""
":= avec keyby n'est accepté que si i n'est pas fourni parce que setkey sur un "
"sous-ensemble de lignes n'est pas possible. Modifiez soit keyby en by, ou "
"supprimez i"

#: data.table.R:312
#, c-format
msgid "nomatch isn't relevant together with :=, ignoring nomatch"
msgstr "nomatch n'est pas pertinent avec with :=, nomatch est ignoré"

#: data.table.R:368
#, c-format
msgid ""
"not-join '!' prefix is present on i but nomatch is provided. Please remove "
"nomatch."
msgstr ""
"le préfixe de non-jointure '!' est présent sur i mais nomatch est fourni. "
"Supprimer nomatch."

#: data.table.R:396
#, c-format
msgid ""
"Operator := detected in i, the first argument inside DT[...], but is only "
"valid in the second argument, j. Most often, this happens when forgetting the "
"first comma (e.g. DT[newvar := 5] instead of DT[ , new_var := 5]). Please "
"double-check the syntax. Run traceback(), and debugger() to get a line number."
msgstr ""
"L'opérateur := est présent dans i, le premier argument de DT[...], mais n'est "
"valide que dans le second argument, j. Le plus souvent, cela se produit "
"lorsqu'on oublie la première virgule (par exemple, DT[newvar := 5] au lieu de "
"DT[ , new_var := 5]). Veuillez vérifier la syntaxe. Exécuter traceback(), et "
"debugger() pour obtenir un numéro de ligne."

#: data.table.R:406
#, c-format
msgid "'%s' is not found in calling scope and it is not a column name either"
msgstr ""
"'%s' n'est pas visible dans le contexte de l'appelant et ce n'est pas non plus "
"un nom de colonne"

#: data.table.R:409
#, c-format
msgid ""
"'%s' is not found in calling scope, but it is a column of type %s. If you wish "
"to select rows where that column contains TRUE, or perhaps that column "
"contains row numbers of itself to select, try DT[(col)], DT[DT$col], or "
"DT[col==TRUE} is particularly clear and is optimized"
msgstr ""
"'%s' n'est pas visible dans le contexte de l'appelant, mais c'est une colonne "
"de type %s. Si vous souhaitez sélectionner des lignes pour lesquelles cette "
"colonne vaut TRUE, ou peut-être que cette colonne contient ses propres numéros "
"de lignes à sélectionner, essayez DT[(col)], DT[DT$col], ou DT[col==TRUE] qui "
"est particulièrement clair et optimisé"

#: data.table.R:412
#, c-format
msgid ""
"%s. When the first argument inside DT[...] is a single symbol (e.g. DT[var]), "
"data.table looks for var in calling scope."
msgstr ""
"%s. Lorsque le premier argument de DT[...] est un symbole unique (par exemple "
"DT[var]), data.table cherche var dans le contexte de l'appelant."

#: data.table.R:424
#, c-format
msgid ""
"i is invalid type (matrix). Perhaps in future a 2 column matrix could return a "
"list of elements of DT (in the spirit of A[B] in FAQ 2.14). Please report to "
"data.table issue tracker if you'd like this, or add your comments to FR #657."
msgstr ""
"i a un type non valide (matrice). Peut-être qu'à l'avenir, une matrice à 2 "
"colonnes pourrait renvoyer une liste d'éléments de DT (dans l'esprit de A[B] "
"de la FAQ 2.14). Veuillez rapporter ce problème dans le gestionnaire de "
"tickets (issues tracker) de data.table si vous le souhaitez, ou ajouter vos "
"commentaires à FR #657."

#: data.table.R:447
#, c-format
msgid ""
"When i is a data.table (or character vector), the columns to join by must be "
"specified using 'on=' argument (see ?data.table), by keying x (i.e. sorted, "
"and, marked as sorted, see ?setkey), or by sharing column names between x and "
"i (i.e., a natural join). Keyed joins might have further speed benefits on "
"very large data due to x being sorted in RAM."
msgstr ""
"Lorsque i est une data.table (ou un vecteur de chaînes de caractères), les "
"colonnes à joindre doivent être spécifiées à l'aide de l'argument 'on=' (voir ?"
"data.table), par l'attribution d'une clé à x (c'est-à-dire trié, et, marqué "
"comme trié, voir ?setkey), ou en partageant les noms des colonnes entre x et i "
"(c'est-à-dire, une jointure naturelle). Les jointures avec clé peuvent avoir "
"des avantages supplémentaires en termes de rapidité sur des données très "
"volumineuses, car x est trié en mémoire vive."

#: data.table.R:455
#, c-format
msgid "Attempting to do natural join but no common columns in provided tables"
msgstr ""
"Aucune colonne commune dans les tables fournies pour réaliser la jointure "
"naturelle"

#: data.table.R:587
#, c-format
msgid "logical error. i is not a data.table, but 'on' argument is provided."
msgstr ""
"erreur logique. i n'est pas une data.table, mais l'argument 'on' est fourni."

#: data.table.R:591
#, c-format
msgid "i has evaluated to type %s. Expecting logical, integer or double."
msgstr ""
"i a pour type %s alors qu'un booléen, un entier ou un double est attendu."

#: data.table.R:613
#, c-format
msgid ""
"i evaluates to a logical vector length %d but there are %d rows. Recycling of "
"logical i is no longer allowed as it hides more bugs than is worth the rare "
"convenience. Explicitly use rep(...,length=.N) if you really need to recycle."
msgstr ""
"i représente un vecteur logique de longueur %d mais il y a %d lignes. Le "
"recyclage du vecteur logique i n'est plus autorisé, car il cache plus souvent "
"des bogues qu'il n'en vaut la peine. Utiliser explicitement rep(...,length=.N) "
"si vous avez vraiment besoin de recycler ce vecteur."

#: data.table.R:616
#, c-format
msgid ""
"Please use nomatch=NULL instead of nomatch=0; see news item 5 in v1.12.0 (Jan "
"2019)"
msgstr ""
"Veuillez utiliser nomatch=NULL au lieu de nomatch=0; voir l'élément 5 des news "
"v1.12.0 (janvier 2019)"

#: data.table.R:688
#, c-format
msgid ""
"with=FALSE together with := was deprecated in v1.9.4 released Oct 2014. Please "
"wrap the LHS of := with parentheses; e.g., DT[,(myVar):=sum(b),by=a] to assign "
"to column name(s) held in variable myVar. See ?':=' for other examples. As "
"warned in 2014, this is now a warning."
msgstr ""
"with=FALSE avec := a été déprécié dans la version 1.9.4 publiée en octobre "
"2014. Veuillez entourer le membre gauche de := avec des parenthèses ; Par "
"exemple, DT[,(monVar):=sum(b),by=a] pour affecter le(s) nom(s) de colonne(s) "
"contenu(s) dans la variable myVar. Voir ?':=' pour d'autres exemples. Comme "
"annoncé en 2014, il s'agit maintenant d'un avertissement."

#: data.table.R:691
#, c-format
msgid ""
"with=FALSE ignored, it isn't needed when using :=. See ?':=' for examples."
msgstr ""
"with=FALSE est ignoré quand := est utilisé. Voir ?':=' pour les exemples."

#: data.table.R:715
#, c-format
msgid "column(s) not removed because not found: %s"
msgstr "colonne(s) non supprimée(s) car manquante(s) : %s"

#: data.table.R:729
#, c-format
msgid "column(s) not found: %s"
msgstr "colonnes(s) absente(s) : %s"

#: data.table.R:735
#, c-format
msgid "Item %d of j is %d which is outside the column number range [1,ncol=%d]"
msgstr ""
"L'élément %d de j vaut %d qui n'est pas dans l'intervalle des index de colonne "
"[1,ncol=%d]"

#: data.table.R:738
#, c-format
msgid "j mixes positives and negatives"
msgstr "j mélange les valeurs positives et négatives"

#: data.table.R:746
#, c-format
msgid ""
"When with=FALSE, j-argument should be of type logical/character/integer "
"indicating the columns to select."
msgstr ""
"Lorsque with=FALSE, l’argument j doit être de type boléen/caractère/entier "
"indiquant les colonnes à sélectionner."

#: data.table.R:760
#, c-format
msgid ""
"'by' contains .I but only the following are currently supported: by=.I, by=.(."
"I), by=c(.I), by=list(.I)"
msgstr ""
"'by' contient .I qui n'autorisé que pour : by=.I, by=.(.I), by=c(.I), by=list(."
"I)"

#: data.table.R:784
#, c-format
msgid "by=c(...), key(...) or names(...) must evaluate to 'character'"
msgstr "by=c(...), key(...) ou names(...) doivent être de type 'character'"

#: data.table.R:794
#, c-format
msgid ""
"'by' is a character vector length %d but one or more items include a comma. "
"Either pass a vector of column names (which can contain spaces, but no "
"commas), or pass a vector length 1 containing comma separated column names. "
"See ?data.table for other possibilities."
msgstr ""
"'by' est un vecteur de caractères de longueur %d mais un ou plusieurs éléments "
"contiennent une virgule. Passer un vecteur de noms de colonnes (pouvant "
"contenir des espaces, mais pas de virgule), ou un vecteur de longueur 1 "
"contenant des noms de colonnes séparés par une virgule. Voir ?data.table pour "
"d'autres possibilités."

#: data.table.R:801
#, c-format
msgid "At least one entry of by is empty"
msgstr "Au moins une valeur de by est vide"

#: data.table.R:876
#, c-format
msgid ""
"'by' appears to evaluate to column names but isn't c() or key(). Use "
"by=list(...) if you can. Otherwise, by=eval%s should work. This is for "
"efficiency so data.table can detect which columns are needed."
msgstr ""
"'by' semble représenter des noms de colonnes mais n'est pas c() ni key(). "
"Utiliser by=list(...) si vous le pouvez. Sinon, by=eval%s doit fonctionner. "
"C'est à data.table de détecter les colonnes nécessaires pour un traitement "
"efficace."

#: data.table.R:887
#, c-format
msgid ""
"'by' or 'keyby' must evaluate to a vector or a list of vectors (where 'list' "
"includes data.table and data.frame which are lists, too)"
msgstr ""
"'by' ou 'keyby' doit correspondre à un vecteur ou à une liste de vecteurs (où "
"'list' inclut data.table et data.frame qui sont également des listes)"

#: data.table.R:891
#, c-format
msgid ""
"Column or expression %d of 'by' or 'keyby' is type '%s' which is not currently "
"supported. If you have a compelling use case, please add it to https://github."
"com/Rdatatable/data.table/issues/1597. As a workaround, consider converting "
"the column to a supported type, e.g. by=sapply(list_col, toString), whilst "
"taking care to maintain distinctness in the process."
msgstr ""
"La colonne ou l'expression %d de 'by' ou 'keyby' est de type '%s' qui n'est "
"pas pris en charge actuellement. Si vous avez un cas d'utilisation "
"convaincant, veuillez l'ajouter sur https://github.com/Rdatatable/data.table/"
"issues/1597. Comme solution de contournement, envisagez de convertir la "
"colonne en un type pris en charge, par exemple by=sapply(list_col, toString), "
"tout en veillant à maintenir la distinction dans le processus."

#: data.table.R:895
#, c-format
msgid ""
"The items in the 'by' or 'keyby' list are length(s) %s. Each must be length "
"%d; the same length as there are rows in x (after subsetting if i is provided)."
msgstr ""
"Les éléments de la liste ‘by’ ou ‘keyby’ sont de longueur(s) %s. Chacun d'eux "
"doit être de longueur %d ; la même longueur que celle des lignes de x (après "
"le sous-ensemble si i est fourni)."

#: data.table.R:948
#, c-format
msgid "Item %d of the .() or list() passed to j is missing"
msgstr "L'élément %d de .() ou de list() passé à j est absent"

#: data.table.R:954
#, c-format
msgid ""
"j may not evaluate to the same number of columns for each group; if you're "
"sure this warning is in error, please put the branching logic outside of [ for "
"efficiency"
msgstr ""
"j peut ne pas évaluer le même nombre de colonnes pour chaque groupe ; si vous "
"êtes sûr que cet avertissement est une erreur, veuillez placer la logique de "
"branchement en dehors de [ pour plus d'efficacité"

#: data.table.R:956
#, c-format
msgid ""
"Different branches of j expression produced different auto-named columns: %s; "
"using the most \"last\" names. If this was intentional (e.g., you know only "
"one branch will ever be used in a given query because the branch is controlled "
"by a function argument), please (1) pull this branch out of the call; (2) "
"explicitly provide missing defaults for each branch in all cases; or (3) use "
"the same name for each branch and re-name it in a follow-up call."
msgstr ""
"Différentes branches de l'expression j ont produit différentes colonnes auto-"
"nommées : %s ; Les derniers noms connus sont utilisés. Si cela était "
"intentionnel (par exemple, vous savez qu'une seule branche sera utilisée dans "
"une requête donnée parce que la branche est contrôlée par un argument de "
"fonction), veuillez (1) retirer cette branche de l'appel ; (2) fournir "
"explicitement les valeurs par défaut manquantes pour chaque branche dans tous "
"les cas ; ou (3) utiliser le même nom pour chaque branche et la renommer dans "
"un appel ultérieur."

#: data.table.R:1026
#, c-format
msgid ""
"When .SDcols is a function, it is applied to each column; the output of this "
"function must be a non-missing boolean scalar signalling inclusion/exclusion "
"of the column. However, these conditions were not met for: %s"
msgstr ""
"Quand .SDcols est une fonction, elle est appliquée à chaque colonne ; La "
"sortie de cette fonction doit être un scalaire booléen présent indiquant "
"l'inclusion ou l'exclusion de la colonne. Néanmoins ces conditions ne sont pas "
"satisfaite pour : %s"

#: data.table.R:1032
#, c-format
msgid ".SDcols missing at the following indices: %s"
msgstr ".SDcols est absent aux indices suivants : %s"

#: data.table.R:1034
#, c-format
msgid ".SDcols is a logical vector length %d but there are %d columns"
msgstr ".SDcols est un vecteur booléens de longueur %d mais il y a %d colonnes"

#: data.table.R:1040
#, c-format
msgid ".SDcols is numeric but has both +ve and -ve indices"
msgstr ".SDcols est numérique mais comporte à la fois des indices +ve et -ve"

#: data.table.R:1042
#, c-format
msgid ".SDcols is numeric but out of bounds [1, %d] at: %s"
msgstr ".SDcols est numérique mais hors de l'intervalle [1, %d] à : %s"

#: data.table.R:1046
#, c-format
msgid ".SDcols should be column numbers or names"
msgstr ".SDcols doit fournir des numéros de colonnes ou des noms"

#: data.table.R:1048
#, c-format
msgid "Some items of .SDcols are not column names: %s"
msgstr "Certains éléments de .SDcols ne sont pas des noms de colonnes : %s"

#: data.table.R:1090
#, c-format
msgid ""
"This j doesn't use .SD but .SDcols has been supplied. Ignoring .SDcols. See ?"
"data.table."
msgstr ""
"Ce j n'utilise pas .SD mais .SDcols qui a été fourni. .SDcols est ignoré. "
"Voir ?data.table."

#: data.table.R:1106
#, c-format
msgid ""
".SD is locked. Using := in .SD's j is reserved for possible future use; a "
"tortuously flexible way to modify by group. Use := in j directly to modify by "
"group by reference."
msgstr ""
".SD est verrouillé. L'utilisation de := dans j de .SD est réservée pour une "
"utilisation future possible ; une manière un peu tordue de modifier par "
"groupe. Utiliser := dans j directement pour modifier par groupe et par "
"référence."

#: data.table.R:1114
#, c-format
msgid "In %s(col1=val1, col2=val2, ...) form, all arguments must be named."
msgstr ""
"Dans la forme %s(col1=val1, col2=val2, ...), tous les arguments doivent être "
"nommés."

#: data.table.R:1136
#, c-format
msgid ""
"In %s(col1=val1, col2=val2, ...) form, all arguments must be named, but the "
"last argument has no name. Did you forget a trailing comma?"
msgstr ""
"Dans la forme %s(col1=val1, col2=val2, ...), tous les arguments doivent être "
"nommés, cependant le dernier argument n’a pas de nom. Avez-vous oublié une "
"virgule à la fin ?"

#: data.table.R:1138
#, c-format
msgid ""
"In %s(col1=val1, col2=val2, ...) form, all arguments must be named, but these "
"arguments lack names: %s."
msgstr ""
"Dans la forme %s(col1=val1, col2=val2, ...), tous les arguments doivent être "
"nommés, mais les arguments suivants n’ont pas de nom : %s."

#: data.table.R:1145
#, c-format
msgid ""
"LHS of := must be a symbol, or an atomic vector (column names or positions)."
msgstr ""
"Le membre gauche de := doit être un symbole, ou un vecteur atomique (noms de "
"colonnes ou positions)."

#: data.table.R:1150
#, c-format
msgid ""
"LHS of := appears to be column positions but are outside [1,ncol] range. New "
"columns can only be added by name."
msgstr ""
"Le membre gauche de := semble être des positions de colonnes mais elles sont "
"en dehors de l'intervalle [1,ncol] . Ajouter les nouvelles colonnes par nom "
"uniquement."

#: data.table.R:1153
#, c-format
msgid ""
"LHS of := isn't column names ('character') or positions ('integer' or "
"'numeric')"
msgstr ""
"Le membre gauche de := ne correspond pas à des noms de colonnes ('character') "
"ni à des positions ('integer' ou 'numeric')"

#: data.table.R:1184
#, c-format
msgid ""
"Invalid .internal.selfref detected and fixed by taking a (shallow) copy of the "
"data.table so that := can add this new column by reference. At an earlier "
"point, this data.table has been copied by R (or was created manually using "
"structure() or similar). Avoid names<- and attr<- which in R currently (and "
"oddly) may copy the whole data.table. Use set* syntax instead to avoid "
"copying: ?set, ?setnames and ?setattr. If this message doesn't help, please "
"report your use case to the data.table issue tracker so the root cause can be "
"fixed or this message improved."
msgstr ""
"Invalide .internal.selfref détecté et corrigé en prenant une copie (peu "
"profonde) du data.table afin que := puisse ajouter cette nouvelle colonne par "
"référence. Ce data.table a été copié antérieurement par R (ou a été créé "
"manuellement en utilisant structure() ou similaire). Évitez names<- et attr<- "
"qui, dans R, peuvent actuellement (et bizarrement) copier tout le data.table. "
"Utilisez plutôt la syntaxe set* pour éviter la copie : ?set, ?setnames et ?"
"setattr. Si ce message ne vous aide pas, veuillez rapporter votre cas "
"d'utilisation dans le gestionnaire de tickets de data.table (issue tracker) "
"afin que la cause première puisse être corrigée ou que ce message soit "
"amélioré."

#: data.table.R:1215
#, c-format
msgid ""
"Cannot assign to an under-allocated recursively indexed list -- L[[i]][,:=] "
"syntax is only valid when i is length 1, but its length is %d"
msgstr ""
"Impossible d'assigner à une sous-liste indexée récursivement -- la syntaxe "
"L[[i]][,:=] n'est autorisée que si i est de longueur 1 mais sa longueur est %d"

#: data.table.R:1284
#, c-format
msgid ""
"Variable '%s' is not found in calling scope. Looking in calling scope because "
"this symbol was prefixed with .. in the j= parameter."
msgstr ""
"La variable '%s' n'est pas visible dans le contexte de l'appelant désigné par "
"le préfixe .. du symbole dans le paramètre j= ."

#: data.table.R:1370
#, c-format
msgid ""
"j (the 2nd argument inside [...]) is a single symbol but column name '%1$s' is "
"not found. If you intended to select columns using a variable in calling "
"scope, please try DT[, ..%1$s]. The .. prefix conveys one-level-up similar to "
"a file system path."
msgstr ""
"j (le deuxième argument à l'intérieur de [...]) est un symbole unique mais le "
"nom de la colonne '%1$s' n'est pas trouvé. Si vous souhaitez sélectionner des "
"colonnes à l'aide d'une variable dans la portée de l'appelant, essayez DT[, .."
"%1$s]. Le préfixe .. indique un niveau supérieur similaire à celui d'un chemin "
"d'accès pour un système de fichiers."

#: data.table.R:1454
#, c-format
msgid ""
"The column '.N' can't be grouped because it conflicts with the special .N "
"variable. Try setnames(DT,'.N','N') first."
msgstr ""
"La colonne '.N' ne peut pas être groupée car elle est en conflit avec la "
"variable spéciale .N variable. Essayer d'abord setnames(DT,'.N','N') ."

#: data.table.R:1455
#, c-format
msgid ""
"The column '.I' can't be grouped because it conflicts with the special .I "
"variable. Try setnames(DT,'.I','I') first."
msgstr ""
"La colonne '.I' ne peut pas être groupée car elle est en conflit avec la "
"variable spéciale .I . Essayez d'abord setnames(DT,'.I','I')."

#: data.table.R:1483
#, c-format
msgid "logical error. i is not data.table, but mult='all' and 'by'=.EACHI"
msgstr ""
"erreur logique. i n'est pas une data.table, mais mult='all' et 'by'=.EACHI"

#: data.table.R:1804
#, c-format
msgid ""
"Unable to optimize call to mean() and could be very slow. You must name 'na."
"rm' like that otherwise if you do mean(x,TRUE) the TRUE is taken to mean "
"'trim' which is the 2nd argument of mean. 'trim' is not yet optimized."
msgstr ""
"Impossible d'optimiser l'appel à mean() et risque d'être très lent. Vous devez "
"nommer 'na.rm' comme cela, sinon si vous faites mean(x,TRUE), TRUE est "
"considéré comme signifiant 'trim' qui est le deuxième argument de mean. 'trim' "
"n'est pas encore optimisé."

#: data.table.R:1950
#, c-format
msgid ""
"The setkey() normally performed by keyby= has been skipped (as if by= was "
"used) because := is being used together with keyby= but the keyby= contains "
"some expressions. To avoid this warning, use by= instead, or provide existing "
"column names to keyby=."
msgstr ""
"Le setkey() normalement exécuté par keyby= a été ignoré (comme si by= était "
"utilisé) parce que := est utilisé avec keyby=, mais keyby= contient des "
"expressions. Pour éviter cet avertissement, utilisez by= à la place, ou "
"fournissez des noms de colonnes existantes à keyby=."

#: data.table.R:2039
#, c-format
msgid "rownames and rownames.value cannot both be used at the same time"
msgstr "rownames et rownames.value ne peuvent pas être utilisés simultanément"

#: data.table.R:2044
#, c-format
msgid ""
"length(rownames)==%d but nrow(DT)==%d. The rownames argument specifies a "
"single column name or number. Consider rownames.value= instead."
msgstr ""
"length(rownames)==%d mais nrow(DT)==%d. L'argument rownames spécifie un nom de "
"colonne unique ou un nombre. Remplacez par rownames.value= ."

#: data.table.R:2048
#, c-format
msgid "length(rownames)==0 but should be a single column name or number, or NULL"
msgstr ""
"length(rownames)==0 mais doit être un nom de vecteur colonne, ou un nombre, ou "
"NULL"

#: data.table.R:2052
#, c-format
msgid ""
"rownames is TRUE but key has multiple columns %s; taking first column x[,1] as "
"rownames"
msgstr ""
"rownames vaut TRUE mais la clé a plusieurs colonnes %s ; Seule la première "
"colonne x[,1] est utilisée pour le nom des lignes"

#: data.table.R:2062
#, c-format
msgid "'%s' is not a column of x"
msgstr "'%s' n'est pas une colonne de x"

#: data.table.R:2068
#, c-format
msgid ""
"as.integer(rownames)==%d which is outside the column number range [1,ncol=%d]."
msgstr ""
"as.integer(rownames)==%d est en dehors de l'intervalle des numéros de colonne "
"[1,ncol=%d]."

#: data.table.R:2073
#, c-format
msgid "length(rownames.value)==%d but should be nrow(x)==%d"
msgstr "length(rownames.value)==%d mais devrait être nrow(x)==%d"

#: data.table.R:2169
#, c-format
msgid ""
"When i is a matrix in DT[i]<-value syntax, it doesn't make sense to provide j"
msgstr ""
"Si i est une matrice, dans la syntaxe DT[i]<-valeur, fournir j n'a pas de sens"

#: data.table.R:2179
#, c-format
msgid "j must be an atomic vector, see ?is.atomic"
msgstr "j doit être un vecteur atomique, voir ?is.atomic"

#: data.table.R:2180
#, c-format
msgid "NA in j"
msgstr "NA trouvé dans j"

#: data.table.R:2186
#, c-format
msgid "j must be vector of column name or positions"
msgstr "j doit être un vecteur de noms de colonnes ou de positions"

#: data.table.R:2187
#, c-format
msgid ""
"Attempt to assign to column position greater than ncol(x). Create the column "
"by name, instead. This logic intends to catch (most likely) user errors."
msgstr ""
"Tentative d'accès à une colonne située au-delà de ncol(x). À la place, créez "
"la colonne par nom. Cette logique permet d'intercepter les erreurs utilisateur "
"(le plus souvent)."

#: data.table.R:2254
#, c-format
msgid ""
"data.table inherits from data.frame (from v1.5), but this data.table does not. "
"Has it been created manually (e.g. by using 'structure' rather than 'data."
"table') or saved to disk using a prior version of data.table?"
msgstr ""
"data.table hérite de data.frame (à partir de la version 1.5), mais pas ce data."
"table. A-t-il été créé manuellement (par exemple en utilisant 'structure' "
"plutôt que 'data.table') ou sauvegardé sur disque à l'aide d'une version "
"antérieure de data.table ?"

#: data.table.R:2263
#, c-format
msgid "attempting to assign invalid object to dimnames of a data.table"
msgstr "assignation d'un objet non valide à dimnames d'une data.table"

#: data.table.R:2264
#, c-format
msgid "data.tables do not have rownames"
msgstr "les data.tables n'ont pas de rownames"

#: data.table.R:2265 data.table.R:2634
#, c-format
msgid "Can't assign %d names to a %d-column data.table"
msgstr "Impossible d'assigner %d noms à une data.table de %d colonne(s)"

#: data.table.R:2329
#, c-format
msgid "'subset' must evaluate to logical"
msgstr "'subset' doit représenter une valeur booléenne"

#: data.table.R:2372
#, c-format
msgid "Argument 'invert' must be logical TRUE/FALSE"
msgstr "L'argument 'invert' doit être un booléen TRUE / FALSE"

#: data.table.R:2413
#, c-format
msgid "x argument must be a data.table"
msgstr "l'argument x doit être une data.table"

#: data.table.R:2418
#, c-format
msgid "group length is 0 but data nrow > 0"
msgstr "la longueur du groupe est 0 mais pour les données, nrow > 0"

#: data.table.R:2420
#, c-format
msgid ""
"passing 'f' argument together with 'by' is not allowed, use 'by' when split by "
"column in data.table and 'f' when split by external factor"
msgstr ""
"le passage de l'argument 'f' en même temps que 'by' n'est pas autorisé, "
"utilisez 'by' pour la division par colonne dans data.table et 'f' pour la "
"division par facteur externe"

#: data.table.R:2428
#, c-format
msgid "Either 'by' or 'f' argument must be supplied"
msgstr "Fournir un seul argument 'by' ou 'f' mais pas les deux"

#: data.table.R:2430
#, c-format
msgid "Column '.ll.tech.split' is reserved for split.data.table processing"
msgstr ""
"La colonne '.ll.tech.split' est réservée au traitement de split.data.table"

#: data.table.R:2431
#, c-format
msgid "Column '.nm.tech.split' is reserved for split.data.table processing"
msgstr ""
"La colonne '.nm.tech.split' est réservée au traitement de split.data.table"

#: data.table.R:2432
#, c-format
msgid "Argument 'by' must refer to column names in x"
msgstr "L'argument 'by' doit se rapporter aux noms des colonnes dans x"

#: data.table.R:2433
#, c-format
msgid ""
"Argument 'by' must refer only to atomic-type columns, but the following "
"columns are non-atomic: %s"
msgstr ""
"L'argument 'by' doit faire référence uniquement à des colonnes de type "
"atomique, mais les colonnes suivantes ne le sont pas : %s"

#: data.table.R:2565
#, c-format
msgid ""
"x is not a data.table|frame. Shallow copy is a copy of the vector of column "
"pointers (only), so is only meaningful for data.table|frame"
msgstr ""
"x n'est pas un data.table|frame. Shallow copy est une copie du vecteur de "
"pointeurs de colonnes (uniquement), et n'a donc de sens que pour un data.table|"
"frame"

#: data.table.R:2574
#, c-format
msgid "setalloccol attempting to modify `*tmp*`"
msgstr "setalloccol essaie de modifier `*tmp*`"

#: data.table.R:2609
#, c-format
msgid ""
"Input is a length=1 logical that points to the same address as R's global "
"value. Therefore the attribute has not been set by reference, rather on a "
"copy. You will need to assign the result back to a variable. See issue #1281."
msgstr ""
"L'entrée est un booléen de longueur 1 pointant vers la même adresse que la "
"valeur globale de R. C'est pourquoi l'attribut n'a pas été initialisé par "
"référence mais plutôt par copie. Vous devrez donc assigner le résultat à une "
"variable. Voir le tickets (issues) numéro #1281."

#: data.table.R:2624
#, c-format
msgid "x is not a data.table or data.frame"
msgstr "x n'est pas une data.table ni un data.frame"

#: data.table.R:2626
#, c-format
msgid "x has %d columns but its names are length %d"
msgstr "x a %d colonnes mais les noms sont de longueur %d"

#: data.table.R:2633
#, c-format
msgid "Passed a vector of type '%s'. Needs to be type 'character'."
msgstr "Passage d'un vecteur de type '%s'. Doit être de type 'character'."

#: data.table.R:2646
#, c-format
msgid "'new' is not a character vector or a function"
msgstr "'new' n’est pas un vecteur de chaîne de caractères ni une fonction"

#: data.table.R:2648
#, c-format
msgid "NA in 'new' at positions %s"
msgstr "NA est présent dans 'new' aux positions %s"

#: data.table.R:2649
#, c-format
msgid "Some duplicates exist in 'old': %s"
msgstr "Présence de certains doublons dans 'old' : %s"

#: data.table.R:2651
#, c-format
msgid "'old' is type %s but should be integer, double or character"
msgstr ""
"'old' est de type %s mais doit être un entier, un double ou de type 'character'"

#: data.table.R:2652
#, c-format
msgid "'old' is length %d but 'new' is length %d"
msgstr "'old' est de longueur %d et 'new' est de longueur %d"

#: data.table.R:2653
#, c-format
msgid "NA (or out of bounds) in 'old' at positions %s"
msgstr "NA (ou valeurs hors limites) trouvées dans 'old' aux positions %s"

#: data.table.R:2656
#, c-format
msgid ""
"Item %d of 'old' is '%s' which appears several times in column names. Just the "
"first will be changed. There are %d other items in 'old' that are also "
"duplicated in column names."
msgstr ""
"L'élément %d de 'old' est '%s' et apparait plusieurs fois dans les noms des "
"colonnes. Seul le premier sera modifié. Il reste %d autres éléments dans 'old' "
"qui sont également dupliqués dans les noms des colonnes."

#: data.table.R:2664
#, c-format
msgid "Items of 'old' not found in column names: %s. Consider skip_absent=TRUE."
msgstr ""
"Eléments de 'old' non trouvés parmi les noms de colonnes : %s. Veuillez "
"utiliser skip_absent=TRUE."

#: data.table.R:2703
#, c-format
msgid ""
"x has some duplicated column name(s): %s. Please remove or rename the "
"duplicate(s) and try again."
msgstr ""
"x comporte des doublons de noms de colonnes : %s. Veuillez les supprimer ou "
"les renommer et recommencer."

#: data.table.R:2705
#, c-format
msgid "Provide either before= or after= but not both"
msgstr "Fournir before= ou after= mais pas les deux simultanément"

#: data.table.R:2707
#, c-format
msgid "before=/after= accept a single column name or number, not more than one"
msgstr ""
"before= ou after= n'acceptent qu'un seul nom de colonne ou nombre et pas plus"

#: data.table.R:2763
#, c-format
msgid "Input is %s but should be a plain list of items to be stacked"
msgstr "L'entrée est %s mais doit être une liste d'éléments à empiler"

#: data.table.R:2767
#, c-format
msgid ""
"idcol must be a logical or character vector of length 1. If logical TRUE the "
"id column will named '.id'."
msgstr ""
"idcol doit être un vecteur booléen ou un vecteur de caractères de longueur 1. "
"Si la valeur logique est TRUE, la colonne id sera nommée '.id'."

#: data.table.R:2772
#, c-format
msgid "use.names=NA invalid"
msgstr "use.names=NA non valide"

#: data.table.R:2774
#, c-format
msgid ""
"use.names='check' cannot be used explicitly because the value 'check' is new "
"in v1.12.2 and subject to change. It is just meant to convey default behavior. "
"See ?rbindlist."
msgstr ""
"use.names='check' ne peut être utilisé explicitement car la valeur 'check' est "
"nouvelle en v1.12.2 et peut changer à l'avenir. Elle est présente juste pour "
"garder le comportement par défaut. Voir ?rbindlist."

#: data.table.R:2789
#, c-format
msgid ""
"Check that is.data.table(DT) == TRUE. Otherwise, :=, `:=`(...) and let(...) "
"are defined for use in j, once only and in particular ways. Note that "
"namespace-qualification like data.table::`:=`(...) is not supported. See "
"help(\":=\")."
msgstr ""
"Vérifiez que is.data.table(DT) == TRUE. Sinon, :=, ':='(...) et let(...) sont "
"définis pour être utilisés dans j, une seule fois et de manières "
"particulières. Notez que la spécification de l’espace de noms comme data."
"table::`:=`(…) n’est pas supportée. Voir help(\":=\")."

#: data.table.R:2806
#, c-format
msgid ""
"setDF only accepts data.table, data.frame or list of equal length as input"
msgstr ""
"setDF n'accepte en entrée que des types data.table, data.frame ou des listes "
"d'égale longeur"

#: data.table.R:2807
#, c-format
msgid "rownames contains duplicates"
msgstr "doublons présents dans rownames"

#: data.table.R:2814 data.table.R:2825 data.table.R:2848
#, c-format
msgid "rownames incorrect length; expected %d names, got %d"
msgstr "longueur incorrecte de rownames ; %d noms attendus, %d sont fournis"

#: data.table.R:2833
#, c-format
msgid "All elements in argument 'x' to 'setDF' must be of same length"
msgstr ""
"Tous les éléments de l'argument 'x' de 'setDF' doivent avoir la même longueur"

#: data.table.R:2862
#, c-format
msgid "Cannot find symbol %s"
msgstr "Symbole %s non trouvé"

#: data.table.R:2869
#, c-format
msgid ""
"Cannot convert '%1$s' to data.table by reference because binding is locked. It "
"is very likely that '%1$s' resides within a package (or an environment) that "
"is locked to prevent modifying its variable bindings. Try copying the object "
"to your current environment, ex: var <- copy(var) and then using setDT again."
msgstr ""
"Impossible de convertir '%1$s' en data.table par référence car le lien est "
"verrouillé. Il est très probable que '%1$s' se trouve dans un package (ou un "
"environnement) qui est verrouillé pour empêcher la modification de ses objets. "
"Essayez de copier l'objet dans votre environnement actuel, ex : var <- "
"copy(var) et utilisez ensuite setDT à nouveau."

#: data.table.R:2922
#, c-format
msgid "Argument 'x' to 'setDT' should be a 'list', 'data.frame' or 'data.table'"
msgstr ""
"L'argument 'x' de 'setDT' doit être de type 'list', 'data.frame' ou 'data."
"table'"

#: data.table.R:2937
#, c-format
msgid "Item '%s' not found in names of input list"
msgstr "Élément '%s' non trouvé parmi les noms de la liste d'entrée"

#: data.table.R:2962 data.table.R:2987
#, c-format
msgid "'prefix' must be NULL or a character vector of length 1."
msgstr ""
"'prefix' doit être NULL ou un vecteur de chaîne de caractères de longueur 1."

#: data.table.R:2965 data.table.R:2990
#, c-format
msgid "x is a single vector, non-NULL 'cols' doesn't make sense."
msgstr "x est un vecteur unique, donc 'cols' non NULL n'a pas de sens."

#: data.table.R:2969 data.table.R:2994
#, c-format
msgid "x is a list, 'cols' cannot be 0-length."
msgstr "x est une liste, 'cols' ne peut avoir une longueur 0."

#: data.table.R:3185
#, c-format
msgid ""
"RHS of %s is length %d which is not 1 or nrow (%d). For robustness, no "
"recycling is allowed (other than of length 1 RHS). Consider %%in%% instead."
msgstr ""
"Le membre de droite de %s a pour longueur %d au lieu de 1 ou nrow (%d) "
"attendu. Pour la robustesse, aucun recyclage n'est autorisé (autre que sur une "
"longueur de 1 du membre de droite). Essayez %%in%% à la place."

#: data.table.R:3300
#, c-format
msgid ""
"'on' argument should be a named atomic vector of column names indicating which "
"columns in 'i' should be joined with which columns in 'x'."
msgstr ""
"l'argument 'on' doit être un vecteur atomique nommé composé de noms de "
"colonnes indiquant quelle colonne de 'i' doit être jointe à quelle colonne de "
"'x'."

#: data.table.R:3341
#, c-format
msgid ""
"Found more than one operator in one 'on' statement: %s. Please specify a "
"single operator."
msgstr ""
"Plus d'un opérateur trouvé dans une déclaration 'on' : %s. Veuillez spécifier "
"un seul opérateur."

#: data.table.R:3364
#, c-format
msgid ""
"'on' contains no column name: %s. Each 'on' clause must contain one or two "
"column names."
msgstr ""
"'on' n'a pas de nom de colonne : %s. Chaque clause 'on' doit contenir un ou "
"deux noms de colonnes."

#: data.table.R:3366
#, c-format
msgid ""
"'on' contains more than 2 column names: %s. Each 'on' clause must contain one "
"or two column names."
msgstr ""
"la clause 'on' contient plus de 2 noms de colonnes : %s. Chaque clause 'on' "
"doit contenir un ou deux noms de colonnes."

#: data.table.R:3371
#, c-format
msgid "Invalid join operators %s. Only allowed operators are %s."
msgstr ""
"Opérateurs de jointure non valides %s. Les seuls opérateurs autorisés sont %s."

#: devel.R:16
#, c-format
msgid "There is no package %s in provided repository."
msgstr "Package %s non trouvé dans le dépôt fourni."

#: duplicated.R:7
#, c-format
msgid "'fromLast' must be TRUE or FALSE"
msgstr "'fromLast' doit être TRUE ou FALSE"

#: duplicated.R:105
#, c-format
msgid "x must be an atomic vector or data.frames/data.tables"
msgstr "x doit être un vecteur atomique ou des data.frames / data.tables"

#: fcast.R:7
#, c-format
msgid "Using '%s' as value column. Use 'value.var' to override"
msgstr ""
"'%s' est utilisé comme colonne de valeurs. Utiliser 'value.var' pour redéfinir"

#: fcast.R:20 fmelt.R:16
#, c-format
msgid ""
"The %1$s generic in data.table has been passed a %2$s, but data.table::%1$s "
"currently only has a method for data.tables. Please confirm your input is a "
"data.table, with setDT(%3$s) or as.data.table(%3$s). If you intend to use a "
"method from reshape2, try installing that package first, but do note that "
"reshape2 is superseded and is no longer actively developed."
msgstr ""
"Le générique %1$s dans data.table a été transmis à un %2$s, mais data.table: :"
"%1$s n'a actuellement qu'une méthode pour data.tables. Veuillez confirmer que "
"votre entrée est un data.table, avec setDT(%3$s) ou as.data.table(%3$s). Si "
"vous avez l'intention d'utiliser une méthode de reshape2, essayez d'installer "
"ce package en premier, mais notez que reshape2 est dépassé et n'est plus "
"activement développé."

#: fcast.R:21
#, c-format
msgid ""
"The %1$s generic in data.table has been passed a %2$s and will attempt to "
"redirect to the relevant reshape2 method; please note that reshape2 is "
"superseded and is no longer actively developed, and this redirection is now "
"deprecated. Please do this redirection yourself like reshape2::%1$s(%3$s). In "
"the next version, this warning will become an error."
msgstr ""
"Le générique %1$s dans data.table s'est vu passer un %2$s et tentera de "
"rediriger vers la méthode reshape2 correspondante ; veuillez noter que "
"reshape2 est dépassé et n'est plus activement développé, et que cette "
"redirection est désormais obsolète. Veuillez effectuer cette redirection vous-"
"même comme reshape2: :%1$s(%3$s). Dans la prochaine version, cet avertissement "
"deviendra une erreur."

#: fcast.R:31
#, c-format
msgid ""
"Invalid formula. Cast formula should be of the form LHS ~ RHS, for e.g., a + b "
"~ c."
msgstr ""
"Formule non valide. La formule du cast s'écrit : membre gauche ~ membre droit, "
"par exemple : a + b ~ c."

#: fcast.R:38
#, c-format
msgid "data.table to cast must have unique column names"
msgstr ""
"cast impossible si les noms de colonnes ne sont pas uniques dans la data.table"

#: fcast.R:83
#, c-format
msgid "value.var values %s are not found in 'data'."
msgstr "valeurs %s de value.var absentes dans 'data'."

#: fcast.R:99
#, c-format
msgid ""
"When 'fun.aggregate' and 'value.var' are both lists, 'value.var' must be "
"either of length =1 or =length(fun.aggregate)."
msgstr ""
"Si 'fun.aggregate' et 'value.var' sont tous deux des listes, 'value.var' doit "
"avoir une longueur =1 ou =length(fun.aggregate)."

#: fcast.R:132
#, c-format
msgid "'data' must be a data.table."
msgstr "'data' doit être une data.table."

#: fcast.R:134
#, c-format
msgid "'drop' must be logical TRUE/FALSE"
msgstr "'drop' doit être un booléen TRUE / FALSE"

#: fcast.R:136
#, c-format
msgid "Argument 'value.var.in.dots' should be logical TRUE/FALSE"
msgstr "L'argument ‘value.var.in.dots’ doit être un booléen TRUE/FALSE"

#: fcast.R:138
#, c-format
msgid ""
"Arguments 'value.var.in.LHSdots', 'value.var.in.RHSdots' should be logical "
"TRUE/FALSE"
msgstr ""
"Les arguments 'value.var.in.LHSdots', 'value.var.in.RHSdots' doivent être des "
"booléens TRUE/FALSE"

#: fcast.R:155
#, c-format
msgid "Column [%s] not found or of unknown type."
msgstr "La colonne [%s] est absente ou de type inconnu."

#: fcast.R:170
#, c-format
msgid "Columns specified in formula can not be of type list"
msgstr ""
"Les colonnes spécifiées dans la formule ne peuvent pas avoir le type liste"

#: fcast.R:185
#, c-format
msgid ""
"'fun.aggregate' is NULL, but found duplicate row/column combinations, so "
"defaulting to length(). That is, the variables %s used in 'formula' do not "
"uniquely identify rows in the input 'data'. In such cases, 'fun.aggregate' is "
"used to derive a single representative value for each combination in the "
"output data.table, for example by summing or averaging (fun.aggregate=sum or "
"fun.aggregate=mean, respectively). Check the resulting table for values larger "
"than 1 to see which combinations were not unique. See ?dcast.data.table for "
"more details."
msgstr ""
"'fun.aggregate' est NULL, mais des combinaisons de lignes/colonnes dupliquées "
"sont rencontrées, donc par défaut length() est utilisé. En d'autres termes, "
"les variables %s utilisées dans 'formula' n'identifient pas de manière unique "
"les lignes dans les données d'entrée 'data'. Dans ce cas, 'fun.aggregate' est "
"utilisé pour dériver une valeur représentative unique pour chaque combinaison "
"dans la 'data.table' de sortie, par exemple en faisant la somme ou la moyenne "
"(fun.aggregate=sum ou fun.aggregate=mean, respectivement). Vérifiez que le "
"tableau résultant contient des valeurs supérieures à 1 pour voir quelles "
"combinaisons n'étaient pas uniques. Voir ?dcast.data.table pour plus de "
"détails."

#: fcast.R:195
msgid ""
"Aggregating function(s) should take a vector as input and return a single "
"value (length=1), but they do not, so the result is undefined. Please fix by "
"modifying your function so that a single value is always returned."
msgstr ""
"La ou les fonction(s) d'agrégation devraient prendre un vecteur en entrée et "
"renvoyer une seule valeur (longueur=1), mais ce n'est pas le cas, et le "
"résultat est donc indéfini. Veuillez corriger en modifiant votre fonction de "
"manière à ce qu'une seule valeur soit toujours renvoyée."

#: fdroplevels.R:13
#, c-format
msgid ""
"droplevels() with in.place=TRUE is deprecated. Use setdroplevels() instead."
msgstr ""
"droplevels() avec in.place=TRUE est obsolète. Utilisez plutôt setdroplevels()."

#: fmelt.R:17
#, c-format
msgid ""
"The %1$s generic in data.table has been passed a %2$s and will attempt to "
"redirect to the relevant reshape2 method; please note that reshape2 is "
"superseded and is no longer actively developed, and this redirection is now "
"deprecated. To continue using melt methods from reshape2 while both libraries "
"are attached, e.g. melt.list, you can prepend the namespace, i.e. reshape2::"
"%1$s(%3$s). In the next version, this warning will become an error."
msgstr ""
"Le générique %1$s dans data.table a reçu un %2$s et tentera de rediriger vers "
"la méthode reshape2 correspondante ; Veuillez noter que reshape2 est remplacé "
"et n'est plus activement développé, et que cette redirection est maintenant "
"dépréciée. Pour continuer à utiliser les méthodes 'melt' de reshape2 alors que "
"les deux bibliothèques sont attachées, par exemple 'melt.list', vous pouvez "
"ajouter l'espace de noms, c'est-à-dire reshape2: :%1$s(%3$s). Dans la "
"prochaine version, cet avertissement deviendra une erreur."

#: fmelt.R:28
#, c-format
msgid "Input patterns must be of type character."
msgstr "Les motifs d'entrée doivent être de type chaînes de caractères."

#: fmelt.R:31
#, c-format
msgid "Pattern(s) not found: [%s]"
msgstr "Motif(s) non trouvé(s) : [%s]"

#: fmelt.R:46
#, c-format
msgid ""
"each ... argument to measure must be either a symbol without argument name, or "
"a function with argument name, problems: %s"
msgstr ""
"chaque argument ... à mesurer doit être soit un symbole sans nom d'argument, "
"soit une fonction avec nom d'argument, problèmes : %s"

#: fmelt.R:54
#, c-format
msgid ""
"group names specified in ... conflict with measure argument names; please fix "
"by changing group names: %s"
msgstr ""
"les noms de groupes spécifiés dans ... sont en conflit avec les noms des "
"arguments de mesure ; veuillez corriger en changeant les noms de groupes : %s"

#: fmelt.R:60
#, c-format
msgid ""
"each ... argument to measure must be a function with at least one argument, "
"problem: %s"
msgstr ""
"chaque argument ... à mesurer doit être une fonction avec au moins un "
"argument, problème : %s"

#: fmelt.R:74
#, c-format
msgid ""
"both sep and pattern arguments used; must use either sep or pattern (not both)"
msgstr ""
"vous utilisez à la fois les arguments sep et pattern ; Choisir entre sep ou "
"pattern (mais pas les deux)"

#: fmelt.R:77
#, c-format
msgid "multiple.keyword must be a character string with nchar>0"
msgstr "multiple.keyword doit être une chaîne de caractères avec nchar>0"

#: fmelt.R:80
#, c-format
msgid "cols must be a character vector of column names"
msgstr "cols doit être un vecteur de chaînes de caractères de noms de colonnes"

#: fmelt.R:88
#, c-format
msgid "in measurev, %s must be named, problems: %s"
msgstr "dans measurev, %s doit avoir un nom, problèmes : %s"

#: fmelt.R:94
#, c-format
msgid "%s should be uniquely named, problems: %s"
msgstr "%s doit avoir un nom unique, problèmes : %s"

#: fmelt.R:99
#, c-format
msgid "number of %s =%d must be same as %s =%d"
msgstr "le nombre de %s =%d doit être le même que %s =%d"

#: fmelt.R:106
#, c-format
msgid "pattern must be character string"
msgstr "le motif doit être une chaîne de caractères"

#: fmelt.R:111
#, c-format
msgid ""
"pattern did not match any cols, so nothing would be melted; fix by changing "
"pattern"
msgstr ""
"le motif ne correspondait à aucune colonne, donc rien n'aurait été fait "
"(melt) ; corrigez en changeant de motif"

#: fmelt.R:115
#, c-format
msgid ""
"pattern must contain at least one capture group (parenthesized sub-pattern)"
msgstr ""
"le motif doit contenir au moins un groupe de capture (sous-motif entre "
"parenthèses)"

#: fmelt.R:124
#, c-format
msgid "sep must be character string"
msgstr "sep doit être une chaîne de caractères"

#: fmelt.R:130
#, c-format
msgid ""
"each column name results in only one item after splitting using sep, which "
"means that all columns would be melted; to fix please either specify melt on "
"all columns directly without using measure, or use a different sep/pattern "
"specification"
msgstr ""
"chaque nom de colonne ne donne qu'un seul élément après séparation à l'aide de "
"'sep', ce qui signifie que toutes les colonnes seraient fusionnées ; pour "
"résoudre ce problème, veuillez spécifier la fusion (melt) sur toutes les "
"colonnes directement sans utiliser la mesure, ou utiliser une spécification "
"sep/motif différente"

#: fmelt.R:140
#, c-format
msgid ""
"number of unique column IDs =%d is less than number of melted columns =%d; fix "
"by changing pattern/sep"
msgstr ""
"le nombre d'ID de colonnes uniques =%d est inférieur au nombre de colonnes "
"fusionnées =%d ; corrigez en changeant le motif ou sep"

#: fmelt.R:150
#, c-format
msgid ""
"in the measurev fun.list, each non-NULL element must be a function with at "
"least one argument, problem: %s"
msgstr ""
"dans la mesurev fun.list, chaque élément non NULL doit être une fonction avec "
"au moins un argument, problème : %s"

#: fmelt.R:154
#, c-format
msgid ""
"each conversion function must return an atomic vector with same length as its "
"first argument, problem: %s"
msgstr ""
"chaque fonction de conversion doit renvoyer un vecteur atomique de même "
"longueur que son premier argument, problème : %s"

#: fmelt.R:157
#, c-format
msgid "%s conversion function returned vector of all NA"
msgstr ""
"la fonction de conversion %s a renvoyé un vecteur ne contenant que des NA"

#: fmelt.R:163
#, c-format
msgid ""
"number of unique groups after applying type conversion functions less than "
"number of groups, change type conversion"
msgstr ""
"nombre de groupes uniques après application des fonctions de conversion de "
"type inférieur au nombre de groupes, modifier la conversion de type"

#: fmelt.R:168
#, c-format
msgid ""
"%s column class=%s after applying conversion function, but must be character"
msgstr ""
"colonne %s class=%s après avoir appliqué les fonctions de conversion, mais "
"doivent être des chaînes de caractères"

#: fmelt.R:172
#, c-format
msgid "%s is the only group; fix by creating at least one more group"
msgstr ""
"%s est le seul groupe ; Corrigez en créant au moins un groupe supplémentaire"

#: fmelt.R:195
#, c-format
msgid "'data' must be a data.table"
msgstr "'data' doit être une data.table"

#: fmelt.R:214
#, c-format
msgid ""
"'value.name' provided in both 'measure.vars' and 'value.name argument'; value "
"provided in 'measure.vars' is given precedence."
msgstr ""
"'value.name' est fourni à la fois dans 'measure.vars' et 'value.name "
"argument' ; La valeur de 'measure.vars' prévaut."

#: fmelt.R:217
#, c-format
msgid "Please provide a name to each element of 'measure.vars'."
msgstr "Veuillez fournir un nom pour chaque élément de 'measure.vars'."

#: foverlaps.R:3
#, c-format
msgid ""
"y and x must both be data.tables. Use `setDT()` to convert list/data.frames to "
"data.tables by reference or as.data.table() to convert to data.tables by "
"copying."
msgstr ""
"y et x doivent tous deux être des data.tables. Utilisez `setDT()` pour "
"convertir des list/data.frames en data.tables par référence ou as.data.table() "
"pour convertir en data.tables par copie."

#: foverlaps.R:9
#, c-format
msgid "maxgap must be a non-negative integer value of length 1"
msgstr "maxgap doit être un entier positif ou nul de longueur 1"

#: foverlaps.R:11
#, c-format
msgid "minoverlap must be a positive integer value of length 1"
msgstr "minorverlap doit être un entier positif ou nul de longueur 1"

#: foverlaps.R:13
#, c-format
msgid "which must be a logical vector of length 1. Either TRUE/FALSE"
msgstr "which doit être un vecteur de booléens de longueur 1. Soit TRUE ou FALSE"

#: foverlaps.R:15
#, c-format
msgid "nomatch must either be NA or NULL"
msgstr "nomatch doit valoir soit NA soit NULL"

#: foverlaps.R:20
#, c-format
msgid "maxgap and minoverlap arguments are not yet implemented."
msgstr "les arguments maxgap et minoverlap ne sont pas encore implémentés."

#: foverlaps.R:22
#, c-format
msgid ""
"y must be keyed (i.e., sorted, and, marked as sorted). Call setkey(y, ...) "
"first, see ?setkey. Also check the examples in ?foverlaps."
msgstr ""
"y doit être transformé en 'key' (c'est-à-dire trié, et, marqué comme étant "
"trié). Appelez d'abord setkey(y, ...), voir ?setkey. Consultez également les "
"exemples dans ?foverlaps."

#: foverlaps.R:24
#, c-format
msgid ""
"'by.x' and 'by.y' should contain at least two column names (or numbers) each - "
"corresponding to 'start' and 'end' points of intervals. Please see ?foverlaps "
"and examples for more info."
msgstr ""
"'by.x' et 'by.y' doivent contenir chacun au moins deux noms de colonnes (ou "
"leurs indices) - correspondant aux bornes 'start' et 'end' des intervalles. "
"Voir ?foverlaps et les exemples pour plus d'information."

#: foverlaps.R:27
#, c-format
msgid ""
"Invalid numeric value for 'by.x'; it should be a vector with values 1 <= by.x "
"<= length(x)"
msgstr ""
"Valeur numérique non valide pour 'by.x' ; Doit être un vecteur de valeurs 1 <= "
"by.x <= length(x)"

#: foverlaps.R:32
#, c-format
msgid ""
"Invalid numeric value for 'by.y'; it should be a vector with values 1 <= by.y "
"<= length(y)"
msgstr ""
"Valeur numérique non valide pour 'by.y' ; Doit être un vecteur de valeurs 1 <= "
"by.y <= length(y)"

#: foverlaps.R:36
#, c-format
msgid "A non-empty vector of column names or numbers is required for by.x"
msgstr ""
"Un vecteur non vide de noms de colonnes ou d’indices (nombres) est nécessaire "
"pour by.x"

#: foverlaps.R:38
#, c-format
msgid "A non-empty vector of column names or numbers is required for by.y"
msgstr ""
"Un vecteur non vide de noms de colonnes ou d’indices (nombres) est nécessaire "
"pour by.y"

#: foverlaps.R:40
#, c-format
msgid ""
"The first %d columns of y's key must be identical to the columns specified in "
"by.y."
msgstr ""
"Les %d premières colonnes de la clé de y doivent être identiques aux colonnes "
"spécifiées dans by.y."

#: foverlaps.R:42
#, c-format
msgid "Elements listed in 'by.x' must be valid names in data.table x"
msgstr ""
"Les éléments listés dans 'by.x' doivent être des noms valides de la data.table "
"x"

#: foverlaps.R:44
#, c-format
msgid ""
"Duplicate columns are not allowed in overlap joins. This may change in the "
"future."
msgstr ""
"Les colonnes dupliquées ne sont pas autorisées pour la jointure avec "
"recouvrement. Ceci peut changer à l'avenir."

#: foverlaps.R:46
#, c-format
msgid ""
"length(by.x) != length(by.y). Columns specified in by.x should correspond to "
"columns specified in by.y and should be of same lengths."
msgstr ""
"length(by.x) != length(by.y). Les colonnes spécifiées dans by.x doivent "
"correspondre aux colonnes spécifiées dans by.y et être de même longueur."

#: foverlaps.R:48 foverlaps.R:50 merge.R:26 merge.R:27
#, c-format
msgid ""
"%s has some duplicated column name(s): %s. Please remove or rename the "
"duplicate(s) and try again."
msgstr ""
"%s comporte certains noms de colonnes dupliqués : %s. Veuillez supprimer les "
"doublons ou les renommer et recommencer."

#: foverlaps.R:56
#, c-format
msgid ""
"The last two columns in by.x should correspond to the 'start' and 'end' "
"intervals in data.table x and must be integer/numeric type."
msgstr ""
"Les deux dernières colonnes de by.x doivent correspondre à l'intervalle "
"'start' et 'end' de la data.table x et doivent être de type entier ou "
"numérique."

#: foverlaps.R:60 foverlaps.R:62 foverlaps.R:69 foverlaps.R:71
#, c-format
msgid ""
"NA values in data.table %s '%s' column: '%s'. All rows with NA values in the "
"range columns must be removed for foverlaps() to work."
msgstr ""
"Valeurs NA présentes dans la data.table %s colonne '%s’ : '%s'. Toutes les "
"lignes avec des valeurs NA dans l'intervalle des colonnes doivent être "
"supprimées avant d’exécuter foverlaps()."

#: foverlaps.R:63
#, c-format
msgid ""
"All entries in column '%s' should be <= corresponding entries in column '%s' "
"in data.table x."
msgstr ""
"Toutes les entrées de la colonne '%s' doivent être <= aux entrées "
"correspondantes de la colonne '%s' de la data.table x."

#: foverlaps.R:66
#, c-format
msgid ""
"The last two columns in by.y should correspond to the 'start' and 'end' "
"intervals in data.table y and must be integer/numeric type."
msgstr ""
"Les deux dernières colonnes de by.y doivent correspondre aux intervalles de "
"'start' et 'end' de la data.table y et doivent être de type entier/numérique."

#: foverlaps.R:72
#, c-format
msgid ""
"All entries in column '%s' should be <= corresponding entries in column '%s' "
"in data.table y."
msgstr ""
"Toutes les entrées de la colonne '%s' doivent être <= aux entrées "
"correspondantes de la colonne '%s' de la data.table y."

#: foverlaps.R:77
#, c-format
msgid ""
"Some interval cols are of type POSIXct while others are not. Please ensure all "
"interval cols are (or are not) of POSIXct type"
msgstr ""
"Certains interval cols sont de type POSIXct et d'autres non. Veuillez vous "
"assurer que tous les 'interval cols' sont (ou ne sont pas) de type POSIXct"

#: foverlaps.R:83
#, c-format
msgid ""
"POSIXct interval cols have mixed timezones. Overlaps are performed on the "
"internal numerical representation of POSIXct objects (always in UTC epoch "
"time), therefore printed values may give the impression that values don't "
"overlap but their internal representations do Please ensure that POSIXct type "
"interval cols have identical 'tzone' attributes to avoid confusion."
msgstr ""
"Les colonnes d'intervalles POSIXct ont des fuseaux horaires différents. Les "
"chevauchements sont effectués sur la représentation numérique interne des "
"objets POSIXct (toujours en temps UTC), par conséquent les valeurs imprimées "
"peuvent donner l'impression que les valeurs ne se chevauchent pas mais leurs "
"représentations internes le font. Veuillez vous assurer que les colonnes "
"d'intervalle de type POSIXct ont des attributs 'tzone' identiques afin "
"d'éviter toute confusion."

#: foverlaps.R:164 foverlaps.R:166 foverlaps.R:170
#, c-format
msgid "Not yet implemented"
msgstr "Non encore implémenté"

#: foverlaps.R:169
#, c-format
msgid "maxgap > minoverlap. maxgap will have no effect here."
msgstr "maxgap > minoverlap. maxgap n'a pas de conséquence ici."

#: frank.R:3
#, c-format
msgid "length(na.last) = 0"
msgstr "length(na.last) = 0"

#: frank.R:5
#, c-format
msgid "length(na.last) > 1, only the first element will be used"
msgstr "length(na.last) > 1, seul le premier élément sera utilisé"

#: frank.R:17
#, c-format
msgid "x is a single vector, non-NULL 'cols' doesn't make sense"
msgstr "x est un vecteur colonne, les 'cols' non NULL n'ont pas de sens"

#: frank.R:23
#, c-format
msgid "x is a list, 'cols' can not be 0-length"
msgstr "x est une liste, 'cols' ne peut pas avoir une longueur 0"

#: frank.R:31
#, c-format
msgid ""
"Input column '..na_prefix..' conflicts with data.table internal usage; please "
"rename"
msgstr ""
"La colonne d'entrée '..na_prefix..' est en conflit avec l'utilisation interne "
"de data.table ; Veuillez la renommer"

#: frank.R:46
#, c-format
msgid ""
"Input column '..stats_runif..' conflicts with data.table internal usage; "
"please rename"
msgstr ""
"La colonne d'entrée '..stats_runif..' est en conflit avec l'utilisation "
"interne de data.table ; Veuillez la renommer"

#: fread.R:10
#, c-format
msgid "Used more than one of the arguments input=, file=, text= and cmd=."
msgstr ""
"Plusieurs occurrences d'un des arguments suivants input=, file=, text=, cmd=."

#: fread.R:23
#, c-format
msgid "Argument 'encoding' must be 'unknown', 'UTF-8' or 'Latin-1'."
msgstr "L'argument 'encoding' doit être 'unknown', 'UTF-8' ou 'Latin-1'."

#: fread.R:42
#, c-format
msgid "'text=' is type %s but must be character."
msgstr "'text=' est de type %s mais doit être de type 'character'."

#: fread.R:55
#, c-format
msgid ""
"input= must be a single character string containing a file name, a system "
"command containing at least one space, a URL starting 'http[s]://', "
"'ftp[s]://' or 'file://', or, the input data itself containing at least one "
"\\n or \\r"
msgstr ""
"input= doit être une seule chaîne de caractères contenant un nom de fichier, "
"une commande système contenant au moins une espace, une URL commençant par "
"'http[s]://', 'ftp[s]://' ou 'file://', ou les données d'entrée elles-mêmes "
"contenant au moins un \\n ou \\r"

#: fread.R:60
#, c-format
msgid ""
"input= contains no \\n or \\r, but starts with a space. Please remove the "
"leading space, or use text=, file= or cmd="
msgstr ""
"input= ne contient ni \\n, ni \\r, mais commence par une espace. Veuillez "
"supprimer l'espace qui précède ou utiliser text=, file= ou cmd="

#: fread.R:64
#, c-format
msgid ""
"Taking input= as a system command because it contains a space ('%s'). If it's "
"a filename please remove the space, or use file= explicitly. A variable is "
"being passed to input= and when this is taken as a system command there is a "
"security concern if you are creating an app, the app could have a malicious "
"user, and the app is not running in a secure environment; e.g. the app is "
"running as root. Please read item 5 in the NEWS file for v1.11.6 for more "
"information and for the option to suppress this message."
msgstr ""
"Le contenu de l’argument input= est considéré comme une commande système parce "
"qu'il contient une espace ('%s'). S'il s'agit d'un nom de fichier, supprimez "
"l'espace ou utilisez explicitement file=. Une variable est passée à input= et "
"lorsque cela est pris comme une commande système, il y a un problème de "
"sécurité si vous créez une application. L’application pourrait alors être "
"détournée par un utilisateur malveillant, si elle ne s'exécute pas dans un "
"environnement sécurisé, par exemple si l'application s'exécute en tant que "
"root. Veuillez lire le point 5 dans le fichier NEWS pour la v1.11.6 pour plus "
"d'informations et pour l'option permettant de supprimer ce message."

#: fread.R:77
#, c-format
msgid ""
"file= must be a single character string containing a filename, or URL starting "
"'http[s]://', 'ftp[s]://' or 'file://'"
msgstr ""
"file= doit être une seule chaîne de caractères contenant un nom de fichier ou "
"une URL commençant par 'http[s]://', 'ftp[s]://' or 'file://'"

#: fread.R:90
#, c-format
msgid "File '%s' does not exist or is non-readable. getwd()=='%s'"
msgstr "Fichier '%s' absent ou non accessible en lecture. getwd()=='%s'"

#: fread.R:91
#, c-format
msgid "File '%s' is a directory. Not yet implemented."
msgstr "Le fichier '%s' est un répertoire. Ceci n’est pas encore implémenté."

#: fread.R:93
#, c-format
msgid "File '%s' has size 0. Returning a NULL %s."
msgstr "Le fichier '%s' a pour taille 0. Renvoi de %s NULL."

#: fread.R:105
#, c-format
msgid "Compressed files containing more than 1 file are currently not supported."
msgstr ""
"Les fichiers compressés contenant plusieurs fichiers ne sont pas reconnus "
"actuellement."

#: fread.R:115
#, c-format
msgid ""
"To read %s files directly, fread() requires 'R.utils' package which cannot be "
"found. Please install 'R.utils' using 'install.packages('R.utils')'."
msgstr ""
"Pour lire directement les fichiers %s, fread() a besoin du package 'R.utils' "
"qui n'a pas été trouvé. Veuillez installer 'R.utils' via 'install.packages('R."
"utils')'."

#: fread.R:125
#, c-format
msgid ""
"'autostart' is now deprecated and ignored. Consider skip='string' or skip=n"
msgstr ""
"'autostart' est maintenant obsolète et ignoré. Remplacer par skip='chaîne' ou "
"skip=n"

#: fread.R:127
#, c-format
msgid ""
"colClasses is type 'logical' which is ok if all NA but it has some TRUE or "
"FALSE values in it which is not allowed. Please consider the drop= or select= "
"argument instead. See ?fread."
msgstr ""
"colClasses est de type booléen, ce qui est acceptable si toutes les valeurs "
"sont NA, mais il contient des valeurs TRUE ou FALSE, ce qui n'est pas "
"autorisé. Veuillez considérer l'argument drop= ou select= à la place. Voir ?"
"fread."

#: fread.R:131
#, c-format
msgid "colClasses is not type list or character vector"
msgstr "colClasses n'est ni du type liste ni un vecteur de chaînes de caractères"

#: fread.R:136
#, c-format
msgid ""
"colClasses=\"NULL\" (quoted) is interpreted as colClasses=NULL (the default) "
"as opposed to dropping every column."
msgstr ""
"colClasses=\"NULL\" (avec des guillemets) est interprété comme colClasses=NULL "
"(la valeur par défaut) contrairement à la suppression de toutes les colonnes."

#: fread.R:148
#, c-format
msgid "na.strings[%d]==\"%s\" consists only of whitespace, ignoring"
msgstr "na.strings[%d]==\"%s\" n'est formé que d'espaces, il est ignoré"

#: fread.R:151
#, c-format
msgid ""
"%s. Since strip.white=TRUE (default), use na.strings=\"\" to specify that any "
"number of spaces in a string column should be read as <NA>."
msgstr ""
"%s. Parce que strip.white=TRUE (valeur par défaut), utilisez na.strings=\"\" "
"pour spécifier que toute suite d'espaces d'une colonne de chaînes doit être "
"lue comme <NA>."

#: fread.R:153
#, c-format
msgid ""
"%s. strip.white==TRUE (default) and \"\" is present in na.strings, so any "
"number of spaces in string columns will already be read as <NA>."
msgstr ""
"%s. strip.white==TRUE (par défault) et \"\" est présent dans na.strings, donc "
"toute suite d'espaces dans les colonnes de chaînes de caractères est déjà lue "
"comme étant <NA>."

#: fread.R:157
#, c-format
msgid ""
"%s. But strip.white=FALSE. Use strip.white=TRUE (default) together with na."
"strings=\"\" to turn any number of spaces in string columns into <NA>"
msgstr ""
"%s. Mais strip.white=FALSE. Utiliser strip.white=TRUE (par défaut) avec na."
"strings=\"\" pour transformer les suites d'espaces en <NA> dans les colonnes "
"de chaînes de caractères"

#: fread.R:163
#, c-format
msgid ""
"'data.table' relies on the package 'yaml' to parse the file header; please add "
"this to your library with install.packages('yaml') and try again."
msgstr ""
"'data.table' dépend du package 'yaml' pour analyser l'entête du fichier ; "
"Veuillez l’ajouter dans votre bibliothèque avec install.packages('yaml') et "
"recommencer."

#: fread.R:167
#, c-format
msgid ""
"Combining a search string as 'skip' and reading a YAML header may not work as "
"expected -- currently, reading will proceed to search for 'skip' from the "
"beginning of the file, NOT from the end of the metadata; please file an issue "
"on GitHub if you'd like to see more intuitive behavior supported."
msgstr ""
"La combinaison d'une chaîne de recherche comme 'skip' et la lecture d'un "
"entête YAML peuvent ne pas fonctionner comme prévu -- actuellement, la lecture "
"va rechercher 'skip' à partir du début du fichier, PAS à partir de la fin des "
"métadonnées ; Veuillez renseigner ce problème sur GitHub si vous souhaitez "
"qu'un comportement plus intuitif soit pris en charge."

#: fread.R:177
#, c-format
msgid ""
"Encountered <%s%s> at the first unskipped line (%d), which does not constitute "
"the start to a valid YAML header (expecting something matching regex \"%s\"); "
"please check your input and try again."
msgstr ""
"<%s%s> trouvé à la première ligne non sautée (%d), ce qui ne constitue pas le "
"début d'un entête YAML valide (on s'attendait à quelque chose correspondant à "
"l'expression régulière \"%s\") ; veuillez vérifier votre entrée et réessayer."

#: fread.R:189
#, c-format
msgid ""
"Reached the end of the file before finding a completion to the YAML header. A "
"valid YAML header is bookended by lines matching the regex \"%s\". Please "
"double check the input file is a valid csvy."
msgstr ""
"La fin du fichier est atteinte avant de trouver la fin de l'entête YAML. Un "
"entête YAML valide est complété par des lignes correspondant à l'expression "
"régulière \"%s\". Veuillez bien vérifier que le fichier d'entrée est un csvy "
"valide."

#: fread.R:203
#, c-format
msgid "User-supplied 'header' will override that found in metadata."
msgstr ""
"Le 'header' fourni par l'utilisateur redéfinira celui trouvé dans les "
"métadonnées."

#: fread.R:221
#, c-format
msgid ""
"User-supplied column names in 'col.names' will override those found in YAML "
"metadata."
msgstr ""
"Les noms de colonnes fournis par l'utilisateur dans 'col.names' remplaceront "
"ceux trouvés dans les métadonnées YAML."

#: fread.R:230
#, c-format
msgid ""
"colClasses dictated by user input and those read from YAML header are in "
"conflict (specifically, for column(s) [%s]); the proceeding assumes the user "
"input was an intentional override and will ignore the type(s) implied by the "
"YAML header; please exclude the column(s) from colClasses if this was "
"unintentional."
msgstr ""
"les colClasses imposées par les entrées de l'utilisateur et celles lues dans "
"l'entête YAML sont en conflit (en particulier, pour la/les colonne(s) [%s]) ; "
"La procédure suppose que la proposition de l'utilisateur est une modification "
"intentionnelle et ignore le(s) type(s) défini(s) par l'entête YAML ; veuillez "
"exclure la/les colonne(s) des colClasses si cela n'est pas intentionnel."

#: fread.R:251
#, c-format
msgid "User-supplied 'sep' will override that found in metadata."
msgstr ""
"Le 'sep' fourni par l'utilisateur redéfinira celui trouvé dans les métadonnées."

#: fread.R:256
#, c-format
msgid "User-supplied 'quote' will override that found in metadata."
msgstr ""
"Le 'quote' fourni par l'utilisateur redéfinira celui trouvé dans les "
"métadonnées."

#: fread.R:261
#, c-format
msgid "User-supplied 'dec' will override that found in metadata."
msgstr ""
"Le 'dec' fourni par l'utilisateur redéfinira celui trouvé dans les métadonnées."

#: fread.R:265
#, c-format
msgid "User-supplied 'na.strings' will override that found in metadata."
msgstr ""
"Le 'na.strings' fourni par l'utilisateur redéfinira celui trouvé dans les "
"métadonnées."

#: fread.R:314
#, c-format
msgid ""
"Column '%s' was requested to be '%s' but fread encountered the following %s:\n"
"\t%s\n"
"so the column has been left as type '%s'"
msgstr ""
"La colonne '%s' devait être '%s' mais fread a rencontré le problème suivant "
"%s :\n"
"\t%s\n"
"la colonne a donc été laissée au type '%s'"

#: fread.R:337
#, c-format
msgid ""
"key argument of data.table() must be a character vector naming columns (NB: "
"col.names are applied before this)"
msgstr ""
"l'argument clé de data.table() doit être un vecteur de caractères nommant les "
"colonnes (NB : col.names est appliqué avant cela)"

#: fread.R:345
#, c-format
msgid ""
"index argument of data.table() must be a character vector naming columns (NB: "
"col.names are applied before this)"
msgstr ""
"l'argument index de data.table() doit être un vecteur de chaînes de caractères "
"qui nomme les colonnes (NB: col.names est appliqué avant)"

#: fwrite.R:19
#, c-format
msgid "Argument 'encoding' must be '', 'UTF-8' or 'native'."
msgstr "L'argument 'encoding' doit être '', 'UTF-8' ou 'native'."

#: fwrite.R:24
#, c-format
msgid "dateTimeAs must be a single string"
msgstr "dateTimeAs doit être une seule chaîne de caractères"

#: fwrite.R:26
#, c-format
msgid "dateTimeAs must be 'ISO','squash','epoch' or 'write.csv'"
msgstr "dateTimeAs doit être 'ISO', 'squash', 'epoch' ou 'write.csv'"

#: fwrite.R:28
#, c-format
msgid "logicalAsInt has been renamed logical01. Use logical01 only, not both."
msgstr ""
"logicalAsInt a été renommé logical01. Utiliser logical01 uniquement, pas les "
"deux."

#: fwrite.R:30
#, c-format
msgid ""
"logicalAsInt has been renamed logical01 for consistency with fread. It works "
"fine for now but please change to logical01 at your convenience so we can "
"remove logicalAsInt in future."
msgstr ""
"logicalAsInt a été renommé logical01 pour des raisons de cohérence avec fread. "
"Cela fonctionne bien pour l'instant, mais nous vous invitons à passer à "
"logical01 à votre convenance afin que nous puissions supprimer logicalAsInt à "
"l'avenir."

#: fwrite.R:40
#, c-format
msgid "x being coerced from class: matrix to data.table"
msgstr "conversion automatique de classe pour x : matrix vers data.table"

#: fwrite.R:85
#, c-format
msgid ""
"If you intended to overwrite the file at %s with an empty one, please use file."
"remove first."
msgstr ""
"Si vous souhaitiez écraser le fichier %s par un fichier vide, utilisez d'abord "
"file.remove."

#: fwrite.R:86
#, c-format
msgid "Input has no columns; doing nothing.%s"
msgstr "L'entrée n'a pas de colonne ; aucune action réalisée. %s"

#: fwrite.R:89
#, c-format
msgid "Input has no columns; creating an empty file at '%s' and exiting."
msgstr ""
"L'entrée n'a pas de colonne ; Création d'un fichier vide à '%s' et sortie."

#: fwrite.R:96
#, c-format
msgid ""
"'data.table' relies on the package 'yaml' to write the file header; please add "
"this to your library with install.packages('yaml') and try again."
msgstr ""
"'data.table' dépend du package 'yaml' pour écrire l'entête du fichier ; "
"Veuillez l’ajouter à votre bibliothèque avec install.packages('yaml') et "
"recommencer."

#: groupingsets.R:7 groupingsets.R:25 groupingsets.R:47
#, c-format
msgid "Argument 'x' must be a data.table object"
msgstr "L'argument 'x' doit être un objet data.table"

#: groupingsets.R:9 groupingsets.R:27 groupingsets.R:53
#, c-format
msgid ""
"Argument 'by' must be a character vector of column names used in grouping."
msgstr ""
"L'argument 'by' doit être un vecteur de chaînes de caractères composé de noms "
"de colonnes utilisées pour le groupement."

#: groupingsets.R:11 groupingsets.R:29 groupingsets.R:59
#, c-format
msgid "Argument 'id' must be a logical scalar."
msgstr "L'argument 'id' doit être un scalaire booléen."

#: groupingsets.R:31
#, c-format
msgid "Argument 'j' is required"
msgstr "L'argument 'j' est obligatoire"

#: groupingsets.R:49
#, c-format
msgid "Argument 'x' is a 0-column data.table; no measure to apply grouping over."
msgstr ""
"L'argument 'x' est une data.table à 0 colonne ; Aucune possibilité de "
"groupement."

#: groupingsets.R:51
#, c-format
msgid "Input data.table must not contain duplicate column names."
msgstr "L'entrée data.table ne doit pas contenir de noms de colonnes dupliqués."

#: groupingsets.R:55
#, c-format
msgid "Argument 'by' must have unique column names for grouping."
msgstr ""
"L'argument 'by' doit avoir des noms de colonnes uniques pour le groupement."

#: groupingsets.R:57
#, c-format
msgid "Argument 'sets' must be a list of character vectors."
msgstr ""
"L'argument 'sets' doit être une liste de vecteurs de chaînes de caractères."

#: groupingsets.R:62
#, c-format
msgid ""
"All columns used in 'sets' argument must be in 'by' too. Columns used in "
"'sets' but not present in 'by': %s"
msgstr ""
"Toutes les colonnes utilisées dans l'argument 'sets' doivent également figurer "
"dans 'by'. Colonnes utilisées dans 'sets' mais non présentes dans 'by' : %s"

#: groupingsets.R:64
#, c-format
msgid ""
"When using `id=TRUE` the 'x' data.table must not have a column named "
"'grouping'."
msgstr ""
"Lorsqu'on utilise `id=TRUE`, le data.table 'x' ne doit pas avoir de colonne "
"nommée 'grouping'."

#: groupingsets.R:66
#, c-format
msgid ""
"Character vectors in 'sets' list must not have duplicated column names within "
"a single grouping set."
msgstr ""
"Les vecteurs de chaînes de caractères de la liste 'sets' ne doivent pas avoir "
"de noms de colonnes dupliqués au sein d'un même ensemble de regroupement."

#: groupingsets.R:68
#, c-format
msgid ""
"'sets' contains a duplicate (i.e., equivalent up to sorting) element at index "
"%d; as such, there will be duplicate rows in the output -- note that grouping "
"by A,B and B,A will produce the same aggregations. Use "
"`sets=unique(lapply(sets, sort))` to eliminate duplicates."
msgstr ""
"'sets' contient un élément dupliqué (c'est-à-dire équivalent lors du tri) à "
"l'index %d ; Il y aura donc des lignes dupliquées dans la sortie -- notez que "
"le regroupement par A,B et B,A produira les mêmes agrégations. Utiliser "
"`sets=unique(lapply(sets, sort))` pour éliminer les doublons."

#: groupingsets.R:73
#, c-format
msgid ""
"Expression passed to grouping sets function must not update by reference. Use "
"':=' on results of your grouping function."
msgstr ""
"L'expression transmise à la fonction de regroupement des ensembles ne doit pas "
"être mise à jour par référence. Utilisez ':=' sur les résultats de votre "
"fonction de regroupement."

#: groupingsets.R:80
#, c-format
msgid ""
"When using `id=TRUE` the 'j' expression must not evaluate to a column named "
"'grouping'."
msgstr ""
"Lors de l'utilisation de `id=TRUE`, l'expression 'j' ne doit pas être évaluée "
"à une colonne nommée 'grouping'."

#: groupingsets.R:82
#, c-format
msgid ""
"There exists duplicated column names in the results, ensure the column passed/"
"evaluated in `j` and those in `by` are not overlapping."
msgstr ""
"Le résultat comporte des doublons parmi les noms de colonnes, vérifier que les "
"colonnes passées ou évaluées dans 'j' et celles du 'by' ne se recouvrent pas."

#: groupingsets.R:92
#, c-format
msgid "Using integer64 class columns require to have 'bit64' package installed."
msgstr ""
"L'utilisation de colonnes de classe integer64 nécessite d'avoir installé le "
"package 'bit64'."

#: last.R:38 last.R:79
#, c-format
msgid ""
"'xts' class passed to %s function but 'xts' is not available, you should have "
"'xts' installed already"
msgstr ""
"la classe 'xts' est passée à la fonction %s mais le package 'xts' n'est pas "
"présent; 'xts' doit être installé auparavant"

#: merge.R:4
#, c-format
msgid "Argument 'sort' should be logical TRUE/FALSE"
msgstr "L'argument 'sort' doit être un booléen TRUE ou FALSE"

#: merge.R:6
#, c-format
msgid "Argument 'no.dups' should be logical TRUE/FALSE"
msgstr "L'argument 'no.dups' doit être un booléen TRUE ou FALSE"

#: merge.R:18
#, c-format
msgid "Neither of the input data.tables to join have columns."
msgstr "Lors de la jointure, aucune des data.tables d'entrée n'a de colonne."

#: merge.R:20 merge.R:22
#, c-format
msgid "Input data.table '%s' has no columns."
msgstr "La data.table d'entrée '%s' n'a pas de colonne."

#: merge.R:31
#, c-format
msgid "`by.x` and `by.y` must be of same length."
msgstr "'by.x' et 'by.y' doivent avoir la même longueur."

#: merge.R:33
#, c-format
msgid "Supplied both `by` and `by.x/by.y`. `by` argument will be ignored."
msgstr ""
"Quand 'by' et 'by.x/by.y' sont présents simultanément, l'argument 'by' est "
"ignoré."

#: merge.R:36
#, c-format
msgid "A non-empty vector of column names is required for `by.x` and `by.y`."
msgstr ""
"'by.x' et 'by.y' doivent être des vecteurs non vides comportant des noms de "
"colonnes."

#: merge.R:38
#, c-format
msgid "Elements listed in `by.x` must be valid column names in x."
msgstr ""
"Les éléments listés dans 'by.x' doivent être des noms de colonnes valides de x."

#: merge.R:40
#, c-format
msgid "Elements listed in `by.y` must be valid column names in y."
msgstr ""
"Les éléments listés dans 'by.y' doivent être des noms de colonnes valides de y."

#: merge.R:51
#, c-format
msgid "A non-empty vector of column names for `by` is required."
msgstr "'by' doit être un vecteur non vide de noms de colonnes."

#: merge.R:53
#, c-format
msgid "Elements listed in `by` must be valid column names in x and y"
msgstr ""
"Les éléments listés dans 'by' doivent être des noms de colonnes valides de x "
"et de y"

#: merge.R:61
#, c-format
msgid "Unknown argument '%s' has been passed."
msgstr "L'argument '%s' fourni n'est pas connu."

#: merge.R:64
#, c-format
msgid "Passed %d unknown and unnamed arguments."
msgstr "Les %d arguments fournis sont inconnus et non nommés."

#: merge.R:114
#, c-format
msgid "column names %s are duplicated in the result"
msgstr "noms de colonnes en doublon %s dans le résultat"

#: onAttach.R:23
#, c-format
msgid ""
"data.table %s IN DEVELOPMENT built %s%s using %d threads (see ?getDTthreads)."
msgstr ""
"data.table %s EN DEVELOPPEMENT build %s%s utilisant %d threads (voir ?"
"getDTthreads)."

#: onAttach.R:25
#, c-format
msgid "data.table %s using %d threads (see ?getDTthreads)."
msgstr "data.table %s utilise %d threads (voir ?getDTthreads)."

#: onAttach.R:26
#, c-format
msgid "Latest news: r-datatable.com"
msgstr "Dernières actualités : r-datatable.com"

#: onAttach.R:27
msgid "TRANSLATION CHECK"
msgstr "CONTROLE DE TRADUCTION"

#: onAttach.R:28
#, c-format
msgid ""
"**********\n"
"Running data.table in English; package support is available in English only. "
"When searching for online help, be sure to also check for the English error "
"message. This can be obtained by looking at the po/R-<locale>.po and po/"
"<locale>.po files in the package source, where the native language and English "
"error messages can be found side-by-side\n"
"**********"
msgstr ""
"**********\n"
"Exécution de data.table en anglais ; L'aide du package n'est disponible qu'en "
"anglais. Lorsque vous recherchez de l'aide en ligne, veillez à vérifier "
"également le message d'erreur en anglais. Pour ce faire, consultez les "
"fichiers po/R-<locale>.po et po/<locale>.po dans le source du package, où les "
"messages d'erreur en langue native et en anglais sont mis côte à côte\n"
"**********"

#: onAttach.R:30
#, c-format
msgid ""
"**********\n"
"This development version of data.table was built more than 4 weeks ago. Please "
"update: data.table::update_dev_pkg()\n"
"**********"
msgstr ""
"**********\n"
"Cette version de développement de data.table a été construite il y a plus de 4 "
"semaines. Veuillez mettre à jour : data.table::update_dev_pkg()\n"
"**********"

#: onAttach.R:32
#, c-format
msgid ""
"**********\n"
"This installation of data.table has not detected OpenMP support. It should "
"still work but in single-threaded mode."
msgstr ""
"**********\n"
"Cette installation de data.table n'a pas détecté le support OpenMP. Elle "
"devrait fonctionner, mais en mode monotâche."

#: onAttach.R:34
#, c-format
msgid ""
"This is a Mac. Please read https://mac.r-project.org/openmp/. Please engage "
"with Apple and ask them for support. Check r-datatable.com for updates, and "
"our Mac instructions here: https://github.com/Rdatatable/data.table/wiki/"
"Installation. After several years of many reports of installation problems on "
"Mac, it's time to gingerly point out that there have been no similar problems "
"on Windows or Linux.\n"
"**********"
msgstr ""
"Il s'agit d'un Mac. Veuillez lire https://mac.r-project.org/openmp/. Contactez "
"Apple et demandez-lui de mieux supporter OpenMP. Consultez r-datable.com pour "
"les mises à jour, et nos instructions pour Mac ici : https://github.com/"
"Rdatatable/data.table/wiki/Installation. Après plusieurs années de rapports "
"faisant état de problèmes d'installation sur Mac, il est temps de souligner "
"avec insistance qu'il n'y a pas eu de problèmes similaires sous Windows ou "
"Linux.\n"
"**********"

#: onAttach.R:36
#, c-format
msgid ""
"This is %s. This warning should not normally occur on Windows or Linux where "
"OpenMP is turned on by data.table's configure script by passing -fopenmp to "
"the compiler. If you see this warning on Windows or Linux, please file a "
"GitHub issue.\n"
"**********"
msgstr ""
"Il s'agit de %s. Cet avertissement ne doit pas se produire normalement sous "
"Windows ou Linux où OpenMP est activé par le script de configuration de data."
"table en passant -fopenmp au compilateur. Si vous voyez cet avertissement sous "
"Windows ou Linux, veuillez reporter le problème dans le gestionnaire de "
"tickets (issue tracker) sur GitHub.\n"
"**********"

#: onAttach.R:40
#, c-format
msgid ""
"**********\n"
"This data.table installation was compiled for R < 3.4.0 (Apr 2017) and is "
"known to leak memory. Please upgrade R and reinstall data.table to fix the "
"leak. Maintaining and testing code branches to support very old versions "
"increases development time so please do upgrade R. We intend to bump data."
"table's dependency from 8 year old R 3.1.0 (Apr 2014) to 5 year old R 3.4.0 "
"(Apr 2017).\n"
"**********"
msgstr ""
"**********\n"
"Cette installation de data.table a été compilée pour R < 3.4.0 (avril 2017) et "
"elle est connue pour avoir des fuites mémoire. Veuillez mettre à jour R et "
"réinstaller data.table pour corriger ces fuites. Maintenir et tester des "
"branches de code pour supporter de très anciennes versions augmentent le temps "
"de développement, veuillez donc mettre à jour R. Nous avons l'intention de "
"faire passer la dépendance de data.table du R 3.1.0 (avril 2014) d'il y a 8 "
"ans au R 3.4.0 (avril 2017) d'il y a 5 ans.\n"
"**********"

#: onLoad.R:9
#, c-format
msgid ""
"Option 'datatable.nomatch' is defined but is now ignored. Please see note 11 "
"in v1.12.4 NEWS (Oct 2019), and note 14 in v1.14.2."
msgstr ""
"L'option 'datatable.nomatch' est définie mais est désormais ignorée. Voir la "
"note 11 dans la v1.12.4 NEWS (Oct 2019), et la note 14 dans la v1.14.2."

#: onLoad.R:27
#, c-format
msgid ""
"The data_table.%s version (%s) does not match the package (%s). Please close "
"all R sessions to release the old %s and reinstall data.table in a fresh R "
"session. The root cause is that R's package installer can in some unconfirmed "
"circumstances leave a package in a state that is apparently functional but "
"where new R code is calling old C code silently: https://bugs.r-project.org/"
"bugzilla/show_bug.cgi?id=17478. Once a package is in this mismatch state it "
"may produce wrong results silently until you next upgrade the package. Please "
"help by adding precise circumstances to 17478 to move the status to confirmed. "
"This mismatch between R and C code can happen with any package not just data."
"table. It is just that data.table has added this check."
msgstr ""
"La data_table.%s version (%s) ne correspond pas au package (%s). Veuillez "
"fermer toutes les sessions R pour libérer l'ancien %s et réinstaller data."
"table dans une nouvelle session R. La cause principale est que l'installateur "
"de packages de R peut, dans certaines circonstances non confirmées, laisser un "
"package dans un état apparemment fonctionnel, mais où le nouveau code R "
"appelle silencieusement l'ancien code C : https://bugs.r-project.org/bugzilla/"
"show_bug.cgi?id=17478. Une fois qu'un package est dans cet état instable, il "
"peut produire des résultats erronés en silence jusqu'à la prochaine mise à "
"jour du package. Merci de nous aider en ajoutant des circonstances précises au "
"17478 pour faire passer le statut à confirmé. Cette incompatibilité entre le "
"code R et le code C peut se produire avec n'importe quel package, et pas "
"seulement avec data.table. C'est juste que data.table a ajouté cette "
"vérification."

#: onLoad.R:31
#, c-format
msgid ""
"This is R %s but data.table has been installed using R %s. The major version "
"must match. Please reinstall data.table."
msgstr ""
"Il s'agit de R %s mais data.table a été installé avec R %s. La version majeure "
"doit correspondre. Veuillez réinstaller data.table."

#: onLoad.R:98
#, c-format
msgid "Unexpected base R behaviour: list(x) has copied x"
msgstr "Comportement inattendu de R de base : list(x) a recopié x"

#: onLoad.R:106
#, c-format
msgid "Unexpected base R behaviour: names<- has copied column contents"
msgstr ""
"Comportement inattendu de R de base : names<- a recopié le contenu de la "
"colonne"

#: onLoad.R:116
#, c-format
msgid ""
"Unexpected base R behaviour: DF[2,2]<- did not copy column 2 which was "
"assigned to"
msgstr ""
"Comportement inattendu de la base R : DF[2,2]<- n'a pas copié la colonne 2 qui "
"était assignée à"

#: onLoad.R:117
#, c-format
msgid ""
"Unexpected base R behaviour: DF[2,2]<- copied the first column which was not "
"assigned to, too"
msgstr ""
"Comportement inattendu de la base R : DF[2,2]<- a copié la première colonne "
"qui n'a pas non plus été affectée à"

#: onLoad.R:119
#, c-format
msgid "Unexpected base R behaviour: DF[2,2]<- has not copied address(DF)"
msgstr ""
"Comportement inattendu de R de base : DF[2,2]<- n'a pas copié address(DF)"

#: openmp-utils.R:3
#, c-format
msgid "Provide either threads= or percent= but not both"
msgstr "Utiliser threads= ou percent= mais pas les deux simultanément"

#: openmp-utils.R:4
#, c-format
msgid "percent= is provided but is length %d"
msgstr "percent= est fourni mais sa longueur vaut %d"

#: openmp-utils.R:6
#, c-format
msgid "percent==%d but should be a number between 2 and 100"
msgstr "percent==%d mais doit être un nombre entre 2 et 100"

#: print.data.table.R:19
#, c-format
msgid "Valid options for col.names are 'auto', 'top', and 'none'"
msgstr "Les options valides pour col.names sont 'auto', 'top', ou 'none'"

#: print.data.table.R:21
#, c-format
msgid "Valid options for trunc.cols are TRUE and FALSE"
msgstr "Les options valides pour trunc.cols sont TRUE ou FALSE"

#: print.data.table.R:23
#, c-format
msgid "Column classes will be suppressed when col.names is 'none'"
msgstr "Les classes des colonnes seront supprimées si col.names est 'none'"

#: print.data.table.R:156
#, c-format
msgid ""
"Internal structure doesn't seem to be a list. Possibly corrupt data.table."
msgstr ""
"La structure interne ne correspond pas à une liste. La data.table est "
"éventuellement corrompue."

#: programming.R:14 programming.R:40
#, c-format
msgid "'x' must be a list"
msgstr "'x' doit être une liste"

#: programming.R:22
#, c-format
msgid ""
"Character objects provided in the input are not scalar objects, if you need "
"them as character vector rather than a name, then wrap each into 'I' call: %s"
msgstr ""
"Les objets caractères fournis en entrée ne sont pas des objets scalaires, si "
"vous avez besoin d'un vecteur de caractères plutôt que d'un nom, encadrez "
"chacun d'eux dans un appel 'I' : %s"

#: programming.R:50
#, c-format
msgid "'env' must not be missing"
msgstr "'env' doit être fourni"

#: programming.R:56
#, c-format
msgid "'env' must be a list or an environment"
msgstr "'env' doit être une liste ou un environnement"

#: programming.R:63
#, c-format
msgid "'env' argument does not have names"
msgstr "il manque les noms dans l'argument 'env'"

#: programming.R:65
#, c-format
msgid "'env' argument has zero char names"
msgstr "L’argument 'env' contient des noms à zéro caractère"

#: programming.R:67
#, c-format
msgid "'env' argument has NA names"
msgstr "l'argument 'env' comporte des noms à NA"

#: programming.R:69
#, c-format
msgid "'env' argument has duplicated names"
msgstr "l'argument 'env' contient des noms dupliqués"

#: setkey.R:3
#, c-format
msgid ""
"x may no longer be the character name of the data.table. The possibility was "
"undocumented and has been removed."
msgstr ""
"x ne peut plus être le nom sous forme de chaîne de caractère de data.table. "
"Cette possibilité n'était pas documentée et a été supprimée."

#: setkey.R:23
#, c-format
msgid ""
"key(x)<-value is deprecated and not supported. Please change to use setkey() "
"with perhaps copy(). Has been warning since 2012."
msgstr ""
"key(x)<-valeur est obsolète et n'est pas supporté. Veuillez changer pour "
"utiliser setkey() avec peut-être copy(). Avertissement depuis 2012."

#: setkey.R:39
#, c-format
msgid "x is not a data.table"
msgstr "x n'est pas une data.table"

#: setkey.R:40
#, c-format
msgid ""
"cols is not a character vector. Please see further information in ?setkey."
msgstr ""
"cols n'est pas un vecteur de chaînes de caractères. Voir les informations "
"supplémentaires dans ?setkey."

#: setkey.R:41
#, c-format
msgid ""
"Setting a physical key on .SD is reserved for possible future use; to modify "
"the original data's order by group. Try setindex() instead. Or, set*(copy(."
"SD)) as a (slow) last resort."
msgstr ""
"La définition d'une clé physique sur .SD est réservée à une utilisation future "
"possible, pour modifier l'ordre des données d'origine par groupe. Essayez "
"plutôt setindex(), ou encore, set*(copy(.SD)) en dernier recours (lent)."

#: setkey.R:43
#, c-format
msgid ""
"cols is a character vector of zero length. Removed the key, but use NULL "
"instead, or wrap with suppressWarnings() to avoid this warning."
msgstr ""
"cols est un vecteur de chaînes de caractères de longueur zéro. Supprimer la "
"clé à remplacer par NULL, ou encadrer le code dans suppressWarnings() pour "
"éviter cet avertissement."

#: setkey.R:47
#, c-format
msgid "cols is the empty string. Use NULL to remove the key."
msgstr "cols est une chaîne vide. Utiliser NULL pour supprimer la clé."

#: setkey.R:48 setkey.R:262
#, c-format
msgid "cols contains some blanks."
msgstr "cols contient des blancs."

#: setkey.R:51 setkey.R:266
#, c-format
msgid "some columns are not in the data.table: %s"
msgstr "certaines colonnes n'appartiennent pas à la data.table : %s"

#: setkey.R:59 setkey.R:267
#, c-format
msgid ""
"x contains a column called '.xi'. Conflicts with internal use by data.table."
msgstr ""
"x contient une colonne appelée '.xi'. Ceci entre en conflit avec l'utilisation "
"interne de data.table."

#: setkey.R:62
#, c-format
msgid ""
"Column '%s' is type '%s' which is not supported as a key column type, "
"currently."
msgstr ""
"La colonne '%s' a pour type '%s' qui n'est pas reconnu actuellement comme type "
"de clé de colonne."

#: setkey.R:137
#, c-format
msgid "x is vector but 'by' is supplied"
msgstr "x est un vecteur mais 'by' est fourni"

#: setkey.R:153
#, c-format
msgid "x is a single vector, non-NULL 'by' doesn't make sense"
msgstr "x est un vecteur colonne, 'by' non NULL n'a pas de sens"

#: setkey.R:184
#, c-format
msgid "Attempting to order a 0-column data.table or data.frame."
msgstr ""
"Tentative de tri d'une data.table ou d'un data.frame qui n'a pas de colonne."

#: setkey.R:189
#, c-format
msgid ""
"The first item passed to [f]order is a plain list but there are more items. It "
"should be a data.table or data.frame."
msgstr ""
"Le premier élément transmis à [f]order est une simple liste, mais il y a "
"d'autres éléments. Il faut un data.table ou un data.frame."

#: setkey.R:206
#, c-format
msgid "Internal code should not be being called on type double"
msgstr "Le code interne ne doit pas être appelé avec un type double"

#: setkey.R:214
#, c-format
msgid ""
"Input is not a vector of type double. New parallel sort has only been done for "
"double vectors so far. Using one thread."
msgstr ""
"L'entrée n'est pas un vecteur de type double. Le nouveau tri parallèle n'a été "
"implémenté que pour les vecteurs de doubles jusqu'à présent. Utilisation d'un "
"seul thread."

#: setkey.R:215
#, c-format
msgid ""
"New parallel sort has not been implemented for decreasing=TRUE so far. Using "
"one thread."
msgstr ""
"Le nouveau tri parallèle n'a pas été implémenté pour decreasing=TRUE jusqu'à "
"présent. Utilisation d'un seul thread."

#: setkey.R:216
#, c-format
msgid ""
"New parallel sort has not been implemented for vectors containing NA values so "
"far. Using one thread."
msgstr ""
"Le nouveau tri parallèle n'a pas été implémenté pour les vecteurs contenant "
"des valeurs NA jusqu'à présent. Utilisation d'un seul thread."

#: setkey.R:228 setkey.R:254
#, c-format
msgid "x must be a data.frame or data.table"
msgstr "x doit être un data.frame ou une data.table"

#: setkey.R:256
#, c-format
msgid "na.last must be logical TRUE/FALSE"
msgstr "na.last doit être un booléen TRUE ou FALSE"

#: setkey.R:257
#, c-format
msgid ""
"cols is not a character vector. Please see further information in ?setorder."
msgstr ""
"cols n'est pas un vecteur de chaînes de caractères. Voir les informations "
"supplémentaires dans ?setorder."

#: setkey.R:259
#, c-format
msgid ""
"cols is a character vector of zero length. Use NULL instead, or wrap with "
"suppressWarnings() to avoid this warning."
msgstr ""
"cols est un vecteur de caractères de longueur nulle. Utilisez NULL à la place, "
"ou utilisez suppressWarnings() pour éviter cet avertissement."

#: setkey.R:270
#, c-format
msgid "Column '%s' is type '%s' which is not supported for ordering currently."
msgstr ""
"La colonne '%s' a pour type '%s' qui n'est pas reconnu actuellement pour le "
"classement."

#: setkey.R:314
#, c-format
msgid ""
"'sorted' is TRUE but element %d is non-atomic, which can't be sorted; try "
"setting sorted = FALSE"
msgstr ""
"'sorted' vaut TRUE mais l'élément %d n'est pas atomique, on ne peut donc pas "
"le trier ; Essayez sorted = FALSE"

#: setkey.R:329
#, c-format
msgid ""
"Cross product of elements provided to CJ() would result in %.0f rows which "
"exceeds .Machine$integer.max == %d"
msgstr ""
"Le produit croisé des éléments fournis à CJ() donnerait %.0f lignes, ce qui "
"dépasse .Machine$integer.max == %d"

#: setops.R:3 setops.R:40
#, c-format
msgid "x and y must both be data.tables"
msgstr "x et y doivent être tous deux des data.tables"

#: setops.R:9
#, c-format
msgid "length(by.x) != length(by.y)"
msgstr "length(by.x) != length(by.y)"

#: setops.R:17
#, c-format
msgid ""
"When x's column ('%s') is character, the corresponding column in y ('%s') "
"should be factor or character, but found incompatible type '%s'."
msgstr ""
"Lorsqu’une colonne de x ('%s') est de type caractère, la colonne "
"correspondante de y ('%s') doit être de type facteur ou caractère, mais le "
"type actuel '%s' n'est pas compatible."

#: setops.R:19
#, c-format
msgid ""
"When x's column ('%s') is factor, the corresponding column in y ('%s') should "
"be character or factor, but found incompatible type '%s'."
msgstr ""
"Lorsque la colonne de x ('%s') est un facteur, la colonne correspondante dans "
"y ('%s') doit aussi être de type caractère ou facteur, mais un type "
"incompatible '%s' est rencontré."

#: setops.R:21
#, c-format
msgid ""
"When x's column ('%s') is integer or numeric, the corresponding column in y "
"('%s') can not be character or logical types, but found incompatible type '%s'."
msgstr ""
"Lorsque la colonne de x ('%s') est entière ou numérique, la colonne "
"correspondante dans y ('%s') ne peut pas être de type caractère ou booléen, "
"mais le type incompatible '%s' est rencontré."

#: setops.R:39
#, c-format
msgid "argument 'all' should be logical of length one"
msgstr "l'argument 'all' doit être un booléen de longueur unitaire"

#: setops.R:41
#, c-format
msgid "x and y must have the same column names"
msgstr "x et y doivent avoir les mêmes noms de colonnes"

#: setops.R:42
#, c-format
msgid "x and y must have the same column order"
msgstr "x et y doivent avoir les colonnes dans le même ordre"

#: setops.R:45
#, c-format
msgid "unsupported column type(s) found in x or y: %s"
msgstr "type(s) de colonne non supporté(s) trouvé(s) dans x ou y : %s"

#: setops.R:53
#, c-format
msgid "Item %d of x is '%s' but the corresponding item of y is '%s'."
msgstr "L'élément %d de x est '%s' mais l'élément correspondant de y est '%s'."

#: setops.R:55
#, c-format
msgid "None of the datasets should contain a column named '.seqn'"
msgstr "Aucun jeu de données ne doit contenir de colonne nommée '.seqn'"

#: setops.R:159 setops.R:170
#, c-format
msgid "Datasets have different %s. 'target': %s. 'current': %s."
msgstr "Les jeux de données ont différents %s. 'target': %s. 'current': %s."

#: setops.R:161 setops.R:162
#, c-format
msgid "has no key"
msgstr "n’a pas de clé"

#: setops.R:172 setops.R:173
#, c-format
msgid "has no index"
msgstr "n’a pas d’index"

#: setops.R:190
#, c-format
msgid "None of the datasets to compare should contain a column named '.seqn'"
msgstr ""
"Aucun des jeux de données à comparer ne doit contenir de colonne nommée '.seqn'"

#: setops.R:193
#, c-format
msgid ""
"Datasets to compare with 'ignore.row.order' must not have unsupported column "
"types: %s"
msgstr ""
"Les jeux de données à comparer avec 'ignore.row.order' ne doivent pas avoir de "
"types de colonnes non supportés : %s"

#: setops.R:195
#, c-format
msgid ""
"Argument 'tolerance' was forced to lowest accepted value `sqrt(.Machine$double."
"eps)` from provided %s"
msgstr ""
"L'argument 'tolerance' a été forcé à la plus petite valeur acceptable `sqrt(."
"Machine$double.eps)` de %s fourni"

#: setops.R:208
#, c-format
msgid ""
"Duplicate rows in datasets, numeric columns and ignore.row.order cannot be "
"used with non 0 tolerance argument"
msgstr ""
"Les doublons dans les lignes des jeux de données, les colonnes numériques et "
"ignore.row.order ne peuvent pas être utilisés avec un argument de tolérance "
"différent de 0"

#: setops.R:222
#, c-format
msgid ""
"Factor columns and ignore.row.order cannot be used with non 0 tolerance "
"argument"
msgstr ""
"Les colonnes de type facteur et ignore.row.order ne peuvent pas être utilisés "
"avec un argument de tolérance différent de 0"

#: shift.R:3
#, c-format
msgid "Provided argument fill=%s will be ignored since type='cyclic'."
msgstr "L'argument fourni fill=%s sera ignoré puisque le type='cyclique'."

#: tables.R:46
#, c-format
msgid "order.col='%s' not a column name of info"
msgstr "order.col='%s' n'est pas un nom de colonne de info"

#: test.data.table.R:17
#, c-format
msgid "data.table package is loaded. Unload or start a fresh R session."
msgstr ""
"le package data.table est chargé. Déchargez-le ou redémarrez une nouvelle "
"session R."

#: test.data.table.R:33
#, c-format
msgid ""
"script must end with '.Rraw'. If a file ending '.Rraw.bz2' exists, that will "
"be found and used."
msgstr ""
"le script doit se terminer par '.Rraw'. Si un fichier se terminant par '.Rraw."
"bz2' existe, il sera trouvé et utilisé."

#: test.data.table.R:63
#, c-format
msgid "Neither %s nor %s exist in %s"
msgstr "Ni %s, ni %s n’est trouvé dans %s"

#: test.data.table.R:118
msgid "object '%s' not found"
msgstr "objet '%s' introuvable"

#: test.data.table.R:142
#, c-format
msgid ""
"memtest intended for Linux. Step through data.table:::rss() to see what went "
"wrong."
msgstr ""
"memtest est prévu pour Linux. Investiguer à l'aide de data.table:::rss() pour "
"localiser le problème."

#: test.data.table.R:196
#, c-format
msgid "Attempt to subset to %d tests matching '%s' failed, running full suite."
msgstr ""
"La tentative de création d’un sous-ensemble de %d tests correspondant à '%s' a "
"échoué, la suite complète est en cours d'exécution."

#: test.data.table.R:245
#, c-format
msgid "Failed in %s after test %s before the next test() call in %s"
msgstr "Echec dans %s après le test %s avant l'appel suivant de test() dans %s"

#: test.data.table.R:255
#, c-format
msgid "%d error(s) out of %d. Search %s for test number(s) %s. Duration: %s."
msgstr ""
"%d erreur(s) sur %d. Recherche de %s pour le(s) test(s) numéro %s. Durée : %s."

#: test.data.table.R:268
#, c-format
msgid "Timings count mismatch: %d vs %d"
msgstr "Différence dans les délais enregistrés : %d versus %d"

#: test.data.table.R:399
#, c-format
msgid ""
"Test %s is invalid: when error= is provided it does not make sense to pass y "
"as well"
msgstr ""
"Le test %s n 'est pas valide : Si error= est fourni alors il n'a pas de sens "
"dans ce cas"

#: timetaken.R:3
#, c-format
msgid "Use started.at=proc.time() not Sys.time() (POSIXt and slow)"
msgstr ""
"Utiliser started.at=proc.time() et non pas Sys.time() (POSIXt et plus lent)"

#: transpose.R:7
#, c-format
msgid "make.names='%s' not found in names of input"
msgstr "make.names='%s' non trouvé parmi les noms d'entrée"

#: transpose.R:12
#, c-format
msgid "make.names=%d is out of range [1,ncol=%d]"
msgstr "make.names=%d hors limites [1,ncol=%d]"

#: transpose.R:28
#, c-format
msgid "'names' must be TRUE/FALSE or a character vector."
msgstr "'names' doit être TRUE ou FALSE ou un vecteur de chaînes de caractères."

#: transpose.R:34
#, c-format
msgid "'keep' should contain integer values between %d and %d."
msgstr "'keep' doit contenir des valeurs entières entre %d et %d."

#: transpose.R:51
#, c-format
msgid "The argument 'type.convert' does not support empty list."
msgstr "L'argument 'type.convert' n'accepte pas de liste vide."

#: transpose.R:57
#, c-format
msgid ""
"When the argument 'type.convert' contains an unnamed element, it is expected "
"to be the last element and should be a function. More than one unnamed element "
"is not allowed unless all elements are functions with length equal to %d (the "
"length of the transpose list or 'keep' argument if it is specified)."
msgstr ""
"Lorsque l'argument 'type.convert' contient un élément non nommé, il est censé "
"être le dernier élément et doit être une fonction. Plus d'un élément non nommé "
"n'est pas autorisé, sauf si tous les éléments sont des fonctions de longueur "
"égale à %d (la longueur de la liste de transpositions ou de l'argument 'keep' "
"s'il est spécifié)."

#: transpose.R:66
#, c-format
msgid ""
"When the argument 'type.convert' contains transpose list indices, it should be "
"a named list of non-missing integer values (with no duplicate) except the last "
"element that should be unnamed if it is a function."
msgstr ""
"Lorsque l'argument 'type.convert' contient des indices de liste de "
"transposition, il doit être une liste nommée de valeurs entières sans valeur "
"manquante (et sans doublons), à l'exception du dernier élément qui ne doit pas "
"être nommé s'il s'agit d'une fonction."

#: transpose.R:68
#, c-format
msgid ""
"When the argument 'type.convert' contains transpose list indices, they should "
"be integer values contained in the argument 'keep' (if it is specified) or be "
"between %d and %d (if it is not). But '%s' is/are not contained in '%s'."
msgstr ""
"Lorsque l'argument 'type.convert' contient des indices de liste de "
"transposition, ceux-ci doivent être des valeurs entières contenues dans "
"l'argument 'keep' (s'il est spécifié) ou comprises entre %d et %d (s'il ne "
"l'est pas). Mais '%s' n’est/ne sont pas contenu(e)s dans '%s'."

#: transpose.R:74
#, c-format
msgid ""
"In the argument 'type.convert', '%s' was ignored because all elements in the "
"transpose list or elements corresponding to indices specified in the 'keep' "
"argument have already been converted."
msgstr ""
"Dans l'argument 'type.convert', '%s' a été ignoré parce que tous les éléments "
"de la liste de transposition ou les éléments correspondant aux indices "
"spécifiés dans l'argument 'keep' ont déjà été convertis."

#: transpose.R:83
#, c-format
msgid ""
"The argument 'type.convert' should be TRUE/FALSE, a function, a list of "
"functions, or a named list of pairs 'fun=indices' with optionally one unnamed "
"element (a function) but an object of type '%s' was provided."
msgstr ""
"L'argument 'type.convert' doit être TRUE/FALSE, une fonction, une liste de "
"fonctions ou une liste nommée de paires 'fun=indices' avec éventuellement un "
"élément non nommé (une fonction), mais un objet de type '%s' a été fourni."

#: transpose.R:88
#, c-format
msgid "length(names) (= %d) is not equal to length(%s) (= %d)."
msgstr "length(names) (= %d) est différent de length(%s) (= %d)."

#: uniqlist.R:11
#, c-format
msgid "l not type list"
msgstr "l n'est pas de type 'list'"

#: utils.R:18
#, c-format
msgid "Argument 'nan' must be length 1"
msgstr "L'argument 'nan' doit être de longueur 1"

#: utils.R:21
#, c-format
msgid "Argument 'nan' must be NA or NaN"
msgstr "L'argument 'nan' doit être NA ou NaN"

#: utils.R:25
msgid "Internal error in"
msgstr "Erreur interne dans"

#: utils.R:28
msgid "Please report to the data.table issues tracker."
msgstr ""
"Veuillez signaler l'erreur au gestionnaire de tickets (issue tracker) de data."
"table."

#: utils.R:57 utils.R:66
#, c-format
msgid "x not boolean"
msgstr "x n'est pas un booléen"

#: utils.R:77
#, c-format
msgid ""
"Some columns are type 'integer64' but package bit64 is not installed. Those "
"columns will print as strange looking floating point data. There is no need to "
"reload the data. Simply install.packages('bit64') to obtain the integer64 "
"print method and print the data again."
msgstr ""
"Certaines colonnes sont de type 'integer64' mais le package bit64 n'est pas "
"installé. Ces colonnes s'afficheront sous la forme de données en virgule "
"flottante à l'aspect étrange. Il n'est pas nécessaire de recharger les "
"données. Il suffit d'installer.packages('bit64') pour obtenir la méthode "
"d'impression integer64 et imprimer à nouveau les données."

#: xts.R:3
#, c-format
msgid "keep.rownames must be length 1"
msgstr "keep.rownames doit être de longueur 1"

#: xts.R:4
#, c-format
msgid "keep.rownames must not be NA"
msgstr "keep.rownames ne peut pas être NA"

#: xts.R:10
#, c-format
msgid ""
"Input xts object should not have '%s' column because it would result in "
"duplicate column names. Rename '%s' column in xts or use `keep.rownames` to "
"change the index column name."
msgstr ""
"L'objet xts d'entrée ne doit pas avoir de colonne '%s' car cela entraînerait "
"une duplication des noms de colonnes. Renommez la colonne '%s' dans l'objet "
"xts ou utilisez `keep.rownames` pour changer le nom de la colonne d'index."

#: xts.R:20
#, c-format
msgid ""
"data.table must have a time based column in first position, use `setcolorder` "
"function to change the order, or see ?timeBased for supported types"
msgstr ""
"data.table doit avoir une colonne basée sur le temps en première position, "
"utiliser la fonction `setcolorder` pour changer l'ordre, ou voir ?timeBased "
"pour les types pris en charge"

#: xts.R:24
#, c-format
msgid "Following columns are not numeric and will be omitted: %s"
msgstr "Les colonnes suivantes ne sont pas numériques et seront omises : %s"

#: print.data.table.R:53
msgid "Index: %s\n"
msgid_plural "Indices: %s\n"
msgstr[0] "Indice : %s\n"
msgstr[1] "Indices : %s\n"

#, c-format
#~ msgid ""
#~ "Internal error -- difftime objects may not be added to IDate, but Ops "
#~ "dispatch should have intervened to prevent this"
#~ msgstr ""
#~ "Erreur interne -- les objets difftime ne peuvent pas être ajoutés à IDate, "
#~ "mais le dispatching de méthode Ops aurait dû empêcher cela"

#, c-format
#~ msgid "Internal error: storage mode of IDate is somehow no longer integer"
#~ msgstr ""
#~ "Erreur interne : le mode d'enregistrement de IDate n'est plus sous forme "
#~ "d'entiers"

#, c-format
#~ msgid ""
#~ "Internal error -- difftime objects may not be subtracted from IDate, but "
#~ "Ops dispatch should have intervened to prevent this"
#~ msgstr ""
#~ "Erreur interne -- les objets difftime ne peuvent pas être soustraits de "
#~ "IDate, mais le dispatching de méthodes Ops aurait dû empêcher cela"

#, c-format
#~ msgid ""
#~ "Internal error:  DT[, ..var] should be dealt with by the branch above now."
#~ msgstr ""
#~ "Erreur interne : DT[, ..var] doit être négocié avec la branche supérieure "
#~ "maintenant."

#, c-format
#~ msgid "Internal error. Cannot by=.EACHI when joining to an index, yet"
#~ msgstr ""
#~ "Erreur interne. Il n'est pas encore possible d'utiliser by=.EACHI pour une "
#~ "jointure vers un index"

#, c-format
#~ msgid "Internal error. irows has length in by=.EACHI"
#~ msgstr "Erreur interne. irows a la longueur dans by=.EACHI"

#, c-format
#~ msgid ""
#~ "internal error: notjoin and which=NA (non-matches), huh? please provide "
#~ "reproducible example to issue tracker"
#~ msgstr ""
#~ "erreur interne : notjoin et which=NA (ne vont pas ensemble), n’est-ce-pas ? "
#~ "Veuillez fournir un exemple reproductible pour le gestionnaire de tickets "
#~ "(issue tracker)"

#, c-format
#~ msgid "Internal error: notjoin but byjoin or !integer or nomatch==NA"
#~ msgstr "Erreur interne : notjoin mais byjoin ou !integer ou nomatch==NA"

#, c-format
#~ msgid "Internal error: irows isn't integer"
#~ msgstr "Erreur interne : irows n'est pas un entier"

#, c-format
#~ msgid "Internal error: drop_dot passed %d items"
#~ msgstr "Erreur interne : drop_dot a passé %d éléments"

#, c-format
#~ msgid "Internal error -- item '%s' not found in names of list"
#~ msgstr "Erreur interne -- élément '%s' non trouvé parmi les noms de la liste"

#, c-format
#~ msgid "Internal error -- column(s) not found: %s"
#~ msgstr "Erreur interne -- colonne(s) introuvable(s) : %s"

#, c-format
#~ msgid ""
#~ "strptime() usage detected and wrapped with as.POSIXct(). This is to "
#~ "minimize the chance of assigning POSIXlt columns, which use 40+ bytes to "
#~ "store one date (versus 8 for POSIXct). Use as.POSIXct() (which will call "
#~ "strptime() as needed internally) to avoid this warning."
#~ msgstr ""
#~ "l'utilisation de strptime() est détectée et enveloppée par as.POSIXct(). "
#~ "Ceci afin de minimiser le risque d'assigner des colonnes POSIXlt, qui "
#~ "utilisent plus de 40 octets pour stocker une date (contre 8 pour POSIXct). "
#~ "Utilisez as.POSIXct() (qui appellera strptime() si nécessaire en interne) "
#~ "pour éviter cet avertissement."

#, c-format
#~ msgid "Internal error: xcolAns does not pass checks: %d/%d/%d/%s"
#~ msgstr "Erreur interne : xcolAns ne passe pas les contrôles : %d/%d/%d/%s"

#, c-format
#~ msgid ""
#~ "Internal error: irows is NULL when making join result at R level. Should no "
#~ "longer happen now we use CsubsetDT earlier."
#~ msgstr ""
#~ "Erreur interne : irows est NULL lors de la création d'un résultat de "
#~ "jointure au niveau R. Cela ne devrait plus se produire maintenant que nous "
#~ "utilisons CsubsetDT plus tôt."

#, c-format
#~ msgid ""
#~ "Internal error: j has created a data.table result containing a NULL column"
#~ msgstr ""
#~ "Erreur interne : j a produit un résultat data.table contenant une colonne "
#~ "NULL"

#, c-format
#~ msgid "Internal error: byindex not the index name"
#~ msgstr "Erreur interne : byindex n’est pas le nom de l'index"

#, c-format
#~ msgid "Internal error: byindex not found"
#~ msgstr "Erreur interne : byindex est absent"

#, c-format
#~ msgid "Internal error: length(irows)!=length(o__)"
#~ msgstr "Erreur interne : length(irows)!=length(o__)"

#, c-format
#~ msgid "Internal error: jvnames is length %d but ans is %d and bynames is %d"
#~ msgstr ""
#~ "Erreur interne : jvnames a pour longueur %d mais ans vaut %d et bynames "
#~ "vaut %d"

#, c-format
#~ msgid ""
#~ "Internal error: as.matrix.data.table length(X)==%d but a dimension is zero"
#~ msgstr ""
#~ "Erreur interne : as.matrix.data.table length(X)==%d mais une dimension est "
#~ "à zéro"

#, c-format
#~ msgid "Internal error: length(i)!=length(new)"
#~ msgstr "Erreur interne : length(i)!=length(new)"

#, c-format
#~ msgid ""
#~ "Some columns are a multi-column type (such as a matrix column): %s. setDT "
#~ "will retain these columns as-is but subsequent operations like grouping and "
#~ "joining may fail. Please consider as.data.table() instead which will create "
#~ "a new column for each embedded column."
#~ msgstr ""
#~ "Certaines colonnes sont de type multi-colonnes (comme une colonne de "
#~ "matrice) : %s. setDT conservera ces colonnes telles quelles, mais les "
#~ "opérations ultérieures telles que le regroupement et la jointure peuvent "
#~ "échouer. Pensez plutôt à utiliser as.data.table() qui créera une nouvelle "
#~ "colonne pour chaque colonne imbriquée."

#, c-format
#~ msgid ""
#~ "Column %d is of POSIXlt type. Please convert it to POSIXct using as.POSIXct "
#~ "and run setDT again. We do not recommend use of POSIXlt at all because it "
#~ "uses 40 bytes to store one date."
#~ msgstr ""
#~ "La colonne %d est de type POSIXlt. Veuillez la convertir en POSIXct en "
#~ "utilisant as.POSIXct et relancez setDT. Nous ne recommandons pas "
#~ "l'utilisation de POSIXlt car il utilise 40 octets pour stocker une date."

#, c-format
#~ msgid ""
#~ "All elements in argument 'x' to 'setDT' must be of same length, but the "
#~ "profile of input lengths (length:frequency) is: %s\n"
#~ "The first entry with fewer than %d entries is %d."
#~ msgstr ""
#~ "Tous les éléments de l'argument 'x' de 'setDT' doivent avoir la même "
#~ "longueur, mais le profil des longueurs d'entrée (longueur:fréquence) est : "
#~ "%s\n"
#~ "La première entrée avec moins de %d entrées est %d."

#, c-format
#~ msgid ""
#~ "Internal error in .isFastSubsettable. Please report to data.table developers"
#~ msgstr ""
#~ "Erreur interne dans .isFastSubsettable. Veuillez rapporter ce point aux "
#~ "développeurs de data.table"

#, c-format
#~ msgid "Aggregate function missing, defaulting to 'length'"
#~ msgstr "Fonction d’agrégation absente, repli par défaut sur 'length'"

#~ msgid ""
#~ "Aggregating function(s) should take vector inputs and return a single value "
#~ "(length=1). However, function(s) returns length!=1. This value will have to "
#~ "be used to fill any missing combinations, and therefore must be length=1. "
#~ "Either override by setting the 'fill' argument explicitly or modify your "
#~ "function to handle this case appropriately."
#~ msgstr ""
#~ "La (les) fonction(s) d'agrégation doit (doivent) prendre des entrées "
#~ "vectorielles et renvoyer une seule valeur (length=1). Cependant, la "
#~ "fonction(s) renvoie length!=1. Cette valeur devra être utilisée pour "
#~ "remplir toutes les combinaisons manquantes, et doit donc être length=1. "
#~ "Vous pouvez soit passer outre en définissant explicitement l'argument "
#~ "'fill', soit modifier votre fonction pour gérer ce cas de manière "
#~ "appropriée."

#, c-format
#~ msgid "Internal error -- empty rhsnames in dcast; please report"
#~ msgstr ""
#~ "Erreur interne -- rhsnames est vide dans dcast ; Veuillez rapporter cette "
#~ "anomalie"

#, c-format
#~ msgid ""
#~ "URL requires download.file functionalities from R >=3.2.2. You can still "
#~ "manually download the file and fread the downloaded file."
#~ msgstr ""
#~ "L’URL nécessite les fonctionnalités de download.file à partir de R >=3.2.2. "
#~ "Il est encore possible de télécharger manuellement le fichier et de faire "
#~ "un fread dessus."

#, c-format
#~ msgid ""
#~ "Option 'datatable.CJ.names' no longer has any effect, as promised for 4 "
#~ "years. It is now ignored. Manually name `...` entries as needed if you "
#~ "still prefer the old behavior."
#~ msgstr ""
#~ "L'option 'datatable.CJ.names' n'a plus d'effet, comme explicité depuis 4 "
#~ "ans. Elle est maintenant ignorée. Nommez manuellement les entrées `...` si "
#~ "nécessaire si vous préférez toujours l'ancien comportement."

#, c-format
#~ msgid ""
#~ "Internal error. 'cols' should be character at this point in setkey; please "
#~ "report."
#~ msgstr ""
#~ "Erreur interne. 'cols' doit être de type caractère à ce niveau dans "
#~ "setkey ; Veuillez rapporter le problème."

#, c-format
#~ msgid "Internal error: index '%s' exists but is invalid"
#~ msgstr "Erreur interne : l'index '%s' existe mais il n'est pas valide"

#, c-format
#~ msgid "Internal error: ncol(current)==ncol(target) was checked above"
#~ msgstr "Erreur interne : ncol(current)==ncol(target) a été vérifié ci-dessus"

#, c-format
#~ msgid "Internal error: factor type mismatch should have been caught earlier"
#~ msgstr ""
#~ "Erreur interne : type factor incohérent ; Cela aurait dû être détecté plus "
#~ "tôt"

#~ msgid "Provided argument fill="
#~ msgstr "L’argument fill= fourni"

#~ msgid "Internal error: use endsWithAny instead of base::endsWith"
#~ msgstr "Erreur interne : utiliser endsWithAny à la place de base::endsWith"
