msgid ""
msgstr ""
"Project-Id-Version: data.table 1.15.99\n"
"POT-Creation-Date: 2025-02-02 23:58-0800\n"
"PO-Revision-Date: 2025-02-09 21:01+0300\n"
"Last-Translator: Ivan Krylov <ikrylov@disroot.org>\n"
"Language-Team: Russian <https://translate.codeberg.org/projects/data-table-"
"ru/gettext-C/ru/>\n"
"Language: ru\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=3; plural=n%10==1 && n%100!=11 ? 0 : n%10>=2 && "
"n%10<=4 && (n%100<10 || n%100>=20) ? 1 : 2;\n"
"X-Generator: Poedit 3.2.2\n"

#: assign.c:122
msgid ""
"The data.table internal attributes of this table are invalid. This is "
"expected and normal for a data.table loaded from disk. Please remember to "
"always setDT() immediately after loading to prevent unexpected behavior. If "
"this table was not loaded from disk or you've already run setDT(), please "
"report to the data.table issue tracker.\n"
msgstr ""
"Некорректные внутренние атрибуты данной data.table. Это ожидаемо и нормально "
"для таблиц, загруженных с диска. Пожалуйста, не забывайте всегда запускать "
"setDT() сразу после загрузки, чтобы избежать неожиданного поведения. Если "
"эта таблица не была загружена с диска или вы уже выполнили setDT(), сообщите "
"об этом в трекере проблем data.table.\n"

#: assign.c:203
#, c-format
msgid ""
"Some columns are a multi-column type (such as a matrix column), for example "
"column %d. setDT will retain these columns as-is but subsequent operations "
"like grouping and joining may fail. Please consider as.data.table() instead "
"which will create a new column for each embedded column."
msgstr ""
"Некоторые столбцы имеют многоколоночный тип (например, матричный столбец), "
"например столбец %d. setDT сохранит эти столбцы как есть, но последующие "
"операции, такие как группировка и объединение, могут оказаться неудачными. "
"Вместо этого используйте as.data.table(), которая создаст новый столбец для "
"каждого встроенного столбца."

#: assign.c:220
#, c-format
msgid ""
"Column %d has class 'POSIXlt'. Please convert it to POSIXct (using as."
"POSIXct) and run setDT() again. We do not recommend the use of POSIXlt at "
"all because it uses 40 bytes to store one date."
msgstr ""
"Столбец №%d имеет класс 'POSIXlt'. Пожалуйста, преобразуйте его в POSIXct (с "
"помощью as.POSIXct) и запустите setDT() снова. Мы не рекомендуем "
"использовать POSIXlt вообще, так как для хранения одной даты в нем "
"используется 40 байт."

#: assign.c:240
#, c-format
msgid ""
"All elements in argument 'x' to 'setDT' must be of equal length, but input "
"%d has length %d whereas the first non-empty input had length %d"
msgstr ""
"Все элементы в аргументе 'x' для 'setDT' должны быть одинаковой длины, но "
"входной аргумент %d имеет длину %d, в то время как первый непустой входной "
"аргумент имеет длину %d"

#: assign.c:250
msgid "alloccol has been passed a NULL dt"
msgstr "alloccol() был передан dt = NULL"

#: assign.c:251
msgid "dt passed to alloccol isn't type VECSXP"
msgstr "dt, переданный в alloccol, не имеет типа VECSXP"

#: assign.c:253
msgid ""
"dt passed to alloccol has no class attribute. Please report result of "
"traceback() to data.table issue tracker."
msgstr ""
"dt, переданный в alloccol, не имеет атрибута class. Пожалуйста, сообщите о "
"результате traceback() в службу отслеживания ошибок data.table."

#: assign.c:270
#, c-format
msgid ""
"tl (%d) is greater than 10,000 items over-allocated (l = %d). If you didn't "
"set the datatable.alloccol option to be very large, please report to data."
"table issue tracker including the result of sessionInfo()."
msgstr ""
"В результате избыточного выделения памяти tl (%d) превышает l (%d) более чем "
"на 10 000 элементов. Если вы не задали параметр datatable.alloccol очень "
"большим, сообщите об этом в трекере проблем data.table, включая результат "
"выполнения sessionInfo()."

#: assign.c:272
#, c-format
msgid ""
"Attempt to reduce allocation from %d to %d ignored. Can only increase "
"allocation via shallow copy. Please do not use DT[...]<- or DT$someCol<-. "
"Use := inside DT[...] instead."
msgstr ""
"Попытка уменьшить выделение памяти с %d элементов до %d игнорируется. Можно "
"только увеличить буфер путем поверхностного копирования. Пожалуйста, не "
"используйте DT[...]<- или DT$someCol<-. Вместо этого используйте := внутри "
"DT[...]."

#: assign.c:280
msgid ""
"Has getOption('datatable.alloccol') somehow become unset? It should be a "
"number, by default 1024."
msgstr ""
"Параметр getOption('datatable.alloccol') каким-то образом был отключен? Это "
"должно быть число, по умолчанию 1024."

#: assign.c:282
#, c-format
msgid ""
"getOption('datatable.alloccol') should be a number, by default 1024. But its "
"type is '%s'."
msgstr ""
"getOption('datatable.alloccol') должно быть числом, по умолчанию 1024. Но "
"его тип - '%s'."

#: assign.c:284
#, c-format
msgid ""
"getOption('datatable.alloc') is a numeric vector ok but its length is %d. "
"Its length should be 1."
msgstr ""
"getOption('datatable.alloc') - это числовой вектор, но его длина равна %d. "
"Его длина должна быть равна 1."

#: assign.c:287
#, c-format
msgid "getOption('datatable.alloc')==%d.  It must be >=0 and not NA."
msgstr "getOption('datatable.alloc')==%d.Оно должно быть >=0, а не NA."

#: assign.c:293 between.c:22 between.c:28 frollR.c:41 frollR.c:95 fsort.c:119
#: gsumm.c:351 gsumm.c:587 gsumm.c:733 gsumm.c:870 gsumm.c:1025 gsumm.c:1117
#: nafill.c:108 openmp-utils.c:79 uniqlist.c:354 utils.c:117 utils.c:119
#, c-format
msgid "%s must be TRUE or FALSE"
msgstr "%s должно быть TRUE или FALSE"

#: assign.c:341
msgid "assign has been passed a NULL dt"
msgstr "в assign() передано NULL значение dt"

#: assign.c:342
msgid "dt passed to assign isn't type VECSXP"
msgstr "dt, переданный функции assign, не имеет типа VECSXP"

#: assign.c:344
msgid ""
".SD is locked. Updating .SD by reference using := or set are reserved for "
"future use. Use := in j directly. Or use copy(.SD) as a (slow) last resort, "
"until shallow() is exported."
msgstr ""
".SD заблокирован. Обновление .SD по ссылке с помощью := или set "
"зарезервировано для будущего использования. Используйте := в j напрямую. Или "
"используйте copy(.SD) в качестве (медленного) последнего средства, пока "
"shallow() не будет экспортирован."

#: assign.c:356
msgid "dt passed to assign has no names"
msgstr "dt, переданный функции assign, не имеет имен"

#: assign.c:360
msgid ""
"data.table is NULL; malformed. A null data.table should be an empty list. "
"typeof() should always return 'list' for data.table."
msgstr ""
"data.table является NULL, что недопустимо. Пустая таблица data.table должна "
"быть пустым списком. typeof() всегда должна возвращать 'list' для объектов "
"data.table."

#: assign.c:370
#, c-format
msgid "Assigning to all %d rows\n"
msgstr "Назначение всех %d строк\n"

#: assign.c:375
msgid ""
"Coerced i from numeric to integer. Please pass integer for efficiency; e.g., "
"2L rather than 2"
msgstr ""
"Принудительное преобразование i из числового в целое. Для повышения "
"эффективности передавайте целое число; например, 2L, а не 2"

#: assign.c:378
#, c-format
msgid ""
"i is type '%s'. Must be integer, or numeric is coerced with warning. If i is "
"a logical subset, simply wrap with which(), and take the which() outside the "
"loop if possible for efficiency."
msgstr ""
"i имеет тип '%s'. Должно быть целым или действительным числом, иначе будет "
"преобразовано с предупреждением. Если i является логическим подмножеством, "
"просто оберните его с помощью which(), а для эффективности вынесите which() "
"за пределы цикла, если это возможно."

#: assign.c:384 subset.c:170
#, c-format
msgid "i[%d] is %d which is out of range [1,nrow=%d]"
msgstr "i[%d] = %d, что находится за пределами диапазона [1,nrow=%d]"

#: assign.c:387
#, c-format
msgid "Assigning to %d row subset of %d rows\n"
msgstr "Присвоение подмножеству из %d строк (всего %d)\n"

#: assign.c:403
msgid "length(LHS)==0; no columns to delete or assign RHS to."
msgstr "length(LHS)==0; нет столбцов для удаления или присвоения RHS."

#: assign.c:417
msgid ""
"set() on a data.frame is for changing existing columns, not adding new ones. "
"Please use a data.table for that. data.table's are over-allocated and don't "
"shallow copy."
msgstr ""
"set() в data.frame предназначен для изменения существующих столбцов, а не "
"для добавления новых. Для этого используйте класс data.table. Его объекты "
"используют избыточное выделение памяти и могут быть изменены по ссылке."

#: assign.c:428
msgid ""
"Coerced j from numeric to integer. Please pass integer for efficiency; e.g., "
"2L rather than 2"
msgstr ""
"Принудительное преобразование j из числового в целое. Для повышения "
"эффективности передавайте целое число; например, 2L, а не 2"

#: assign.c:431
#, c-format
msgid ""
"j is type '%s'. Must be integer, character, or numeric is coerced with "
"warning."
msgstr ""
"j имеет тип '%s'. Должно быть целым; строковые и действительные значения "
"будут преобразованы с выдачей предупреждения."

#: assign.c:433
msgid ""
"Can't assign to the same column twice in the same query (duplicates "
"detected)."
msgstr ""
"Невозможно дважды назначить один и тот же столбец в одном и том же запросе "
"(обнаружены дубликаты)."

#: assign.c:434
msgid "newcolnames is supplied but isn't a character vector"
msgstr "newcolnames указан, но не является вектором строк"

#: assign.c:436
msgid ""
"Values of type POSIXlt detected and converted to POSIXct. We do not "
"recommend the use of POSIXlt at all because it typically takes more than 6 "
"times the storage as an equivalent POSIXct column. Use as.POSIXct() to avoid "
"this warning."
msgstr ""
"Обнаружены значения типа POSIXlt и преобразованы в POSIXct. Пожалуйста, не "
"используйте POSIXlt с data.table, поскольку он занимает в 6 раз больше "
"места, чем эквивалентный столбец типа POSIXct. Чтобы избежать этого "
"предупреждения, используйте as.POSIXct()."

#: assign.c:446
#, c-format
msgid ""
"RHS_list_of_columns revised to true because RHS list has 1 item which is "
"NULL, or whose length %d is either 1 or targetlen (%d). Please unwrap RHS.\n"
msgstr ""
"RHS_list_of_columns пересмотрен на true, потому что в списке правой части "
"присваивания есть 1 элемент, который либо является NULL, либо длина которого "
"%d равна 1 или targetlen (%d). Пожалуйста, разверните правую сторону "
"присваивания.\n"

#: assign.c:451
#, c-format
msgid ""
"Supplied %d columns to be assigned an empty list (which may be an empty data."
"table or data.frame since they are lists too). To delete multiple columns "
"use NULL instead. To add multiple empty list columns, use list(list())."
msgstr ""
"%d переданным столбцам присваивается пустой список (который может быть "
"пустой data.table или data.frame, поскольку они тоже являются списками). "
"Чтобы удалить несколько столбцов, используйте вместо этого значение NULL. "
"Чтобы добавить несколько пустых столбцов-списков, используйте list(list())."

#: assign.c:456
#, c-format
msgid "Recycling single RHS list item across %d columns. Please unwrap RHS.\n"
msgstr ""
"Переработка одного элемента списка RHS в %d столбцов. Пожалуйста, расширьте "
"RHS.\n"

#: assign.c:458
#, c-format
msgid ""
"Supplied %d columns to be assigned %d items. Please see NEWS for v1.12.2."
msgstr ""
"Для присвоения %d столбцам предоставлено %d элементов. Пожалуйста, смотрите "
"историю изменений для версии 1.12.2."

#: assign.c:466
#, c-format
msgid ""
"Item %d of column numbers in j is %d which is outside range [1,ncol=%d]. "
"set() on a data.frame is for changing existing columns, not adding new ones. "
"Please use a data.table for that."
msgstr ""
"Среди номеров столбцов в j элемент №%d равен %d, что вне допустимого "
"диапазона номеров столбцов, [1, %d]. set() для объектов data.frame только "
"изменяет существующие столбцы, но не добавляет новые. Чтобы добавлять новые "
"столбцы через set(), используйте data.table."

#: assign.c:467
#, c-format
msgid ""
"Item %d of column numbers in j is %d which is outside range [1,ncol=%d]. Use "
"column names instead in j to add new columns."
msgstr ""
"Среди номеров столбцов в 'j' элемент №%d равен %d, что вне диапазона номеров "
"столбцов, [1, %d]. Чтобы добавлять новые столбцы, передайте в 'j' их имена, "
"а не номера."

#: assign.c:473
msgid ""
"Doubly-invalid attempt to delete a non-existent column while also providing i"
msgstr ""
"Попытка удалить несуществующий столбец (при заданном 'i', что само по себе "
"ошибка)"

#: assign.c:475
msgid ""
"Invalid attempt to delete a list column while also providing i; did you "
"intend to add NULL to those rows instead? If so, use list_col := "
"list(list(NULL))."
msgstr ""
"Нельзя удалить столбец-список, если задан 'i'; возможно, Вы хотели добавить "
"NULL к его строкам? Тогда используйте столбец_список := list(list(NULL))."

#: assign.c:476
msgid "When deleting columns, i should not be provided"
msgstr "При удалении столбцов нельзя указывать строки"

#: assign.c:484
#, c-format
msgid ""
"RHS of assignment to existing column '%s' is zero length but not NULL. If "
"you intend to delete the column use NULL. Otherwise, the RHS must have "
"length > 0; e.g., NA_integer_. If you are trying to change the column type "
"to be an empty list column then, as with all column type changes, provide a "
"full length RHS vector such as vector('list',nrow(DT)); i.e., 'plonk' in the "
"new column."
msgstr ""
"Правая часть присвоения существующему столбцу «%s» имеет нулевую длину, но "
"не NULL. Если вы собираетесь удалить столбец, используйте NULL. В противном "
"случае длина правой части должна быть > 0; например, NA_integer_. Если вы "
"пытаетесь изменить тип столбца на пустой столбец-список, то, как и при всех "
"изменениях типов столбцов, укажите в правой части полноразмерный вектор, "
"например, vector('list',nrow(DT)), чтобы напрямую подменить старый столбец "
"новым."

#: assign.c:491
#, c-format
msgid ""
"Tried to assign NULL to column '%s', but this column does not exist to remove"
msgstr ""
"Попытка присвоить NULL столбцу «%s», но этот столбец не существует и поэтому "
"не может быть удалён"

#: assign.c:499
#, c-format
msgid "%d column matrix RHS of := will be treated as one vector"
msgstr ""
"%d-столбцовая матрица в правой части := будет обработана как один вектор"

#: assign.c:504
#, c-format
msgid ""
"Can't assign to column '%s' (type 'factor') a value of type '%s' (not "
"character, factor, integer or numeric)"
msgstr ""
"Невозможно присвоить столбцу «%s» (тип «фактор») значение типа «%s» (не "
"символьное, множительное, целое или числовое)"

#: assign.c:510
#, c-format
msgid ""
"Supplied %d items to be assigned to %d items of column '%s'. If you wish to "
"'recycle' the RHS please use rep() to make this intent clear to readers of "
"your code."
msgstr ""
"Предоставленные %d элементов должны быть присвоены %d элементам столбца "
"'%s'. Если вы хотите «многократно использовать» правую часть, используйте "
"rep(), чтобы дать понять это читателям вашего кода."

#: assign.c:520
msgid ""
"This data.table has either been loaded from disk (e.g. using readRDS()/"
"load()) or constructed manually (e.g. using structure()). Please run setDT() "
"or setalloccol() on it first (to pre-allocate space for new columns) before "
"assigning by reference to it."
msgstr ""
"Эта таблица data.table была либо загружена с диска (например, с помощью "
"readRDS()/load()), либо создана вручную (например, с помощью structure()). "
"Прежде чем изменять её содержимое по ссылке, сначала выполните setDT() или "
"setalloccol() (для предварительного выделения места под новые столбцы)."

#: assign.c:523
#, c-format
msgid ""
"truelength (%d) is greater than 10,000 items over-allocated (length = %d). "
"See ?truelength. If you didn't set the datatable.alloccol option very large, "
"please report to data.table issue tracker including the result of "
"sessionInfo()."
msgstr ""
"truelength (%d) превышает длину вектора (%d) более чем на 10 000. См. "
"раздел ?truelength. Если вы не задали параметр datatable.alloccol очень "
"большим, сообщите об этом в трекере проблем data.table, включая результат "
"работы функции sessionInfo()."

#: assign.c:527
msgid ""
"It appears that at some earlier point, names of this data.table have been "
"reassigned. Please ensure to use setnames() rather than names<- or "
"colnames<-. Otherwise, please report to data.table issue tracker."
msgstr ""
"Похоже, что в какой-то момент времени имена этой таблицы data.table были "
"переназначены. Пожалуйста, убедитесь, что вы используете setnames(), а не "
"names<- или colnames<-. В противном случае, пожалуйста, сообщите об этом в "
"трекере проблем data.table."

#: assign.c:534
msgid ""
"It appears that at some earlier point, attributes of this data.table have "
"been reassigned. Please use setattr(DT, name, value) rather than attr(DT, "
"name) <- value. If that doesn't apply to you, please report your case to the "
"data.table issue tracker."
msgstr ""
"Похоже, что в какой-то момент времени атрибуты этой data.table были "
"изменены. Пожалуйста, используйте setattr(DT, имя, значение), а не attr(DT, "
"имя) <- значение. Если Вы такого не делали, пожалуйста, сообщите об этом в "
"трекере проблем data.table."

#: assign.c:564
#, c-format
msgid ""
"RHS for item %d has been duplicated because MAYBE_REFERENCED==%d "
"MAYBE_SHARED==%d, but then is being plonked. length(values)==%d; "
"length(cols)==%d\n"
msgstr ""
"В правой части элемент №%d был скопирован, поскольку MAYBE_REFERENCED==%d и "
"MAYBE_SHARED==%d, но потом присваивается напрямую. length(правая_часть)==%d; "
"length(левая_часть)==%d\n"

#: assign.c:569
#, c-format
msgid ""
"Direct plonk of unnamed RHS, no copy. MAYBE_REFERENCED==%d, "
"MAYBE_SHARED==%d\n"
msgstr ""
"Прямое, без копии присваивание безымянной правой части. "
"MAYBE_REFERENCED==%d, MAYBE_SHARED==%d\n"

#: assign.c:638
#, c-format
msgid ""
"Dropping index '%s' as it doesn't have '__' at the beginning of its name. It "
"was very likely created by v1.9.4 of data.table.\n"
msgstr ""
"Удаление индекса '%s', поскольку он не имеет '__' в начале своего имени. "
"Вероятно, он был создан в версии 1.9.4 data.table.\n"

#: assign.c:683 assign.c:699
#, c-format
msgid "Dropping index '%s' due to an update on a key column\n"
msgstr "Удаляю индекс '%s' из-за обновления столбца-ключа\n"

#: assign.c:692
#, c-format
msgid "Shortening index '%s' to '%s' due to an update on a key column\n"
msgstr "Сокращение индекса '%s' до '%s' из-за обновления столбца-ключа\n"

#: assign.c:750
#, c-format
msgid "(column %d named '%s')"
msgstr "(столбец №%d, имя '%s')"

#: assign.c:784
#, c-format
msgid ""
"Cannot assign 'factor' to '%s'. Factors can only be assigned to factor, "
"character or list columns."
msgstr ""
"Невозможно присвоить значение-фактор к «%s». Факторы можно присваивать "
"только столбцам-факторам, строкам или спискам."

#: assign.c:799
#, c-format
msgid ""
"Assigning factor numbers to target vector. But %d is outside the level range "
"[1,%d]"
msgstr ""
"Присвоение уровней факторов к целевому вектору. Но %d находится вне "
"диапазона уровней [1,%d]"

#: assign.c:801
#, c-format
msgid ""
"Assigning factor numbers to column %d named '%s'. But %d is outside the "
"level range [1,%d]"
msgstr ""
"Присвоение уровней факторов столбцу №%d под названием '%s'. Но %d находится "
"вне диапазона уровней [1,%d]"

#: assign.c:811
#, c-format
msgid ""
"Assigning factor numbers to target vector. But %f is outside the level range "
"[1,%d], or is not a whole number."
msgstr ""
"Присвоение чисел-уровней факторов целевому вектору. Но %f находится вне "
"диапазона уровней [1,%d] или не является целым числом."

#: assign.c:813
#, c-format
msgid ""
"Assigning factor numbers to column %d named '%s'. But %f is outside the "
"level range [1,%d], or is not a whole number."
msgstr ""
"Присвоение чисел-уровней факторов столбцу №%d ('%s'). Но %f находится вне "
"диапазона уровней [1,%d] или не является целым числом."

#: assign.c:819
#, c-format
msgid ""
"Cannot assign '%s' to 'factor'. Factor columns can be assigned factor, "
"character, NA in any type, or level numbers."
msgstr ""
"Не могу присвоить данные типа '%s' столбцу-фактору. Допустимы только "
"факторы, строки, NA любого типа, а также номера уровней."

#: assign.c:879
msgid "Unable to allocate working memory of %zu bytes to combine factor levels"
msgstr "Не могу выделить %zu байт, чтобы объединить уровни факторов"

#: assign.c:906
#, c-format
msgid "Coercing 'character' RHS to '%s' to match the type of target vector."
msgstr ""
"Привожу строковую правую часть к '%s', чтобы соответствовать типу целевого "
"вектора."

#: assign.c:908
#, c-format
msgid ""
"Coercing 'character' RHS to '%s' to match the type of column %d named '%s'."
msgstr ""
"Привожу строковую правую часть к '%s', чтобы соответствовать типу столбца №"
"%d ('%s')."

#: assign.c:916
msgid ""
"Cannot coerce 'list' RHS to 'integer64' to match the type of target vector."
msgstr ""
"Не могу привести правую часть-список к 'integer64' в целях соответствия типу "
"целевого вектора."

#: assign.c:918
#, c-format
msgid ""
"Cannot coerce 'list' RHS to 'integer64' to match the type of column %d named "
"'%s'."
msgstr ""
"Не могу привести правую часть-список к 'integer64', чтобы соответствовать "
"типу столбца №%d ('%s')."

#: assign.c:924
#, c-format
msgid "Coercing 'list' RHS to '%s' to match the type of target vector."
msgstr ""
"Привожу правую часть-список к '%s', чтобы соответствовать типу целевого "
"вектора."

#: assign.c:926
#, c-format
msgid "Coercing 'list' RHS to '%s' to match the type of column %d named '%s'."
msgstr ""
"Привожу правую часть-список к '%s', чтобы соответствовать типу столбца №%d "
"('%s')."

#: assign.c:934
#, c-format
msgid "Zero-copy coerce when assigning '%s' to '%s' target vector.\n"
msgstr ""
"Преобразование типов без копирования при присваивании '%s' к целевому "
"вектору типа '%s'.\n"

#: assign.c:936
#, c-format
msgid ""
"Zero-copy coerce when assigning '%s' to column %d named '%s' which is '%s'.\n"
msgstr ""
"Преобразование типов без копирования при присваивании '%s' к столбцу №%d "
"('%s') типа '%s'.\n"

#: assign.c:952
#, c-format
msgid "(target vector)"
msgstr "(целевой вектор)"

#: assign.c:962 assign.c:963
#, c-format
msgid ""
"%d (type '%s') at RHS position %d taken as TRUE when assigning to type '%s' "
"%s"
msgstr ""
"считаю как TRUE значение %d (типа '%s'), элемент правой части №%d при "
"присваивании типу '%s' %s"

#: assign.c:965
#, c-format
msgid ""
"%<PRId64> (type '%s') at RHS position %d taken as TRUE when assigning to "
"type '%s' %s"
msgstr ""
"считаю как TRUE значение %<PRId64> (типа '%s'), элемент правой части №%d при "
"присваивании типу '%s' %s"

#: assign.c:966
#, c-format
msgid ""
"%f (type '%s') at RHS position %d taken as TRUE when assigning to type '%s' "
"%s"
msgstr ""
"считаю как TRUE значение %f (типа '%s'), элемент правой части №%d при "
"присваивании типу '%s' %s"

#: assign.c:970
#, c-format
msgid ""
"%d (type '%s') at RHS position %d taken as 0 when assigning to type '%s' %s"
msgstr ""
"считаю как 0 значение %d (типа '%s'), элемент правой части №%d при "
"присваивании типу '%s' %s"

#: assign.c:972
#, c-format
msgid ""
"%<PRId64> (type '%s') at RHS position %d taken as 0 when assigning to type "
"'%s' %s"
msgstr ""
"считаю как 0 значение %<PRId64> (типа '%s'), элемент правой части №%d при "
"присваивании типу '%s' %s"

#: assign.c:973
#, c-format
msgid ""
"%f (type '%s') at RHS position %d either truncated (precision lost) or taken "
"as 0 when assigning to type '%s' %s"
msgstr ""
"округляю (с потерей точности) либо считаю за 0 значение %f (типа '%s'), "
"элемент правой части №%d при присваивании типу '%s' %s"

#: assign.c:978
#, c-format
msgid ""
"%<PRId64> (type '%s') at RHS position %d out-of-range (NA) when assigning to "
"type '%s' %s"
msgstr ""
"значение %<PRId64> (типа '%s'), элемент правой части №%d вне допустимого "
"диапазона (NA) при присваивании типу '%s' %s"

#: assign.c:979 assign.c:986
#, c-format
msgid ""
"%f (type '%s') at RHS position %d out-of-range(NA) or truncated (precision "
"lost) when assigning to type '%s' %s"
msgstr ""
"значение %f (типа '%s'), элемент правой части №%d вне допустимого диапазона "
"(NA) или округлено (с потерей точности) при присваивании типу '%s' %s"

#: assign.c:981 assign.c:990
#, c-format
msgid ""
"%f (type '%s') at RHS position %d either imaginary part discarded or real "
"part truncated (precision lost) when assigning to type '%s' %s"
msgstr ""
"отбрасываю мнимую часть либо округляю с потерей точности значение %f (типа "
"'%s'), элемент правой части №%d при присваивании типу '%s' %s"

#: assign.c:991
#, c-format
msgid ""
"%f (type '%s') at RHS position %d imaginary part discarded when assigning to "
"type '%s' %s"
msgstr ""
"отбрасываю мнимую часть значения %f (типа '%s'), элемент правой части №%d "
"при присваивании типу '%s' %s"

#: assign.c:1036
#, c-format
msgid "type '%s' cannot be coerced to '%s'"
msgstr "не могу привести значение типа '%s' к типу '%s'"

#: assign.c:1194
#, c-format
msgid "Unsupported column type in assign.c:memrecycle '%s'"
msgstr "Неподдерживаемый тип столбца '%s' в assign.c:memrecycle"

#: assign.c:1288
#, c-format
msgid "Failed to allocate initial %d items in savetl_init"
msgstr "Не удалось выделить память для первых %d элементов в savetl_init"

#: assign.c:1304
#, c-format
msgid "Failed to realloc saveds to %d items in savetl"
msgstr "Не удалось сменить размер выделенных saveds на %d в savetl"

#: assign.c:1310
#, c-format
msgid "Failed to realloc savedtl to %d items in savetl"
msgstr "Не удалось сменить размер выделенных savedl на %d в savetl"

#: assign.c:1333
msgid "x must be a character vector"
msgstr "x должен быть строковым вектором"

#: assign.c:1334
msgid "'which' must be an integer vector"
msgstr "'which' должен быть целочисленным вектором"

#: assign.c:1335
msgid "'new' must be a character vector"
msgstr "'new' должен быть строковым вектором"

#: assign.c:1336
#, c-format
msgid "'new' is length %d. Should be the same as length of 'which' (%d)"
msgstr "'new' - длины %d. Должен быть такой же длины, что и 'which' (%d)"

#: assign.c:1339
#, c-format
msgid ""
"Item %d of 'which' is %d which is outside range of the length %d character "
"vector"
msgstr ""
"Элемент 'which' №%d равен %d, что выходит за границы длины строкового "
"вектора, равной %d"

#: between.c:18
#, c-format
msgid ""
"Incompatible vector lengths: length(x)==%d length(lower)==%d "
"length(upper)==%d. Each should be either length 1 or the length of the "
"longest."
msgstr ""
"Несовместимые длины векторов: length(x)==%d; length(lower)==%d; "
"length(upper)==%d. Каждый из них должен быть либо длины 1, либо как самый "
"длинный из векторов."

#: between.c:25
msgid "NAbounds must be TRUE or NA"
msgstr "NAbounds должно быть либо TRUE, либо NA"

#: between.c:70
#, c-format
msgid "Item %d of lower (%d) is greater than item %d of upper (%d)"
msgstr ""
"Элемент №%d вектора lower (%d) превышает элемент №%d вектора upper (%d)"

#: between.c:88
#, c-format
msgid "between parallel processing of integer took %8.3fs\n"
msgstr "в функции between параллельная обработка целых чисел заняла %8.3f с\n"

#: between.c:94
msgid "x is integer64 but lower and/or upper are not."
msgstr "x является integer64, а lower и/или upper - нет."

#: between.c:101
#, c-format
msgid ""
"Item %d of lower (%<PRId64>) is greater than item %d of upper (%<PRId64>)"
msgstr ""
"Элемент №%d вектора lower (%<PRId64>) превышает элемент №%d вектора upper "
"(%<PRId64>)"

#: between.c:118
#, c-format
msgid "between parallel processing of integer64 took %8.3fs\n"
msgstr "в функции between параллельная обработка integer64 заняла %8.3f с\n"

#: between.c:121
msgid ""
"x is not integer64 but lower and/or upper is integer64. Please align classes."
msgstr ""
"x не является integer64, а lower и/или upper - являются. Пожалуйста, "
"сделайте классы единообразными."

#: between.c:128
#, c-format
msgid "Item %d of lower (%f) is greater than item %d of upper (%f)"
msgstr ""
"Элемент №%d вектора lower (%f) превышает элемент №%d вектора upper (%f)"

#: between.c:146
#, c-format
msgid "between parallel processing of double with open bounds took %8.3fs\n"
msgstr ""
"в функции between параллельная обработка чисел с плавающей запятой на "
"открытом интервале заняла %8.3f с\n"

#: between.c:163
#, c-format
msgid "between parallel processing of double with closed bounds took %8.3fs\n"
msgstr ""
"в функции between параллельная обработка чисел с плавающей запятой на "
"отрезке заняла %8.3f с\n"

#: between.c:178
#, c-format
msgid "Item %d of lower ('%s') is greater than item %d of upper ('%s')"
msgstr ""
"Элемент №%d вектора lower ('%s') сортируется выше элемента №%d вектора upper "
"('%s')"

#: between.c:193
#, c-format
msgid "between non-parallel processing of character took %8.3fs\n"
msgstr "в функции between не-параллельная обработка строк заняла %8.3f с\n"

#: bmerge.c:65
#, c-format
msgid "icols[%d]=%d outside range [1,length(i)=%d]"
msgstr "icols[%d]=%d вне допустимого диапазона [1, length(i)=%d]"

#: bmerge.c:66
#, c-format
msgid "xcols[%d]=%d outside range [1,length(x)=%d]"
msgstr "xcols[%d]=%d вне допустимого диапазона [1, length(x)=%d]"

#: bmerge.c:72
#, c-format
msgid "Type '%s' is not supported for joining/merging"
msgstr "Тип '%s' не поддерживается для операции соединения"

#: bmerge.c:78
msgid "roll is character but not 'nearest'"
msgstr "аргумент 'roll' является строкой, но не \"nearest\""

#: bmerge.c:79
msgid "roll='nearest' can't be applied to a character column, yet."
msgstr "roll='nearest' пока что нельзя применять к строковым столбцам."

#: bmerge.c:87
msgid "rollends must be a length 2 logical vector"
msgstr "rollends должен быть логическим вектором длины 2"

#: bmerge.c:116
msgid "Only '==' operator is supported for columns of type character."
msgstr "Только оператор '==' поддерживается для строковых столбцов."

#: bmerge.c:190
#, c-format
msgid "bmerge: looping bmerge_r took %.3fs\n"
msgstr "bmerge(): цикл bmerge_r занял %.3f с\n"

#: bmerge.c:222
#, c-format
msgid "bmerge: took %.3fs\n"
msgstr "bmerge: заняло %.3f с\n"

#: chmatch.c:5
#, c-format
msgid "table is type '%s' (must be 'character' or NULL)"
msgstr "table типа '%s' (должна быть типа 'character' либо NULL)"

#: chmatch.c:19
#, c-format
msgid "x is type '%s' (must be 'character' or NULL)"
msgstr "x типа '%s' (должен быть типа 'character' либо NULL)"

#: chmatch.c:106
#, c-format
msgid ""
"Failed to allocate %<PRIu64> bytes working memory in chmatchdup: "
"length(table)=%d length(unique(table))=%d"
msgstr ""
"Не могу выделить %<PRIu64> байт памяти в функции chmatchdup: "
"length(table)=%d length(unique(table))=%d"

#: cj.c:95
#, c-format
msgid "Type '%s' is not supported by CJ."
msgstr "CJ не поддерживает тип '%s'."

#: coalesce.c:20
msgid ""
"The first argument is a list, data.table or data.frame. In this case there "
"should be no other arguments provided."
msgstr ""
"Первый переданный аргумент является списком, data.frame или data.table. В "
"этом случае других аргументов быть не должно."

#: coalesce.c:36
#, c-format
msgid ""
"Item 1 is a factor but item %d is not a factor. When factors are involved, "
"all items must be factor."
msgstr ""
"Элемент №1 является фактором, но элемент №%d - не фактор. Все элементы "
"должны быть факторами, если есть хотя бы один фактор."

#: coalesce.c:38
#, c-format
msgid ""
"Item %d is a factor but its levels are not identical to the first item's "
"levels."
msgstr ""
"Элемент №%d является фактором, но его уровни не совпадают с уровнями первого "
"элемента."

#: coalesce.c:42
#, c-format
msgid ""
"Item %d is a factor but item 1 is not a factor. When factors are involved, "
"all items must be factor."
msgstr ""
"Элемент №%d является фактором, но элемент №1 - не фактор. Все элементы "
"должны быть факторами, если есть хотя бы один фактор."

#: coalesce.c:45
#, c-format
msgid ""
"Item %d is type %s but the first item is type %s. Please coerce before "
"coalescing."
msgstr ""
"Элемент №%d - типа %s, но первый элемент - типа %s. Пожалуйста, приведите "
"всё к единому типу перед вызовом fcoalesce."

#: coalesce.c:47
#, c-format
msgid "Item %d has a different class than item 1."
msgstr "Класс элемента №%d отличается от класса элемента №1."

#: coalesce.c:50
#, c-format
msgid ""
"Item %d is length %d but the first item is length %d. Only singletons are "
"recycled."
msgstr ""
"Элемент №%d длины %d, но первый элемент - длины %d. Только векторы длины 1 "
"будут рециркулированы."

#: coalesce.c:54
msgid "coalesce copied first item (inplace=FALSE)\n"
msgstr "операция coalesce скопировала первый аргумент (inplace=FALSE)\n"

#: coalesce.c:170 fifelse.c:199 shift.c:171 uniqlist.c:98 uniqlist.c:130
#: uniqlist.c:211 uniqlist.c:248 uniqlist.c:321
#, c-format
msgid "Type '%s' is not supported"
msgstr "Тип '%s' не поддерживается"

#: dogroups.c:82 gsumm.c:48
msgid "env is not an environment"
msgstr "env не является окружением"

#: dogroups.c:133
msgid "row.names attribute of .SD not found"
msgstr "у .SD не нашлось атрибута row.names"

#: dogroups.c:135
#, c-format
msgid ""
"row.names of .SD isn't integer length 2 with NA as first item; i.e., ."
"set_row_names(). [%s %d %d]"
msgstr ""
"у .SD атрибут row.names не является целочисленным вектором с NA в качестве "
"первого элемента; см. .set_row_names(). [%s %d %d]"

#: dogroups.c:166
#, c-format
msgid "length(iSD)[%d] != length(jiscols)[%d]"
msgstr "length(iSD)[%d] != length(jiscols)[%d]"

#: dogroups.c:167
#, c-format
msgid "length(xSD)[%d] != length(xjiscols)[%d]"
msgstr "length(xSD)[%d] != length(xjiscols)[%d]"

#: dogroups.c:278
#, c-format
msgid "j evaluates to type '%s'. Must evaluate to atomic vector or list."
msgstr ""
"результат вычисления j имеет тип '%s'. Он должен давать список или атомарный "
"вектор."

#: dogroups.c:287
#, c-format
msgid ""
"Entry %d for group %d in j=list(...) should be atomic vector or list. If you "
"are trying something like j=list(.SD,newcol=mean(colA)) then use := by group "
"instead (much quicker), or cbind or merge afterwards."
msgstr ""
"Элемент №%d для группы %d в j=list(...) должен быть атомарным вектором или "
"списком. Если Вы пытаетесь сделать что-то вроде j=list(.SD,"
"newcol=mean(colA)), лучше воспользуйтесь := по группам (это гораздо "
"быстрее), либо cbind()/merge() в качестве следующего шага."

#: dogroups.c:294
#, c-format
msgid ""
"Entry %d for group %d in j=list(...) is an array with %d dimensions > 1, "
"which is disallowed. \"Break\" the array yourself with c() or as.vector() if "
"that is intentional."
msgstr ""
"Элемент №%d для группы %d в j=list(...) является многомерным массивом (%d > "
"1 измерения), что не разрешено. Используйте с() или as.vector(), чтобы "
"удалить измерения."

#: dogroups.c:304
msgid ""
"RHS of := is NULL during grouped assignment, but it's not possible to delete "
"parts of a column."
msgstr ""
"Правая часть := оказалась NULL в ходе группового присваивания. Не могу "
"удалить только часть столбца."

#: dogroups.c:308
#, c-format
msgid ""
"Supplied %d items to be assigned to group %d of size %d in column '%s'. The "
"RHS length must either be 1 (single values are ok) or match the LHS length "
"exactly. If you wish to 'recycle' the RHS please use rep() explicitly to "
"make this intent clear to readers of your code."
msgstr ""
"Передано %d элементов для присваивания группе %d размером %d в столбце '%s'. "
"Длина правой части должна быть либо 1, либо в точности равна длине левой "
"части. Если хотите \"рециркулировать\" вектор другой длины, используйте "
"rep() явным (в т.ч. для читателей кода) образом."

#: dogroups.c:340
#, c-format
msgid "Group %d column '%s': %s"
msgstr "Группа %d, столбец '%s': %s"

#: dogroups.c:347
msgid "j doesn't evaluate to the same number of columns for each group"
msgstr "вычисление j даёт разное количество столбцов для разных групп"

#: dogroups.c:381
#, c-format
msgid ""
"Column %d of j's result for the first group is NULL. We rely on the column "
"types of the first result to decide the type expected for the remaining "
"groups (and require consistency). NULL columns are acceptable for later "
"groups (and those are replaced with NA of appropriate type and recycled) but "
"not for the first. Please use a typed empty vector instead, such as "
"integer() or numeric()."
msgstr ""
"Столбец %d результата вычисления 'j' для первой группы является NULL. Типы "
"столбцов первого результата определяют типы столбцов для последующих "
"результатов. Столбцы-NULL допустимы для последующих групп (и будут заменены "
"на NA соответствующего типа), но не для самой первой. Пожалуйста, "
"используйте вектор нулевой длины соответствующего типа, например, integer() "
"или numeric()."

#: dogroups.c:384
msgid ""
"j appears to be a named vector. The same names will likely be created over "
"and over again for each group and slow things down. Try and pass a named "
"list (which data.table optimizes) or an unnamed list() instead.\n"
msgstr ""
"похоже, j является именованным вектором. Вычисление j для каждой группы, "
"вероятно, приведёт к повторному созданию этих имён. Попробуйте поместить в j "
"вызов list(...) с именами (для него в data.table есть оптимизация) либо "
"неименованный список.\n"

#: dogroups.c:386
#, c-format
msgid ""
"Column %d of j is a named vector (each item down the rows is named, "
"somehow). Please remove those names for efficiency (to save creating them "
"over and over for each group). They are ignored anyway.\n"
msgstr ""
"Столбец №%d результата вычисления j является именованным вектором (почему-то "
"каждый его элемент имеет имя). Для повышения эффективности, пожалуйста, "
"уберите имена, чтобы не создавать их заново для каждой группы. Их потом всё "
"равно игнорируют.\n"

#: dogroups.c:394
msgid ""
"The result of j is a named list. It's very inefficient to create the same "
"names over and over again for each group. When j=list(...), any names are "
"detected, removed and put back after grouping has completed, for efficiency. "
"Using j=transform(), for example, prevents that speedup (consider changing "
"to :=). This message may be upgraded to warning in future.\n"
msgstr ""
"Результатом вычисления j является именованный список. Создавать имена заново "
"для каждой группы - не очень-то эффективно. Для формы j=list(...) есть "
"оптимизация, которая находит и создаёт имена только один раз, но для других "
"форм, которые могут возвращать именованные списки (например, "
"j=transform(...), что лучше заменить на :=) таких оптимизаций нет. В будущем "
"это сообщение может стать предупреждением.\n"

#: dogroups.c:406
#, c-format
msgid "dogroups: growing from %d to %d rows\n"
msgstr "dogroups: увеличение с %d до %d строк\n"

#: dogroups.c:426
#, c-format
msgid ""
"Item %d of j's result for group %d is zero length. This will be filled with "
"%d NAs to match the longest column in this result. Later groups may have a "
"similar problem but only the first is reported to save filling the warning "
"buffer."
msgstr ""
"Элемент №%d результата вычисления j для группы %d имеет длину 0. Он будет "
"заполнен NA в количестве %d, что соответствует самому длинному столбцу в "
"данной группе. Для последующих групп это сообщение выведено не будет."

#: dogroups.c:433
#, c-format
msgid ""
"Column %d of result for group %d is type '%s' but expecting type '%s'. "
"Column types must be consistent for each group."
msgstr ""
"Столбец %d результата вычисления для группы %d имеет тип '%s', хотя должен "
"быть '%s'. Типы соответствующих столбцов должны совпадать между группами."

#: dogroups.c:435
#, c-format
msgid ""
"Supplied %d items for column %d of group %d which has %d rows. The RHS "
"length must either be 1 (single values are ok) or match the LHS length "
"exactly. If you wish to 'recycle' the RHS please use rep() explicitly to "
"make this intent clear to readers of your code."
msgstr ""
"Передано %d элементов для столбца №%d группы %d, в которой %d строк. Длина "
"правой части присваивания должна быть либо 1, либо в точности совпадать с "
"длиной левой части присваивания. Если Вы хотите рециркулировать элементы, "
"пожалуйста, явным образом (в т.ч. для читателей) используйте rep()."

#: dogroups.c:453 fsort.c:266 fwrite.c:733
msgid "\n"
msgstr "\n"

#: dogroups.c:455 dogroups.c:470
#, c-format
msgid ""
"Processed %d groups out of %d. %.0f%% done. Time elapsed: %ds. ETA: %ds."
msgstr ""
"Обработано %d групп из %d. Всего сделано %.0f%%. Прошло времени: %d с. "
"Осталось: %d с."

#: dogroups.c:475
#, c-format
msgid "Wrote less rows (%d) than allocated (%d).\n"
msgstr "Записано меньше строк (%d), чем для них выделено памяти (%d).\n"

#: dogroups.c:499
#, c-format
msgid ""
"\n"
"  collecting discontiguous groups took %.3fs for %d groups\n"
msgstr ""
"\n"
"  сбор несмежных групп занял %.3f с для %d групп\n"

#: dogroups.c:500
#, c-format
msgid ""
"\n"
"  memcpy contiguous groups took %.3fs for %d groups\n"
msgstr ""
"\n"
"  memcpy() для смежных групп заняло %.3f с для %d групп\n"

#: dogroups.c:502
#, c-format
msgid "  eval(j) took %.3fs for %d calls\n"
msgstr "  eval(j) заняло %.3f с для %d вызовов\n"

#: dogroups.c:531
msgid "growVector passed NULL"
msgstr "функции growVector передан NULL"

#: fastmean.c:39 rbindlist.c:8 rbindlist.c:12
#, c-format
msgid "%s should be TRUE or FALSE"
msgstr "%s должно быть либо TRUE, либо FALSE"

#: fastmean.c:45
#, c-format
msgid "fastmean was passed type %s, not numeric or logical"
msgstr ""
"функции fastmean передано значение типа %s, не являющееся численным либо "
"логическим"

#: fcast.c:101
#, c-format
msgid "Unsupported column type in fcast val: '%s'"
msgstr "Неподдерживаемый тип столбца в функции fcast: '%s'"

#: fifelse.c:11
msgid "Argument 'test' must be logical."
msgstr "Аргумент 'test' должен быть логическим."

#: fifelse.c:15
msgid "S4 class objects (except nanotime) are not supported."
msgstr "Объекты классов S4, кроме 'nanotime', не поддерживаются."

#: fifelse.c:30
#, c-format
msgid ""
"Length of 'yes' is %<PRId64> but must be 1 or length of 'test' (%<PRId64>)."
msgstr ""
"Длина 'yes' составляет %<PRId64>, но должна быть либо 1, либо длины "
"'test' (%<PRId64>)."

#: fifelse.c:32
#, c-format
msgid ""
"Length of 'no' is %<PRId64> but must be 1 or length of 'test' (%<PRId64>)."
msgstr ""
"Длина 'no' составляет %<PRId64>, но должна быть либо 1, либо длины "
"'test' (%<PRId64>)."

#: fifelse.c:34
#, c-format
msgid ""
"Length of 'na' is %<PRId64> but must be 1 or length of 'test' (%<PRId64>)."
msgstr ""
"Длина 'na' составляет %<PRId64>, но должна быть либо 1, либо длины "
"'test' (%<PRId64>)."

#: fifelse.c:52
#, c-format
msgid ""
"'no' is of type %s but '%s' is %s. Please make all arguments have the same "
"type."
msgstr ""
"'no' типа %s, хотя '%s' типа %s. Пожалуйста, сделайте все аргументы одного "
"типа."

#: fifelse.c:58
#, c-format
msgid ""
"'na' is of type %s but '%s' is %s. Please make all arguments have the same "
"type."
msgstr ""
"'na' типа %s, хотя '%s' типа %s. Пожалуйста, сделайте все аргументы одного "
"типа."

#: fifelse.c:63
msgid ""
"'yes' has different class than 'no'. Please make sure that both arguments "
"have the same class."
msgstr ""
"Класс 'yes' отличается от класса 'no'. Пожалуйста, сделайте оба аргумента "
"одного класса."

#: fifelse.c:68
msgid ""
"'yes' has different class than 'na'. Please make sure that both arguments "
"have the same class."
msgstr ""
"Класс 'yes' отличается от класса 'na'. Пожалуйста, сделайте оба аргумента "
"одного класса."

#: fifelse.c:73
msgid ""
"'no' has different class than 'na'. Please make sure that both arguments "
"have the same class."
msgstr ""
"Класс 'no' отличается от класса 'na'. Пожалуйста, сделайте оба аргумента "
"одного класса."

#: fifelse.c:80
msgid "'yes' and 'no' are both type factor but their levels are different."
msgstr "'yes' и 'no' оба являются факторами, но их уровни отличаются."

#: fifelse.c:85
msgid "'yes' and 'na' are both type factor but their levels are different."
msgstr "'yes' и 'na' оба являются факторами, но их уровни отличаются."

#: fifelse.c:90
msgid "'no' and 'na' are both type factor but their levels are different."
msgstr "'no' и 'na' оба являются факторами, но их уровни отличаются."

#: fifelse.c:213
#, c-format
msgid ""
"Received %d inputs; please supply an even number of arguments in ..., "
"consisting of logical condition, resulting value pairs (in that order). Note "
"that the default argument must be named explicitly, e.g., default=0"
msgstr ""
"Получено %d входных аргументов; пожалуйста, передайте чётное количество "
"аргументов в ..., состоящее из пар (логическое условие, желаемое значение). "
"Обратите внимание, что аргумент default должен быть явным образом именован "
"(например, 'default = 0')"

#: fifelse.c:235
msgid ""
"S4 class objects (except nanotime) are not supported. Please see https://"
"github.com/Rdatatable/data.table/issues/4131."
msgstr ""
"Объекты классов S4 (кроме nanotime) не поддерживаются. См. https://github."
"com/Rdatatable/data.table/issues/4131."

#: fifelse.c:238
#, c-format
msgid "Argument #%d must be logical but was of type %s."
msgstr "Аргумент №%d должен быть логическим, но оказался типа %s."

#: fifelse.c:260
#, c-format
msgid ""
"Argument #%d has length %lld which differs from that of argument #1 (%lld). "
"Please make sure all logical conditions have the same length."
msgstr ""
"Аргумент №%d оказался длины %lld, что отличается от длины аргумента №1 "
"(%lld). Пожалуйста, сделайте все векторы условий одинаковой длины."

#: fifelse.c:266
#, c-format
msgid ""
"Resulting value is of type %s but 'default' is of type %s. Please make sure "
"that both arguments have the same type."
msgstr ""
"Результат вычисления оказался типа %s, но 'default' типа %s. Пожалуйста, "
"сделайте оба аргумента одного типа."

#: fifelse.c:269
#, c-format
msgid ""
"Argument #%d is of type %s, however argument #2 is of type %s. Please make "
"sure all output values have the same type."
msgstr ""
"Аргумент №%d оказался типа %s, но аргумент №2 - типа %s. Пожалуйста, "
"сделайте все результирующие значения одного типа."

#: fifelse.c:277
msgid ""
"Resulting value has different class than 'default'. Please make sure that "
"both arguments have the same class."
msgstr ""
"Класс результирующего значения отличается от класса 'default'. Пожалуйста, "
"сделайте оба аргумента одного класса."

#: fifelse.c:280
#, c-format
msgid ""
"Argument #%d has different class than argument #2, Please make sure all "
"output values have the same class."
msgstr ""
"Аргумент №%d оказался не того же класса, что аргумент №2. Пожалуйста, "
"сделайте все результирующие значения одного класса."

#: fifelse.c:289
msgid ""
"Resulting value and 'default' are both type factor but their levels are "
"different."
msgstr ""
"Результирующее значение и 'default' оба факторы, но их уровни различаются."

#: fifelse.c:291
#, c-format
msgid ""
"Argument #2 and argument #%d are both factor but their levels are different."
msgstr "Аргумент №2 и аргумент №%d оба факторы, но их уровни различаются."

#: fifelse.c:300
#, c-format
msgid "Length of 'default' must be 1 or %lld."
msgstr "Длина 'default' должна быть либо 1, либо %lld."

#: fifelse.c:302
#, c-format
msgid ""
"Length of output value #%d (%lld) must either be 1 or match the length of "
"the logical condition (%lld)."
msgstr ""
"Длина результирующего значения №%d (%lld) должна быть либо 1, либо совпадать "
"с длиной условия (%lld)."

#: fifelse.c:407
#, c-format
msgid "Type '%s' is not supported."
msgstr "Тип '%s' не поддерживается."

#: fmelt.c:18
msgid "'x' must be an integer"
msgstr "'x' должен быть целочисленным вектором"

#: fmelt.c:19
msgid "'n' must be a positive integer"
msgstr "'n' должен быть положительным целым"

#: fmelt.c:41
msgid "Argument to 'which' must be logical"
msgstr "Аргумент для функции 'which' должен быть логическим вектором"

#: fmelt.c:65
msgid "concat: 'vec' must be a character vector"
msgstr "в функции concat: 'vec' должен быть строковым вектором"

#: fmelt.c:67
msgid "concat: 'idx' must be an integer vector"
msgstr "в функции concat: 'idx' должен быть целочисленным вектором"

#: fmelt.c:135
#, c-format
msgid "Unknown 'measure.vars' type %s at index %d of list"
msgstr "Неизвестный тип %s 'measure.vars' в элементе списка №%d"

#: fmelt.c:188
msgid "One or more values in 'measure.vars' is invalid."
msgstr "Некоторые значения в 'measure.vars' являются некорректными."

#: fmelt.c:190
msgid "One or more values in 'id.vars' is invalid."
msgstr "Некоторые значения в 'id.vars' являются некорректными."

#: fmelt.c:214
#, c-format
msgid ""
"Unknown 'measure.vars' type %s, must be character or integer vector/list"
msgstr ""
"Неизвестный тип %s 'measure.vars': должен быть вектором или списком строк "
"или целых чисел"

#: fmelt.c:216
#, c-format
msgid "Unknown 'id.vars' type %s, must be character or integer vector"
msgstr ""
"Неизвестный тип %s 'id.vars': должен быть вектором строк или целых чисел"

#: fmelt.c:241
#, c-format
msgid ""
"id.vars and measure.vars are internally guessed when both are 'NULL'. All "
"non-numeric/integer/logical type columns are considered id.vars, which in "
"this case are columns [%s]. Consider providing at least one of 'id' or "
"'measure' vars in future."
msgstr ""
"Пытаюсь угадать id.vars и measure.vars, когда оба равны 'NULL'. Считаю все "
"не-числовые/логические столбцы id.vars, в этом случае [%s]. Пожалуйста, в "
"будущем передавайте хотя бы 'id.vars' или 'measure.vars'."

#: fmelt.c:247
msgid ""
"'measure.vars' is missing. Assigning all columns other than 'id.vars' "
"columns as 'measure.vars'.\n"
msgstr ""
"Аргумент 'measure.vars' не передан. Считаю ими все столбцы, которые не 'id."
"vars'.\n"

#: fmelt.c:249
#, c-format
msgid "Assigned 'measure.vars' are [%s].\n"
msgstr "Назначаю столбцы 'measure.vars' [%s].\n"

#: fmelt.c:260
msgid ""
"'id.vars' is missing. Assigning all columns other than 'measure.vars' "
"columns as 'id.vars'.\n"
msgstr ""
"Аргумент 'id.vars' не передан. Считаю ими все столбцы, которые не 'measure."
"vars'.\n"

#: fmelt.c:261
#, c-format
msgid "Assigned 'id.vars' are [%s].\n"
msgstr "Назначаю столбцы 'id.vars' [%s].\n"

#: fmelt.c:315
msgid ""
"When 'measure.vars' is a list, 'value.name' must be a character vector of "
"length =1 or =length(measure.vars)."
msgstr ""
"Если 'measure.vars' является списком, 'value.name' должен быть строковым "
"вектором длины 1 либо длины 'measure.vars'."

#: fmelt.c:316
msgid ""
"When 'measure.vars' is either not specified or a character/integer vector, "
"'value.name' must be a character vector of length =1."
msgstr ""
"Если 'measure.vars' не передан либо является строковым/целочисленным "
"вектором, 'value.name' должен быть одной строкой."

#: fmelt.c:319
msgid "'variable.name' must be a character/integer vector of length 1."
msgstr "'variable.name' должен быть одной сторокой или одним целым числом."

#: fmelt.c:372
msgid ""
"variable_table attribute of measure.vars should be a data table with at "
"least one column"
msgstr ""
"атрибут measure.vars \"variable_table\" должен быть data.table с как минимум "
"одним столбцом"

#: fmelt.c:377
#, c-format
msgid ""
"variable_table attribute of measure.vars should be a data table with same "
"number of rows as max length of measure.vars vectors =%d"
msgstr ""
"атрибут measure.vars \"variable_table\" должен быть data.table с тем же "
"количеством строк, что максимальная длина векторов 'measure.vars', %d"

#: fmelt.c:381
msgid ""
"variable_table attribute of measure.vars should be either NULL or a data "
"table"
msgstr ""
"атрибут measure.vars \"variable_table\" должен быть либо NULL, либо data."
"table"

#: fmelt.c:464
#, c-format
msgid ""
"'measure.vars' [%s] are not all of the same type. By order of hierarchy, the "
"molten data value column will be of type '%s'. All measure variables not of "
"type '%s' will be coerced too. Check DETAILS in ?melt.data.table for more on "
"coercion.\n"
msgstr ""
"'measure.vars' [%s] не все одного типа. После приведения типов столбец "
"получится типа '%s'. Все переменные не типа '%s' будут преобразованы. "
"Подробнее про приведение типов см. секцию \"Details\" в ?melt.data.table.\n"

#: fmelt.c:576
#, c-format
msgid "Unknown column type '%s' for column '%s'."
msgstr "Неизвестный тип столбца '%s' для столбца '%s'."

#: fmelt.c:600
msgid ""
"measure.vars is a list with length=1, which as long documented should return "
"integer indices in the 'variable' column, but currently returns character "
"column names. To increase consistency in the next release, we plan to change "
"'variable' to integer, so users who were relying on this behavior should "
"change measure.vars=list('col_name') (output variable is column name now, "
"but will become column index/integer) to measure.vars='col_name' (variable "
"is column name before and after the planned change)."
msgstr ""
"measure.vars является списком длины 1. Согласно документации, в этой "
"ситуации в столбце «variable» должны быть возвращены целочисленные номера "
"столбцов, однако сейчас функция возвращает имена столбцов текстом. Чтобы "
"исправить это недоразумение, в будущей версии «variable» станет "
"целочисленным столбцом. Если Вам нужны имена столбцов, вместо measure."
"vars=list('имя_столбца') (что будет возвращать номера столбцов) используйте "
"measure.vars='имя_столбца' (что и сейчас, и в будущем будет возвращать их "
"имена)."

#: fmelt.c:686
#, c-format
msgid "variable_table does not support column type '%s' for column '%s'."
msgstr "'variable_type' не поддерживает тип столбца '%s' для столбца '%s'."

#: fmelt.c:780
#, c-format
msgid "Unknown column type '%s' for column '%s' in 'data'"
msgstr "Неизвестный тип '%s' столбца '%s' в 'data'"

#: fmelt.c:791
msgid "Input is not of type VECSXP, expected a data.table, data.frame or list"
msgstr ""
"Входное значение не типа VECSXP, а должно быть data.table, data.frame или "
"хотя бы списком"

#: fmelt.c:792
msgid "Argument 'value.factor' should be logical TRUE/FALSE"
msgstr "Аргумент 'value.factor' должен быть либо TRUE, либо FALSE"

#: fmelt.c:793
msgid "Argument 'variable.factor' should be logical TRUE/FALSE"
msgstr "Аргумент 'variable.factor' должен быть либо TRUE, либо FALSE"

#: fmelt.c:794
msgid "Argument 'na.rm' should be logical TRUE/FALSE."
msgstr "Аргумент 'na.rm' должен быть либо TRUE, либо FALSE."

#: fmelt.c:795
msgid "Argument 'variable.name' must be a character vector"
msgstr "Аргумент 'variable.factor' должен быть строковым вектором"

#: fmelt.c:796
msgid "Argument 'value.name' must be a character vector"
msgstr "Аргумент 'value.name' должен быть строковым вектором"

#: fmelt.c:797
msgid "Argument 'verbose' should be logical TRUE/FALSE"
msgstr "Аргумент 'verbose' должен быть либо TRUE, либо FALSE"

#: fmelt.c:801
msgid "ncol(data) is 0. Nothing to melt. Returning original data.table."
msgstr ""
"ncol(data) равно 0, обрабатывать нечего. Возвращаю исходную data.table."

#: forder.c:111 utils.c:460
msgid "Internal error in"
msgstr "Внутренняя ошибка в"

#: forder.c:111 utils.c:460
msgid "Please report to the data.table issues tracker."
msgstr "Пожалуйста, сообщите об этом в систему отслеживания ошибок data.table."

#: forder.c:121
#, c-format
msgid "Failed to realloc thread private group size buffer to %d*4bytes"
msgstr ""
"Не удалось изменить до %d*4 байт размер выделенной памяти под размеры групп "
"внутри потока"

#: forder.c:135
#, c-format
msgid "Failed to realloc group size result to %d*4bytes"
msgstr ""
"Не удалось изменить до %d*4 байт размер выделенной памяти под длины групп"

#: forder.c:269
#, c-format
msgid ""
"Logical error. counts[0]=%d in cradix but should have been decremented to 0. "
"radix=%d"
msgstr ""
"Логическая ошибка. В функции cradix counts[0]=%d, хотя должен был "
"уменьшиться до 0. radix=%d"

#: forder.c:287
msgid "Failed to alloc cradix_counts and/or cradix_tmp"
msgstr "Не удалось выделить память под cradix_counts и/или cradix_tmp"

#: forder.c:320
#, c-format
msgid "Unable to realloc %d * %d bytes in range_str"
msgstr ""
"Не удалось изменить размер выделенной памяти до %d * %d байт в range_str"

#: forder.c:347
msgid "Failed to alloc ustr3 when converting strings to UTF8"
msgstr "Не удалось выделить память под ustr3 при переводе строк в UTF-8"

#: forder.c:366
msgid "Failed to alloc tl when converting strings to UTF8"
msgstr "Не удалось выделить tl при переводе строк в UTF-8"

#: forder.c:395
msgid "Must an integer or numeric vector length 1"
msgstr "Должно быть целым или действительным числом"

#: forder.c:396
msgid "Must be 2, 1 or 0"
msgstr "Должно быть 2, 1 или 0"

#: forder.c:431
msgid "Unknown non-finite value; not NA, NaN, -Inf or +Inf"
msgstr "Неизвестное не-конечное число: ни NA, ни NaN, ни +/- бесконечность"

#: forder.c:470
msgid ""
"Input is an atomic vector (not a list of columns) but order= is not a length "
"1 integer"
msgstr ""
"Передан атомарный вектор (а не список столбцов), но order= не является одним "
"целым числом"

#: forder.c:472
#, c-format
msgid "forder.c received a vector type '%s' length %d\n"
msgstr "forder.c получил вектор типа '%s' длиной %d\n"

#: forder.c:480
#, c-format
msgid "forder.c received %d rows and %d columns\n"
msgstr "forder.c получил %d строк и %d столбцов\n"

#: forder.c:490
#, c-format
msgid "'order' length (%d) is different to by='s length (%d)"
msgstr "длина 'order' (%d) отличается от длины by= (%d)"

#: forder.c:504
#, c-format
msgid ""
"Column %d is length %d which differs from length of column 1 (%d), are you "
"attempting to order by a list column?\n"
msgstr ""
"Столбец №%d - длины %d, что отличается от длины столбца №%d. Возможно, в "
"качестве ключа сортировки передан столбец-список?\n"

#: forder.c:508 forder.c:1654
msgid "retGrp must be TRUE or FALSE"
msgstr "retGrp должно быть TRUE или FALSE"

#: forder.c:511 forder.c:1657
msgid "retStats must be TRUE or FALSE"
msgstr "retStats должно быть TRUE или FALSE"

#: forder.c:514 forder.c:1660
msgid "retStats must be TRUE whenever retGrp is TRUE"
msgstr "retStats должно быть TRUE всегда, когда retGrp == TRUE"

#: forder.c:516 forder.c:1662
msgid "sort must be TRUE or FALSE"
msgstr "sort должно быть TRUE или FALSE"

#: forder.c:519
msgid "At least one of retGrp= or sort= must be TRUE"
msgstr "Хотя бы один аргумент из retGtp= и sort= должен быть TRUE"

#: forder.c:521 forder.c:1665
msgid "na.last must be logical TRUE, FALSE or NA of length 1"
msgstr "na.last должен быть TRUE, FALSE, или NA_logical_"

#: forder.c:555 forder.c:669
#, c-format
msgid "Unable to allocate %<PRIu64> bytes of working memory"
msgstr "Не удалось выделить %<PRIu64> байт оперативной памяти"

#: forder.c:573
#, c-format
msgid "Item %d of order (ascending/descending) is %d. Must be +1 or -1."
msgstr ""
"Элемент 'order' №%d (сортировка по возрастанию/убыванию) равен %d, а должен "
"быть +/-1."

#: forder.c:603
#, c-format
msgid ""
"\n"
"*** Column %d passed to forder is a date stored as an 8 byte double but no "
"fractions are present. Please consider a 4 byte integer date such as IDate "
"to save space and time.\n"
msgstr ""
"\n"
"*** Столбец №%d, переданный forder, хранит даты в виде 8-байтных чисел с "
"плавающей запятой, но все числа целые. Возможно, лучше будет использовать 4-"
"байтный класс IDate, чтобы сэкономить время и место.\n"

#: forder.c:615
#, c-format
msgid "Column %d passed to [f]order is type '%s', not yet supported."
msgstr ""
"Столбец №%d, переданный [f]order, оказался типа '%s', что пока не "
"поддерживается."

#: forder.c:792
#, c-format
msgid ""
"Failed to allocate TMP or UGRP or they weren't cache line aligned: nth=%d"
msgstr ""
"Не удалось выделить оперативную память под TMP или UGRP, либо они не были "
"выровнены по границе линии кэш-памяти: nth=%d"

#: forder.c:801
msgid "Could not allocate (very tiny) group size thread buffers"
msgstr ""
"Не удалось выделить (совсем немного) оперативной памяти под принадлежащие "
"потокам буферы размеров групп"

#: forder.c:869
#, c-format
msgid "Timing block %2d%s = %8.3f   %8d\n"
msgstr "Время блока %2d%s = %8.3f   %8d\n"

#: forder.c:919 forder.c:989 forder.c:1011 forder.c:1113 forder.c:1244
#: forder.c:1300 fread.c:2643
#, c-format
msgid "Failed to allocate %d bytes for '%s'."
msgstr "Не удалось выделить %d байт оперативной памяти под '%s'."

#: forder.c:1144
#, c-format
msgid "Failed to allocate parallel counts. my_n=%d, nBatch=%d"
msgstr ""
"Не удалось выделить память под счета параллельных блоков. my_n=%d, nBatch=%d"

#: forder.c:1156
#, c-format
msgid "Failed to allocate 'my_otmp' and/or 'my_ktmp' arrays (%d bytes)."
msgstr ""
"Не удалось выделить память под массивы 'my_otmp' и/или 'my_ktmp' (%d байт)."

#: forder.c:1261
#, c-format
msgid "Unable to allocate TMP for my_n=%d items in parallel batch counting"
msgstr ""
"Не удалось выделить память под TMP для my_n=%d элементов при подсчёте "
"параллельных блоков"

#: forder.c:1376 forder.c:1427
#, c-format
msgid "issorted 'by' [%d] out of range [1,%d]"
msgstr "в функции issorted 'by' [%d] вне диапазона [1,%d]"

#: forder.c:1381
msgid "is.sorted does not work on list columns"
msgstr "is.sorted не работает на столбцах-списках"

#: forder.c:1414 forder.c:1444 forder.c:1478
#, c-format
msgid "type '%s' is not yet supported"
msgstr "тип '%s' пока не поддерживается"

#: forder.c:1491
msgid "x must be either NULL or an integer vector"
msgstr "x должен быть либо NULL, либо целочисленный вектор"

#: forder.c:1493
msgid "nrow must be integer vector length 1"
msgstr "nrow должен быть одним целым числом"

#: forder.c:1495
#, c-format
msgid "nrow==%d but must be >=0"
msgstr "nrow==%d, но должен быть >= 0"

#: forder.c:1512
msgid "x must be type 'double'"
msgstr "x должен быть типа 'double'"

#: forder.c:1622
msgid "'datatable.use.index' option must be TRUE or FALSE"
msgstr "опция 'datatable.use.index' должна быть TRUE или FALSE"

#: forder.c:1635
msgid "'datatable.forder.auto.index' option must be TRUE or FALSE"
msgstr "опция 'datatable.forder.auto.index' должна быть TRUE или FALSE"

#: forder.c:1652
msgid "DT is NULL"
msgstr "вместо аргумента-data.table передан NULL"

#: forder.c:1668
msgid "order must be integer"
msgstr "order должен быть целочисленным"

#: forder.c:1670
msgid "reuseSorting must be logical TRUE, FALSE or NA of length 1"
msgstr "reuseSorting должно быть TRUE, FALSE, или NA_logical_"

#: forder.c:1682
#, c-format
msgid ""
"forderReuseSorting: opt not possible: is.data.table(DT)=%d, sortGroups=%d, "
"all1(ascArg)=%d\n"
msgstr ""
"forderReuseSorting(): не могу оптимизировать: is.data.table(DT)=%d, "
"sortGroups=%d, all1(ascArg)=%d\n"

#: forder.c:1701
#, c-format
msgid "forderReuseSorting: using key: %s\n"
msgstr "forderReuseSorting(): использую ключ: %s\n"

#: forder.c:1736
#, c-format
msgid "forderReuseSorting: index found but not for retGrp and retStats: %s\n"
msgstr ""
"forderReuseSorting(): индекс найден, но не для 'retGrp' и 'retStats': %s\n"

#: forder.c:1739
#, c-format
msgid "forderReuseSorting: index found but not for retGrp: %s\n"
msgstr "forderReuseSorting(): индекс найден, но не для retGrp: %s\n"

#: forder.c:1742
#, c-format
msgid "forderReuseSorting: index found but not for retStats: %s\n"
msgstr "forderReuseSorting(): индекс найден, но не для 'retStats': %s\n"

#: forder.c:1749
#, c-format
msgid ""
"forderReuseSorting: index found but na.last=TRUE and no stats available: %s\n"
msgstr ""
"forderReuseSorting(): индекс найден, но na.last=TRUE и соответствующая "
"информация недоступна: %s\n"

#: forder.c:1752
#, c-format
msgid "forderReuseSorting: index found but na.last=TRUE and NAs present: %s\n"
msgstr ""
"forderReuseSorting(): индекс найден, но na.last=TRUE и присутствуют "
"пропущенные значения: %s\n"

#: forder.c:1760
#, c-format
msgid "forderReuseSorting: using existing index: %s\n"
msgstr "forderReuseSorting(): использую существующий индекс: %s\n"

#: forder.c:1772
#, c-format
msgid "forderReuseSorting: setting index (retGrp=%d, retStats=%d) on DT: %s\n"
msgstr ""
"forderReuseSorting(): создаю индекс (retGrp=%d, retStats=%d) на таблице "
"данных: %s\n"

#: forder.c:1776
#, c-format
msgid "forderReuseSorting: opt=%d, took %.3fs\n"
msgstr "forderReuseSorting(): opt=%d, заняло %.3f с\n"

#: frank.c:14 frank.c:192
#, c-format
msgid "Item %d of 'cols' is %d which is outside 1-based range [1,ncol(x)=%d]"
msgstr "Элемент вектора 'cols' №%d равен %d, что вне диапазона [1, ncol(x)=%d]"

#: frank.c:24 frank.c:200
#, c-format
msgid ""
"Column %d of input list x is length %d, inconsistent with first column of "
"that item which is length %d."
msgstr ""
"Столбец №%d входного списка 'x' имеет длину %d, что несовместимо с первым "
"столбцом, который имеет длину %d."

#: frank.c:101 frank.c:234 transpose.c:97
#, c-format
msgid "Unsupported column type '%s'"
msgstr "Неподдерживаемый тип столбца '%s'"

#: fread.c:155
#, c-format
msgid "System error %lu unmapping view of file\n"
msgstr ""
"Системная ошибка %lu при попытке удалить отображение файла в адресное "
"пространство\n"

#: fread.c:158
#, c-format
msgid "System errno %d unmapping file: %s\n"
msgstr ""
"Системная ошибка %d при попытке удалить отображение файла в адресное "
"пространство: %s\n"

#: fread.c:1308
msgid ""
"Previous fread() session was not cleaned up properly. Cleaned up ok at the "
"beginning of this fread() call.\n"
msgstr ""
"Предыдущий вызов fread() не был корректно завершён. Оставшиеся ресурсы "
"возвращены в начале этого вызова fread().\n"

#: fread.c:1311
msgid "[01] Check arguments\n"
msgstr "[01] Проверка аргументов\n"

#: fread.c:1318
#, c-format
msgid "  Using %d threads (omp_get_max_threads()=%d, nth=%d)\n"
msgstr "  Использую %d потоков (omp_get_max_threads()=%d, nth=%d)\n"

#: fread.c:1340
#, c-format
msgid "freadMain: NAstring <<%s>> has whitespace at the beginning or end"
msgstr ""
"freadMain: NAstring «%s» содержит пробельные символы в начале или конце"

#: fread.c:1344
#, c-format
msgid ""
"freadMain: NAstring <<%s>> is recognized as type boolean, this is not "
"permitted."
msgstr ""
"freadMain: NAstring «%s» распознаётся как логическая, что не разрешено."

#: fread.c:1346 fread.c:1348
#, c-format
msgid "freadMain: NAstring <<%s>> and %s=TRUE, this is not permitted."
msgstr "freadMain: NAstring «%s» и %s=TRUE, что не разрешено."

#: fread.c:1361
msgid "  No NAstrings provided.\n"
msgstr "  NAstrings не указаны.\n"

#: fread.c:1368
msgid "  One or more of the NAstrings looks like a number.\n"
msgstr "  Одна или несколько NAstrings выглядят как число.\n"

#: fread.c:1370
msgid "  None of the NAstrings look like numbers.\n"
msgstr "  Ни одна из NAstrings не выглядят как числа.\n"

#: fread.c:1372
#, c-format
msgid "  skip num lines = %<PRId64>\n"
msgstr "  пропускаю строк = %<PRId64>\n"

#: fread.c:1373
#, c-format
msgid "  skip to string = <<%s>>\n"
msgstr "  пропустить до строки = «%s»\n"

#: fread.c:1374
#, c-format
msgid "  show progress = %d\n"
msgstr "  показывать индикатор выполнения = %d\n"

#: fread.c:1375
#, c-format
msgid "  0/1 column will be read as %s\n"
msgstr "  буду читать столбцы из 0/1 как %s\n"

#: fread.c:1376
#, c-format
msgid "  Y/N column will be read as %s\n"
msgstr "  буду читать столбцы с «Y»/«N» как %s\n"

#: fread.c:1388
#, c-format
msgid "sep == quote ('%c') is not allowed"
msgstr "sep == quote ('%c') не разрешено"

#: fread.c:1389
#, c-format
msgid "sep == dec ('%c') is not allowed"
msgstr "sep == dec ('%c') не разрешено"

#: fread.c:1390
#, c-format
msgid "quote == dec ('%c') is not allowed"
msgstr "quote == dec ('%c') не разрешено"

#: fread.c:1407
msgid "[02] Opening the file\n"
msgstr "[02] Открываю файл\n"

#: fread.c:1410
msgid ""
"  `input` argument is provided rather than a file name, interpreting as raw "
"text to read\n"
msgstr ""
"  вместо имени файла передан аргумент `input`, интерпретирую как текст, "
"который нужно считать\n"

#: fread.c:1417
#, c-format
msgid "  Opening file %s\n"
msgstr "  Открываю файл %s\n"

#: fread.c:1421 fread.c:1450
#, c-format
msgid "File not found: %s"
msgstr "Файл не найден: %s"

#: fread.c:1425
#, c-format
msgid "Opened file ok but couldn't obtain its size: %s"
msgstr "Файл открыт, но не могу узнать его размер: %s"

#: fread.c:1428 fread.c:1460
#, c-format
msgid "File is empty: %s"
msgstr "Файл пуст: %s"

#: fread.c:1429 fread.c:1461
#, c-format
msgid "  File opened, size = %s.\n"
msgstr "  Файл открыт, размер = %s.\n"

#: fread.c:1456
#, c-format
msgid "Unable to open file after %d attempts (error %lu): %s"
msgstr "Не могу открыть файл после %d попыток (ошибка %lu): %s"

#: fread.c:1458
#, c-format
msgid "GetFileSizeEx failed (returned 0) on file: %s"
msgstr "Не получилось сделать GetFileSizeEx (функция вернула 0) для файла: %s"

#: fread.c:1463
#, c-format
msgid "This is Windows, CreateFileMapping returned error %lu for file %s"
msgstr "Это Windows; CreateFileMapping вернула ошибку %lu для файла %s"

#: fread.c:1470
#, c-format
msgid ""
"Opened %s file ok but could not memory map it. This is a %dbit process. %s."
msgstr ""
"Файл %s открыт, но не удалось отобразить его в память. Это %d-битный "
"процесс. %s."

#: fread.c:1471
msgid "Please upgrade to 64bit"
msgstr "Нужно 64-битное адресное пространство"

#: fread.c:1471
msgid "There is probably not enough contiguous virtual memory available"
msgstr "Вероятно, не хватает непрерывной виртуальной памяти"

#: fread.c:1474
msgid "  Memory mapped ok\n"
msgstr "  Файл отображён в адресное пространство\n"

#: fread.c:1493
msgid "[03] Detect and skip BOM\n"
msgstr "[03] Обнаружение и пропуск метки порядка байт\n"

#: fread.c:1497
msgid ""
"  UTF-8 byte order mark EF BB BF found at the start of the file and "
"skipped.\n"
msgstr ""
"  Метка порядка байтов UTF-8 EF BB BF найдена в начале файла и пропущена.\n"

#: fread.c:1502
msgid ""
"GB-18030 encoding detected, however fread() is unable to decode it. Some "
"character fields may be garbled.\n"
msgstr ""
"Обнаружена кодировка GB-18030, но fread() не может ее декодировать. "
"Некоторые строки могут быть искажены.\n"

#: fread.c:1505
msgid ""
"File is encoded in UTF-16, this encoding is not supported by fread(). Please "
"recode the file to UTF-8."
msgstr ""
"Файл закодирован в UTF-16, но fread() не поддерживает эту кодировку. "
"Пожалуйста, перекодируйте файл в UTF-8."

#: fread.c:1510
#, c-format
msgid "  Last byte(s) of input found to be %s and removed.\n"
msgstr "  На конце файла нашлось %s и было удалено.\n"

#: fread.c:1513
msgid "Input is empty or only contains BOM or terminal control characters"
msgstr "Файл пуст или содержит только BOM или управляющие символы терминала"

#: fread.c:1520
msgid "[04] Arrange mmap to be \\0 terminated\n"
msgstr "[04] Готовлю \\0 после отображённого в память файла\n"

#: fread.c:1527
msgid ""
"  No \\n exists in the file at all, so single \\r (if any) will be taken as "
"one line ending. This is unusual but will happen normally when there is no "
"\\r either; e.g. a single line missing its end of line.\n"
msgstr ""
"  В файле вообще нет \\n, поэтому одиночный \\r (если он есть) будет "
"воспринят как конец одной строки. Это необычно, но может произойти, когда "
"\\r тоже нет; например, файл из одной строки, не завершённой маркером конца "
"строки.\n"

#: fread.c:1528
msgid ""
"  \\n has been found in the input and different lines can end with different "
"line endings (e.g. mixed \\n and \\r\\n in one file). This is common and "
"ideal.\n"
msgstr ""
"  \\n был найден во входных данных, и разные строки могут заканчиваться "
"разными маркерами (например, смесь \\n и \\r\\n в одном файле). Это "
"нормально.\n"

#: fread.c:1552
#, c-format
msgid ""
"  File ends abruptly with '%c'. Final end-of-line is missing. Using cow page "
"to write 0 to the last byte.\n"
msgstr ""
"  Файл внезапно заканчивается '%c', без маркера конца строки. Записываю 0 в "
"последний байт в виртуальной памяти.\n"

#: fread.c:1558
msgid ""
"This file is very unusual: it ends abruptly without a final newline, and "
"also its size is a multiple of 4096 bytes. Please properly end the last row "
"with a newline using for example 'echo >> file'"
msgstr ""
"Очень необычный файл: заканчивается без маркера конца строки, а размер "
"кратен 4096 байтам. Пожалуйста, добавьте маркер конца строки, используя, "
"например, 'echo >> file'"

#: fread.c:1560
#, c-format
msgid ""
"  File ends abruptly with '%c'. Final end-of-line is missing. Copying file "
"in RAM. %s.\n"
msgstr ""
"  Файл оканчивается '%c' без маркера конца строки. Копирую файл в "
"оперативную память. %s.\n"

#: fread.c:1566 fread.c:1850
#, c-format
msgid "%s. Attempt to copy file in RAM failed."
msgstr "%s. Попытка скопировать файл в память не удалась."

#: fread.c:1567 fread.c:1851
#, c-format
msgid "Unable to allocate %s of contiguous virtual RAM."
msgstr "Не могу выделить %s непрерывной виртуальной памяти."

#: fread.c:1571 fread.c:1855
#, c-format
msgid "  File copy in RAM took %.3f seconds.\n"
msgstr "  Копирование файла в оперативную память заняло %.3f с.\n"

#: fread.c:1573 fread.c:1857
#, c-format
msgid "Avoidable file copy in RAM took %.3f seconds. %s.\n"
msgstr ""
"Копирование файла в оперативную память, которого можно было избежать, заняло "
"%.3f с. %s.\n"

#: fread.c:1605
msgid "[05] Skipping initial rows if needed\n"
msgstr "[05] При необходимости пропускаю начальные строки\n"

#: fread.c:1611
#, c-format
msgid ""
"skip='%s' not found in input (it is case sensitive and literal; i.e., no "
"patterns, wildcards or regex)"
msgstr ""
"skip='%s' не найдено в файле (интерпретирую строку буквально, чувствительно "
"к регистру: никаких шаблонов, масок или регулярных выражений)"

#: fread.c:1617
#, c-format
msgid ""
"Found skip='%s' on line %<PRIu64>. Taking this to be header row or first row "
"of data.\n"
msgstr ""
"В строке %2$<PRIu64> нашлось skip='%1$s'. Считаю, что это строка заголовка "
"или первая строка данных.\n"

#: fread.c:1631
#, c-format
msgid "  Skipped to line %<PRIu64> in the file"
msgstr "  Переход к строке %<PRIu64> в файле"

#: fread.c:1645
msgid ""
"Input is either empty, fully whitespace, or skip has been set after the last "
"non-whitespace."
msgstr ""
"Либо файл пустой, либо состоит из пробельных символов, либо skip задан после "
"последнего не-пробельного символа."

#: fread.c:1647
#, c-format
msgid "  Moved forward to first non-blank line (%d)\n"
msgstr "  Спускаюсь на первую непустую строку (%d)\n"

#: fread.c:1648
#, c-format
msgid "  Positioned on line %d starting: <<%s>>\n"
msgstr "  Располагаюсь на строке %d, которая начинается на «%s»\n"

#: fread.c:1670
msgid "[06] Detect separator, quoting rule, and ncolumns\n"
msgstr "[06] Определяю разделитель, кавычки и количество столбцов\n"

#: fread.c:1674
msgid "  sep='\\n' passed in meaning read lines as single character column\n"
msgstr "  sep='\\n': считываю строки в один строковой столбец\n"

#: fread.c:1693
msgid "  Detecting sep automatically ...\n"
msgstr "  Автоматически определяю разделитель...\n"

#: fread.c:1700
#, c-format
msgid "  Using supplied sep '%s'\n"
msgstr "  Использую переданный разделитель '%s'\n"

#: fread.c:1734
#, c-format
msgid "  with %d fields using quote rule %d\n"
msgstr "  с %d полями и режимом кавычек %d\n"

#: fread.c:1784
#, c-format
msgid "  with %d lines of %d fields using quote rule %d\n"
msgstr "  с %d строками по %d полей и режимом кавычек %d\n"

#: fread.c:1791
msgid ""
"  No sep and quote rule found a block of 2x2 or greater. Single column "
"input.\n"
msgstr ""
"  Ни с одним разделителем и режимом кавычек удалось найти блок в 2*2 ячейки "
"или больше. Считываю один столбец.\n"

#: fread.c:1807
msgid ""
"Single column input contains invalid quotes. Self healing only effective "
"when ncol>1"
msgstr ""
"Одноколоночный ввод содержит неправильные кавычки. Могу попытаться исправить "
"только при ncol>1"

#: fread.c:1812
#, c-format
msgid ""
"Found and resolved improper quoting in first %d rows. If the fields are not "
"quoted (e.g. field separator does not appear within any field), try "
"quote=\"\" to avoid this warning."
msgstr ""
"В первых %d строках найдены и исправлены неправильные кавычки. Если кавычек "
"на самом деле не было (например, потому что разделитель не встречается "
"внутри полей), попробуйте quote=\"\", чтобы избежать этого предупреждения."

#: fread.c:1833
#, c-format
msgid ""
"  Detected %d columns on line %d. This line is either column names or first "
"data row. Line starts as: <<%s>>\n"
msgstr ""
"  Обнаружено %d столбцов в строке %d. В этой строке находятся либо имена "
"столбцов, либо первая строка данных. Начало строки: «%s»\n"

#: fread.c:1835
#, c-format
msgid "  Quote rule picked = %d\n"
msgstr "  Выбран режим кавычек = %d\n"

#: fread.c:1836
#, c-format
msgid "  fill=%s and the most number of columns found is %d\n"
msgstr "  fill=%s; наибольшее количество найденных столбцов равно %d\n"

#: fread.c:1842
msgid ""
"This file is very unusual: it's one single column, ends with 2 or more end-"
"of-line (representing several NA at the end), and the file size is a "
"multiple of 4096, too"
msgstr ""
"Этот файл очень необычен: он состоит из одного столбца, заканчивается 2 или "
"более маркерами конца строки (что значит несколько NA в конце), а размер "
"файла кратен 4096"

#: fread.c:1844
#, c-format
msgid "  Copying file in RAM. %s\n"
msgstr "  Копирую файл в оперативную память. %s\n"

#: fread.c:1861
msgid ""
"  1-column file ends with 2 or more end-of-line. Restoring last eol using "
"extra byte in cow page.\n"
msgstr ""
"  Файл из 1 столбца заканчивается 2 или более маркерами конца строки. "
"Восстанавливаю последний маркер с использованием лишнего байта в виртуальной "
"памяти.\n"

#: fread.c:1880
msgid ""
"[07] Detect column types, dec, good nrow estimate and whether first row is "
"column names\n"
msgstr ""
"[07] Определяю тип столбца, десятичный разделитель, оценку количества строк, "
"а также определяю, содержит ли первая строка имена столбцов\n"

#: fread.c:1881
#, c-format
msgid "  'header' changed by user from 'auto' to %s\n"
msgstr "  'header' изменён пользователем с 'auto' на %s\n"

#: fread.c:1887
#, c-format
msgid "Failed to allocate 2 x %d bytes for type and tmpType: %s"
msgstr "Не удалось выделить 2 * %d байт для 'type' и 'tmpType': %s"

#: fread.c:1892
msgid "  sep=',' so dec set to '.'\n"
msgstr "  sep=',' так что считаю dec='.'\n"

#: fread.c:1917
#, c-format
msgid ""
"  Number of sampling jump points = %d because nrow limit (%<PRIu64>) "
"supplied\n"
msgstr ""
"  Количество точек отбора = %d, потому что передано ограничение на "
"количество строк (%<PRIu64>)\n"

#: fread.c:1919
#, c-format
msgid "  Number of sampling jump points = %d because jump0size==0\n"
msgstr "  Количество точек отбора = %d, потому что jump0size==0\n"

#: fread.c:1921
#, c-format
msgid ""
"  Number of sampling jump points = %d because (%<PRIu64> bytes from row 1 to "
"eof) / (2 * %<PRIu64> jump0size) == %<PRIu64>\n"
msgstr ""
"  Количество точек отбора = %d, потому что (%<PRIu64> байт от первой строки "
"до конца файла) / (2 * %<PRIu64> jump0size) == %<PRIu64>\n"

#: fread.c:1962
#, c-format
msgid ""
"  A line with too-few fields (%d/%d) was found on line %d of sample jump %d. "
"%s\n"
msgstr ""
"  Недостаточное количество полей (%d/%d) найдено на строке №%d точки отбора №"
"%d. %s\n"

#: fread.c:1963
#, c-format
msgid ""
"  A line with too-many fields (%d/%d) was found on line %d of sample jump "
"%d. %s\n"
msgstr ""
"  Слишком большое количество полей (%d/%d) найдено на строке №%d точки "
"отбора №%d. %s\n"

#: fread.c:1964
msgid ""
"Most likely this jump landed awkwardly so type bumps here will be skipped."
msgstr ""
"Вероятно, нам не повезло с точкой отбора, так что мы не будем менять оценки "
"типов данных."

#: fread.c:1987 fread.c:2013
#, c-format
msgid "  dec='%c' detected based on a balance of %d parsed fields\n"
msgstr "  считаю dec='%c' на основании %d рассмотренных полей\n"

#: fread.c:1997
#, c-format
msgid "  Type codes (jump %03d)    : %s  Quote rule %d\n"
msgstr "  Коды типов (отбор %03d)    : %s  Режим кавычек %d\n"

#: fread.c:2019
#, c-format
msgid ""
"  'header' determined to be true due to column %d containing a string on row "
"1 and a lower type (%s) in the rest of the %<PRId64> sample rows\n"
msgstr ""
"  считаю 'header'=TRUE, поскольку столбец %d содержит текст в первой строке "
"и более низкий тип (%s) в остальных %<PRId64> строках выборки\n"

#: fread.c:2033
#, c-format
msgid ""
"Types in 1st data row match types in 2nd data row but previous row has %d "
"fields. Taking previous row as column names."
msgstr ""
"Типы 1-й строки данных совпадают с типами 2-й строки данных, но первая "
"строка содержит %d полей. Считаю её содержащей имена столбцов."

#: fread.c:2037
#, c-format
msgid ""
"Detected %d column names but the data has %d columns (i.e. invalid file). "
"Added an extra default column name for the first column which is guessed to "
"be row names or an index. Use setnames() afterwards if this guess is not "
"correct, or fix the file write command that created the file to create a "
"valid file.\n"
msgstr ""
"Обнаружено %d имен столбцов, но данные содержат %d столбцов (т. е. "
"некорректный файл). Добавляю ещё одно имя для первого столбца, который "
"предположительно содержит имена строк или индекс. Если это неверно, "
"используйте setnames(), чтобы исправить имена, либо исправьте сам файл.\n"

#: fread.c:2040
#, c-format
msgid ""
"Detected %d column names but the data has %d columns (i.e. invalid file). "
"Added %d extra default column names at the end.\n"
msgstr ""
"Обнаружено %d имен столбцов, но данные содержат %d столбцов (т. е. "
"некорректный файл). Добавляю в конце %d имён столбцов.\n"

#: fread.c:2044
#, c-format
msgid ""
"Detected %d column names but the data has %d columns. Filling rows "
"automatically. Set fill=TRUE explicitly to avoid this warning.\n"
msgstr ""
"Обнаружено %d имен столбцов, но данные содержат %d столбцов. Автоматически "
"заполняю строки. Чтобы избежать этого предупреждения, явно задайте "
"fill=TRUE.\n"

#: fread.c:2048
#, c-format
msgid "Failed to realloc 2 x %d bytes for type and tmpType: %s"
msgstr ""
"Не удалось изменить размер выделенной памяти до 2 * %d байт для 'type' и "
"'tmpType': %s"

#: fread.c:2069
msgid ""
"  'header' determined to be TRUE because there are no number fields in the "
"first and only row\n"
msgstr ""
"  считаю 'header'=TRUE, потому что не нашлось столбцов с числами в первой и "
"единственной строке\n"

#: fread.c:2071
msgid ""
"  'header' determined to be FALSE because there are number fields in the "
"first and only row\n"
msgstr ""
"  считаю 'header'=FALSE, потому что нашлось несколько столбцов с числами в "
"первой строке\n"

#: fread.c:2074
msgid ""
"  'header' determined to be true because all columns are type string and a "
"better guess is not possible\n"
msgstr ""
"  считаю 'header'=TRUE, потому что все столбцы содержат текст и более точное "
"предположение невозможно\n"

#: fread.c:2076
msgid ""
"  'header' determined to be false because there are some number columns and "
"those columns do not have a string field at the top of them\n"
msgstr ""
"  считаю 'header'=FALSE, потому что есть несколько столбцов с числами и в "
"верхней части этих столбцов нет строки-заголовка\n"

#: fread.c:2092
#, c-format
msgid "  Type codes (first row)   : %s  Quote rule %d\n"
msgstr "  Коды типов (первая строка)   : %s  Режим кавычек %d\n"

#: fread.c:2101
#, c-format
msgid ""
"  All rows were sampled since file is small so we know nrow=%<PRIu64> "
"exactly\n"
msgstr ""
"  Рассмотрены все строки, поскольку файл очень мал и мы точно знаем "
"nrow=%<PRIu64>\n"

#: fread.c:2114
#, c-format
msgid ""
"  Sampled %<PRIu64> rows (handled \\n inside quoted fields) at %d jump "
"points\n"
msgstr ""
"  Рассмотрено %<PRIu64> строк (с учётом \\n внутри полей с кавычками) в %d "
"точках выборки\n"

#: fread.c:2115
#, c-format
msgid ""
"  Bytes from first data row on line %d to the end of last row: %<PRIu64>\n"
msgstr ""
"  Байт от начала данных на строке %d до конца последней строки: %<PRIu64>\n"

#: fread.c:2116
#, c-format
msgid "  Line length: mean=%.2f sd=%.2f min=%d max=%d\n"
msgstr ""
"  Длины строк: средняя=%.2f стандартное отклонение=%.2f минимум=%d "
"максимум=%d\n"

#: fread.c:2117
#, c-format
msgid "  Estimated number of rows: %<PRIu64> / %.2f = %<PRIu64>\n"
msgstr "  Оценка числа строк: %<PRIu64> / %.2f = %<PRIu64>\n"

#: fread.c:2118
#, c-format
msgid ""
"  Initial alloc = %<PRIu64> rows (%<PRIu64> + %d%%) using bytes/"
"max(mean-2*sd,min) clamped between [1.1*estn, 2.0*estn]\n"
msgstr ""
"  Начальное выделение памяти = %<PRIu64> строк (%<PRIu64> + %d%%), используя "
"байт/max(среднее-2*σ, min) с ограничением между [1.1*оценка, 2.0*оценка]\n"

#: fread.c:2126
#, c-format
msgid "  Alloc limited to lower nrows=%<PRIu64> passed in.\n"
msgstr "  Выделение памяти ограничено переданным nrows=%<PRIu64>.\n"

#: fread.c:2138
msgid "[08] Assign column names\n"
msgstr "[08] Назначаю имена столбцов\n"

#: fread.c:2147
#, c-format
msgid "Unable to allocate %d*%d bytes for column name pointers: %s"
msgstr "Не удалось выделить %d*%d байт для указателей имен столбцов: %s"

#: fread.c:2187
msgid "[09] Apply user overrides on column types\n"
msgstr "[09] Применяю пользовательские переопределения для типов столбцов\n"

#: fread.c:2191
msgid "  Cancelled by user: userOverride() returned false."
msgstr "  Отменено пользователем: userOverride() вернула false."

#: fread.c:2202
#, c-format
msgid "Failed to allocate %d bytes for '%s': %s"
msgstr "Не удалось выделить %d байт для '%s': %s"

#: fread.c:2209
#, c-format
msgid ""
"Attempt to override column %d%s%.*s%s of inherent type '%s' down to '%s' "
"ignored. Only overrides to a higher type are currently supported. If this "
"was intended, please coerce to the lower type afterwards."
msgstr ""
"Игнорирую попытку переопределить столбец %d%s%.*s%s естественного типа '%s' "
"до '%s'. В настоящее время поддерживаются только переопределения к более "
"высокому типу. Если Вы и правда этого хотите, приведите столбец к желаемому "
"типу потом."

#: fread.c:2224
#, c-format
msgid "  After %d type and %d drop user overrides : %s\n"
msgstr "  После %d назначенных типов и %d пропущенных столбцов: %s\n"

#: fread.c:2232
msgid "[10] Allocate memory for the datatable\n"
msgstr "[10] Выделяю память под data.table\n"

#: fread.c:2233
#, c-format
msgid "  Allocating %d column slots (%d - %d dropped) with %<PRIu64> rows\n"
msgstr ""
"  Выделяю %d слотов столбцов (%d - %d пропущено) с %<PRIu64> строками\n"

#: fread.c:2288
#, c-format
msgid "Buffer size %<PRId64> is too large\n"
msgstr "Размер буфера %<PRId64> слишком велик\n"

#: fread.c:2291
msgid "[11] Read the data\n"
msgstr "[11] Читаю данные\n"

#: fread.c:2520
#, c-format
msgid ""
"Column %d%s%.*s%s bumped from '%s' to '%s' due to <<%.*s>> on row %<PRIu64>\n"
msgstr ""
"Меняю тип столбца %d%s%.*s%s с '%s' на '%s' из-за <<%.*s>> на строке "
"%<PRIu64>\n"

#: fread.c:2638
#, c-format
msgid "  Provided number of fill columns: %d but only found %d\n"
msgstr "  Указано столбцов: %d, но найдено только %d\n"

#: fread.c:2639
#, c-format
msgid "  Dropping %d overallocated columns\n"
msgstr "  Выбрасываю %d лишних столбцов\n"

#: fread.c:2657
#, c-format
msgid ""
"Internal error in %s: %s. Please report to the data.table issues tracker"
msgstr ""
"Внутренняя ошибка в %s: %s. Пожалуйста, сообщите в трекер ошибок data.table"

#: fread.c:2664
#, c-format
msgid ""
"  Too few rows allocated. Allocating additional %<PRIu64> rows (now "
"nrows=%<PRIu64>) and continue reading from jump %d\n"
msgstr ""
"  Выделено памяти под слишком мало строк. Выделяю ещё %<PRIu64> строк "
"(теперь nrows=%<PRIu64>) и продолжаю читать с точки перехода №%d\n"

#: fread.c:2671
#, c-format
msgid "  Restarting team from jump %d. nSwept==%d quoteRule==%d\n"
msgstr "  Перезапускаю потоки с точки перехода №%d. nSwept==%d quoteRule==%d\n"

#: fread.c:2691
#, c-format
msgid "  %d out-of-sample type bumps: %s\n"
msgstr "  %d раз изменены типы после начальной оценки: %s\n"

#: fread.c:2726
#, c-format
msgid ""
"Read %<PRIu64> rows x %d columns from %s file in %02d:%06.3f wall clock "
"time\n"
msgstr ""
"Чтение %<PRIu64> строк * %d столбцов из файла %s заняло %02d:%06.3f мин:с\n"

#: fread.c:2733
msgid "[12] Finalizing the datatable\n"
msgstr "[12] Завершающие штрихи\n"

#: fread.c:2734
msgid "  Type counts:\n"
msgstr "  Количества типов:\n"

#: fread.c:2736
#, c-format
msgid "%10d : %-9s '%c'\n"
msgstr "%10d : %-9s '%c'\n"

#: fread.c:2752
#, c-format
msgid "Discarded single-line footer: <<%s>>"
msgstr "Пропущена завершающая строка после данных: <<%s>>"

#: fread.c:2758
#, c-format
msgid ""
"Stopped early on line %<PRIu64>. Expected %d fields but found %d. Consider "
"fill=%d or even more based on your knowledge of the input file. Use fill=Inf "
"for reading the whole file for detecting the number of fields. First "
"discarded non-empty line: <<%s>>"
msgstr ""
"Ранняя остановка на строке %<PRIu64>. Ожидалось %d полей, а найдено %d. "
"Попробуйте задать fill=%d или больше, исходя из Ваших знаний о входном "
"файле. Используйте fill=Inf, чтобы считать весь файл для определения "
"количества полей. Первая отброшенная непустая строка: <<%s>>"

#: fread.c:2761
#, c-format
msgid ""
"Stopped early on line %<PRIu64>. Expected %d fields but found %d. Consider "
"fill=TRUE and comment.char=. First discarded non-empty line: <<%s>>"
msgstr ""
"Ранняя остановка на строке %<PRIu64>. Ожидалось %d полей, а найдено %d. "
"Попробуйте fill=TRUE и comment.char=. Первая отброшенная непустая строка: "
"<<%s>>"

#: fread.c:2768
#, c-format
msgid ""
"Found and resolved improper quoting out-of-sample. First healed line "
"%<PRIu64>: <<%s>>. If the fields are not quoted (e.g. field separator does "
"not appear within any field), try quote=\"\" to avoid this warning."
msgstr ""
"Найдены и исправлены неправильные кавычки вне первичной выборки. Первая "
"исправленная строка %<PRIu64>: <<%s>>. Если поля не заключены в кавычки "
"(например, разделитель полей не появляется ни в одном из полей), попробуйте "
"использовать quote=\"\", чтобы избежать этого предупреждения."

#: fread.c:2774
#, c-format
msgid "%8.3fs (%3.0f%%) Memory map %.3fGB file\n"
msgstr ""
"%8.3f с (%3.0f%%) Отображение файла размером %.3f ГБ в виртуальную память\n"

#: fread.c:2777
#, c-format
msgid " ncol=%d and header detection\n"
msgstr " ncol=%d и определение заголовка\n"

#: fread.c:2778
#, c-format
msgid "%8.3fs (%3.0f%%) Column type detection using %<PRIu64> sample rows\n"
msgstr ""
"%8.3f с (%3.0f%%) Определение типов столбцов по выборке из %<PRIu64> строк\n"

#: fread.c:2780
#, c-format
msgid ""
"%8.3fs (%3.0f%%) Allocation of %<PRIu64> rows x %d cols (%.3fGB) of which "
"%<PRIu64> (%3.0f%%) rows used\n"
msgstr ""
"%8.3f с (%3.0f%%) Выделение памяти под %<PRIu64> строк * %d столбцов (%.3f "
"ГБ), из которых использовано %<PRIu64> (%3.0f%%) строк\n"

#: fread.c:2784
#, c-format
msgid ""
"%8.3fs (%3.0f%%) Reading %d chunks (%d swept) of %.3fMB (each chunk %d rows) "
"using %d threads\n"
msgstr ""
"%8.3f с (%3.0f%%) Чтение %d частей (%d перемотано) размером %.3f МБ (по %d "
"строк) с использованием %d потоков\n"

#: fread.c:2786
#, c-format
msgid ""
"   + %8.3fs (%3.0f%%) Parse to row-major thread buffers (grown %d times)\n"
msgstr ""
"   + %8.3f с (%3.0f%%) Анализ в построчных буферах потоков (наращены %d "
"раз)\n"

#: fread.c:2787
#, c-format
msgid "   + %8.3fs (%3.0f%%) Transpose\n"
msgstr "   + %8.3f с (%3.0f%%) Транспонирование\n"

#: fread.c:2788
#, c-format
msgid "   + %8.3fs (%3.0f%%) Waiting\n"
msgstr "   + %8.3f с (%3.0f%%) Ожидание\n"

#: fread.c:2789
#, c-format
msgid ""
"%8.3fs (%3.0f%%) Rereading %d columns due to out-of-sample type exceptions\n"
msgstr ""
"%8.3f с (%3.0f%%) Перечитывание %d столбцов из-за неожиданной смены типа\n"

#: fread.c:2791
#, c-format
msgid "%8.3fs        Total\n"
msgstr "%8.3f с        Итого\n"

#: freadR.c:94
#, c-format
msgid "freadR.c has been passed a filename: %s\n"
msgstr "freadR.c передано имя файла: %s\n"

#: freadR.c:98
msgid "freadR.c has been passed the data as text input (not a filename)\n"
msgstr "freadR.c переданы данные в виде текста (без имени файла)\n"

#: freadR.c:116
msgid "quote= must be a single character, blank \"\", or FALSE"
msgstr "quote= должен быть одиночным символом, пустым \"\" или FALSE"

#: freadR.c:170
msgid "'integer64' must be a single character string"
msgstr "'integer64' должен быть одиночной строкой"

#: freadR.c:178
#, c-format
msgid ""
"Invalid value integer64='%s'. Must be 'integer64', 'character', 'double' or "
"'numeric'"
msgstr ""
"Недопустимое значение integer64='%s'. Должно быть 'integer64', 'character', "
"'double' или 'numeric'"

#: freadR.c:186
msgid "Use either select= or drop= but not both."
msgstr "Используйте либо select=, либо drop=, но не оба одновременно."

#: freadR.c:189
msgid ""
"select= is type list for specifying types in select=, but colClasses= has "
"been provided as well. Please remove colClasses=."
msgstr ""
"select= содержит типы столбцов, но также был предоставлен colClasses=. "
"Пожалуйста, удалите colClasses=."

#: freadR.c:191
msgid ""
"select= is type list but has no names; expecting list(type1=cols1, "
"type2=cols2, ...)"
msgstr ""
"select= передан в виде списка, но не содержит имён столбцов; должен быть в "
"виде list(тип1=столбцы1, тип2=столбцы2, ...)"

#: freadR.c:198
msgid ""
"select= is a named vector specifying the columns to select and their types, "
"but colClasses= has been provided as well. Please remove colClasses=."
msgstr ""
"select= передан в виде списка с именами и типами столбцов, но также передан "
"colClasses. Пожалуйста, удалите colClasses=."

#: freadR.c:206 freadR.c:372
msgid "colClasses is type list but has no names"
msgstr "в списке colClasses нет имён"

#: freadR.c:216
#, c-format
msgid "encoding='%s' invalid. Must be 'unknown', 'Latin-1' or 'UTF-8'"
msgstr ""
"Неправильная encoding='%s'. Должно быть 'unknown', 'Latin-1' или 'UTF-8'"

#: freadR.c:239
#, c-format
msgid "Column name '%s' (%s) not found"
msgstr "Имя столбца '%s' (%s) не найдено"

#: freadR.c:241
#, c-format
msgid "%s is NA"
msgstr "%s является NA"

#: freadR.c:243
#, c-format
msgid "%s is %d which is out of range [1,ncol=%d]"
msgstr "%s равно %d, что выходит за пределы диапазона [1,ncol=%d]"

#: freadR.c:292
#, c-format
msgid ""
"Column name '%s' not found in column name header (case sensitive), skipping."
msgstr ""
"Имя столбца '%s' не найдено в заголовке с именами столбцов (с учетом "
"регистра), пропускаю."

#: freadR.c:302
#, c-format
msgid ""
"Column number %d (select[%d]) is negative but should be in the range [1,"
"ncol=%d]. Consider drop= for column exclusion."
msgstr ""
"Номер столбца %d (select[%d]) отрицательный, но должен быть в диапазоне [1,"
"ncol=%d]. Чтобы исключить столбцы, используйте drop=."

#: freadR.c:303
#, c-format
msgid ""
"select = 0 (select[%d]) has no meaning. All values of select should be in "
"the range [1,ncol=%d]."
msgstr ""
"select[%d] = 0 не имеет смысла. Все значения select должны находиться в "
"диапазоне [1,ncol=%d]."

#: freadR.c:304
#, c-format
msgid ""
"Column number %d (select[%d]) is too large for this table, which only has %d "
"columns."
msgstr ""
"Номер столбца %d (select[%d]) слишком велик для этой таблицы, в которой "
"всего %d столбцов."

#: freadR.c:305
#, c-format
msgid "Column number %d ('%s') has been selected twice by select="
msgstr "Номер столбца %d ('%s') был выбран дважды с помощью select="

#: freadR.c:328
#, c-format
msgid ""
"colClasses= is an unnamed vector of types, length %d, but there are %d "
"columns in the input. To specify types for a subset of columns, you can use "
"a named vector, list format, or specify types using select= instead of "
"colClasses=. Please see examples in ?fread."
msgstr ""
"В colClasses= передан неименованный вектор типов длиной %d, но во входных "
"данных имеется %d столбцов. Чтобы указать типы для подмножества столбцов, "
"передайте именованный вектор или список, либо используйте select= вместо "
"colClasses=. См. примеры в ?fread."

#: freadR.c:370
#, c-format
msgid "colClasses is type '%s' but should be list or character"
msgstr ""
"colClasses имеет тип '%s', но должен быть списком или строковым вектором"

#: freadR.c:394
#, c-format
msgid "Column name '%s' (colClasses[[%d]][%d]) not found"
msgstr "Имя столбца '%s' (colClasses[[%d]][%d]) не найдено"

#: freadR.c:396
#, c-format
msgid "colClasses[[%d]][%d] is NA"
msgstr "colClasses[[%d]][%d] является NA"

#: freadR.c:400
#, c-format
msgid "Column number %d (colClasses[[%d]][%d]) is out of range [1,ncol=%d]"
msgstr ""
"Номер столбца %d (colClasses[[%d]][%d]) находится вне диапазона [1,ncol=%d]"

#: freadR.c:404
#, c-format
msgid ""
"Column %d ('%s') appears more than once in colClasses. The second time is "
"colClasses[[%d]][%d]."
msgstr ""
"Столбец %d ('%s') встречается в colClasses более одного раза. Второй раз - "
"colClasses[[%d]][%d]."

#: freadR.c:646
#, c-format
msgid "Field size is 1 but the field is of type %d\n"
msgstr "Размер поля равен 1, но поле имеет тип %d\n"

#: froll.c:23 froll.c:232 froll.c:416
#, c-format
msgid "%s: window width longer than input vector, returning all NA vector\n"
msgstr "%s: ширина окна больше входного вектора, возвращаю вектор из NA\n"

#: froll.c:41 froll.c:249 froll.c:465
#, c-format
msgid "%s: align %d, shift answer by %d\n"
msgstr "%s: выравнивание %d, смещение ответа на %d\n"

#: froll.c:48 froll.c:256 frolladaptive.c:19 frolladaptive.c:214
#, c-format
msgid "%s: processing algo %u took %.3fs\n"
msgstr "%s: обработка алгоритмом %u заняла %.3f с\n"

#: froll.c:57 froll.c:260
#, c-format
msgid "%s: running for input length %<PRIu64>, window %d, hasna %d, narm %d\n"
msgstr ""
"%s: работаю для входных данных длины %<PRIu64>, ширина окна %d, hasna=%d, "
"narm=%d\n"

#: froll.c:77 froll.c:87 froll.c:178 froll.c:280 froll.c:290 froll.c:371
#: frolladaptive.c:58 frolladaptive.c:147 frolladaptive.c:247
#: frolladaptive.c:326
#, c-format
msgid ""
"%s: hasNA=FALSE used but NA (or other non-finite) value(s) are present in "
"input, use default hasNA=NA to avoid this warning"
msgstr ""
"%s: передано hasNA=FALSE, но во входных данных присутствуют NA (или другие "
"не-конечные значения). Используйте значение по умолчанию hasNA=NA, чтобы "
"избежать этого предупреждения"

#: froll.c:80 froll.c:182 froll.c:283 froll.c:375 frolladaptive.c:61
#: frolladaptive.c:151 frolladaptive.c:250 frolladaptive.c:330
#, c-format
msgid ""
"%s: NA (or other non-finite) value(s) are present in input, re-running with "
"extra care for NAs\n"
msgstr ""
"%s: во входных данных найдены NA (или другие не-конечные) значения; запускаю "
"ещё раз в более осторожном режиме\n"

#: froll.c:90 froll.c:293
#, c-format
msgid ""
"%s: NA (or other non-finite) value(s) are present in input, skip non-NA "
"attempt and run with extra care for NAs\n"
msgstr ""
"%s: во входных данных присутствует NA (или другие не-конечные значения), "
"пропускаю попытку работать без NA и сразу перехожу в осторожный режим\n"

#: froll.c:146 froll.c:344
#, c-format
msgid ""
"%s: running in parallel for input length %<PRIu64>, window %d, hasna %d, "
"narm %d\n"
msgstr ""
"%s: работаю параллельно для входных данных длины %<PRIu64>, ширина окна %d, "
"hasna=%d, narm=%d\n"

#: froll.c:184 froll.c:377 frolladaptive.c:153 frolladaptive.c:332
#, c-format
msgid ""
"%s: NA (or other non-finite) value(s) are present in input, na.rm was FALSE "
"so in 'exact' implementation NAs were handled already, no need to re-run\n"
msgstr ""
"%s: на входе присутствует NA (или другие не-конечные значения), na.rm был "
"FALSE, поэтому \"точная\" реализация уже обработала NA, перезапуск не нужен\n"

#: froll.c:433
#, c-format
msgid "%s: results from provided FUN are not length 1"
msgstr "%s: возвращаемое значение из данной FUN не длины 1"

#: froll.c:440
#, c-format
msgid ""
"%s: results from provided FUN are not of type double, coercion from integer "
"or logical will be applied on each iteration\n"
msgstr ""
"%s: возвращаемое данной FUN значение не типа double; на каждой итерации буду "
"выполнять приведение типов из целочисленного или логического\n"

#: froll.c:443
#, c-format
msgid "%s: results from provided FUN are not of type double"
msgstr "%s: возвращаемое данной FUN значение не типа double"

#: froll.c:472 nafill.c:43 nafill.c:65 nafill.c:87
#, c-format
msgid "%s: took %.3fs\n"
msgstr "%s: заняло %.3f с\n"

#: frollR.c:17
msgid ""
"x must be of type numeric or logical, or a list, data.frame or data.table of "
"such"
msgstr ""
"x должен иметь численным, логическим, списком, либо data.frame или data."
"table, состоящей из столбцов таких типов"

#: frollR.c:38 frollR.c:244
msgid "n must be non 0 length"
msgstr "n должно быть ненулевой длины"

#: frollR.c:49
msgid "n must be integer, list is accepted for adaptive TRUE"
msgstr "n должно быть целочисленным; для adaptive=TRUE также допустим список n"

#: frollR.c:56 frollR.c:236 frollR.c:239
msgid "n must be integer"
msgstr "n должно быть целочисленным"

#: frollR.c:63
msgid "n must be positive integer values (> 0)"
msgstr "n должно быть целочисленным и положительным (> 0)"

#: frollR.c:72 frollR.c:84
msgid "n must be integer vector or list of integer vectors"
msgstr ""
"n должен быть целочисленным вектором или списком целочисленных векторов"

#: frollR.c:98
msgid "hasNA must be TRUE, FALSE or NA"
msgstr "hasNA должно быть TRUE, FALSE или NA"

#: frollR.c:100
msgid ""
"using hasNA FALSE and na.rm TRUE does not make sense, if you know there are "
"NA values use hasNA TRUE, otherwise leave it as default NA"
msgstr ""
"использование вместе hasNA=FALSE и na.rm=TRUE не имеет смысла; если Вы "
"знаете, что есть значения NA, используйте hasNA=TRUE, в противном случае "
"оставьте по умолчанию hasNA=NA"

#: frollR.c:113
msgid ""
"using adaptive TRUE and align argument different than 'right' is not "
"implemented"
msgstr "сочетание adaptive=TRUE и align!='right' пока не реализовано"

#: frollR.c:117 frollR.c:267
#, c-format
msgid "%s: allocating memory for results %dx%d\n"
msgstr "%s: выделяю память для результатов %d*%d\n"

#: frollR.c:126
msgid ""
"adaptive rolling function can only process 'x' having equal length of "
"elements, like data.table or data.frame; If you want to call rolling "
"function on list having variable length of elements call it for each field "
"separately"
msgstr ""
"адаптивная скользящая функция может обрабатывать только 'x' с одинаковой "
"длиной элементов, как в data.table или data.frame; если Вы хотите вызвать "
"скользящую функцию для списка с переменной длиной элементов, вызывайте ее "
"для каждого элемента отдельно"

#: frollR.c:128
msgid ""
"length of integer vector(s) provided as list to 'n' argument must be equal "
"to number of observations provided in 'x'"
msgstr ""
"длина целочисленного(ых) вектора(ов), переданного(ых) в виде списка 'n', "
"должна быть равна количеству наблюдений, переданных в 'x'"

#: frollR.c:146 frollR.c:259 gsumm.c:1203 shift.c:21
msgid "fill must be a vector of length 1"
msgstr "'fill' должен быть вектором длины 1"

#: frollR.c:148 frollR.c:261
msgid "fill must be numeric or logical"
msgstr "'fill' должен быть численным или логическим"

#: frollR.c:178
#, c-format
msgid ""
"%s: %d column(s) and %d window(s), if product > 1 then entering parallel "
"execution\n"
msgstr ""
"%s: %d столбец(ов) и %d окно(он); если их произведение > 1, то выполняю "
"параллельно\n"

#: frollR.c:180
#, c-format
msgid ""
"%s: %d column(s) and %d window(s), not entering parallel execution here "
"because algo='exact' will compute results in parallel\n"
msgstr ""
"%s: %d столбец(ов) и %d окно(он); здесь не выполняю параллельно, поскольку "
"этим займётся algo='exact'\n"

#: frollR.c:207 frollR.c:299
#, c-format
msgid "%s: processing of %d column(s) and %d window(s) took %.3fs\n"
msgstr "%s: обработка %d столбца(ов) и %d окна(он) заняла %.3f с\n"

#: frolladaptive.c:29 frolladaptive.c:218
#, c-format
msgid "%s: running for input length %<PRIu64>, hasna %d, narm %d\n"
msgstr "%s: входные данные длиной %<PRIu64>, hasna=%d, narm=%d\n"

#: frolladaptive.c:35 frolladaptive.c:224
#, c-format
msgid "%s: Unable to allocate memory for cumsum"
msgstr "%s: Не удалось выделить память для накапливаемой суммы"

#: frolladaptive.c:71 frolladaptive.c:260
#, c-format
msgid "%s: Unable to allocate memory for cum NA counter"
msgstr "%s: Не удалось выделить память для кумулятивного счётчика NA"

#: frolladaptive.c:114 frolladaptive.c:298
#, c-format
msgid "%s: running in parallel for input length %<PRIu64>, hasna %d, narm %d\n"
msgstr ""
"%s: работаю параллельно для входных данных длиной %<PRIu64>, hasna %d, narm "
"%d\n"

#: fsort.c:106
msgid "Reduced MSBsize from %zu to %zu by excluding 0 and 1 counts\n"
msgstr ""
"MSBsize уменьшен с %zu до %zu путём исключения счетов, равных 0 или 1\n"

#: fsort.c:121
msgid "x must be a vector of type double currently"
msgstr "в текущей версии x должен быть вектором типа double"

#: fsort.c:147
#, c-format
msgid "Failed to allocate %d bytes in fsort()."
msgstr "Не удалось выделить %d байт в fsort()."

#: fsort.c:173
#, c-format
msgid "Range = [%g,%g]\n"
msgstr "Диапазон = [%g,%g]\n"

#: fsort.c:174
msgid "Cannot yet handle negatives."
msgstr "Пока не могу справляться с отрицательными числами."

#: fsort.c:196
#, c-format
msgid ""
"counts is %dMB (%d pages per nBatch=%d, batchSize=%<PRIu64>, "
"lastBatchSize=%<PRIu64>)\n"
msgstr ""
"'counts' занимает %d МБ (%d страниц на nBatch=%d, batchSize=%<PRIu64>, "
"lastBatchSize=%<PRIu64>)\n"

#: fsort.c:266
msgid "Top 20 MSB counts: "
msgstr "20 самых часто встречающихся значений самых старших битов: "

#: fsort.c:266
#, c-format
msgid "%<PRId64> "
msgstr "%<PRId64> "

#: fsort.c:333
#, c-format
msgid ""
"OpenMP %d did not assign threads to iterations monotonically. Please search "
"Stack Overflow for this message."
msgstr ""
"OpenMP %1$d не назначило потоки итерациям монотонным образом. Пожалуйста, "
"найдите «OpenMP %1$d did not assign threads to iterations monotonically» на "
"Stack Overflow."

#: fsort.c:335
msgid "Unable to allocate working memory"
msgstr "Не удалось выделить оперативную память"

#: fsort.c:345
#, c-format
msgid "%d: %.3f (%4.1f%%)\n"
msgstr "%d: %.3f (%4.1f%%)\n"

#: fwrite.c:625
msgid ""
"Compression in fwrite uses zlib library. Its header files were not found at "
"the time data.table was compiled. To enable fwrite compression, please "
"reinstall data.table and study the output for further guidance."
msgstr ""
"Сжатие в fwrite использует библиотеку zlib. Ее заголовочные файлы не были "
"найдены во время компиляции data.table. Чтобы включить сжатие в fwrite, "
"переустановите data.table и изучите вывод компиляции для получения "
"дальнейших указаний."

#: fwrite.c:641
#, c-format
msgid ""
"eol must be 1 or more bytes (usually either \\n or \\r\\n) but is length %d"
msgstr ""
"'eol' должен быть 1 или более байт (обычно \"\\n\" или \"\\r\\n\"), но его "
"длина составляет %d"

#: fwrite.c:644
msgid "Column writers: "
msgstr "Буду записывать столбцы: "

#: fwrite.c:690
#, c-format
msgid "type %d has no max length method implemented"
msgstr "для типа %d не реализован метод нахождения максимальной длины"

#: fwrite.c:702
#, c-format
msgid "maxLineLen=%<PRIu64>. Found in %.3fs\n"
msgstr "maxLineLen=%<PRIu64>. Найдено за %.3f с\n"

#: fwrite.c:721
#, c-format
msgid ""
"%s: '%s'. Failed to open existing file for writing. Do you have write "
"permission to it? Is this Windows and does another process such as Excel "
"have it open?"
msgstr ""
"%s: '%s'. Не удалось открыть существующий файл для записи. Есть ли у вас "
"разрешение на запись в него? Возможно, это Windows и он открыт другим "
"процессом, например, Excel?"

#: fwrite.c:722
#, c-format
msgid ""
"%s: '%s'. Unable to create new file for writing (it does not exist already). "
"Do you have permission to write here, is there space on the disk and does "
"the path exist?"
msgstr ""
"%s: '%s'. Невозможно создать новый файл для записи (он еще не существует). "
"Есть ли у вас разрешение на запись сюда, есть ли место на диске и существует "
"ли путь?"

#: fwrite.c:730
#, c-format
msgid "Writing bom (%s), yaml (%d characters) and column names (%s)\n"
msgstr ""
"Записываю маркер порядка байт (%s), YAML (%d символов) и заголовки столбцов "
"(%s)\n"

#: fwrite.c:782
#, c-format
msgid ""
"Writing %<PRId64> rows in %d batches of %d rows, each buffer size %zu bytes "
"(%zu MiB), showProgress=%d, nth=%d\n"
msgstr ""
"Запись %<PRId64> строк в %d партиях по %d строк; размер каждого буфера %zu "
"байт (%zu МиБ), showProgress=%d, nth=%d\n"

#: fwrite.c:790
msgid "Allocate %zu bytes (%zu MiB) for buffPool\n"
msgstr "Выделяю %zu байт (%zu МиБ) для 'buffPool'\n"

#: fwrite.c:794
#, c-format
msgid ""
"Unable to allocate %zu MB * %d thread buffers; '%d: %s'. Please read ?fwrite "
"for nThread, buffMB and verbose options."
msgstr ""
"Невозможно выделить %zu МБ * %d буферов потоков; '%d: %s'. Пожалуйста, "
"прочитайте ?fwrite про параметры nThread, buffMB и verbose."

#: fwrite.c:810
msgid "Can't init stream structure for deflateBound"
msgstr "Не удалось инициализировать структуру потока для deflateBound"

#: fwrite.c:815
#, c-format
msgid "zbuffSize=%d returned from deflateBound\n"
msgstr "deflateBound вернула zbuffSize=%d\n"

#: fwrite.c:821
msgid "Allocate %zu bytes (%zu MiB) for zbuffPool\n"
msgstr "Выделяю %zu байт (%zu МиБ) для zbuffPool\n"

#: fwrite.c:828
#, c-format
msgid ""
"Unable to allocate %zu MiB * %d thread compressed buffers; '%d: %s'. Please "
"read ?fwrite for nThread, buffMB and verbose options."
msgstr ""
"Не удалось выделить %zu МиБ * %d буферов сжатых данных потоков; '%d: %s'. "
"Пожалуйста, прочитайте ?fwrite про параметры nThread, buffMB и verbose."

#: fwrite.c:909
#, c-format
msgid "Failed to write gzip header. Write returned %d"
msgstr "Не удалось записать заголовок gzip. Системный вызов вернул %d"

#: fwrite.c:910
#, c-format
msgid "Failed to compress gzip. compressbuff() returned %d"
msgstr "Не удалось сжать при помощи gzip. compressbuff() вернула %d"

#: fwrite.c:911 fwrite.c:928
#, c-format
msgid "%s: '%s'"
msgstr "%s: '%s'"

#: fwrite.c:917
#, c-format
msgid "Initialization done in %.3fs\n"
msgstr "Инициализация выполнена за %.3f с\n"

#: fwrite.c:922
msgid "No data rows present (nrow==0)\n"
msgstr "Нет строк с данными (nrow==0)\n"

#: fwrite.c:1096
msgid "Failed to write gzip trailer"
msgstr "Не удалось записать концевые данные gzip"

#: fwrite.c:1115
#, c-format
msgid ""
"zlib: uncompressed length=%zu (%zu MiB), compressed length=%zu (%zu MiB), "
"ratio=%.1f%%, crc=%x\n"
msgstr ""
"zlib: исходные данные размером %zu Б (%zu МиБ), сжатые – %zu Б (%zu МиБ), "
"коэффициент сжатия=%.1f%%, CRC=%x\n"

#: fwrite.c:1119
#, c-format
msgid ""
"Written %<PRId64> rows in %.3f secs using %d thread%s. MaxBuffUsed=%d%%\n"
msgstr ""
"Записано %<PRId64> строк за %.3f с с использованием %d поток(ов)%.0s. "
"MaxBuffUsed=%d%%\n"

#: fwrite.c:1133
#, c-format
msgid ""
"zlib %s (zlib.h %s) deflate() returned error %d Z_FINISH=%d Z_BLOCK=%d. %s"
msgstr ""
"zlib %s (zlib.h %s) deflate() вернула ошибку %d с Z_FINISH=%d Z_BLOCK=%d. %s"

#: fwrite.c:1135
msgid ""
"Please include the full output above and below this message in your data."
"table bug report."
msgstr ""
"Пожалуйста, включите полный вывод выше и ниже этого сообщения в отчет об "
"ошибке data.table."

#: fwrite.c:1136
msgid ""
"Please retry fwrite() with verbose=TRUE and include the full output with "
"your data.table bug report."
msgstr ""
"Пожалуйста, запустите fwrite() ещё раз с verbose=TRUE и приложите полный "
"вывод к сообщению об ошибке в трекере data.table."

#: fwriteR.c:103
#, c-format
msgid ""
"Row %<PRId64> of list column is type '%s' - not yet implemented. fwrite() "
"can write list columns containing items which are atomic vectors of type "
"logical, integer, integer64, double, complex and character."
msgstr ""
"Строка %<PRId64> столбца списка имеет тип '%s', что пока не реализовано. "
"fwrite() может записывать столбцы-списки, содержащие элементы, которые "
"являются атомарными векторами: логическими, целочисленными, integer64, с "
"плавающей запятой, комплексными и строковыми."

#: fwriteR.c:177
msgid ""
"fwrite must be passed an object of type list; e.g. data.frame, data.table"
msgstr "fwrite принимает объекты-списки, например, data.frame и data.table"

#: fwriteR.c:188
msgid "fwrite was passed an empty list of no columns. Nothing to write."
msgstr "fwrite передан пустой список без столбцов. Нечего записывать."

#: fwriteR.c:242
#, c-format
msgid ""
"Column %d's length (%d) is not the same as column 1's length (%<PRId64>)"
msgstr "Длина столбца №%d (%d) не совпадает с длиной столбца 1 (%<PRId64>)"

#: fwriteR.c:246
#, c-format
msgid "Column %d's type is '%s' - not yet implemented in fwrite."
msgstr "Тип столбца №%d - '%s', еще не реализован в fwrite."

#: fwriteR.c:269
#, c-format
msgid ""
"input has specific integer rownames but their length (%lld) != nrow "
"(%<PRId64>)"
msgstr ""
"у входного значения специальный целочисленный атрибут row.names, но "
"указанная длина (%lld) != количеству строк (%<PRId64>)"

#: fwriteR.c:284
msgid ""
"No list columns are present. Setting sep2='' otherwise quote='auto' would "
"quote fields containing sep2.\n"
msgstr ""
"Нет столбцов-списков. Задаю sep2=''; в противном случае quote='auto' "
"приведёт к тому, что поля, содержащие sep2, будут заключены в кавычки.\n"

#: fwriteR.c:288
#, c-format
msgid ""
"If quote='auto', fields will be quoted if the field contains either sep "
"('%c') or sep2 ('%c') because column %d is a list column.\n"
msgstr ""
"Если quote='auto', поля, содержащие sep ('%c') или sep2 ('%c'), будут "
"заключены в кавычки, поскольку столбец %d является списком.\n"

#: fwriteR.c:292
#, c-format
msgid ""
"sep ('%c'), sep2 ('%c') and dec ('%c') must all be different. Column %d is a "
"list column."
msgstr ""
"sep ('%c'), sep2 ('%c') и dec ('%c') должны быть разными. Столбец №%d "
"является списком."

#: gsumm.c:50 gsumm.c:51 gsumm.c:52
#, c-format
msgid "%s is not an integer vector"
msgstr "%s не является целочисленным вектором"

#: gsumm.c:61
msgid "irowsArg is neither an integer vector nor NULL"
msgstr "irowsArg не является ни целочисленным вектором, ни NULL"

#: gsumm.c:72
#, c-format
msgid "o has length %d but sum(l)=%d"
msgstr "'o' длины %d, но sum(l)=%d"

#: gsumm.c:104
#, c-format
msgid "gforce initial population of grp took %.3f\n"
msgstr "gforce: начальное заполнение grp заняло %.3f с\n"

#: gsumm.c:124
msgid "Failed to allocate counts or TMP when assigning g in gforce"
msgstr ""
"Не удалось выделить память для 'counts' или 'TMP' при назначении g в gforce"

#: gsumm.c:203
#, c-format
msgid "gforce assign high and low took %.3f\n"
msgstr "gforce: запись 'high' и 'low' заняла %.3f с\n"

#: gsumm.c:209
#, c-format
msgid "gforce eval took %.3f\n"
msgstr "gforce: eval() занял %.3f с\n"

#: gsumm.c:342
#, c-format
msgid "gather implemented for INTSXP, REALSXP, and CPLXSXP but not '%s'"
msgstr "gather() работает для INTSXP, REALSXP, CPLXSXP, но не '%s'"

#: gsumm.c:344
#, c-format
msgid "gather took %.3fs\n"
msgstr "gather() заняло %.3f с\n"

#: gsumm.c:354 gsumm.c:585 gsumm.c:736 gsumm.c:873 gsumm.c:1028 gsumm.c:1122
#, c-format
msgid "%s is not meaningful for factors."
msgstr "%s не имеет смысла для факторов."

#: gsumm.c:358
#, c-format
msgid "This gsum (narm=%s) took ... "
msgstr "Вызов gsum(narm=%s) занимает ... "

#: gsumm.c:359 gsumm.c:593 gsumm.c:741 gsumm.c:876 gsumm.c:928 gsumm.c:1030
#: gsumm.c:1126
#, c-format
msgid "nrow [%d] != length(x) [%d] in %s"
msgstr "nrow [%d] != length(x) [%d] в %s"

#: gsumm.c:413
msgid ""
"The sum of an integer column for a group was more than type 'integer' can "
"hold so the result has been coerced to 'numeric' automatically for "
"convenience."
msgstr ""
"Групповая сумма для целочисленного столбца оказалась больше, чем может "
"вместить тип 'integer', поэтому результат был автоматически приведен к "
"'numeric'."

#: gsumm.c:574 gsumm.c:848 gsumm.c:914 gsumm.c:1099 gsumm.c:1171
#, c-format
msgid ""
"Type '%s' is not supported by GForce %s. Either add the prefix %s or turn "
"off GForce optimization using options(datatable.optimize=1)"
msgstr ""
"Тип '%s' не поддерживается GForce %s. Либо добавьте префикс %s, либо "
"отключите оптимизацию GForce при помощи options(datatable.optimize=1)"

#: gsumm.c:577 gsumm.c:725
#, c-format
msgid "%.3fs\n"
msgstr "%.3f с\n"

#: gsumm.c:592
#, c-format
msgid "This gmean took (narm=%s) ... "
msgstr "Операция gmean(narm=%s) занимает... "

#: gsumm.c:630 gsumm.c:686
#, c-format
msgid "Unable to allocate %d * %zu bytes for non-NA counts in gmean na.rm=TRUE"
msgstr ""
"Не удалось выделить %d * %zu байт для количеств не-пропущенных значений в "
"gmean(na.rm=TRUE)"

#: gsumm.c:722
#, c-format
msgid ""
"Type '%s' not supported by GForce mean (gmean). Either add the prefix base::"
"mean(.) or turn off GForce optimization using options(datatable.optimize=1)"
msgstr ""
"Тип '%s' не поддерживается GForce mean() (gmean). Либо добавьте префикс "
"base::mean(.), либо отключите оптимизацию GForce с помощью options(datatable."
"optimize=1)"

#: gsumm.c:734
msgid ""
"GForce min/max can only be applied to columns, not .SD or similar. To find "
"min/max of all items in a list such as .SD, either add the prefix base::min(."
"SD) or turn off GForce optimization using options(datatable.optimize=1). "
"More likely, you may be looking for 'DT[,lapply(.SD,min),by=,.SDcols=]'"
msgstr ""
"GForce min/max можно применять только к столбцам, но не к .SD и тому "
"подобным. Чтобы найти min/max для всех элементов в списке, например .SD, "
"либо добавьте префикс base::min(.SD), либо отключите оптимизацию GForce с "
"помощью options(datatable.optimize=1). Скорее всего, Вам нужно 'DT[,lapply(."
"SD,min),by=,.SDcols=]'"

#: gsumm.c:845
msgid "Type 'complex' has no well-defined min/max"
msgstr "Для комплексных чисел нет максимума или минимума"

#: gsumm.c:871
msgid ""
"GForce median can only be applied to columns, not .SD or similar. To find "
"median of all items in a list such as .SD, either add the prefix stats::"
"median(.SD) or turn off GForce optimization using options(datatable."
"optimize=1). More likely, you may be looking for 'DT[,lapply(.SD,median),"
"by=,.SDcols=]'"
msgstr ""
"GForce median можно применять только к столбцам, но не к .SD и тому "
"подобным. Чтобы найти медиану для всех элементов в списке, например .SD, "
"либо добавьте префикс stats::median(.SD), либо отключите оптимизацию GForce "
"с помощью options(datatable.optimize=1). Скорее всего, Вам нужно 'DT[,"
"lapply(.SD,median),by=,.SDcols=]'"

#: gsumm.c:988
#, c-format
msgid ""
"Type '%s' is not supported by GForce head/tail/first/last/`[`. Either add "
"the namespace prefix (e.g. utils::head(.)) or turn off GForce optimization "
"using options(datatable.optimize=1)"
msgstr ""
"Тип '%s' не поддерживается GForce head/tail/first/last/`[`. Либо добавьте "
"префикс пространства имен (например, utils::head(.)), либо отключите "
"оптимизацию GForce с помощью options(datatable.optimize=1)"

#: gsumm.c:1026
msgid ""
"GForce var/sd can only be applied to columns, not .SD or similar. For the "
"full covariance matrix of all items in a list such as .SD, either add the "
"prefix stats::var(.SD) (or stats::sd(.SD)) or turn off GForce optimization "
"using options(datatable.optimize=1). Alternatively, if you only need the "
"diagonal elements, 'DT[,lapply(.SD,var),by=,.SDcols=]' is the optimized way "
"to do this."
msgstr ""
"GForce var/sd можно применять только к столбцам, но не к .SD и тому "
"подобным. Для получения полной ковариационной матрицы всех элементов списка, "
"например .SD, либо добавьте префикс stats::var(.SD) (или stats::sd(.SD)), "
"либо отключите оптимизацию GForce с помощью options(datatable.optimize=1). "
"Если Вам нужны только диагональные элементы, попробуйте 'DT[,lapply(.SD,var),"
"by=,.SDcols=]'."

#: gsumm.c:1120
msgid ""
"GForce prod can only be applied to columns, not .SD or similar. To multiply "
"all items in a list such as .SD, either add the prefix base::prod(.SD) or "
"turn off GForce optimization using options(datatable.optimize=1). More "
"likely, you may be looking for 'DT[,lapply(.SD,prod),by=,.SDcols=]'"
msgstr ""
"GForce prod можно применять только к столбцам, но не к .SD и тому подобным. "
"Чтобы перемножить все элементы в списке, например .SD, либо добавьте префикс "
"base::prod(.SD), либо отключите оптимизацию GForce с помощью "
"options(datatable.optimize=1). Вероятно, Вам нужно 'DT[,lapply(.SD,prod),"
"by=,.SDcols=]'"

#: gsumm.c:1129
#, c-format
msgid "Unable to allocate %d * %zu bytes for gprod"
msgstr "Не удалось выделить %d * %zu байт для gprod"

#: gsumm.c:1220 shift.c:34
#, c-format
msgid "Item %d of n is NA"
msgstr "Элемент №%d из n является NA"

#: gsumm.c:1277
#, c-format
msgid ""
"Type '%s' is not supported by GForce gshift. Either add the namespace prefix "
"(e.g. data.table::shift(.)) or turn off GForce optimization using "
"options(datatable.optimize=1)"
msgstr ""
"Тип '%s' не поддерживается GForce gshift. Либо добавьте префикс пространства "
"имен (например, data.table::shift(.)), либо отключите оптимизацию GForce с "
"помощью options(datatable.optimize=1)"

#: idatetime.c:126 vecseq.c:13
msgid "x must be an integer vector"
msgstr "x должен быть целочисленным вектором"

#: ijoin.c:128
#, c-format
msgid "First pass on calculating lengths in lookup ... done in %8.3f seconds\n"
msgstr ""
"Первый проход вычислений длин в функции lookup() ... выполнен за %8.3f "
"секунд\n"

#: ijoin.c:141
#, c-format
msgid "Second pass on allocation in lookup ... done in %8.3f seconds\n"
msgstr ""
"Второй проход, выделение памяти в lookup() ... выполнено за %8.3f секунд\n"

#: ijoin.c:220
#, c-format
msgid "Final step in generating lookup ... done in %8.3f seconds\n"
msgstr "Последний проход, вычисление lookup() ... готово за %8.3f секунд\n"

#: ijoin.c:330
#, c-format
msgid ""
"First pass on calculating lengths in overlaps ... done in %8.3f seconds\n"
msgstr ""
"Первый проход, вычисление длин в overlaps() ... выполнено за %8.3f секунд\n"

#: ijoin.c:729
#, c-format
msgid "Final step, fetching indices in overlaps ... done in %8.3f seconds\n"
msgstr ""
"Последний проход, получение индексов в overlaps() ... готово за %8.3f "
"секунд\n"

#: init.c:173
msgid ""
"Pointers are %zu bytes, greater than 8. We have not tested on any "
"architecture greater than 64bit yet."
msgstr ""
"Указатели имеют размер %zu байт, что больше 8. Мы ничего не тестировали на "
"архитектурах с более чем 64-битным адресным пространством."

#: init.c:187
msgid "... failed. Please forward this message to maintainer('data.table')."
msgstr ""
"... ошибка. Пожалуйста, перешлите это сообщение по адресу maintainer('data."
"table')."

#: init.c:188
#, c-format
msgid "Checking NA_INTEGER [%d] == INT_MIN [%d] %s"
msgstr "Проверяю NA_INTEGER [%d] == INT_MIN [%d] %s"

#: init.c:189
#, c-format
msgid "Checking NA_INTEGER [%d] == NA_LOGICAL [%d] %s"
msgstr "Проверяю NA_INTEGER [%d] == NA_LOGICAL [%d] %s"

#: init.c:190 init.c:191 init.c:193 init.c:196 init.c:197 init.c:198 init.c:199
#: init.c:200 init.c:201 init.c:202
#, c-format
msgid "Checking sizeof(%s) [%zu] is %d %s"
msgstr "Проверяю sizeof(%s) [%zu] == %d %s"

#: init.c:194
#, c-format
msgid "Checking sizeof(pointer) [%zu] is 4 or 8 %s"
msgstr "Проверяю sizeof(указатель) [%zu] == 4 или 8 %s"

#: init.c:195
#, c-format
msgid "Checking sizeof(SEXP) [%zu] == sizeof(pointer) [%zu] %s"
msgstr "Проверяю sizeof(SEXP) [%zu] == sizeof(указатель) [%zu] %s"

#: init.c:205
#, c-format
msgid "Checking LENGTH(allocVector(INTSXP,2)) [%d] is 2 %s"
msgstr "Проверяю, что LENGTH(allocVector(INTSXP,2)) [%d] == 2 %s"

#: init.c:207
#, c-format
msgid "Checking TRUELENGTH(allocVector(INTSXP,2)) [%lld] is 0 %s"
msgstr "Проверяю, что TRUELENGTH(allocVector(INTSXP,2)) [%lld] == 0 %s"

#: init.c:214
#, c-format
msgid "Checking memset(&i,0,sizeof(int)); i == (int)0 %s"
msgstr "Проверяю: memset(&i,0,sizeof(int)); i == (int)0 %s"

#: init.c:217
#, c-format
msgid "Checking memset(&ui, 0, sizeof(unsigned int)); ui == (unsigned int)0 %s"
msgstr ""
"Проверяю: memset(&ui, 0, sizeof(unsigned int)); ui == (unsigned int)0 %s"

#: init.c:220
#, c-format
msgid "Checking memset(&d, 0, sizeof(double)); d == (double)0.0 %s"
msgstr "Проверяю: memset(&d, 0, sizeof(double)); d == (double)0.0 %s"

#: init.c:223
#, c-format
msgid "Checking memset(&ld, 0, sizeof(long double)); ld == (long double)0.0 %s"
msgstr ""
"Проверяю: memset(&ld, 0, sizeof(long double)); ld == (long double)0.0 %s"

#: init.c:226
msgid ""
"Unlike the very common case, e.g. ASCII, the character '/' is not just "
"before '0'."
msgstr ""
"В отличие от ASCII-совместимых кодировок, в системной кодировке символ '/' "
"не располагается сразу перед '0'."

#: init.c:227
msgid "The C expression (uint_fast8_t)('/'-'0')<10 is true. Should be false."
msgstr ""
"Выражение на языке C (uint_fast8_t)('/'-'0')<10 возвращает истину, а должно "
"возвращать ложь."

#: init.c:228
msgid ""
"Unlike the very common case, e.g. ASCII, the character ':' is not just after "
"'9'."
msgstr ""
"В отличие от ASCII-совместимых кодировок, в системной кодировке символ ':' "
"не располагается сразу после '9'."

#: init.c:229
msgid "The C expression (uint_fast8_t)('9'-':')<10 is true. Should be false."
msgstr ""
"Выражение на языке C (uint_fast8_t)('9'-':')<10 возвращает истину, а должно "
"возвращать ложь."

#: init.c:234
#, c-format
msgid "Conversion of NA_INT64 via double failed %<PRId64>!=%<PRId64>"
msgstr ""
"Не удалось перевести NA_INT64 в double и обратно без потерь: %<PRId64>!"
"=%<PRId64>"

#: init.c:238
msgid "NA_INT64_D (negative -0.0) is not == 0.0."
msgstr ""
"NA_INT64_D (-0.0, отрицательный ноль с плавающей запятой) не равно == 0.0."

#: init.c:239
msgid "NA_INT64_D (negative -0.0) is not ==-0.0."
msgstr ""
"NA_INT64_D (-0.0, отрицательный ноль с плавающей запятой) не равно == -0.0."

#: init.c:240
msgid "ISNAN(NA_INT64_D) is TRUE but should not be"
msgstr "ISNAN(NA_INT64_D) равно TRUE, хотя не должно"

#: init.c:241
msgid "isnan(NA_INT64_D) is TRUE but should not be"
msgstr "isnan(NA_INT64_D) равно TRUE, хотя не должно"

#: init.c:275
#, c-format
msgid "PRINTNAME(install(\"integer64\")) has returned %s not %s"
msgstr "PRINTNAME(install(\"integer64\")) вернула %s вместо %s"

#: init.c:334
msgid "verbose option must be length 1 non-NA logical or integer"
msgstr ""
"опция \"verbose\" должна быть логическим или целочисленным скаляром, не-NA"

#: init.c:368
msgid ".Last.updated in namespace is not a length 1 integer"
msgstr ""
".Last.updated в пространстве имён data.table не является целочисленным "
"вектором длины 1"

#: nafill.c:115
msgid ""
"'x' argument is atomic vector, in-place update is supported only for list/"
"data.table"
msgstr ""
"Аргумент 'x' - атомарный вектор; обновление на месте поддерживается только "
"для списка/data.table"

#: nafill.c:117 nafill.c:128
msgid "'x' argument must be numeric type, or list/data.table of numeric types"
msgstr ""
"Аргумент 'x' должен быть численным или списком/data.table численных векторов"

#: nafill.c:184
msgid "fill must be a vector of length 1 or a list of length of x"
msgstr ""
"'fill' должен быть вектором длины 1 или списком такой же длины, как 'x'"

#: negate.c:5
msgid "not logical or integer vector"
msgstr "не является логическим или целочисленным вектором"

#: openmp-utils.c:23
#, c-format
msgid ""
"Ignoring invalid %s==\"%s\". Not an integer >= 1. Please remove any "
"characters that are not a digit [0-9]. See ?data.table::setDTthreads."
msgstr ""
"Игнорирую неправильное %s==\"%s\", потому что оно не является целым числом "
">= 1. Удалите все символы, которые не являются цифрами [0-9]. См. ?data."
"table::setDTthreads."

#: openmp-utils.c:44
#, c-format
msgid ""
"Ignoring invalid R_DATATABLE_NUM_PROCS_PERCENT==%d. If used it must be an "
"integer between 2 and 100. Default is 50. See ?setDTtheads."
msgstr ""
"Игнорирую неправильное значение R_DATATABLE_NUM_PROCS_PERCENT==%d. Должно "
"быть целым между 2 и 100, по умолчанию 50. См. ?setDTtheads."

#: openmp-utils.c:82
msgid ""
"This installation of data.table has not been compiled with OpenMP support.\n"
msgstr "Эта копия data.table не была собрана с поддержкой OpenMP.\n"

#: openmp-utils.c:84
#, c-format
msgid "  OpenMP version (_OPENMP)       %d\n"
msgstr "  версия OpenMP (_OPENMP)        %d\n"

#: openmp-utils.c:100
#, c-format
msgid ""
"  data.table is using %d threads with throttle==%d. See ?setDTthreads.\n"
msgstr ""
"  data.table использует %d потоков с throttle==%d. См. ?setDTthreads.\n"

#: openmp-utils.c:108
msgid ""
"restore_after_fork= must be TRUE, FALSE, or NULL (default). "
"getDTthreads(verbose=TRUE) reports the current setting.\n"
msgstr ""
"restore_after_fork= должно быть TRUE, FALSE или NULL (по умолчанию). "
"getDTthreads(verbose=TRUE) сообщает о текущих настройках.\n"

#: openmp-utils.c:114
msgid "'throttle' must be a single number, non-NA, and >=1"
msgstr "'throttle' должно быть числом, не NА и >=1"

#: openmp-utils.c:128
msgid ""
"threads= must be either NULL or a single number >= 0. See ?setDTthreads."
msgstr "threads= должен быть либо NULL, либо числом >= 0. См. ?setDTthreads."

#: programming.c:17
#, c-format
msgid ""
"Attempting to substitute '%s' element with object of type '%s' but it has to "
"be 'symbol' type when substituting name of the call argument, functions 'as."
"name' and 'I' can be used to work out proper substitution, see ?substitute2 "
"examples."
msgstr ""
"Попытка подставить вместо имени '%s' объект типа '%s', но в качестве имён "
"аргументов функций работают только типы 'symbol' и 'character'. Используйте "
"I() и as.name(), чтобы собрать подходящий аргумент 'env'. См. примеры ?"
"substitute2."

#: rbindlist.c:10
msgid "use.names= should be TRUE, FALSE, or not used (\"check\" by default)"
msgstr ""
"use.names= должно быть TRUE, FALSE или не использоваться (\"check\" по "
"умолчанию)"

#: rbindlist.c:14
msgid ""
"Input to rbindlist must be a list. This list can contain data.tables, data."
"frames or plain lists."
msgstr ""
"Входной аргумент для rbindlist должен представлять собой список. Этот список "
"может содержать data.table, data.frame или обычные списки."

#: rbindlist.c:33
#, c-format
msgid "Item %d of input is not a data.frame, data.table or list"
msgstr ""
"Элемент №%d входного аргумента не является data.frame, data.table или списком"

#: rbindlist.c:41
#, c-format
msgid ""
"Item %d has %d columns, inconsistent with item %d which has %d columns. To "
"fill missing columns use fill=TRUE."
msgstr ""
"В элементе №%d - %d столбцов, что не соответствует элементу %d, в котором %d "
"столбцов. Чтобы дополнить недостающие столбцы, используйте fill=TRUE."

#: rbindlist.c:44
#, c-format
msgid "Item %d has %d columns but %d column names. Invalid object."
msgstr ""
"В элементе №%d - %d столбцов, но %d имён столбцов. Это неправильный объект."

#: rbindlist.c:51
#, c-format
msgid ""
"Column %d of item %d is length %d inconsistent with column %d which is "
"length %d. Only length-1 columns are recycled."
msgstr ""
"Столбец %d элемента №%d длиной %d несовместим со столбцом %d, длина которого "
"составляет %d. \"Повторно используются\" только столбцы длины 1."

#: rbindlist.c:66
#, c-format
msgid ""
"Total rows in the list is %<PRId64> which is larger than the maximum number "
"of rows, currently %d"
msgstr ""
"В списке всего %<PRId64> строк, что больше, чем максимально возможное "
"количество строк, в настоящее время %d"

#: rbindlist.c:67
msgid "use.names=TRUE but no item of input list has any names"
msgstr "use.names=TRUE, но ни один элемент входного списка не имеет имен"

#: rbindlist.c:76
#, c-format
msgid ""
"Failed to allocate upper bound of %<PRId64> unique column names "
"[sum(lapply(l,ncol))]"
msgstr ""
"Не удалось выделить память под верхнюю оценку количества уникальных имён "
"столбцов [sum(lapply(l,ncol)) = %<PRId64>]"

#: rbindlist.c:105
#, c-format
msgid "Failed to allocate nuniq=%d items working memory in rbindlist.c"
msgstr "Не удалось выделить nuniq=%d элементов рабочей памяти в rbindlist.c"

#: rbindlist.c:140
#, c-format
msgid "Failed to allocate ncol=%d items working memory in rbindlist.c"
msgstr "Не удалось выделить ncol=%d элементов рабочей памяти в rbindlist.c"

#: rbindlist.c:201
msgid ""
" use.names='check' (default from v1.12.2) emits this message and proceeds as "
"if use.names=FALSE for  backwards compatibility. See news item 5 in v1.12.2 "
"for options to control this message."
msgstr ""
" в целях обратной совместимости use.names='check' (по умолчанию с версии "
"1.12.2) выдает это сообщение и продолжает работу, как если бы было use."
"names=FALSE. О том, как управлять этим сообщением, см. в новости 5 для "
"версии 1.12.2."

#: rbindlist.c:215
#, c-format
msgid ""
"Column %d ['%s'] of item %d is missing in item %d. Use fill=TRUE to fill "
"with NA (NULL for list columns), or use.names=FALSE to ignore column names.%s"
msgstr ""
"Столбец %d ['%s'] элемента №%d отсутствует в элементе №%d. Используйте "
"fill=TRUE для заполнения NA (NULL для столбцов списка), или use.names=FALSE "
"для игнорирования имен столбцов.%s"

#: rbindlist.c:224
#, c-format
msgid ""
"Column %d ['%s'] of item %d appears in position %d in item %d. Set use."
"names=TRUE to match by column name, or use.names=FALSE to ignore column "
"names.%s"
msgstr ""
"Столбец %d ['%s'] элемента №%d появляется в позиции %d в элементе №%d. "
"Установите use.names=TRUE для поиска по имени столбца или use.names=FALSE "
"для игнорирования имен столбцов.%s"

#: rbindlist.c:233
msgid ""
"options()$datatable.rbindlist.check is set but is not a single string. See "
"news item 5 in v1.12.2."
msgstr ""
"options()$datatable.rbindlist.check задано, но не является строкой. См. "
"новость 5 в версии 1.12.2."

#: rbindlist.c:240
#, c-format
msgid ""
"options()$datatable.rbindlist.check=='%s' which is not "
"'message'|'warning'|'error'|'none'. See news item 5 in v1.12.2."
msgstr ""
"options()$datatable.rbindlist.check=='%s', что не является "
"'message'|'warning'|'error'|'none'. См. новость 5 в версии 1.12.2."

#: rbindlist.c:303
#, c-format
msgid ""
"Column %d of item %d has type 'factor' but has no levels; i.e. malformed."
msgstr ""
"Столбец %d элемента №%d имеет тип 'factor', но не имеет уровней, т.е. "
"некорректен."

#: rbindlist.c:332
#, c-format
msgid ""
"Class attribute on column %d of item %d does not match with column %d of "
"item %d. You can deactivate this safety-check by using ignore.attr=TRUE"
msgstr ""
"Атрибут 'class' в столбце %d элемента №%d не совпадает со столбцом %d "
"элемента №%d. Вы можете отключить эту проверку, используя ignore.attr=TRUE"

#: rbindlist.c:383
#, c-format
msgid ""
"Failed to allocate working memory for %d ordered factor levels of result "
"column %d"
msgstr ""
"Не удалось выделить рабочую память для %d упорядоченных уровней факторов в "
"столбце результатов №%d"

#: rbindlist.c:406
#, c-format
msgid ""
"Column %d of item %d is an ordered factor but level %d ['%s'] is missing "
"from the ordered levels from column %d of item %d. Each set of ordered "
"factor levels should be an ordered subset of the first longest. A regular "
"factor will be created for this column."
msgstr ""
"Столбец %d элемента №%d является упорядоченным фактором, но уровень %d "
"['%s'] отсутствует в упорядоченных уровнях из столбца %d элемента №%d. "
"Каждый набор упорядоченных уровней фактора должен быть упорядоченным "
"подмножеством первого самого длинного. Для этого столбца будет создан "
"обычный фактор."

#: rbindlist.c:411
#, c-format
msgid ""
"Column %d of item %d is an ordered factor with '%s'<'%s' in its levels. But "
"'%s'<'%s' in the ordered levels from column %d of item %d. A regular factor "
"will be created for this column due to this ambiguity."
msgstr ""
"Столбец %1$d элемента №%2$d является упорядоченным фактором с '%3$s'<'%4$s' "
"в его уровнях. Однако, в упорядоченных уровнях из столбца %7$d элемента №"
"%8$d '%5$s'<'%6$s'. Из-за этой неоднозначности для этого столбца будет "
"создан обычный фактор."

#: rbindlist.c:456
#, c-format
msgid ""
"Failed to allocate working memory for %d factor levels of result column %d "
"when reading item %d of item %d"
msgstr ""
"Не удалось выделить рабочую память для %d уровней факторов в столбце "
"результатов %d при чтении элемента №%d из элемента №%d"

#: rbindlist.c:548 rbindlist.c:551
#, c-format
msgid "Column %d of item %d: %s"
msgstr "Столбец %d элемента %d: %s"

#: reorder.c:22
#, c-format
msgid "Item %d of list is type '%s' which isn't yet supported (SIZEOF=%zu)"
msgstr ""
"Элемент списка №%d имеет тип '%s', который пока не поддерживается "
"(SIZEOF=%zu)"

#: reorder.c:24
#, c-format
msgid ""
"Column %d is length %d which differs from length of column 1 (%d). Invalid "
"data.table."
msgstr ""
"Столбец №%d имеет длину %d, которая отличается от длины столбца №1 (%d). "
"Неправильная таблица данных."

#: reorder.c:32
#, c-format
msgid ""
"reorder accepts vectors but this non-VECSXP is type '%s' which isn't yet "
"supported (SIZEOF=%zu)"
msgstr ""
"reorder() принимает векторы, но этот не-VECSXP вектор имеет тип '%s', "
"который пока не поддерживается (SIZEOF=%zu)"

#: reorder.c:39
msgid "order must be an integer vector"
msgstr "order должен быть целочисленным вектором"

#: reorder.c:58
#, c-format
msgid ""
"Item %d of order (%d) is either NA, out of range [1,%d], or is duplicated. "
"The new order must be a strict permutation of 1:n"
msgstr ""
"Элемент №%d вектора 'order' (%d) является либо NA, либо находится вне "
"диапазона [1,%d], либо дублирован. Новый порядок должен быть перестановкой 1:"
"n без повторения"

#: reorder.c:118
msgid "dt passed to setcolorder has no names"
msgstr "в функции setcolorder у dt нет имён"

#: shift.c:12
msgid ""
"shift input must not be matrix or array, consider wrapping it into data."
"table() or c()"
msgstr ""
"входной аргумент для shift() не должен быть матрицей или массивом; возможно, "
"Вам стоит обернуть его в data.table() или c()"

#: shift.c:17
#, c-format
msgid ""
"type '%s' passed to shift(). Must be a vector, list, data.frame or data.table"
msgstr ""
"в shift() передан объект типа '%s'. Должен быть вектором, списком, data."
"frame или data.table"

#: snprintf.c:193 snprintf.c:196 snprintf.c:199 snprintf.c:202 snprintf.c:205
#: snprintf.c:208 snprintf.c:211 snprintf.c:214 snprintf.c:217 snprintf.c:221
#: snprintf.c:224 snprintf.c:227 snprintf.c:230 snprintf.c:233 snprintf.c:236
#: snprintf.c:239 snprintf.c:242 snprintf.c:245
#, c-format
msgid "dt_win_snprintf test %d failed: %s"
msgstr "dt_win_snprintf тест %d завершился с ошибкой: %s"

#: snprintf.c:218
#, c-format
msgid "dt_win_snprintf test %d failed: %d"
msgstr "dt_win_snprintf тест %d завершился с ошибкой: %d"

#: subset.c:182
#, c-format
msgid ""
"Item %d of i is %d and item %d is %d. Cannot mix positives and negatives."
msgstr ""
"Элемент №%d в i равен %d, а элемент №%d равен %d. Нельзя смешивать "
"положительные и отрицательные значения."

#: subset.c:192
#, c-format
msgid "Item %d of i is %d and item %d is NA. Cannot mix negatives and NA."
msgstr ""
"Элемент №%d в i - это %d, а элемент №%d - это NA. Нельзя смешивать "
"отрицательные значения и NA."

#: subset.c:239
#, c-format
msgid ""
"Item %d of i is %d but there are only %d rows. Ignoring this and %d more "
"like it out of %d."
msgstr ""
"Элемент №%d из i - это %d, но есть только %d строк. Пропускаю его и еще %d "
"из %d подобных элементов."

#: subset.c:241
#, c-format
msgid ""
"Item %d of i is %d which removes that item but that has occurred before. "
"Ignoring this dup and %d other dups."
msgstr ""
"Элемент №%d из i - это %d, который удаляет этот уже удалённый элемент. "
"Пропускаю этот дубль и %d других дублей."

#: subset.c:255
#, c-format
msgid "Column %d is NULL; malformed data.table."
msgstr "Столбец %d является NULL; неправильная data.table."

#: subset.c:258
#, c-format
msgid "Column %d ['%s'] is a data.frame or data.table; malformed data.table."
msgstr ""
"Столбец %d ['%s'] является data.frame или data.table; неправильная data."
"table."

#: subset.c:263
#, c-format
msgid ""
"Column %d ['%s'] is length %d but column 1 is length %d; malformed data."
"table."
msgstr ""
"Столбец %d ['%s'] имеет длину %d, но столбец 1 имеет длину %d; неправильная "
"data.table."

#: subset.c:296
#, c-format
msgid "Item %d of cols is %d which is outside the range [1,ncol(x)=%d]"
msgstr ""
"Элемент №%d из 'cols' равен %d, что выходит за пределы диапазона [1,"
"ncol(x)=%d]"

#: transpose.c:9
msgid "l must be a list."
msgstr "'I' должно быть списком."

#: transpose.c:13
msgid "ignore.empty should be logical TRUE/FALSE."
msgstr "ignore.empty должен быть логическим TRUE/FALSE."

#: transpose.c:16
msgid ""
"keep.names should be either NULL, or the name of the first column of the "
"result in which to place the names of the input"
msgstr ""
"keep.names должен быть либо NULL, либо именем первого столбца результата, в "
"который следует поместить имена входных данных"

#: transpose.c:19
msgid "fill must be a length 1 vector, such as the default NA"
msgstr "fill должен быть вектором длины 1, например, по умолчанию NA"

#: transpose.c:22
msgid "list.cols should be logical TRUE/FALSE."
msgstr "list.cols должен быть логическим TRUE/FALSE."

#: transpose.c:31
#, c-format
msgid "Item %d of list input is not either an atomic vector, or a list"
msgstr ""
"Элемент №%d входного списка не является ни атомарным вектором, ни списком"

#: uniqlist.c:151
msgid "Input argument 'x' to 'uniqlengths' must be an integer vector"
msgstr ""
"Входной аргумент 'x' функции 'uniqlengths' должен быть целочисленным вектором"

#: uniqlist.c:152
msgid ""
"Input argument 'n' to 'uniqlengths' must be an integer vector of length 1"
msgstr "Входной аргумент 'n' функции 'uniqlengths' должен быть целым числом"

#: uniqlist.c:170 uniqlist.c:267
msgid "cols must be an integer vector with length >= 1"
msgstr "cols должен быть целочисленным вектором длины >= 1"

#: uniqlist.c:174
#, c-format
msgid "Item %d of cols is %d which is outside the range [1,length(l)=%d]"
msgstr "cols[%d] = %d, что вне допустимого диапазона [1,length(l)=%d]"

#: uniqlist.c:177
#, c-format
msgid ""
"All elements to input list must be of same length. Element [%d] has length "
"%<PRIu64> != length of first element = %<PRIu64>."
msgstr ""
"Все элементы входного списка должны быть одинаковой длины. Элемент [%d] дан "
"длины %<PRIu64>, что не равно длине первого элемента, %<PRIu64>."

#: uniqlist.c:352
msgid "x is not a logical vector"
msgstr "x не является логическим вектором"

#: utils.c:95
#, c-format
msgid "Unsupported type '%s' passed to allNA()"
msgstr "Функции allNA() передано значение неподдерживаемого типа '%s'"

#: utils.c:115
msgid "'x' argument must be data.table compatible"
msgstr "аргумент 'x' должен быть совместимым с data.table"

#: utils.c:139
msgid ""
"argument specifying columns is type 'double' and one or more items in it are "
"not whole integers"
msgstr ""
"номера строк переданы в виде чисел с плавающей запятой, и как минимум одно "
"из них не является целым"

#: utils.c:145
#, c-format
msgid ""
"argument specifying columns received non-existing column(s): cols[%d]=%d"
msgstr "передан несуществующий столбец: cols[%d]='%d'"

#: utils.c:152
msgid "'x' argument data.table has no names"
msgstr "'x', переданный data.table(), не имеет имён"

#: utils.c:158
#, c-format
msgid ""
"argument specifying columns received non-existing column(s): cols[%d]='%s'"
msgstr "передан несуществующий столбец: cols[%d]='%s'"

#: utils.c:162
msgid "argument specifying columns must be character or numeric"
msgstr "переданный список столбцов должен быть вектором строк или чисел"

#: utils.c:165
msgid "argument specifying columns received duplicate column(s)"
msgstr "в переданном списке столбцов нашлись дубликаты"

#: utils.c:383
msgid "'x' is not atomic"
msgstr "'x' не является атомарным"

#: utils.c:385
msgid "'x' must not be matrix or array"
msgstr "'x' не должен быть матрицей или многомерным массивом"

#: utils.c:387
msgid "input must not be matrix or array"
msgstr "входной аргумент не должен быть матрицей или многомерным массивом"

#: utils.c:391
#, c-format
msgid "copy=false and input already of expected type and class %s[%s]\n"
msgstr "copy=false и входные данные и так нужного типа и класса %s[%s]\n"

#: utils.c:398
#, c-format
msgid "Coercing %s[%s] into %s[%s]\n"
msgstr "Преобразую %s[%s] в %s[%s]\n"

#: utils.c:414
#, c-format
msgid "zlib header files were not found when data.table was compiled"
msgstr "При компиляции data.table не были найдены заголовочные файлы zlib"

#: vecseq.c:14
msgid "len must be an integer vector"
msgstr "'len' должна быть целочисленным вектором"

#: vecseq.c:15
msgid "x and len must be the same length"
msgstr "'x' и 'len' должны быть одинаковой длины"

#: vecseq.c:21
msgid ""
"Join results in more than 2^31 rows (internal vecseq reached physical "
"limit). Very likely misspecified join. Check for duplicate key values in i "
"each of which join to the same group in x over and over again. If that's ok, "
"try by=.EACHI to run j for each group to avoid the large allocation. "
"Otherwise, please search for this error message in the FAQ, Wiki, Stack "
"Overflow and data.table issue tracker for advice."
msgstr ""
"Соединение даёт >= 2^31 строк, что превышает физический лимит на длину "
"столбца. Проверьте, нет ли дублирующихся значений ключей в 'i', которые "
"больше одного раза подходят к группам из 'x'. Если подобный результат Вас "
"устроит, попробуйте by=.EACHI, чтобы выполнить 'j' для каждой группы в "
"отдельности и избежать большого выделения памяти. В противном случае, "
"попробуйте поискать это сообщение об ошибке — «Join results in more than "
"2^31 rows (internal vecseq reached physical limit)» — в ЧаВо, Wiki, Stack "
"Overflow, а также трекере ошибок в data.table."

#: vecseq.c:25
msgid "clamp must be a double vector length 1"
msgstr "'clamp' должно быть действительным числом (вектор длины 1)"

#: vecseq.c:27
msgid "clamp must be positive"
msgstr "'clamp' должно быть положительным"

#: vecseq.c:28
#, c-format
msgid ""
"Join results in %d rows; more than %d = nrow(x)+nrow(i). Check for duplicate "
"key values in i each of which join to the same group in x over and over "
"again. If that's ok, try by=.EACHI to run j for each group to avoid the "
"large allocation. If you are sure you wish to proceed, rerun with allow."
"cartesian=TRUE. Otherwise, please search for this error message in the FAQ, "
"Wiki, Stack Overflow and data.table issue tracker for advice."
msgstr ""
"Соединение даёт %1$d строк, что больше, чем %2$d = nrow(x)+nrow(i). "
"Проверьте, нет ли дублирующихся значений ключей в 'i', которые больше одного "
"раза подходят к группам из 'x'. Если подобный результат Вас устроит, "
"попробуйте by=.EACHI, чтобы выполнить 'j' для каждой группы в отдельности и "
"избежать большого выделения памяти. Если Вы хотите именно перекрёстное "
"слияние, используйте allow.cartesian=TRUE. В противном случае, попробуйте "
"поискать это сообщение об ошибке («Join results in %1$d rows; more than %2$d "
"= nrow(x)+nrow(i)») в ЧаВо, Wiki, Stack Overflow, а также трекере ошибок в "
"data.table."

#: wrappers.c:11
msgid "Attribute name must be a character vector of length 1"
msgstr "Имя атрибута должно быть строкой (вектором длины 1)"

#: wrappers.c:16
msgid ""
"Internal structure doesn't seem to be a list. Can't set class to be 'data."
"table' or 'data.frame'. Use 'as.data.table()' or 'as.data.frame()' methods "
"instead."
msgstr ""
"Внутренняя структура не является списком. Не могу выставить класс 'data."
"table' или 'data.frame'. Пожалуйста, используйте вместо этого 'as.data."
"table()' или 'as.data.frame()'."

#: wrappers.c:68
#, c-format
msgid "i (%d) is outside the range of items [1,%d]"
msgstr "i (%d) вне допустимого диапазона [1,%d]"

#: wrappers.c:99
msgid "x isn't a VECSXP"
msgstr "x не является VECSXP"

#: wrappers.c:114
#, c-format
msgid ""
"dim.data.table expects a data.table as input (which is a list), but seems to "
"be of type %s"
msgstr ""
"Для dim.data.table() в качестве входного аргумента нужна data.table (т.е. "
"список), а досталось значение типа %s"

#, c-format
#~ msgid "savetl_init checks failed (%d %d %p %p)"
#~ msgstr "неудачная проверка в savetl_init (%d %d %p %p)"

#, c-format
#~ msgid "%8.3fs (%3.0f%%) sep="
#~ msgstr "%8.3f с (%3.0f%%) sep="

#, c-format
#~ msgid "Compress gzip error: %d"
#~ msgstr "Ошибка сжатия gzip: %d"

#, c-format
#~ msgid "RHS_list_of_columns == %s\n"
#~ msgstr "RHS_list_of_columns == %s\n"

#~ msgid "%"
#~ msgstr "%"

#, c-format
#~ msgid "typeof x.%s (%s) != typeof i.%s (%s)"
#~ msgstr "typeof x.%s (%s) != typeof i.%s (%s)"

#, c-format
#~ msgid "!length(bynames)[%d]==length(groups)[%d]==length(grpcols)[%d]"
#~ msgstr "!length(bynames)[%d]==length(groups)[%d]==length(grpcols)[%d]"

#~ msgid "length(names)!=length(SD)"
#~ msgstr "length(names)!=length(SD)"

#~ msgid "length(xknames)!=length(xSD)"
#~ msgstr "length(xknames)!=length(xSD)"

#, c-format
#~ msgid "dogroups: length(ans)[%d]!=ngrpcols[%d]+njval[%d]"
#~ msgstr "dogroups: length(ans)[%d]!=ngrpcols[%d]+njval[%d]"

#~ msgid "names(data) is NULL. Please report to data.table-help"
#~ msgstr ""
#~ "names(data) равно NULL. Пожалуйста, обратитесь в трекер ошибок data.table"

#, c-format
#~ msgid "nradix=%d\n"
#~ msgstr "nradix=%d\n"

#, c-format
#~ msgid "stat[%03d]==%20<PRIu64>\n"
#~ msgstr "stat[%03d]==%20<PRIu64>\n"

#~ msgid "  NAstrings = ["
#~ msgstr "  NAstrings = ["

#~ msgid "]\n"
#~ msgstr "]\n"

#, c-format
#~ msgid "nrow limit (%<PRIu64>) supplied\n"
#~ msgstr "передан предел количества строк (%<PRIu64>)\n"

#~ msgid "jump0size==0\n"
#~ msgstr "jump0size==0\n"

#~ msgid "  =====\n"
#~ msgstr "  =====\n"

#, c-format
#~ msgid "  jumps=[%d..%d), chunk_size=%<PRIu64>, total_size=%<PRIu64>\n"
#~ msgstr "  jumps=[%d..%d), chunk_size=%<PRIu64>, total_size=%<PRIu64>\n"

#~ msgid "=============================\n"
#~ msgstr "=============================\n"

#, c-format
#~ msgid "nThread(%d)<1"
#~ msgstr "nThread(%d)<1"

#, c-format
#~ msgid "%s"
#~ msgstr "%s"

#, c-format
#~ msgid "nth=%d, nBatch=%d\n"
#~ msgstr "nth=%d, nBatch=%d\n"

#, c-format
#~ msgid "maxBit=%d; MSBNbits=%d; shift=%d; MSBsize=%zu\n"
#~ msgstr "maxBit=%d; MSBNbits=%d; shift=%d; MSBsize=%zu\n"

#, c-format
#~ msgid "Reduced MSBsize from %zu to "
#~ msgstr "'MSBsize' уменьшено с %zu до "

#, c-format
#~ msgid "buffMB=%d outside [1,1024]"
#~ msgstr "buffMB=%d не в диапазоне [1,1024]"

#, c-format
#~ msgid "%d "
#~ msgstr "%d "

#~ msgid "... "
#~ msgstr "... "

#, c-format
#~ msgid ""
#~ "\n"
#~ "args.doRowNames=%d args.rowNames=%p args.rowNameFun=%d doQuote=%d args."
#~ "nrow=%<PRId64> args.ncol=%d eolLen=%d\n"
#~ msgstr ""
#~ "\n"
#~ "args.doRowNames=%d args.rowNames=%p args.rowNameFun=%d doQuote=%d args."
#~ "nrow=%<PRId64> args.ncol=%d eolLen=%d\n"

#, c-format
#~ msgid "Unable to allocate %zu MiB for header: %s"
#~ msgstr "Не удалось выделить %zu МиБ для заголовка: %s"

#, c-format
#~ msgid "Unable to allocate %zu MiB for zbuffer: %s"
#~ msgstr "Не удалось выделить %zu МиБ для zbuffer: %s"

#, c-format
#~ msgid "Failed to allocated %d bytes for '%s'."
#~ msgstr "Не удалось выделить %d байт для '%s'."

#, c-format
#~ msgid "length(f)=%d != length(l)=%d"
#~ msgstr "length(f)=%d != length(l)=%d"

#, c-format
#~ msgid "  omp_get_num_procs()            %d\n"
#~ msgstr "  omp_get_num_procs()            %d\n"

#, c-format
#~ msgid "  R_DATATABLE_NUM_PROCS_PERCENT  %s\n"
#~ msgstr "  R_DATATABLE_NUM_PROCS_PERCENT  %s\n"

#, c-format
#~ msgid "  R_DATATABLE_NUM_THREADS        %s\n"
#~ msgstr "  R_DATATABLE_NUM_THREADS        %s\n"

#, c-format
#~ msgid "  R_DATATABLE_THROTTLE           %s\n"
#~ msgstr "  R_DATATABLE_THROTTLE           %s\n"

#, c-format
#~ msgid "  omp_get_thread_limit()         %d\n"
#~ msgstr "  omp_get_thread_limit()         %d\n"

#, c-format
#~ msgid "  omp_get_max_threads()          %d\n"
#~ msgstr "  omp_get_max_threads()          %d\n"

#, c-format
#~ msgid "  OMP_THREAD_LIMIT               %s\n"
#~ msgstr "  OMP_THREAD_LIMIT               %s\n"

#, c-format
#~ msgid "  OMP_NUM_THREADS                %s\n"
#~ msgstr "  OMP_NUM_THREADS                %s\n"

#, c-format
#~ msgid "  RestoreAfterFork               %s\n"
#~ msgstr "  RestoreAfterFork               %s\n"

#, c-format
#~ msgid "nrow(x)[%d]!=length(order)[%d]"
#~ msgstr "nrow(x)[%d]!=length(order)[%d]"

#~ msgid "First argument to setlistelt must be a list()"
#~ msgstr "Первый аргумент setlistelt() должен быть списком"

#~ msgid "Second argument to setlistelt must a length 1 integer vector"
#~ msgstr "Второй аргумент setlistelt() должен быть одним целым числом"

#, c-format
#~ msgid "Added %d new column%s initialized with all-NA\n"
#~ msgstr "Добавлено %d новых столбцов%.0s, инициализированных всеми NA\n"

#, c-format
#~ msgid "Found and copied %d column%s with a shared memory address\n"
#~ msgstr "Найдено и скопировано %d столбцов%.0s с общим адресом в памяти\n"

#~ msgid "Internal error: finalizer hasn't received an ExternalPtr"
#~ msgstr "Внутренняя ошибка: финализатор не получил ExternalPtr"

#~ msgid "Internal error: finalizer's ExternalPtr doesn't see names in tag"
#~ msgstr "Внутренняя ошибка: ExternalPtr финализатора не видит имен в теге"

#, c-format
#~ msgid "Internal error: finalizer sees l=%d, tl=%d"
#~ msgstr "Внутренняя ошибка: финализатор видит l=%d, tl=%d"

#~ msgid "Internal error: .internal.selfref ptr is neither NULL nor R_NilValue"
#~ msgstr ""
#~ "Внутренняя ошибка: указатель .internal.selfref не является ни NULL, ни "
#~ "R_NilValue"

#~ msgid ""
#~ "Internal error: .internal.selfref tag is neither NULL nor a character "
#~ "vector"
#~ msgstr ""
#~ "Внутренняя ошибка: тег .internal.selfref не является ни NULL, ни вектором "
#~ "строк"

#~ msgid "Internal error: length(names)>0 but <length(dt)"
#~ msgstr "Внутренняя ошибка: длина(имена)>0, но <длина(dt)"

#, c-format
#~ msgid "Internal error: length of names (%d) is not length of dt (%d)"
#~ msgstr "Внутренняя ошибка: длина имен (%d) не равна длине dt (%d)"

#~ msgid "Internal error, tl of class is marked but tl<0."
#~ msgstr ""
#~ "Внутренняя ошибка, TRUELENGTH(<объект data.table>) < 0 («tl of class is "
#~ "marked but tl<0»)."

#, c-format
#~ msgid ""
#~ "Internal error, please report (including result of sessionInfo()) to data."
#~ "table issue tracker: tl (%d) < l (%d) but tl of class is marked."
#~ msgstr ""
#~ "Внутренняя ошибка; пожалуйста, сообщите (включая результат sessionInfo()) "
#~ "на трекер проблем data.table: у объекта data.table tl (%d) < l (%d) («but "
#~ "tl of class is marked»)."

#, fuzzy
#~ msgid ""
#~ "Internal error: dt passed to Cassign is not a data.table or data.frame"
#~ msgstr ""
#~ "Внутренняя ошибка: dt, переданное в Cassign, не является таблицей или "
#~ "кадром данных (data.table или data.frame)"

#, c-format
#~ msgid ""
#~ "Internal error in assign.c: length(newcolnames)=%d, length(names)=%d, "
#~ "coln=%d"
#~ msgstr ""
#~ "Внутренняя ошибка в Assign.c: длина (новые имена столбцов) = %d, длина "
#~ "(имена) = %d, столбец = %d"

#, c-format
#~ msgid ""
#~ "Internal error: oldtncol(%d) < oldncol(%d). Please report to data.table "
#~ "issue tracker, including result of sessionInfo()."
#~ msgstr ""
#~ "Внутренняя ошибка: oldtncol(%d) < oldncol(%d). Пожалуйста, сообщите об "
#~ "этом в трекере проблем data.table, включая результат выполнения функции "
#~ "sessionInfo()."

#, c-format
#~ msgid ""
#~ "Internal error: DT passed to assign has not been allocated enough column "
#~ "slots. l=%d, tl=%d, adding %d"
#~ msgstr ""
#~ "Внутренняя ошибка: DT, переданному в assign, не выделено достаточно "
#~ "слотов для столбцов. l=%d, tl=%d, добавление %d"

#, c-format
#~ msgid "Internal error: selfrefnames is ok but tl names [%lld] != tl [%d]"
#~ msgstr ""
#~ "Внутренняя ошибка: selfrefnames в порядке, но tl names [%lld] != tl [%d]"

#~ msgid ""
#~ "Internal error: earlier error 'When deleting columns, i should not be "
#~ "provided' did not happen."
#~ msgstr ""
#~ "Внутренняя ошибка: ранее ошибка 'При удалении столбцов i не должен быть "
#~ "предоставлен' не произошла, хотя должна была."

#~ msgid "Internal error: Couldn't allocate memory for s4."
#~ msgstr "Внутренняя ошибка: не удалось выделить память для s4."

#~ msgid "Internal error: Couldn't allocate memory for s5."
#~ msgstr "Внутренняя ошибка: Не удалось выделить память для s5."

#~ msgid "Internal error: memrecycle has received NULL colname"
#~ msgstr "Внутренняя ошибка: memrecycle получил NULL colname"

#, c-format
#~ msgid ""
#~ "Internal error: uniqlist has been passed length(order)==%d but nrow==%d"
#~ msgstr ""
#~ "Внутренняя ошибка: функции uniqlist передано length(order)==%d, но nrow=%d"

#~ msgid "Internal error: nestedid was not passed a list length 1 or more"
#~ msgstr ""
#~ "Внутренняя ошибка: функции nestedid не передан список длиной как минимум 1"

#, c-format
#~ msgid "Internal error: nrows[%d]>0 but ngrps==0"
#~ msgstr "Внутренняя ошибка: nrows[%d] > 0, но ngrps==0"

#, c-format
#~ msgid "Internal error: copyAsPlain returning ALTREP for type '%s'"
#~ msgstr "Внутренняя ошибка: copyAsPlain() вернула ALTREP для типа '%s'"
