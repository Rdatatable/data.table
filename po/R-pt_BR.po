#
# Translators:
# Italo Santos <ids37@nau.edu>, 2024
# Leonardo Fontenelle <leonardof@leonardof.med.br>, 2024
# Rafael Fontenelle <rffontenelle@gmail.com>, 2024
#
msgid ""
msgstr ""
"Project-Id-Version: data.table 1.15.99\n"
"POT-Creation-Date: 2024-08-28 21:08+0000\n"
"PO-Revision-Date: 2024-06-20 20:50-0300\n"
"Last-Translator: Leonardo Fontenelle <leonardof@leonardof.med.br>\n"
"Language-Team: Brazilian Portuguese\n"
"Language: pt_BR\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=2; plural=(n > 1);\n"

#: AllS4.R:2
#, c-format
msgid "data.table package loaded. When developing don't load package"
msgstr "Pacote data.table carregado. Ao desenvolver, não carregue o pacote"

#: IDateTime.R:107
#, c-format
msgid "binary + is not defined for \"IDate\" objects"
msgstr "binário + não está definida para objetos \"IDate\""

#: IDateTime.R:114
#, c-format
msgid "can only subtract from \"IDate\" objects"
msgstr "pode apenas subtrair de objetos \"IDate\""

#: IDateTime.R:119
#, c-format
msgid "unary - is not defined for \"IDate\" objects"
msgstr "unário - não está definido para objetos \"IDate\""

#: IDateTime.R:309
#, c-format
msgid "Valid options for ms are 'truncate', 'nearest', and 'ceil'."
msgstr "Opções válidas para ms são 'truncate', 'nearest', e 'ceil'."

#: as.data.table.R:86
#, c-format
msgid ""
"as.data.table.array method should only be called for arrays with 3+ "
"dimensions; use the matrix method for 2-dimensional arrays"
msgstr ""
"O método as.data.table.array só deve ser chamado para arrays com mais de 3 "
"dimensões ou mais; use o método matrix para arrays de 2 dimensões"

#: as.data.table.R:88
#, c-format
msgid ""
"Argument 'value.name' must be scalar character, non-NA and at least one "
"character"
msgstr ""
"O argumento 'value.name' deve ser um caractere escalar, não-NA e ter pelo "
"menos um caractere"

#: as.data.table.R:90
#, c-format
msgid "Argument 'sorted' must be scalar logical and non-NA"
msgstr "O argumento 'sorted' deve ser lógico escalar e não-NA"

#: as.data.table.R:92
#, c-format
msgid "Argument 'na.rm' must be scalar logical and non-NA"
msgstr "O argumento 'na.rm' deve ser lógico escalar e não-NA"

#: as.data.table.R:94
#, c-format
msgid "Please provide either 'key' or 'sorted', but not both."
msgstr "Favor fornecer ou 'key' ou 'sorted', mas não ambos."

#: as.data.table.R:108
#, c-format
msgid ""
"Argument 'value.name' should not overlap with column names in result: %s"
msgstr ""
"O argumento 'value.name' não deve se sobrepor aos nomes das colunas no "
"resultado: %s"

#: as.data.table.R:140
#, c-format
msgid ""
"POSIXlt column type detected and converted to POSIXct. We do not recommend "
"use of POSIXlt at all because it uses 40 bytes to store one date."
msgstr ""
"Tipo de coluna POSIXlt detectado e convertido em POSIXct. Não recomendamos o "
"uso do POSIXlt porque ele usa 40 bytes para armazenar uma data."

#: as.data.table.R:181
#, c-format
msgid "Item %d has %d rows but longest item has %d; recycled with remainder."
msgstr ""
"O item %d possui %d linhas, mas o item mais longo possui %d; reciclado com o "
"restante."

#: as.data.table.R:196
#, c-format
msgid "A column may not be called .SD. That has special meaning."
msgstr ""
"Uma coluna não pode ser chamada de .SD. Esse nome tem um significado "
"especial."

#: as.data.table.R:210
#, c-format
msgid "class must be length 1"
msgstr "class deve ter comprimento 1"

#: between.R:3
#, c-format
msgid "between has been passed an argument x of type logical"
msgstr "between recebeu um argumento x do tipo lógico"

#: between.R:13 between.R:15
#, c-format
msgid ""
"'between' function the 'x' argument is a POSIX class while '%s' was not, "
"coercion to POSIX failed with: %s"
msgstr ""
"na função 'between', o argumento 'x' é uma classe POSIX enquanto '%s' não "
"era, então a coerção para POSIX falhou com: %s"

#: between.R:27
#, c-format
msgid ""
"'between' lower= and upper= are both POSIXct but have different tzone "
"attributes: %s. Please align their time zones."
msgstr ""
"lower= e upper= do 'between' são ambos POSIXct, mas possuem atributos tzone "
"diferentes: %s. Alinhe seus fusos horários."

#: between.R:31
#, c-format
msgid ""
"'between' arguments are all POSIXct but have mismatched tzone attributes: "
"%s. The UTC times will be compared."
msgstr ""
"os argumentos de 'between' são todos POSIXct, mas possuem atributos tzone "
"incompatíveis: %s. Os horários UTC serão comparados."

#: between.R:36
#, c-format
msgid "trying to use integer64 class when 'bit64' package is not installed"
msgstr ""
"tentando usar a classe integer64 quando o pacote 'bit64' não está instalado"

#: between.R:48
#, c-format
msgid ""
"Not yet implemented NAbounds=TRUE for this non-numeric and non-character type"
msgstr ""
"Ainda não implementado NAbounds=TRUE para este tipo não numérico e não "
"caractere"

#: between.R:49
#, c-format
msgid "Some lower>upper for this non-numeric and non-character type"
msgstr "Alguns lower>upper para este tipo não numérico e não caractere"

#: between.R:63
#, c-format
msgid "Perhaps you meant %s?"
msgstr "Talvez você quis dizer %s?"

#: between.R:64
#, c-format
msgid ""
"RHS has length() %d; expecting length 2. %sThe first element should be the "
"lower bound(s); the second element should be the upper bound(s)."
msgstr ""
"O lado direito (RHS) tem length() %d; esperando comprimento 2. %sO primeiro "
"elemento deve ser o(s) limite(s) inferior(es); o segundo elemento deve ser "
"o(s) limite(s) superior(es)."

#: bmerge.R:48 bmerge.R:49
#, c-format
msgid "%s is type %s which is not supported by data.table join"
msgstr "%s é do tipo %s, o qual não é suportado pela junção do data.table"

#: bmerge.R:52
#, c-format
msgid ""
"Attempting roll join on factor column when joining %s to %s. Only integer, "
"double or character columns may be roll joined."
msgstr ""
"Tentando uma junção por \"rolamento\" na coluna de fatores ao fazer a junção "
"entre %s e %s. Apenas colunas de inteiros, double ou caracteres podem ser "
"usadas na junção. "

#: bmerge.R:71
#, c-format
msgid ""
"Incompatible join types: %s (%s) and %s (%s). Factor columns must join to "
"factor or character columns."
msgstr ""
"Tipos de junção incompatíveis: %s (%s) e %s (%s). Colunas de fator devem "
"unir-se a colunas de caractere ou de fator."

#: bmerge.R:90
#, c-format
msgid "Incompatible join types: %s (%s) and %s (%s)"
msgstr "Tipos de junção incompatíveis: %s (%s) e %s (%s)"

#: bmerge.R:98
#, c-format
msgid ""
"Incompatible join types: %s is type integer64 but %s is type double and "
"contains fractions"
msgstr ""
"Tipos de junção incompatíveis: %s é do tipo integer64, mas %s é do tipo "
"'double' e contém frações"

#: bmerge.R:150
#, c-format
msgid "roll is not implemented for non-equi joins yet."
msgstr "'roll' ainda não está implementado para junções por desigualdade."

#: bmerge.R:170
#, c-format
msgid "Column name '_nqgrp_' is reserved for non-equi joins."
msgstr ""
"O nome de coluna '_nqgrp_' está reservado para junções por desigualdade."

#: data.table.R:55
#, c-format
msgid "key argument of data.table() must be character"
msgstr "o argumento key do data.table() deve ser caractere"

#: data.table.R:121
#, c-format
msgid "Object '%s' not found. Perhaps you intended %s"
msgstr "Objeto '%s' não encontrado. Talvez sua intenção fosse %s"

#: data.table.R:123
#, c-format
msgid "Object '%s' not found amongst %s"
msgstr "Objeto '%s' não encontrado entre %s"

#: data.table.R:139
#, c-format
msgid ""
"[ was called on a data.table in an environment that is not data.table-aware "
"(i.e. cedta()), but '%s' was used, implying the owner of this call really "
"intended for data.table methods to be called. See vignette('datatable-"
"importing') for details on properly importing data.table."
msgstr ""
"[ foi chamado em uma data.table em um ambiente que não está ciente de data."
"table (p.ex. cedta()), mas '%s' foi usado, implicando que o dono desta "
"chamada realmente pretendia que métodos data.table fossem chamados. Veja "
"vignette('datatable-importing') para detalhes sobre importar uma data.table "
"apropriadamente."

#: data.table.R:150
#, c-format
msgid "verbose must be logical or integer"
msgstr "verbose deve ser lógico ou inteiro"

#: data.table.R:151
#, c-format
msgid "verbose must be length 1 non-NA"
msgstr "verbose deve ser não NA e de comprimento 1"

#: data.table.R:159
#, c-format
msgid "Ignoring by/keyby because 'j' is not supplied"
msgstr "Ignorando by/keyby porque 'j' não foi fornecido"

#: data.table.R:173
#, c-format
msgid "When by and keyby are both provided, keyby must be TRUE or FALSE"
msgstr "Quando by e keyby são ambos fornecidos, keyby deve ser TRUE ou FALSE"

#: data.table.R:185
#, c-format
msgid ""
"When on= is provided but not i=, on= must be a named list or data.table|"
"frame, and a natural join (i.e. join on common names) is invoked. Ignoring "
"on= which is '%s'."
msgstr ""
"Quando on= é fornecido, mas não i=, on= deve ser uma lista nomeada ou data."
"table|frame, e uma junção natural (ou seja, junção em nomes comuns) é "
"invocada. Ignorando on= , que é '%s'."

#: data.table.R:198
#, c-format
msgid ""
"i and j are both missing so ignoring the other arguments. This warning will "
"be upgraded to error in future."
msgstr ""
"i e j estão faltando, ignorando os outros argumentos. Este aviso será "
"atualizado para se tornar um erro no futuro."

#: data.table.R:202
#, c-format
msgid "mult argument can only be 'first', 'last' or 'all'"
msgstr "o argumento mult só pode ser 'first', 'last' ou 'all'"

#: data.table.R:204
#, c-format
msgid ""
"roll must be a single TRUE, FALSE, positive/negative integer/double "
"including +Inf and -Inf or 'nearest'"
msgstr ""
"roll deve ser TRUE, FALSE, número inteiro/duplo positivo/negativo, incluindo "
"+Inf e -Inf ou 'nearest'"

#: data.table.R:206
#, c-format
msgid "roll is '%s' (type character). Only valid character value is 'nearest'."
msgstr ""
"roll é '%s' (tipo caractere). O único valor de caractere válido é 'nearest'."

#: data.table.R:211
#, c-format
msgid "rollends must be a logical vector"
msgstr "rollends deve ser um vetor lógico"

#: data.table.R:212
#, c-format
msgid "rollends must be length 1 or 2"
msgstr "rollends deve ter comprimento 1 ou 2"

#: data.table.R:220
#, c-format
msgid ""
"nomatch= must be either NA or NULL (or 0 for backwards compatibility which "
"is the same as NULL but please use NULL)"
msgstr ""
"nomatch= deve ser NA ou NULL (ou 0 para compatibilidade com versões "
"anteriores, que é igual a NULL, mas use NULL)"

#: data.table.R:223
#, c-format
msgid "which= must be a logical vector length 1. Either FALSE, TRUE or NA."
msgstr "which= deve ser um vetor lógico de comprimento 1. FALSE, TRUE ou NA."

#: data.table.R:224
#, c-format
msgid ""
"which==%s (meaning return row numbers) but j is also supplied. Either you "
"need row numbers or the result of j, but only one type of result can be "
"returned."
msgstr ""
"which==%s (significando retornar números de linha), mas j também é "
"fornecido. Ou você precisa de números de linha ou do resultado de j, mas "
"apenas um tipo de resultado pode ser retornado."

#: data.table.R:225
#, c-format
msgid ""
"which=NA with nomatch=0|NULL would always return an empty vector. Please "
"change or remove either which or nomatch."
msgstr ""
"which=NA com nomatch=0|NULL sempre retornaria um vetor vazio. Favor alterar "
"ou remover ou which, ou nomatch."

#: data.table.R:226
#, c-format
msgid "j must be provided when with=FALSE"
msgstr "j deve ser fornecido quando with=FALSE"

#: data.table.R:227
msgid "%s must be TRUE or FALSE"
msgstr "%s deve ser TRUE ou FALSE"

#: data.table.R:267
#, c-format
msgid ""
"The symbol .. is invalid. The .. prefix must be followed by at least one "
"character."
msgstr ""
"O símbolo .. é inválido. O prefixo .. deve ser seguido por pelo menos um "
"caractere."

#: data.table.R:270
#, c-format
msgid ""
"Variable '..%s' does exist in calling scope though, so please just removed "
"the .. prefix from that variable name in calling scope."
msgstr ""
"A variável '..%s' existe no escopo de chamada, portanto, então favor "
"simplesmente remover o prefixo .. desse nome de variável no escopo de "
"chamada."

#: data.table.R:274
#, c-format
msgid ""
"Variable '%s' is not found in calling scope. Looking in calling scope "
"because you used the .. prefix.%s"
msgstr ""
"A variável '%s' não foi encontrada no escopo de chamada. Procurando no "
"escopo de chamada porque você usou .. como prefixo.%s"

#: data.table.R:276
#, c-format
msgid ""
"Both '%1$s' and '..%1$s' exist in calling scope. Please remove the '..%1$s' "
"variable in calling scope for clarity."
msgstr ""
"Tanto '%1$s' quanto '..%1$s' existem no escopo de chamada. Remova a variável "
"'..%1$s' na chamada do escopo para maior clareza."

#: data.table.R:284
#, c-format
msgid ""
"Variable '%s' is not found in calling scope. Looking in calling scope "
"because you set with=FALSE. Also, please use .. symbol prefix and remove "
"with=FALSE."
msgstr ""
"A variável '%s' não foi encontrada no escopo de chamada. Procurando no "
"escopo de chamada porque você definiu with=FALSE. Além disso, favor usr o "
"prefixo de símbolo .. e remover with=FALSE."

#: data.table.R:292
#, c-format
msgid ""
"You have wrapped := with {} which is ok but then := must be the only thing "
"inside {}. You have something else inside {} as well. Consider placing the "
"{} on the RHS of := instead; e.g. DT[,someCol:={tmpVar1<-...;tmpVar2<-...;"
"tmpVar1*tmpVar2}"
msgstr ""
"Você envolveu := com {}, o que está tudo bem, mas := deve ser a única coisa "
"dentro de {}. Você também tem algo mais dentro de {}. Considere colocar {} "
"ao lado direito de :=; por exemplo, DT[,algumaCol:={tmpVar1<-...;"
"tmpVar2<-...;tmpVar1*tmpVar2}]"

#: data.table.R:310
#, c-format
msgid ""
":= with keyby is only possible when i is not supplied since you can't setkey "
"on a subset of rows. Either change keyby to by or remove i"
msgstr ""
":= com keyby só é possível quando i não é fornecido, pois você não pode "
"definir a chave em um subconjunto de linhas. Ou altere keyby para by, ou "
"remova i"

#: data.table.R:312
#, c-format
msgid "nomatch isn't relevant together with :=, ignoring nomatch"
msgstr "nomatch não é relevante junto com :=, ignorando nomatch"

#: data.table.R:368
#, c-format
msgid ""
"not-join '!' prefix is present on i but nomatch is provided. Please remove "
"nomatch."
msgstr ""
"prefixo de não-junção '!' está presente em i, mas nomatch foi fornecido. Por "
"favor, remova nomatch."

#: data.table.R:396
#, c-format
msgid ""
"Operator := detected in i, the first argument inside DT[...], but is only "
"valid in the second argument, j. Most often, this happens when forgetting "
"the first comma (e.g. DT[newvar := 5] instead of DT[ , new_var := 5]). "
"Please double-check the syntax. Run traceback(), and debugger() to get a "
"line number."
msgstr ""
"Operador := detectado em i, o primeiro argumento dentro de DT[...], mas só é "
"válido no segundo argumento, j. Na maioria das vezes, isso acontece quando "
"se esquece a primeira vírgula (por exemplo, DT[nova_var := 5] em vez de "
"DT[ , nova_var := 5]). Verifique novamente a sintaxe. Execute traceback() e "
"debugger() para obter um número de linha."

#: data.table.R:406
#, c-format
msgid "'%s' is not found in calling scope and it is not a column name either"
msgstr ""
"'%s' não foi encontrado no escopo de chamada e também não é um nome de coluna"

#: data.table.R:409
#, c-format
msgid ""
"'%s' is not found in calling scope, but it is a column of type %s. If you "
"wish to select rows where that column contains TRUE, or perhaps that column "
"contains row numbers of itself to select, try DT[(col)], DT[DT$col], or "
"DT[col==TRUE} is particularly clear and is optimized"
msgstr ""
"'%s' não foi encontrado no escopo de chamada, mas é uma coluna do tipo %s. "
"Se você deseja selecionar linhas onde essa coluna contém TRUE, ou talvez "
"onde essa coluna contenha números de linha para selecionar, tente DT[(col)], "
"DT[DT$col] ou DT[col==TRUE}, o que é particularmente claro e otimizado"

#: data.table.R:412
#, c-format
msgid ""
"%s. When the first argument inside DT[...] is a single symbol (e.g. "
"DT[var]), data.table looks for var in calling scope."
msgstr ""
"%s. Quando o primeiro argumento dentro de DT[...] é um único símbolo (por "
"exemplo, DT[var]), data.table procura por var na chamada do escopo."

#: data.table.R:424
#, c-format
msgid ""
"i is invalid type (matrix). Perhaps in future a 2 column matrix could return "
"a list of elements of DT (in the spirit of A[B] in FAQ 2.14). Please report "
"to data.table issue tracker if you'd like this, or add your comments to FR "
"#657."
msgstr ""
"i é um tipo inválido (matrix). Talvez no futuro uma matriz de 2 colunas "
"possa retornar uma lista de elementos de DT (no espírito de A[B] no FAQ "
"2.14). Por favor, relate no rastreador de problemas do data.table se desejar "
"isso, ou adicione seus comentários ao FR #657."

#: data.table.R:447
#, c-format
msgid ""
"When i is a data.table (or character vector), the columns to join by must be "
"specified using 'on=' argument (see ?data.table), by keying x (i.e. sorted, "
"and, marked as sorted, see ?setkey), or by sharing column names between x "
"and i (i.e., a natural join). Keyed joins might have further speed benefits "
"on very large data due to x being sorted in RAM."
msgstr ""
"Quando i é uma data.table (ou vetor de caracteres), as colunas nas quais "
"fazer a junção devem ser especificadas usando o argumento 'on=' (consulte ?"
"data.table), por meio de chaveamento de x (ou seja, ordenado e marcado como "
"ordenado, consulte ?setkey) ou compartilhando de nomes de colunas entre x e "
"i (ou seja, uma junção natural). As junções chaveadas podem ter benefícios "
"adicionais de velocidade em dados muito grandes devido ao x estar ordenado "
"na RAM."

#: data.table.R:455
#, c-format
msgid "Attempting to do natural join but no common columns in provided tables"
msgstr ""
"Tentando fazer junção natural, mas não há colunas comuns nas tabelas "
"fornecidas"

#: data.table.R:587
#, c-format
msgid "logical error. i is not a data.table, but 'on' argument is provided."
msgstr ""
"erro lógico. i não é uma data.table, mas o argumento 'on' foi fornecido."

#: data.table.R:591
#, c-format
msgid "i has evaluated to type %s. Expecting logical, integer or double."
msgstr "i foi avaliado para o tipo %s. Esperava lógico, inteiro ou 'double'."

#: data.table.R:613
#, c-format
msgid ""
"i evaluates to a logical vector length %d but there are %d rows. Recycling "
"of logical i is no longer allowed as it hides more bugs than is worth the "
"rare convenience. Explicitly use rep(...,length=.N) if you really need to "
"recycle."
msgstr ""
"i foi avaliado como um vetor lógico de comprimento %d, mas há %d linhas. A "
"reciclagem do i lógico não é mais permitida, pois mais esconde bugs do que "
"vale a rara conveniência. Use explicitamente rep(...,length=.N) se você "
"realmente precisar reciclar."

#: data.table.R:616
#, c-format
msgid ""
"Please use nomatch=NULL instead of nomatch=0; see news item 5 in v1.12.0 "
"(Jan 2019)"
msgstr ""
"Favor usar nomatch=NULL em vez de nomatch=0; veja o item 5 das novidades da "
"v1.12.0 (jan 2019)"

#: data.table.R:688
#, c-format
msgid ""
"with=FALSE together with := was deprecated in v1.9.4 released Oct 2014. "
"Please wrap the LHS of := with parentheses; e.g., DT[,(myVar):=sum(b),by=a] "
"to assign to column name(s) held in variable myVar. See ?':=' for other "
"examples. As warned in 2014, this is now a warning."
msgstr ""
"o uso de with=FALSE junto com := é obsoleto desde v1.9.4, lançada em outubro "
"de 2014. Coloque o lado esquerdo de := entre parênteses; por exemplo, DT[,"
"(minhaVar):=sum(b),by=a] para atribuir para nomes de colunas mantidos na "
"variável minhaVar. Veja ?':=' para outros exemplos.  Tal como antecipado em "
"2014, isto é agora um aviso."

#: data.table.R:691
#, c-format
msgid ""
"with=FALSE ignored, it isn't needed when using :=. See ?':=' for examples."
msgstr ""
"with=FALSE ignorado, não é necessário ao usar :=. Veja ?':=' para exemplos."

#: data.table.R:715
#, c-format
msgid "column(s) not removed because not found: %s"
msgstr "coluna(s) não removida(s) por não ter(em) sido encontrada(s): %s"

#: data.table.R:729
#, c-format
msgid "column(s) not found: %s"
msgstr "coluna(s) não encontrada(s): %s"

#: data.table.R:735
#, c-format
msgid "Item %d of j is %d which is outside the column number range [1,ncol=%d]"
msgstr ""
"O item %d de j é %d, o qual está fora do intervalo de números de colunas [1,"
"ncol=%d]"

#: data.table.R:738
#, c-format
msgid "j mixes positives and negatives"
msgstr "j mistura positivos e negativos"

#: data.table.R:746
#, c-format
msgid ""
"When with=FALSE, j-argument should be of type logical/character/integer "
"indicating the columns to select."
msgstr ""
"Quando with=FALSE, o argumento j deve ser do tipo lógico/caractere/inteiro "
"indicando as colunas a serem selecionadas."

#: data.table.R:760
#, c-format
msgid ""
"'by' contains .I but only the following are currently supported: by=.I, by=."
"(.I), by=c(.I), by=list(.I)"
msgstr ""
"'by' contém .I, mas atualmente só há suporte aos seguintes: by=.I, by=.(.I), "
"by=c(.I), by=list(.I)"

#: data.table.R:784
#, c-format
msgid "by=c(...), key(...) or names(...) must evaluate to 'character'"
msgstr "by=c(...), key(...) ou names(...) devem ser avaliados para 'character'"

#: data.table.R:794
#, c-format
msgid ""
"'by' is a character vector length %d but one or more items include a comma. "
"Either pass a vector of column names (which can contain spaces, but no "
"commas), or pass a vector length 1 containing comma separated column names. "
"See ?data.table for other possibilities."
msgstr ""

#: data.table.R:801
#, c-format
msgid "At least one entry of by is empty"
msgstr "Ao menos uma entrada de by está vazia"

#: data.table.R:876
#, c-format
msgid ""
"'by' appears to evaluate to column names but isn't c() or key(). Use "
"by=list(...) if you can. Otherwise, by=eval%s should work. This is for "
"efficiency so data.table can detect which columns are needed."
msgstr ""
"'by' parece ser avaliado para nomes de colunas, mas não é c() ou key(). Use "
"by=list(...) se puder. Caso contrário, by=eval%s deveria funcionar. Isso é "
"para maior eficiência, para que data.table possa detectar quais colunas são "
"necessárias."

#: data.table.R:887
#, c-format
msgid ""
"'by' or 'keyby' must evaluate to a vector or a list of vectors (where 'list' "
"includes data.table and data.frame which are lists, too)"
msgstr ""
"'by' ou 'keyby' deve ser avaliado como um vetor ou uma lista de vetores "
"(onde 'list' inclui data.table e data.frame, que também são listas)"

#: data.table.R:891
#, c-format
msgid ""
"Column or expression %d of 'by' or 'keyby' is type '%s' which is not "
"currently supported. If you have a compelling use case, please add it to "
"https://github.com/Rdatatable/data.table/issues/1597. As a workaround, "
"consider converting the column to a supported type, e.g. by=sapply(list_col, "
"toString), whilst taking care to maintain distinctness in the process."
msgstr ""
"A coluna ou expressão %d de 'by' ou 'keyby' é do tipo '%s' e não é suportada "
"atualmente. Se você tiver um caso de uso atraente, adicione-o a https://"
"github.com/Rdatatable/data.table/issues/1597. Como solução alternativa, "
"considere converter a coluna em um tipo compatível, como "
"by=sapply(lista_colunas, toString), tomando cuidado para manter a distinção "
"no processo."

#: data.table.R:895
#, c-format
msgid ""
"The items in the 'by' or 'keyby' list are length(s) %s. Each must be length "
"%d; the same length as there are rows in x (after subsetting if i is "
"provided)."
msgstr ""
"Os itens na lista 'by' ou 'keyby' têm comprimento(s) %s. Cada um deve ter "
"comprimento %d; o mesmo comprimento que há linhas em x (após obter "
"subconjuntos se i for fornecido)."

#: data.table.R:948
#, c-format
msgid "Item %d of the .() or list() passed to j is missing"
msgstr "O item %d de .() ou list() passado para j está ausente"

#: data.table.R:954
#, c-format
msgid ""
"j may not evaluate to the same number of columns for each group; if you're "
"sure this warning is in error, please put the branching logic outside of "
"[ for efficiency"
msgstr ""
"j pode não ser avaliado com o mesmo número de colunas para cada grupo; se "
"você tiver certeza de que este aviso está errado, coloque a lógica de "
"branching fora de [ para eficiência"

#: data.table.R:956
#, c-format
msgid ""
"Different branches of j expression produced different auto-named columns: "
"%s; using the most \"last\" names. If this was intentional (e.g., you know "
"only one branch will ever be used in a given query because the branch is "
"controlled by a function argument), please (1) pull this branch out of the "
"call; (2) explicitly provide missing defaults for each branch in all cases; "
"or (3) use the same name for each branch and re-name it in a follow-up call."
msgstr ""
"Diferentes branches da expressão j produziram diferentes colunas nomeadas "
"automaticamente: %s; usando os nomes definidos por último. Se isso foi "
"intencional (por exemplo, você sabe que apenas um branch será usado em uma "
"determinada consulta porque o branch é controlado por um argumento de "
"função), favor, (1) retirar esse branch da chamada; (2) fornecer "
"explicitamente os valores padrão faltantes para cada branch em todos os "
"casos; ou (3) use o mesmo nome para cada branch e renomeie-o em uma chamada "
"seguinte."

#: data.table.R:1026
#, c-format
msgid ""
"When .SDcols is a function, it is applied to each column; the output of this "
"function must be a non-missing boolean scalar signalling inclusion/exclusion "
"of the column. However, these conditions were not met for: %s"
msgstr ""
"Quando .SDcols é uma função, ela é aplicada a cada coluna; a saída desta "
"função deve ser um escalar booleano não NA sinalizando inclusão/exclusão da "
"coluna. No entanto, estas condições não foram cumpridas para: %s"

#: data.table.R:1032
#, c-format
msgid ".SDcols missing at the following indices: %s"
msgstr ".SDcols ausentes nos seguintes índices: %s"

#: data.table.R:1034
#, c-format
msgid ".SDcols is a logical vector length %d but there are %d columns"
msgstr ".SDcols tem um vetor lógico de comprimento %d, mas existem %d colunas"

#: data.table.R:1040
#, c-format
msgid ".SDcols is numeric but has both +ve and -ve indices"
msgstr ".SDcols é numérico, mas possui índices positivos e negativos"

#: data.table.R:1042
#, c-format
msgid ".SDcols is numeric but out of bounds [1, %d] at: %s"
msgstr ".SDcols é numérico, mas está fora dos limites [1, %d] em: %s"

#: data.table.R:1046
#, c-format
msgid ".SDcols should be column numbers or names"
msgstr ".SDcols deve consistir em números ou nomes de colunas"

#: data.table.R:1048
#, c-format
msgid "Some items of .SDcols are not column names: %s"
msgstr "Alguns itens de .SDcols não são nomes de colunas: %s"

#: data.table.R:1090
#, c-format
msgid ""
"This j doesn't use .SD but .SDcols has been supplied. Ignoring .SDcols. See ?"
"data.table."
msgstr ""
"Este j não usa .SD, mas .SDcols foi fornecido. Ignorando .SDcols. Consulte ?"
"data.table."

#: data.table.R:1106
#, c-format
msgid ""
".SD is locked. Using := in .SD's j is reserved for possible future use; a "
"tortuously flexible way to modify by group. Use := in j directly to modify "
"by group by reference."
msgstr ""
".SD é travado. O uso de := no j de .SD está reservado para possível uso "
"futuro; uma maneira tortuosamente flexível de modificar por grupo. Use := in "
"j diretamente para modificar por grupo por referência."

#: data.table.R:1114
#, c-format
msgid "In %s(col1=val1, col2=val2, ...) form, all arguments must be named."
msgstr ""
"Na forma %s(col1=val1, col2=val2, ...), todos os argumentos devem ser "
"nomeados."

#: data.table.R:1136
#, c-format
msgid ""
"In %s(col1=val1, col2=val2, ...) form, all arguments must be named, but the "
"last argument has no name. Did you forget a trailing comma?"
msgstr ""
"Na forma %s(col1=val1, col2=val2, ...), todos os argumentos devem ser "
"nomeados, mas o último argumento não tem nome. Você se esqueceu de uma "
"vírgula final?"

#: data.table.R:1138
#, c-format
msgid ""
"In %s(col1=val1, col2=val2, ...) form, all arguments must be named, but "
"these arguments lack names: %s."
msgstr ""
"Na forma %s(col1=val1, col2=val2, ...), todos os argumentos devem ser "
"nomeados, mas estes elementos estão sem nome: %s."

#: data.table.R:1145
#, c-format
msgid ""
"LHS of := must be a symbol, or an atomic vector (column names or positions)."
msgstr ""
"O lado esquerdo de := deve ser um símbolo ou um vetor atômico (nomes de "
"colunas ou posições)."

#: data.table.R:1150
#, c-format
msgid ""
"LHS of := appears to be column positions but are outside [1,ncol] range. New "
"columns can only be added by name."
msgstr ""
"Parece que o lado esquerdo de := são posições de coluna, mas estão fora do "
"intervalo [1,ncol]. Novas colunas só podem ser adicionadas por nome."

#: data.table.R:1153
#, c-format
msgid ""
"LHS of := isn't column names ('character') or positions ('integer' or "
"'numeric')"
msgstr ""
"O lado esquerdo de := não são nomes de colunas ('character') ou posições "
"('integer' ou 'numeric')"

#: data.table.R:1184
#, c-format
msgid ""
"Invalid .internal.selfref detected and fixed by taking a (shallow) copy of "
"the data.table so that := can add this new column by reference. At an "
"earlier point, this data.table has been copied by R (or was created manually "
"using structure() or similar). Avoid names<- and attr<- which in R currently "
"(and oddly) may copy the whole data.table. Use set* syntax instead to avoid "
"copying: ?set, ?setnames and ?setattr. If this message doesn't help, please "
"report your use case to the data.table issue tracker so the root cause can "
"be fixed or this message improved."
msgstr ""
".internal.selfref inválido detectado e corrigido fazendo uma cópia (rasa) do "
"data.table para que := possa adicionar esta nova coluna por referência. "
"Anteriormente, este data.table foi copiado por R (ou foi criado manualmente "
"usando structure() ou similar). Evite names<- e attr<- que, atualmente (e "
"estranhamente) no R podem copiar toda a data.table. Use a sintaxe set* para "
"evitar copiar: ?set, ?setnames e ?setattr. Se esta mensagem não ajudar, por "
"favor, relate isso no rastreador de problemas do data.table para que a causa "
"raiz possa ser corrigida ou esta mensagem melhorada."

#: data.table.R:1215
#, c-format
msgid ""
"Cannot assign to an under-allocated recursively indexed list -- L[[i]][,:=] "
"syntax is only valid when i is length 1, but its length is %d"
msgstr ""
"Não é possível atribuir a uma lista indexada recursivamente subalocada - a "
"sintaxe L[[i]][,:=] só é válida quando i tem comprimento 1, mas seu "
"comprimento é %d"

#: data.table.R:1284
#, c-format
msgid ""
"Variable '%s' is not found in calling scope. Looking in calling scope "
"because this symbol was prefixed with .. in the j= parameter."
msgstr ""
"A variável '%s' não foi encontrada no escopo de chamada. Procurando no "
"escopo de chamada porque este símbolo foi prefixado com .. no parâmetro j=."

#: data.table.R:1370
#, c-format
msgid ""
"j (the 2nd argument inside [...]) is a single symbol but column name '%1$s' "
"is not found. If you intended to select columns using a variable in calling "
"scope, please try DT[, ..%1$s]. The .. prefix conveys one-level-up similar "
"to a file system path."
msgstr ""
"j (o 2º argumento dentro de [...]) é um símbolo único, mas o nome da coluna "
"'%1$s' não foi encontrado. Se você pretendia selecionar colunas usando uma "
"variável na chamada do escopo, tente DT[, ..%1$s]. O prefixo .. transmite um "
"nível superior semelhante a um caminho do sistema de arquivos."

#: data.table.R:1454
#, c-format
msgid ""
"The column '.N' can't be grouped because it conflicts with the special .N "
"variable. Try setnames(DT,'.N','N') first."
msgstr ""
"A coluna '.N' não pode ser agrupada porque conflita com a variável especial ."
"N. Tente setnames(DT,'.N','N') primeiro."

#: data.table.R:1455
#, c-format
msgid ""
"The column '.I' can't be grouped because it conflicts with the special .I "
"variable. Try setnames(DT,'.I','I') first."
msgstr ""
"A coluna '.I' não pode ser agrupada porque conflita com a variável especial ."
"I. Tente setnames(DT,'.I','I') primeiro."

#: data.table.R:1483
#, c-format
msgid "logical error. i is not data.table, but mult='all' and 'by'=.EACHI"
msgstr "erro lógico. i não é data.table, mas mult='all' e 'by'=.EACHI"

#: data.table.R:1804
#, c-format
msgid ""
"Unable to optimize call to mean() and could be very slow. You must name 'na."
"rm' like that otherwise if you do mean(x,TRUE) the TRUE is taken to mean "
"'trim' which is the 2nd argument of mean. 'trim' is not yet optimized."
msgstr ""
"Não foi possível otimizar a chamada de mean() e pode ser muito lento. Você "
"deve nomear 'na.rm' como tal, caso contrário, se você usar mean(x,TRUE), o "
"TRUE é obtido para fazer uma média truncada, pois 'trim' é o 2º argumento de "
"mean. 'trim' ainda não está otimizado."

#: data.table.R:1950
#, c-format
msgid ""
"The setkey() normally performed by keyby= has been skipped (as if by= was "
"used) because := is being used together with keyby= but the keyby= contains "
"some expressions. To avoid this warning, use by= instead, or provide "
"existing column names to keyby=."
msgstr ""
"O setkey() normalmente executado por keyby= foi ignorado (como se by= fosse "
"usado) porque := está sendo usado junto com keyby= mas keyby= contém algumas "
"expressões. Para evitar esse aviso, use by= ou forneça nomes de colunas "
"existentes para keyby=."

#: data.table.R:2039
#, c-format
msgid "rownames and rownames.value cannot both be used at the same time"
msgstr "rownames e rownames.value não podem ser usados ao mesmo tempo"

#: data.table.R:2044
#, c-format
msgid ""
"length(rownames)==%d but nrow(DT)==%d. The rownames argument specifies a "
"single column name or number. Consider rownames.value= instead."
msgstr ""
"length(rownames)==%d, mas nrow(DT)==%d. O argumento rownames especifica um "
"único nome ou número de coluna. Considere usar rownames.value= em vez disso."

#: data.table.R:2048
#, c-format
msgid ""
"length(rownames)==0 but should be a single column name or number, or NULL"
msgstr ""
"length(rownames)==0, mas deve ser um nome ou número de única coluna, ou NULL"

#: data.table.R:2052
#, c-format
msgid ""
"rownames is TRUE but key has multiple columns %s; taking first column x[,1] "
"as rownames"
msgstr ""
"rownames é TRUE, mas a chave possui múltiplas colunas %s; usando primeira "
"coluna x[,1] como rownames"

#: data.table.R:2062
#, c-format
msgid "'%s' is not a column of x"
msgstr "'%s' não é uma coluna de x"

#: data.table.R:2068
#, c-format
msgid ""
"as.integer(rownames)==%d which is outside the column number range [1,"
"ncol=%d]."
msgstr ""
"as.integer(rownames)==%d que está fora do intervalo de números de coluna [1,"
"ncol=%d]."

#: data.table.R:2073
#, c-format
msgid "length(rownames.value)==%d but should be nrow(x)==%d"
msgstr "length(rownames.value)==%d, mas deveria ser nrow(x)==%d"

#: data.table.R:2169
#, c-format
msgid ""
"When i is a matrix in DT[i]<-value syntax, it doesn't make sense to provide j"
msgstr ""
"Quando i é uma matriz na sintaxe DT[i]<-valor, não faz sentido fornecer j"

#: data.table.R:2179
#, c-format
msgid "j must be an atomic vector, see ?is.atomic"
msgstr "j deve ser um vetor atômico, veja ?is.atomic"

#: data.table.R:2180
#, c-format
msgid "NA in j"
msgstr "NA em j"

#: data.table.R:2186
#, c-format
msgid "j must be vector of column name or positions"
msgstr "j deve ser um vetor de posições ou nome de coluna"

#: data.table.R:2187
#, c-format
msgid ""
"Attempt to assign to column position greater than ncol(x). Create the column "
"by name, instead. This logic intends to catch (most likely) user errors."
msgstr ""
"Tentativa de atribuir a uma posição de coluna maior que ncol(x). Em vez "
"disso, crie a coluna por nome. Esta lógica pretende capturar (prováveis) "
"erros do usuário."

#: data.table.R:2254
#, c-format
msgid ""
"data.table inherits from data.frame (from v1.5), but this data.table does "
"not. Has it been created manually (e.g. by using 'structure' rather than "
"'data.table') or saved to disk using a prior version of data.table?"
msgstr ""
"data.table herda de data.frame (desde v1.5), mas esta data.table não. Ela "
"foi criado=a manualmente (por exemplo, usando 'structure' em vez de 'data."
"table') ou salvo=a em disco usando uma versão anterior do data.table?"

#: data.table.R:2263
#, c-format
msgid "attempting to assign invalid object to dimnames of a data.table"
msgstr "tentando atribuir objeto inválido a dimnames de uma data.table"

#: data.table.R:2264
#, c-format
msgid "data.tables do not have rownames"
msgstr "data.tables não têm rownames"

#: data.table.R:2265 data.table.R:2634
#, c-format
msgid "Can't assign %d names to a %d-column data.table"
msgstr "Não é possível atribuir %d nomes a uma data.table de %d colunas"

#: data.table.R:2329
#, c-format
msgid "'subset' must evaluate to logical"
msgstr "'subset' deve ser avaliado para tipo lógico"

#: data.table.R:2372
#, c-format
msgid "Argument 'invert' must be logical TRUE/FALSE"
msgstr "Argumento 'invert' deve ser lógico TRUE/FALSE"

#: data.table.R:2413
#, c-format
msgid "x argument must be a data.table"
msgstr "o argumento x deve ser uma data.table"

#: data.table.R:2418
#, c-format
msgid "group length is 0 but data nrow > 0"
msgstr "o comprimento do grupo é 0, mas os dados têm nrow > 0"

#: data.table.R:2420
#, c-format
msgid ""
"passing 'f' argument together with 'by' is not allowed, use 'by' when split "
"by column in data.table and 'f' when split by external factor"
msgstr ""
"passar o argumento 'f' junto com 'by' não é permitido, use 'by' quando "
"dividido por uma coluna na data.table e 'f' quando dividido por fator externo"

#: data.table.R:2428
#, c-format
msgid "Either 'by' or 'f' argument must be supplied"
msgstr "O argumento 'by' ou 'f' deve ser fornecido"

#: data.table.R:2430
#, c-format
msgid "Column '.ll.tech.split' is reserved for split.data.table processing"
msgstr ""
"A coluna '.ll.tech.split' é reservada para processamento em split.data.table"

#: data.table.R:2431
#, c-format
msgid "Column '.nm.tech.split' is reserved for split.data.table processing"
msgstr ""
"A coluna '.nm.tech.split' é reservada para processamento em split.data.table"

#: data.table.R:2432
#, c-format
msgid "Argument 'by' must refer to column names in x"
msgstr "O argumento 'by' deve referir-se a nomes das colunas em x"

#: data.table.R:2433
#, c-format
msgid ""
"Argument 'by' must refer only to atomic-type columns, but the following "
"columns are non-atomic: %s"
msgstr ""
"O argumento 'by' deve referir-se apenas a colunas do tipo atômico, mas as "
"seguintes colunas não são atômicas: %s"

#: data.table.R:2565
#, c-format
msgid ""
"x is not a data.table|frame. Shallow copy is a copy of the vector of column "
"pointers (only), so is only meaningful for data.table|frame"
msgstr ""
"x não é um data.table|frame. A cópia rasa é uma cópia do vetor de ponteiros "
"de coluna (apenas), portanto, só é significativa para data.table|frame"

#: data.table.R:2574
#, c-format
msgid "setalloccol attempting to modify `*tmp*`"
msgstr "setalloccol tentando modificar `*tmp*`"

#: data.table.R:2609
#, c-format
msgid ""
"Input is a length=1 logical that points to the same address as R's global "
"value. Therefore the attribute has not been set by reference, rather on a "
"copy. You will need to assign the result back to a variable. See issue #1281."
msgstr ""
"A entrada é um tipo lógico de comprimento 1 que aponta para o mesmo endereço "
"que o valor global do R. Portanto, o atributo não foi definido por "
"referência, mas sim por uma cópia. Você precisará atribuir o resultado de "
"volta a uma variável. Consulte o issue #1281."

#: data.table.R:2624
#, c-format
msgid "x is not a data.table or data.frame"
msgstr "x não é um data.table ou data.frame"

#: data.table.R:2626
#, c-format
msgid "x has %d columns but its names are length %d"
msgstr "x tem %d colunas, mas seus nomes têm comprimento %d"

#: data.table.R:2633
#, c-format
msgid "Passed a vector of type '%s'. Needs to be type 'character'."
msgstr "Passou um vetor do tipo '%s'. Precisa ser do tipo 'character'."

#: data.table.R:2646
#, c-format
msgid "'new' is not a character vector or a function"
msgstr "'new' não é um vetor de caracteres ou uma função"

#: data.table.R:2648
#, c-format
msgid "NA in 'new' at positions %s"
msgstr "NA em 'new' nas posições %s"

#: data.table.R:2649
#, c-format
msgid "Some duplicates exist in 'old': %s"
msgstr "Existem algumas duplicatas em 'old': %s"

#: data.table.R:2651
#, c-format
msgid "'old' is type %s but should be integer, double or character"
msgstr "'old' é do tipo %s, mas deve ser inteiro, double ou caractere"

#: data.table.R:2652
#, c-format
msgid "'old' is length %d but 'new' is length %d"
msgstr "'old' tem comprimento %d, mas 'new' tem comprimento %d"

#: data.table.R:2653
#, c-format
msgid "NA (or out of bounds) in 'old' at positions %s"
msgstr "NA (ou fora dos limites) em 'old' nas posições %s"

#: data.table.R:2656
#, c-format
msgid ""
"Item %d of 'old' is '%s' which appears several times in column names. Just "
"the first will be changed. There are %d other items in 'old' that are also "
"duplicated in column names."
msgstr ""
"O item %d de 'old' é '%s', que aparece várias vezes nos nomes das colunas. "
"Apenas o primeiro será alterado. Existem %d outros itens em 'old' que também "
"estão duplicados nos nomes das colunas."

#: data.table.R:2664
#, c-format
msgid ""
"Items of 'old' not found in column names: %s. Consider skip_absent=TRUE."
msgstr ""
"Itens de 'old' não encontrados nos nomes das colunas: %s. Considere "
"skip_absent=TRUE."

#: data.table.R:2703
#, c-format
msgid ""
"x has some duplicated column name(s): %s. Please remove or rename the "
"duplicate(s) and try again."
msgstr ""
"x tem alguns nomes de coluna duplicados: %s. Por favor, remova ou renomeie "
"as duplicatas e tente novamente."

#: data.table.R:2705
#, c-format
msgid "Provide either before= or after= but not both"
msgstr "Forneça before= ou after=, mas não ambos"

#: data.table.R:2707
#, c-format
msgid "before=/after= accept a single column name or number, not more than one"
msgstr ""
"before=/after= aceitam um único nome ou número de coluna, não mais do que um"

#: data.table.R:2763
#, c-format
msgid "Input is %s but should be a plain list of items to be stacked"
msgstr ""
"A entrada é %s, mas deve ser uma lista simples de itens a serem empilhados"

#: data.table.R:2767
#, c-format
msgid ""
"idcol must be a logical or character vector of length 1. If logical TRUE the "
"id column will named '.id'."
msgstr ""
"idcol deve ser um vetor de valores lógicos ou caracteres de comprimento 1. "
"Se for lógico TRUE, a coluna de identificação denominada '.id'."

#: data.table.R:2772
#, c-format
msgid "use.names=NA invalid"
msgstr "use.names=NA inválido"

#: data.table.R:2774
#, c-format
msgid ""
"use.names='check' cannot be used explicitly because the value 'check' is new "
"in v1.12.2 and subject to change. It is just meant to convey default "
"behavior. See ?rbindlist."
msgstr ""
"use.names='check' não pode ser usado explicitamente porque o valor 'check' é "
"novo na v1.12.2 e está sujeito a alterações. O objetivo é apenas transmitir "
"o comportamento padrão. Consulte ?rbindlist."

#: data.table.R:2789
#, fuzzy, c-format
#| msgid ""
#| "Check that is.data.table(DT) == TRUE. Otherwise, :=, `:=`(...) and "
#| "let(...) are defined for use in j, once only and in particular ways. See "
#| "help(\":=\")."
msgid ""
"Check that is.data.table(DT) == TRUE. Otherwise, :=, `:=`(...) and let(...) "
"are defined for use in j, once only and in particular ways. Note that "
"namespace-qualification like data.table::`:=`(...) is not supported. See "
"help(\":=\")."
msgstr ""
"Verifique se is.data.table(DT) == TRUE. De qualquer forma, :=, `:=`(...) e "
"let(...) são definidos para uso em j, apenas uma vez e de maneiras "
"específicas. Veja help(\":=\")."

#: data.table.R:2806
#, c-format
msgid ""
"setDF only accepts data.table, data.frame or list of equal length as input"
msgstr ""
"setDF aceita apenas data.table, data.frame ou lista de igual comprimento "
"como entrada"

#: data.table.R:2807
#, c-format
msgid "rownames contains duplicates"
msgstr "rownames contém duplicatas"

#: data.table.R:2814 data.table.R:2825 data.table.R:2848
#, c-format
msgid "rownames incorrect length; expected %d names, got %d"
msgstr "rownames com comprimento incorreto; esperava %d nomes, obteve %d"

#: data.table.R:2833
#, c-format
msgid "All elements in argument 'x' to 'setDF' must be of same length"
msgstr ""
"Todos os elementos no argumento 'x' para 'setDF' devem ter o mesmo "
"comprimento"

#: data.table.R:2862
#, c-format
msgid "Cannot find symbol %s"
msgstr "Não foi possível encontrar o símbolo %s"

#: data.table.R:2869
#, c-format
msgid ""
"Cannot convert '%1$s' to data.table by reference because binding is locked. "
"It is very likely that '%1$s' resides within a package (or an environment) "
"that is locked to prevent modifying its variable bindings. Try copying the "
"object to your current environment, ex: var <- copy(var) and then using "
"setDT again."
msgstr ""
"Não é possível converter '%1$s' em data.table por referência porque o "
"vínculo está travado. É muito provável que '%1$s' resida em um pacote (ou "
"ambiente) que esteja travado para evitar a modificação de seus vínculos de "
"variáveis. Experimente copiar o objeto para o seu ambiente atual, ex: var <- "
"copy(var) e depois usar setDT novamente."

#: data.table.R:2922
#, c-format
msgid ""
"Argument 'x' to 'setDT' should be a 'list', 'data.frame' or 'data.table'"
msgstr ""
"O argumento 'x' para 'setDT' deve ser uma 'list', 'data.frame' ou 'data."
"table'"

#: data.table.R:2937
#, c-format
msgid "Item '%s' not found in names of input list"
msgstr "Item '%s' não encontrado nos nomes da lista recebida"

#: data.table.R:2962 data.table.R:2987
#, c-format
msgid "'prefix' must be NULL or a character vector of length 1."
msgstr "'prefix' deve ser NULL ou um vetor de caracteres de comprimento 1."

#: data.table.R:2965 data.table.R:2990
#, c-format
msgid "x is a single vector, non-NULL 'cols' doesn't make sense."
msgstr "x é um único vetor, 'cols' não NULL não faz sentido."

#: data.table.R:2969 data.table.R:2994
#, c-format
msgid "x is a list, 'cols' cannot be 0-length."
msgstr "x é uma lista, 'cols' não pode ter comprimento 0."

#: data.table.R:3185
#, c-format
msgid ""
"RHS of %s is length %d which is not 1 or nrow (%d). For robustness, no "
"recycling is allowed (other than of length 1 RHS). Consider %%in%% instead."
msgstr ""
"Lado direito (RHS) de %s tem comprimento %d que não é 1 ou nrow (%d). Para "
"maior robustez, nenhuma reciclagem é permitida (exceto em lado direito de "
"comprimento 1). Considere %%in%% em vez disso."

#: data.table.R:3300
#, c-format
msgid ""
"'on' argument should be a named atomic vector of column names indicating "
"which columns in 'i' should be joined with which columns in 'x'."
msgstr ""
"O argumento 'on' deve ser um vetor atômico nomeado de nomes de colunas "
"indicando quais colunas em 'i' correspondem a quais colunas em 'x' para a "
"junção."

#: data.table.R:3341
#, c-format
msgid ""
"Found more than one operator in one 'on' statement: %s. Please specify a "
"single operator."
msgstr ""
"Encontrado mais de um operador em uma instrução 'on': %s. Especifique um "
"único operador."

#: data.table.R:3364
#, c-format
msgid ""
"'on' contains no column name: %s. Each 'on' clause must contain one or two "
"column names."
msgstr ""
"'on' não contém nome de coluna: %s. Cada cláusula 'on' deve conter um ou "
"dois nomes de coluna."

#: data.table.R:3366
#, c-format
msgid ""
"'on' contains more than 2 column names: %s. Each 'on' clause must contain "
"one or two column names."
msgstr ""
"'on' contém mais de 2 nomes de colunas: %s. Cada cláusula 'on' deve conter "
"um ou dois nomes de coluna."

#: data.table.R:3371
#, c-format
msgid "Invalid join operators %s. Only allowed operators are %s."
msgstr ""
"Operadores de junção inválidos: %s. Os únicos operadores permitidos são %s."

#: devel.R:16
#, c-format
msgid "There is no package %s in provided repository."
msgstr "Não há um pacote %s no repositório fornecido."

#: duplicated.R:7
#, c-format
msgid "'fromLast' must be TRUE or FALSE"
msgstr "'fromLast' deve ser TRUE ou FALSE"

#: duplicated.R:105
#, c-format
msgid "x must be an atomic vector or data.frames/data.tables"
msgstr "x deve ser um vetor atômico ou data.frames/data.tables"

#: fcast.R:7
#, c-format
msgid "Using '%s' as value column. Use 'value.var' to override"
msgstr "Usando '%s'como coluna do valor. Use 'value.var' para contornar"

#: fcast.R:20 fmelt.R:16
#, c-format
msgid ""
"The %1$s generic in data.table has been passed a %2$s, but data.table::%1$s "
"currently only has a method for data.tables. Please confirm your input is a "
"data.table, with setDT(%3$s) or as.data.table(%3$s). If you intend to use a "
"method from reshape2, try installing that package first, but do note that "
"reshape2 is superseded and is no longer actively developed."
msgstr ""
"Um %2$s foi passado para o genérico %1$s em data.table, mas atualmente data."
"table::%1$s só tem um método para data.tables. Favor garantir que a entrada "
"seja uma data.table, com setDT(%3$s) ou as.data.table(%3$s). Se você "
"pretende usar um método de reshape2, tente instalar aquele pacote primeiro, "
"mas note que reshape2 foi substituído e não está mais em desenvolvimento "
"ativo."

#: fcast.R:21
#, c-format
msgid ""
"The %1$s generic in data.table has been passed a %2$s and will attempt to "
"redirect to the relevant reshape2 method; please note that reshape2 is "
"superseded and is no longer actively developed, and this redirection is now "
"deprecated. Please do this redirection yourself like reshape2::%1$s(%3$s). "
"In the next version, this warning will become an error."
msgstr ""
"Um %2$s foi passado para o genérico %1$s em data.table e vai tentar "
"redirecionar para o método relevante no pacote reshape2; favor notar que "
"reshape2 foi substituído e não está mais em desenvolvimento ativo, e que "
"esse redirecionamento agora é obsoleto. Por favor, faça esse "
"redirecionamento por conta própria usando reshape2::%1$s(%3$s). Na próxima "
"versão, este aviso se tornará um erro."

#: fcast.R:31
#, c-format
msgid ""
"Invalid formula. Cast formula should be of the form LHS ~ RHS, for e.g., a + "
"b ~ c."
msgstr ""
"Fórmula inválida. A fórmula do cast deveria ter o formato LHS ~ RHS (lado "
"esquerdo ~ lado direito), p. ex. a + b ~ c."

#: fcast.R:38
#, c-format
msgid "data.table to cast must have unique column names"
msgstr "a data.table a ser \"moldada\" deve ter nomes de coluna únicos"

#: fcast.R:83
#, c-format
msgid "value.var values %s are not found in 'data'."
msgstr "os valores de value.var  %s não se encontram em 'data'."

#: fcast.R:99
#, c-format
msgid ""
"When 'fun.aggregate' and 'value.var' are both lists, 'value.var' must be "
"either of length =1 or =length(fun.aggregate)."
msgstr ""
"Quando 'fun.aggregate' e 'value.var' são listas, o comprimento de 'value."
"var' deve ser ou =1 ou  =length(fun.aggregate)."

#: fcast.R:132
#, c-format
msgid "'data' must be a data.table."
msgstr "'data' deve ser uma data.table."

#: fcast.R:134
#, c-format
msgid "'drop' must be logical TRUE/FALSE"
msgstr "'drop' deve ser lógico TRUE/FALSE"

#: fcast.R:136
#, c-format
msgid "Argument 'value.var.in.dots' should be logical TRUE/FALSE"
msgstr "Argumento 'value.var.in.dots' deveria ser lógico TRUE/FALSE"

#: fcast.R:138
#, c-format
msgid ""
"Arguments 'value.var.in.LHSdots', 'value.var.in.RHSdots' should be logical "
"TRUE/FALSE"
msgstr ""
"Os argumentos 'value.var.in.LHSdots', 'value.var.in.RHSdots' deveriam ser "
"lógicos TRUE/FALSE"

#: fcast.R:155
#, c-format
msgid "Column [%s] not found or of unknown type."
msgstr "Coluna [%s] não encontrada ou de tipo desconhecido."

#: fcast.R:170
#, c-format
msgid "Columns specified in formula can not be of type list"
msgstr "Colunas especificadas na formula não podem ser do tipo lista"

#: fcast.R:185
#, c-format
msgid ""
"'fun.aggregate' is NULL, but found duplicate row/column combinations, so "
"defaulting to length(). That is, the variables %s used in 'formula' do not "
"uniquely identify rows in the input 'data'. In such cases, 'fun.aggregate' "
"is used to derive a single representative value for each combination in the "
"output data.table, for example by summing or averaging (fun.aggregate=sum or "
"fun.aggregate=mean, respectively). Check the resulting table for values "
"larger than 1 to see which combinations were not unique. See ?dcast.data."
"table for more details."
msgstr ""
"'fun.aggregate' é NULL, mas foram encontradas combinações duplicadas de "
"linha/coluna, então usando length() por padrão. Isso é, as variáveis %s "
"usadas em 'formula' não identificam de forma única as linhas na entrada "
"'data'. Em tais casos, 'fun.aggregate' é usado para derivar um único valor "
"representativo para cada combinação na data.table de saída, por exemplo "
"somando ou tirando a média (fun.aggregate=sum ou fun.aggregate=mean, "
"respectivamente). Verifique a tabela resultante por valores maiores do que 1 "
"para ver quais combinações não foram únicas. Veja ?dcast.data.table para "
"mais detalhes."

#: fcast.R:195
msgid ""
"Aggregating function(s) should take a vector as input and return a single "
"value (length=1), but they do not, so the result is undefined. Please fix by "
"modifying your function so that a single value is always returned."
msgstr ""

#: fdroplevels.R:13
#, c-format
msgid ""
"droplevels() with in.place=TRUE is deprecated. Use setdroplevels() instead."
msgstr ""

#: fmelt.R:17
#, c-format
msgid ""
"The %1$s generic in data.table has been passed a %2$s and will attempt to "
"redirect to the relevant reshape2 method; please note that reshape2 is "
"superseded and is no longer actively developed, and this redirection is now "
"deprecated. To continue using melt methods from reshape2 while both "
"libraries are attached, e.g. melt.list, you can prepend the namespace, i.e. "
"reshape2::%1$s(%3$s). In the next version, this warning will become an error."
msgstr ""
"Um %2$s foi passado para o genérico %1$s em data.table, que vai tentar "
"redirecionar para o método relevante no pacote reshape2; favor notar que "
"reshape2 foi substituído e não está mais em desenvolvimento ativo, e que "
"esse redirecionamento agora é obsoleto. Para continuar usando métodos melt "
"de reshape2 enquanto ambos os pacotes estão anexados, p.ex. melt.list, você "
"pode prefixar com o namespace, p.ex. reshape2::%1$s(%3$s). Na próxima "
"versão, este aviso se tornará um erro."

#: fmelt.R:28
#, c-format
msgid "Input patterns must be of type character."
msgstr "Padrões de entrada devem ser do tipo caracter."

#: fmelt.R:31
#, c-format
msgid "Pattern(s) not found: [%s]"
msgstr "Padrão(ões) não encontrado(s): [%s]"

#: fmelt.R:46
#, c-format
msgid ""
"each ... argument to measure must be either a symbol without argument name, "
"or a function with argument name, problems: %s"
msgstr ""
"cada argumento ... para measure deve ser ou um símbolo sem nome de "
"argumento, ou uma função com nome de argumento, problemas: %s"

#: fmelt.R:54
#, c-format
msgid ""
"group names specified in ... conflict with measure argument names; please "
"fix by changing group names: %s"
msgstr ""
"nomes de grupo especificados em ... conflitam com nomes de argumento de "
"measures; favor consertar trocando os nomes de grupo: %s"

#: fmelt.R:60
#, c-format
msgid ""
"each ... argument to measure must be a function with at least one argument, "
"problem: %s"
msgstr ""
"cada ... argumento para measure deve ser uma função com ao menos um "
"argumento, problema: %s"

#: fmelt.R:74
#, c-format
msgid ""
"both sep and pattern arguments used; must use either sep or pattern (not "
"both)"
msgstr ""
"ambos os argumentos sep e pattern usados; deve usar ou sep, ou pattern (não "
"os dois)"

#: fmelt.R:77
#, c-format
msgid "multiple.keyword must be a character string with nchar>0"
msgstr "multiple.keyword deve ser uma string de caracteres com nchar>0"

#: fmelt.R:80
#, c-format
msgid "cols must be a character vector of column names"
msgstr "cols deve ser um vetor de caracteres de nomes de coluna"

#: fmelt.R:88
#, c-format
msgid "in measurev, %s must be named, problems: %s"
msgstr "em measurev, %s deve ser nomeado, problemas: %s"

#: fmelt.R:94
#, c-format
msgid "%s should be uniquely named, problems: %s"
msgstr "%s deveria receber nomes únicos, problemas: %s"

#: fmelt.R:99
#, c-format
msgid "number of %s =%d must be same as %s =%d"
msgstr "número de %s=%d deve ser o mesmo de %s =%d"

#: fmelt.R:106
#, c-format
msgid "pattern must be character string"
msgstr "pattern deve ser uma string de caracteres"

#: fmelt.R:111
#, c-format
msgid ""
"pattern did not match any cols, so nothing would be melted; fix by changing "
"pattern"
msgstr ""
"pattern não coincidiu com nenhuma coluna, então nada será \"derretido\"; "
"corrija mudando o padrão"

#: fmelt.R:115
#, c-format
msgid ""
"pattern must contain at least one capture group (parenthesized sub-pattern)"
msgstr ""
"pattern deve conter pelo menos um grupo de captura (subpadrão entre "
"parênteses)"

#: fmelt.R:124
#, c-format
msgid "sep must be character string"
msgstr "sep deve ser uma string de caracteres"

#: fmelt.R:130
#, c-format
msgid ""
"each column name results in only one item after splitting using sep, which "
"means that all columns would be melted; to fix please either specify melt on "
"all columns directly without using measure, or use a different sep/pattern "
"specification"
msgstr ""
"cada nome de coluna resulta em apenas um item após dividir usando sep, o que "
"significa que todas as colunas seriam \"derretidas\"; para consertar, favor "
"ou especificar o \"derretimento\" em todas as colunas diretamente sem usar "
"'measure', ou especifique um sep/pattern diferente"

#: fmelt.R:140
#, c-format
msgid ""
"number of unique column IDs =%d is less than number of melted columns =%d; "
"fix by changing pattern/sep"
msgstr ""
"o número de colunas de identificação únicas = %d é menor do que o número de "
"colunas \"derretidas\" = %d; conserte trocando pattern/sep"

#: fmelt.R:150
#, c-format
msgid ""
"in the measurev fun.list, each non-NULL element must be a function with at "
"least one argument, problem: %s"
msgstr ""
"na fun.list de measurev, cada elemento não-NULL deve ser uma função com ao "
"menos um argumento, problema: %s"

#: fmelt.R:154
#, c-format
msgid ""
"each conversion function must return an atomic vector with same length as "
"its first argument, problem: %s"
msgstr ""
"cada função de conversão deve retornar um vetor atômico com o mesmo "
"comprimento que seu primeiro argumento, problema: %s"

#: fmelt.R:157
#, c-format
msgid "%s conversion function returned vector of all NA"
msgstr "função de conversão %s retornou um vetor inteiro de NA"

#: fmelt.R:163
#, c-format
msgid ""
"number of unique groups after applying type conversion functions less than "
"number of groups, change type conversion"
msgstr ""
"o número de grupos únicos depois de aplicar funções de conversão de tipo é "
"menor do que o número de grupos, mude a conversão de tipo"

#: fmelt.R:168
#, c-format
msgid ""
"%s column class=%s after applying conversion function, but must be character"
msgstr ""
"coluna %s com classe=%s depois de aplicar função de conversão, mas tem que "
"ser caractere"

#: fmelt.R:172
#, c-format
msgid "%s is the only group; fix by creating at least one more group"
msgstr "%s é o único grupo; conserte criando ao menos mais um grupo"

#: fmelt.R:195
#, c-format
msgid "'data' must be a data.table"
msgstr "'data' deve ser uma data.table"

#: fmelt.R:214
#, c-format
msgid ""
"'value.name' provided in both 'measure.vars' and 'value.name argument'; "
"value provided in 'measure.vars' is given precedence."
msgstr ""
"'value.name' fornecido tanto em 'measure.vars' quanto no argumento 'value."
"name'; o valor fornecido em 'measure.vars' tem precedência"

#: fmelt.R:217
#, c-format
msgid "Please provide a name to each element of 'measure.vars'."
msgstr "Favor fornecer um nome para cada elemento de 'measure.vars'."

#: foverlaps.R:3
#, c-format
msgid ""
"y and x must both be data.tables. Use `setDT()` to convert list/data.frames "
"to data.tables by reference or as.data.table() to convert to data.tables by "
"copying."
msgstr ""
"y e x devem ambos serem data.tables. Use `setDT()` para converter listas e "
"data.frames para data.tables por referência ou as.data.table() para "
"converter para data.tables copiando."

#: foverlaps.R:9
#, c-format
msgid "maxgap must be a non-negative integer value of length 1"
msgstr "maxgap deve ser um valor inteiro não-negativo de comprimento 1"

#: foverlaps.R:11
#, c-format
msgid "minoverlap must be a positive integer value of length 1"
msgstr "minoverlap deve ser um valor inteiro positivo de comprimento 1"

#: foverlaps.R:13
#, c-format
msgid "which must be a logical vector of length 1. Either TRUE/FALSE"
msgstr "which deve ser um vetor lógico de comprimento 1. TRUE ou FALSE"

#: foverlaps.R:15
#, c-format
msgid "nomatch must either be NA or NULL"
msgstr "nomatch deve ser ou NA ou NULL"

#: foverlaps.R:20
#, c-format
msgid "maxgap and minoverlap arguments are not yet implemented."
msgstr "argumentos maxgap e minoverlap  ainda não estão implementados."

#: foverlaps.R:22
#, c-format
msgid ""
"y must be keyed (i.e., sorted, and, marked as sorted). Call setkey(y, ...) "
"first, see ?setkey. Also check the examples in ?foverlaps."
msgstr ""
"y deve ser chaveada (ou seja, ordenada e marcada como ordenada). Chame "
"setkey(y, …) primeiro, veja ?setkey. Também confira os exemplos em ?"
"foverlaps."

#: foverlaps.R:24
#, c-format
msgid ""
"'by.x' and 'by.y' should contain at least two column names (or numbers) each "
"- corresponding to 'start' and 'end' points of intervals. Please see ?"
"foverlaps and examples for more info."
msgstr ""
"'by.x' e 'by.y' deveriam conter ao menos dois nomes de coluna (ou números) "
"cada - correspondendo aos pontos de início e fim dos intervalos. Favor ver ?"
"foverlaps e exemplos para mais informação. "

#: foverlaps.R:27
#, c-format
msgid ""
"Invalid numeric value for 'by.x'; it should be a vector with values 1 <= by."
"x <= length(x)"
msgstr ""
"Valor numérico inválido para 'by.x'; deveria ser um vetor com valores 1 <= "
"by.x <= length(x)"

#: foverlaps.R:32
#, c-format
msgid ""
"Invalid numeric value for 'by.y'; it should be a vector with values 1 <= by."
"y <= length(y)"
msgstr ""
"Valor numérico inválido para 'by.y'; deveria ser um vetor com valores 1 <= "
"by.y <= length(y)"

#: foverlaps.R:36
#, c-format
msgid "A non-empty vector of column names or numbers is required for by.x"
msgstr ""
"Um vetor não-vazio de nomes ou números de coluna é necessário para by.x"

#: foverlaps.R:38
#, c-format
msgid "A non-empty vector of column names or numbers is required for by.y"
msgstr ""
"Um vetor não-vazio de nomes ou números de coluna é necessário para by.y"

#: foverlaps.R:40
#, c-format
msgid ""
"The first %d columns of y's key must be identical to the columns specified "
"in by.y."
msgstr ""
"As primeiras %d colunas da chave de y devem ser idênticas às colunas "
"especificadas em by.y."

#: foverlaps.R:42
#, c-format
msgid "Elements listed in 'by.x' must be valid names in data.table x"
msgstr "Elementos listados em 'by.x' devem ser nomes válidos na data.table x"

#: foverlaps.R:44
#, c-format
msgid ""
"Duplicate columns are not allowed in overlap joins. This may change in the "
"future."
msgstr ""
"Colunas duplicadas não são permitidas em junções de sobreposição. Isso pode "
"mudar no futuro."

#: foverlaps.R:46
#, c-format
msgid ""
"length(by.x) != length(by.y). Columns specified in by.x should correspond to "
"columns specified in by.y and should be of same lengths."
msgstr ""
"length(by.x) != length(by.y). As colunas especificadas em by.x deveriam "
"corresponder às colunas especificadas em by.y, e os argumentos deveriam ser "
"do mesmo comprimento."

#: foverlaps.R:48 foverlaps.R:50 merge.R:26 merge.R:27
#, c-format
msgid ""
"%s has some duplicated column name(s): %s. Please remove or rename the "
"duplicate(s) and try again."
msgstr ""
"%s tem alguns nomes de coluna duplicados: %s. Por favor, remova ou renomeie "
"as duplicatas e tente novamente."

#: foverlaps.R:56
#, c-format
msgid ""
"The last two columns in by.x should correspond to the 'start' and 'end' "
"intervals in data.table x and must be integer/numeric type."
msgstr ""
"As últimas duas colunas em by.x deveriam corresponder às colunas de início e "
"de fim dos intervalos na data.table x e devem ser do tipo inteiro/numérico."

#: foverlaps.R:60 foverlaps.R:62 foverlaps.R:69 foverlaps.R:71
#, c-format
msgid ""
"NA values in data.table %s '%s' column: '%s'. All rows with NA values in the "
"range columns must be removed for foverlaps() to work."
msgstr ""
"Valores NA na coluna %s '%s' da data.table: '%s'. Todas as linhas com "
"valores NA nas colunas de intervalo devem ser removidas para o foverlaps() "
"funcionar."

#: foverlaps.R:63
#, c-format
msgid ""
"All entries in column '%s' should be <= corresponding entries in column '%s' "
"in data.table x."
msgstr ""
"Todas as entradas na coluna '%s' deveriam ser <= as entradas correspondentes "
"na coluna '%s' na data.table x."

#: foverlaps.R:66
#, c-format
msgid ""
"The last two columns in by.y should correspond to the 'start' and 'end' "
"intervals in data.table y and must be integer/numeric type."
msgstr ""
"As últimas duas colunas em by.y deveriam corresponder às colunas de início e "
"de fim dos intervalos na data.table y e devem ser do tipo inteiro/numérico."

#: foverlaps.R:72
#, c-format
msgid ""
"All entries in column '%s' should be <= corresponding entries in column '%s' "
"in data.table y."
msgstr ""
"Todas as entradas na coluna '%s' deveriam ser <= as entradas correspondentes "
"na coluna '%s' na data.table y."

#: foverlaps.R:77
#, c-format
msgid ""
"Some interval cols are of type POSIXct while others are not. Please ensure "
"all interval cols are (or are not) of POSIXct type"
msgstr ""
"Algumas colunas de intervalo são do tipo POSIXct, enquanto outras não são. "
"Favor garantir que todas as colunas de intervalo sejam (ou todas não sejam) "
"to tipo POSIXct"

#: foverlaps.R:83
#, c-format
msgid ""
"POSIXct interval cols have mixed timezones. Overlaps are performed on the "
"internal numerical representation of POSIXct objects (always in UTC epoch "
"time), therefore printed values may give the impression that values don't "
"overlap but their internal representations do Please ensure that POSIXct "
"type interval cols have identical 'tzone' attributes to avoid confusion."
msgstr ""
"Colunas de intervalo POSIXct têm fusos horários diferentes. As sobreposições "
"são realizadas na representação numérica dos objetos POSIXct (sempre em UTC, "
"era UNIX), de forma que os valores exibidos podem dar a impressão de que os "
"valores não se sobrepõem mas suas representações internas se sobrepõem. "
"Favor garantir que as colunas de intervalo do tipo POSIXct tenham atributos "
"'tzone' idênticos para evitar confusão."

#: foverlaps.R:164 foverlaps.R:166 foverlaps.R:170
#, c-format
msgid "Not yet implemented"
msgstr "Ainda não implementado"

#: foverlaps.R:169
#, c-format
msgid "maxgap > minoverlap. maxgap will have no effect here."
msgstr "maxgap > minoverlap. maxgap não terá efeito aqui."

#: frank.R:3
#, c-format
msgid "length(na.last) = 0"
msgstr "length(na.last) = 0"

#: frank.R:5
#, c-format
msgid "length(na.last) > 1, only the first element will be used"
msgstr "length(na.last) > 1, apenas o primeiro item será usado"

#: frank.R:17
#, c-format
msgid "x is a single vector, non-NULL 'cols' doesn't make sense"
msgstr "x é um vetor simples, 'cols' não-NULL não faz sentido"

#: frank.R:23
#, c-format
msgid "x is a list, 'cols' can not be 0-length"
msgstr "x é uma lista, 'cols' não pode ser de comprimento 0"

#: frank.R:31
#, c-format
msgid ""
"Input column '..na_prefix..' conflicts with data.table internal usage; "
"please rename"
msgstr ""
"Coluna de entrada '..na_prefix..' conflita com utilização interna por data."
"table; favor renomear"

#: frank.R:46
#, c-format
msgid ""
"Input column '..stats_runif..' conflicts with data.table internal usage; "
"please rename"
msgstr ""
"Coluna de entrada '..stats_runif..' conflita com utilização interna por data."
"table; favor renomear"

#: fread.R:10
#, c-format
msgid "Used more than one of the arguments input=, file=, text= and cmd=."
msgstr "Usados mais de um dos argumentos input=, file=, text= e cmd=."

#: fread.R:23
#, c-format
msgid "Argument 'encoding' must be 'unknown', 'UTF-8' or 'Latin-1'."
msgstr "Argumento 'encoding' deve ser 'unknown', 'UTF-8' ou 'Latin-1'."

#: fread.R:42
#, c-format
msgid "'text=' is type %s but must be character."
msgstr "'text=' é do tipo %s, mas deve ser caractere."

#: fread.R:55
#, c-format
msgid ""
"input= must be a single character string containing a file name, a system "
"command containing at least one space, a URL starting 'http[s]://', "
"'ftp[s]://' or 'file://', or, the input data itself containing at least one "
"\\n or \\r"
msgstr ""
"input= deve ser uma única sequência de caracteres contendo um nome de "
"arquivo, um comando do sistema contendo pelo menos um espaço, uma URL "
"começando com 'http[s]://', ​​'ftp[s]://' ou 'file://', ou os próprios dados "
"de entrada contendo pelo menos um entre \\n ou \\r"

#: fread.R:60
#, c-format
msgid ""
"input= contains no \\n or \\r, but starts with a space. Please remove the "
"leading space, or use text=, file= or cmd="
msgstr ""
"input= não contém \\n ou \\r, mas começa com um espaço. Por favor, remova o "
"espaço inicial ou use text=, file= ou cmd="

#: fread.R:64
#, c-format
msgid ""
"Taking input= as a system command because it contains a space ('%s'). If "
"it's a filename please remove the space, or use file= explicitly. A variable "
"is being passed to input= and when this is taken as a system command there "
"is a security concern if you are creating an app, the app could have a "
"malicious user, and the app is not running in a secure environment; e.g. the "
"app is running as root. Please read item 5 in the NEWS file for v1.11.6 for "
"more information and for the option to suppress this message."
msgstr ""
"Considerando input= como um comando do sistema porque contém um espaço "
"('%s'). Se for um nome de arquivo, remova o espaço ou use file= "
"explicitamente. Uma variável está sendo passada para input= e quando isso é "
"considerado um comando do sistema, há uma preocupação de segurança se você "
"estiver criando um aplicativo, o aplicativo pode ter um usuário mal-"
"intencionado e o aplicativo não está sendo executado em um ambiente seguro; "
"por exemplo. o aplicativo está sendo executado como root. Leia o item 5 no "
"arquivo NEWS da versão 1.11.6 para obter mais informações e para a opção de "
"suprimir esta mensagem."

#: fread.R:77
#, c-format
msgid ""
"file= must be a single character string containing a filename, or URL "
"starting 'http[s]://', 'ftp[s]://' or 'file://'"
msgstr ""
"file= deve ser uma única sequência de caracteres contendo um nome de arquivo "
"ou URL começando com 'http[s]://', ​​'ftp[s]://' ou 'file://'"

#: fread.R:90
#, c-format
msgid "File '%s' does not exist or is non-readable. getwd()=='%s'"
msgstr "O arquivo '%s' não existe ou não é legível. getwd()=='%s'"

#: fread.R:91
#, c-format
msgid "File '%s' is a directory. Not yet implemented."
msgstr "O arquivo '%s' é um diretório. Ainda não implementado."

#: fread.R:93
#, c-format
msgid "File '%s' has size 0. Returning a NULL %s."
msgstr "O arquivo '%s' tem tamanho 0. Retornando NULL %s."

#: fread.R:105
#, c-format
msgid ""
"Compressed files containing more than 1 file are currently not supported."
msgstr ""
"Arquivos compactados contendo mais de 1 arquivo não são suportados "
"atualmente."

#: fread.R:115
#, fuzzy, c-format
#| msgid ""
#| "To read gz and bz2 files directly, fread() requires 'R.utils' package "
#| "which cannot be found. Please install 'R.utils' using 'install."
#| "packages('R.utils')'."
msgid ""
"To read %s files directly, fread() requires 'R.utils' package which cannot "
"be found. Please install 'R.utils' using 'install.packages('R.utils')'."
msgstr ""
"Para ler arquivos gz e bz2 diretamente, fread() requer o pacote 'R.utils' "
"que não pôde ser encontrado. Instale 'R.utils' usando 'install.packages('R."
"utils')'."

#: fread.R:125
#, c-format
msgid ""
"'autostart' is now deprecated and ignored. Consider skip='string' or skip=n"
msgstr ""
"'autostart' agora está descontinuado e é ignorado. Considere skip='string' "
"ou skip=n"

#: fread.R:127
#, c-format
msgid ""
"colClasses is type 'logical' which is ok if all NA but it has some TRUE or "
"FALSE values in it which is not allowed. Please consider the drop= or "
"select= argument instead. See ?fread."
msgstr ""
"colClasses é do tipo 'logical', que está tudo bem se for todo NA, mas "
"contiver alguns valores TRUE ou FALSE que não são permitidos. Por favor, "
"considere o argumento drop= ou select=. Veja ?fread."

#: fread.R:131
#, c-format
msgid "colClasses is not type list or character vector"
msgstr "colClasses não é lista de tipos ou vetor de caracteres"

#: fread.R:136
#, c-format
msgid ""
"colClasses=\"NULL\" (quoted) is interpreted as colClasses=NULL (the default) "
"as opposed to dropping every column."
msgstr ""
"colClasses=\"NULL\" (entre aspas) é interpretado como colClasses=NULL (o "
"padrão) em vez de descartar todas as colunas."

#: fread.R:148
#, c-format
msgid "na.strings[%d]==\"%s\" consists only of whitespace, ignoring"
msgstr "na.strings[%d]==\"%s\" consiste apenas em espaços em branco, ignorando"

#: fread.R:151
#, c-format
msgid ""
"%s. Since strip.white=TRUE (default), use na.strings=\"\" to specify that "
"any number of spaces in a string column should be read as <NA>."
msgstr ""
"%s. Como strip.white=TRUE (padrão), use na.strings=\"\" para especificar que "
"qualquer número de espaços em uma coluna de string deve ser lido como <NA>."

#: fread.R:153
#, c-format
msgid ""
"%s. strip.white==TRUE (default) and \"\" is present in na.strings, so any "
"number of spaces in string columns will already be read as <NA>."
msgstr ""
"%s. strip.white==TRUE (padrão) e \"\" está presente em na.strings, portanto "
"qualquer número de espaços nas colunas de string já será lido como <NA>."

#: fread.R:157
#, c-format
msgid ""
"%s. But strip.white=FALSE. Use strip.white=TRUE (default) together with na."
"strings=\"\" to turn any number of spaces in string columns into <NA>"
msgstr ""
"%s. Mas strip.white=FALSE. Use strip.white=TRUE (padrão) junto com na."
"strings=\"\" para transformar qualquer número de espaços em colunas de "
"strings em <NA>"

#: fread.R:163
#, c-format
msgid ""
"'data.table' relies on the package 'yaml' to parse the file header; please "
"add this to your library with install.packages('yaml') and try again."
msgstr ""
"'data.table' depende do pacote 'yaml' para analisar o cabeçalho do arquivo; "
"adicione isso à sua biblioteca com install.packages('yaml') e tente "
"novamente."

#: fread.R:167
#, c-format
msgid ""
"Combining a search string as 'skip' and reading a YAML header may not work "
"as expected -- currently, reading will proceed to search for 'skip' from the "
"beginning of the file, NOT from the end of the metadata; please file an "
"issue on GitHub if you'd like to see more intuitive behavior supported."
msgstr ""
"Combinar uma string de pesquisa como 'skip' e ler um cabeçalho YAML pode não "
"funcionar como esperado -- atualmente, a leitura continuará a procurar por "
"'skip' desde o início do arquivo, NÃO a partir do final dos metadados; por "
"favor, registre um issue no GitHub se desejar ver suporte para um "
"comportamento mais intuitivo."

#: fread.R:177
#, c-format
msgid ""
"Encountered <%s%s> at the first unskipped line (%d), which does not "
"constitute the start to a valid YAML header (expecting something matching "
"regex \"%s\"); please check your input and try again."
msgstr ""
"Encontrado <%s%s> na primeira linha não ignorada (%d), que não constitui o "
"início de um cabeçalho YAML válido (esperando algo correspondente à regex "
"\"%s\"); verifique sua entrada e tente novamente."

#: fread.R:189
#, c-format
msgid ""
"Reached the end of the file before finding a completion to the YAML header. "
"A valid YAML header is bookended by lines matching the regex \"%s\". Please "
"double check the input file is a valid csvy."
msgstr ""
"Chegou ao final do arquivo antes de encontrar uma conclusão no cabeçalho "
"YAML. Um cabeçalho YAML válido é delimitado por linhas que correspondem à "
"regex \"%s\". Verifique novamente se o arquivo de entrada é um csvy válido."

#: fread.R:203
#, c-format
msgid "User-supplied 'header' will override that found in metadata."
msgstr ""
"O 'header' fornecido pelo usuário substituirá o encontrado nos metadados."

#: fread.R:221
#, c-format
msgid ""
"User-supplied column names in 'col.names' will override those found in YAML "
"metadata."
msgstr ""
"Os nomes de colunas fornecidos pelo usuário em 'col.names' substituirão "
"aqueles encontrados nos metadados YAML."

#: fread.R:230
#, c-format
msgid ""
"colClasses dictated by user input and those read from YAML header are in "
"conflict (specifically, for column(s) [%s]); the proceeding assumes the user "
"input was an intentional override and will ignore the type(s) implied by the "
"YAML header; please exclude the column(s) from colClasses if this was "
"unintentional."
msgstr ""
"colClasses ditadas pela entrada do usuário e aquelas lidas do cabeçalho YAML "
"estão em conflito (especificamente, para coluna(s) [%s]); o processo "
"pressupõe que a entrada do(a) usuário(a) foi uma substituição intencional e "
"ignorará o(s) tipo(s) implícito(s) no cabeçalho YAML; exclua a(s) coluna(s) "
"de colClasses se isso não for intencional."

#: fread.R:251
#, c-format
msgid "User-supplied 'sep' will override that found in metadata."
msgstr "O 'sep' fornecido pelo usuário substituirá o encontrado nos metadados."

#: fread.R:256
#, c-format
msgid "User-supplied 'quote' will override that found in metadata."
msgstr ""
"O 'quote' fornecido pelo(a) usuário(a) substituirá a encontrada nos "
"metadados."

#: fread.R:261
#, c-format
msgid "User-supplied 'dec' will override that found in metadata."
msgstr ""
"O 'dec' fornecido pelo(a) usuário(a) substituirá o encontrado nos metadados."

#: fread.R:265
#, c-format
msgid "User-supplied 'na.strings' will override that found in metadata."
msgstr ""
"O 'na.strings' fornecido pelo(a) usuário(a) substituirá a encontrada nos "
"metadados."

#: fread.R:314
#, c-format
msgid ""
"Column '%s' was requested to be '%s' but fread encountered the following "
"%s:\n"
"\t%s\n"
"so the column has been left as type '%s'"
msgstr ""
"Foi solicitado que a coluna '%s' seja '%s', mas fread encontrou o seguinte "
"%s:\n"
"\t%s\n"
"então a coluna foi deixada como tipo '%s'"

#: fread.R:337
#, c-format
msgid ""
"key argument of data.table() must be a character vector naming columns (NB: "
"col.names are applied before this)"
msgstr ""
"O argumento key de data.table() deve ser um vetor de caracteres que nomeia "
"colunas (Nota: col.names são aplicados antes disso)"

#: fread.R:345
#, c-format
msgid ""
"index argument of data.table() must be a character vector naming columns "
"(NB: col.names are applied before this)"
msgstr ""
"O argumento index do data.table() deve ser um vetor de caracteres que nomeia "
"colunas (Nota: col.names são aplicados antes disso)"

#: fwrite.R:19
#, c-format
msgid "Argument 'encoding' must be '', 'UTF-8' or 'native'."
msgstr "Argumento 'encoding' deve ser '', 'UTF-8' ou 'native'."

#: fwrite.R:24
#, c-format
msgid "dateTimeAs must be a single string"
msgstr "dateTimeAs deve ser uma única string"

#: fwrite.R:26
#, c-format
msgid "dateTimeAs must be 'ISO','squash','epoch' or 'write.csv'"
msgstr "dateTimeAs deve ser 'ISO','squash','epoch' ou 'write.csv'"

#: fwrite.R:28
#, c-format
msgid "logicalAsInt has been renamed logical01. Use logical01 only, not both."
msgstr ""
"logicalAsInt foi renomeado para logical01. Use apenas logical01, não ambos."

#: fwrite.R:30
#, c-format
msgid ""
"logicalAsInt has been renamed logical01 for consistency with fread. It works "
"fine for now but please change to logical01 at your convenience so we can "
"remove logicalAsInt in future."
msgstr ""
"logicalAsInt foi renomeado para logical01 para consistência com fread. "
"Funciona bem por enquanto, mas, por favor, mude para logical01 quando "
"possível para que possamos remover logicalAsInt no futuro."

#: fwrite.R:40
#, c-format
msgid "x being coerced from class: matrix to data.table"
msgstr "fazendo coerção de x da classe matrix para data.table"

#: fwrite.R:85
#, c-format
msgid ""
"If you intended to overwrite the file at %s with an empty one, please use "
"file.remove first."
msgstr ""
"Se você pretendia sobrescrever o arquivo em %s com um vazio, por favor, use "
"file.remove primeiro."

#: fwrite.R:86
#, c-format
msgid "Input has no columns; doing nothing.%s"
msgstr "Entrada não tem colunas; não há nada a fazer.%s"

#: fwrite.R:89
#, c-format
msgid "Input has no columns; creating an empty file at '%s' and exiting."
msgstr "Entrada não tem colunas; criando um arquivo vazio em '%s' e saindo."

#: fwrite.R:96
#, c-format
msgid ""
"'data.table' relies on the package 'yaml' to write the file header; please "
"add this to your library with install.packages('yaml') and try again."
msgstr ""
"'data.table' depende do pacote 'yaml' para escrever o cabeçalho do arquivo; "
"por favor, adicione isso à sua biblioteca com install.packages('yaml') e "
"tente novamente."

#: groupingsets.R:7 groupingsets.R:25 groupingsets.R:47
#, c-format
msgid "Argument 'x' must be a data.table object"
msgstr "Argumento 'x' deve ser um objeto data.table"

#: groupingsets.R:9 groupingsets.R:27 groupingsets.R:53
#, c-format
msgid ""
"Argument 'by' must be a character vector of column names used in grouping."
msgstr ""
"Argumento 'by' deve ser um vetor de caracteres de nomes de colunas usados em "
"agrupamento."

#: groupingsets.R:11 groupingsets.R:29 groupingsets.R:59
#, c-format
msgid "Argument 'id' must be a logical scalar."
msgstr "Argumento 'id' deve ser um escalar lógico."

#: groupingsets.R:31
#, c-format
msgid "Argument 'j' is required"
msgstr "Argumento 'j' é obrigatório"

#: groupingsets.R:49
#, c-format
msgid ""
"Argument 'x' is a 0-column data.table; no measure to apply grouping over."
msgstr ""
"Argumento 'x' é um data.table com 0 colunas; nenhuma medida para aplicar "
"sobre o agrupamento."

#: groupingsets.R:51
#, c-format
msgid "Input data.table must not contain duplicate column names."
msgstr "A data.table de entrada não deve conter nomes de colunas duplicados."

#: groupingsets.R:55
#, c-format
msgid "Argument 'by' must have unique column names for grouping."
msgstr "Argumento 'by' deve ter nomes de colunas únicos para agrupamento."

#: groupingsets.R:57
#, c-format
msgid "Argument 'sets' must be a list of character vectors."
msgstr "Argumento 'sets' deve ser uma lista de vetores de caracteres."

#: groupingsets.R:62
#, c-format
msgid ""
"All columns used in 'sets' argument must be in 'by' too. Columns used in "
"'sets' but not present in 'by': %s"
msgstr ""
"Todas as colunas usadas no argumento 'sets' também devem estar em 'by'. "
"Colunas usadas em 'sets', mas não presentes em 'by': %s"

#: groupingsets.R:64
#, c-format
msgid ""
"When using `id=TRUE` the 'x' data.table must not have a column named "
"'grouping'."
msgstr ""
"Ao usar `id=TRUE`, o data.table 'x' não deve ter uma coluna chamada "
"'grouping'."

#: groupingsets.R:66
#, c-format
msgid ""
"Character vectors in 'sets' list must not have duplicated column names "
"within a single grouping set."
msgstr ""
"Vetores de caracteres na lista 'sets' não devem ter nomes de colunas "
"duplicados dentro de um único conjunto de agrupamento."

#: groupingsets.R:68
#, c-format
msgid ""
"'sets' contains a duplicate (i.e., equivalent up to sorting) element at "
"index %d; as such, there will be duplicate rows in the output -- note that "
"grouping by A,B and B,A will produce the same aggregations. Use "
"`sets=unique(lapply(sets, sort))` to eliminate duplicates."
msgstr ""
"'sets' contém um elemento duplicado (isto é, equivalente até a ordenação) no "
"índice %d; assim, haverá linhas duplicadas na saída -- note que agrupar por "
"A,B e B,A produzirá as mesmas agregações. Use `sets=unique(lapply(sets, "
"sort))` para eliminar duplicados."

#: groupingsets.R:73
#, c-format
msgid ""
"Expression passed to grouping sets function must not update by reference. "
"Use ':=' on results of your grouping function."
msgstr ""
"Expressão passada para a função de conjuntos de agrupamento não deve "
"atualizar por referência. Use ':=' nos resultados da sua função de "
"agrupamento."

#: groupingsets.R:80
#, c-format
msgid ""
"When using `id=TRUE` the 'j' expression must not evaluate to a column named "
"'grouping'."
msgstr ""
"Ao usar `id=TRUE`, a expressão 'j' não deve avaliar para uma coluna chamada "
"'grouping'."

#: groupingsets.R:82
#, c-format
msgid ""
"There exists duplicated column names in the results, ensure the column "
"passed/evaluated in `j` and those in `by` are not overlapping."
msgstr ""
"Existem nomes de colunas duplicados nos resultados, certifique-se de que a "
"coluna passada/avaliada em `j` e as em `by` não se sobreponham."

#: groupingsets.R:92
#, c-format
msgid ""
"Using integer64 class columns require to have 'bit64' package installed."
msgstr ""
"Utilizando colunas da classe integer64 requer a instalação do pacote 'bit64'."

#: last.R:38 last.R:79
#, c-format
msgid ""
"'xts' class passed to %s function but 'xts' is not available, you should "
"have 'xts' installed already"
msgstr ""
"classe 'xts' foi passada para a função %s, mas 'xts' não está disponível. "
"Você deveria já ter 'xts' instalado"

#: merge.R:4
#, c-format
msgid "Argument 'sort' should be logical TRUE/FALSE"
msgstr "Argumento 'sort' deve ser lógico TRUE/FALSE"

#: merge.R:6
#, c-format
msgid "Argument 'no.dups' should be logical TRUE/FALSE"
msgstr "Argumento 'no.dups' deve ser lógico TRUE/FALSE"

#: merge.R:18
#, c-format
msgid "Neither of the input data.tables to join have columns."
msgstr "Nenhuma das data.tables de entrada para junção tem colunas."

#: merge.R:20 merge.R:22
#, c-format
msgid "Input data.table '%s' has no columns."
msgstr "data.table de entrada '%s' não tem colunas."

#: merge.R:31
#, c-format
msgid "`by.x` and `by.y` must be of same length."
msgstr "`by.x` e `by.y` devem ter o mesmo comprimento."

#: merge.R:33
#, c-format
msgid "Supplied both `by` and `by.x/by.y`. `by` argument will be ignored."
msgstr "Fornecidos ambos `by` e `by.x/by.y`. Argumento `by` será ignorado."

#: merge.R:36
#, c-format
msgid "A non-empty vector of column names is required for `by.x` and `by.y`."
msgstr ""
"Um vetor não vazio de nomes de colunas é necessário para `by.x` e `by.y`."

#: merge.R:38
#, c-format
msgid "Elements listed in `by.x` must be valid column names in x."
msgstr "Elementos listados em `by.x` devem ser nomes de colunas válidos em x."

#: merge.R:40
#, c-format
msgid "Elements listed in `by.y` must be valid column names in y."
msgstr "Elementos listados em `by.y` devem ser nomes de colunas válidos em y."

#: merge.R:51
#, c-format
msgid "A non-empty vector of column names for `by` is required."
msgstr "É necessário um vetor não vazio de nomes de colunas para `by`."

#: merge.R:53
#, c-format
msgid "Elements listed in `by` must be valid column names in x and y"
msgstr ""
"Os elementos listados em `by` devem ser nomes de colunas válidos em x e y."

#: merge.R:61
#, c-format
msgid "Unknown argument '%s' has been passed."
msgstr "Argumento desconhecido '%s' foi passado."

#: merge.R:64
#, c-format
msgid "Passed %d unknown and unnamed arguments."
msgstr "Passado %d argumentos desconhecidos e sem nome."

#: merge.R:114
#, c-format
msgid "column names %s are duplicated in the result"
msgstr "nomes das colunas %s estão duplicados no resultado"

#: onAttach.R:23
#, c-format
msgid ""
"data.table %s IN DEVELOPMENT built %s%s using %d threads (see ?getDTthreads)."
msgstr ""
"data.table %s EM DESENVOLVIMENTO construído %s%s usando %d threads (veja ?"
"getDTthreads)."

#: onAttach.R:25
#, c-format
msgid "data.table %s using %d threads (see ?getDTthreads)."
msgstr "data.table %s usando %d threads (veja ?getDTthreads)."

#: onAttach.R:26
#, c-format
msgid "Latest news: r-datatable.com"
msgstr "Últimas notícias: r-datatable.com"

#: onAttach.R:27
msgid "TRANSLATION CHECK"
msgstr "VERIFICAÇÃO DE TRADUÇÃO"

#: onAttach.R:28
#, c-format
msgid ""
"**********\n"
"Running data.table in English; package support is available in English only. "
"When searching for online help, be sure to also check for the English error "
"message. This can be obtained by looking at the po/R-<locale>.po and po/"
"<locale>.po files in the package source, where the native language and "
"English error messages can be found side-by-side\n"
"**********"
msgstr ""
"**********\n"
"Executando data.table em português; o suporte ao pacote está disponível "
"apenas em inglês. Ao procurar ajuda online, certifique-se de verificar "
"também a mensagem de erro em inglês. Isso pode ser obtido examinando os "
"arquivos po/R-pt_BR.po e po/pt_BR.po no código-fonte do pacote, onde as "
"mensagens de erro no idioma nativo e em inglês podem ser encontradas lado a "
"lado.\n"
"**********"

#: onAttach.R:30
#, c-format
msgid ""
"**********\n"
"This development version of data.table was built more than 4 weeks ago. "
"Please update: data.table::update_dev_pkg()\n"
"**********"
msgstr ""
"**********\n"
"Esta versão de desenvolvimento do data.table foi construída há mais de 4 "
"semanas. Por favor, atualize: data.table::update_dev_pkg()\n"
"**********"

#: onAttach.R:32
#, c-format
msgid ""
"**********\n"
"This installation of data.table has not detected OpenMP support. It should "
"still work but in single-threaded mode."
msgstr ""
"**********\n"
"Esta instalação do data.table não detectou suporte ao OpenMP. Ainda deve "
"funcionar, mas em modo de single-threaded."

#: onAttach.R:34
#, c-format
msgid ""
"This is a Mac. Please read https://mac.r-project.org/openmp/. Please engage "
"with Apple and ask them for support. Check r-datatable.com for updates, and "
"our Mac instructions here: https://github.com/Rdatatable/data.table/wiki/"
"Installation. After several years of many reports of installation problems "
"on Mac, it's time to gingerly point out that there have been no similar "
"problems on Windows or Linux.\n"
"**********"
msgstr ""
"Este é um Mac. Por favor, leia https://mac.r-project.org/openmp/. Por favor, "
"envolva-se com a Apple e peça suporte. Verifique r-datatable.com para "
"atualizações e nossas instruções para Mac aqui: https://github.com/"
"Rdatatable/data.table/wiki/Installation. Após vários anos de muitos relatos "
"de problemas de instalação no Mac, é hora de apontar cuidadosamente que não "
"houve problemas semelhantes no Windows ou Linux.\n"
"**********"

#: onAttach.R:36
#, c-format
msgid ""
"This is %s. This warning should not normally occur on Windows or Linux where "
"OpenMP is turned on by data.table's configure script by passing -fopenmp to "
"the compiler. If you see this warning on Windows or Linux, please file a "
"GitHub issue.\n"
"**********"
msgstr ""
"Este é %s. Este aviso normalmente não deve ocorrer no Windows ou Linux, onde "
"o OpenMP é ativado pelo script de configuração do data.table passando -"
"fopenmp para o compilador. Se você vir este aviso no Windows ou Linux, por "
"favor, relate no rastreador de problemas no GitHub.\n"
"**********"

#: onAttach.R:40
#, c-format
msgid ""
"**********\n"
"This data.table installation was compiled for R < 3.4.0 (Apr 2017) and is "
"known to leak memory. Please upgrade R and reinstall data.table to fix the "
"leak. Maintaining and testing code branches to support very old versions "
"increases development time so please do upgrade R. We intend to bump data."
"table's dependency from 8 year old R 3.1.0 (Apr 2014) to 5 year old R 3.4.0 "
"(Apr 2017).\n"
"**********"
msgstr ""
"**********\n"
"Esta instalação do data.table foi compilada para o R < 3.4.0 (Abr 2017) e é "
"conhecida por vazar memória. Por favor, atualize o R e reinstale o data."
"table para corrigir o vazamento. Manter e testar ramificações de código para "
"suportar versões muito antigas aumenta o tempo de desenvolvimento, então, "
"por favor, atualize o R. Pretendemos aumentar a dependência do data.table de "
"R 3.1.0 (Abr 2014), de 8 anos, para R 3.4.0 (Abr 2017), de 5 anos.\n"
"**********"

#: onLoad.R:9
#, c-format
msgid ""
"Option 'datatable.nomatch' is defined but is now ignored. Please see note 11 "
"in v1.12.4 NEWS (Oct 2019), and note 14 in v1.14.2."
msgstr ""
"Opção 'datatable.nomatch' está definida, mas agora é ignorada. Por favor, "
"veja a nota 11 nas notícias de v1.12.4 (Outubro de 2019) e a nota 14 em "
"v1.14.2."

#: onLoad.R:27
#, c-format
msgid ""
"The data_table.%s version (%s) does not match the package (%s). Please close "
"all R sessions to release the old %s and reinstall data.table in a fresh R "
"session. The root cause is that R's package installer can in some "
"unconfirmed circumstances leave a package in a state that is apparently "
"functional but where new R code is calling old C code silently: https://bugs."
"r-project.org/bugzilla/show_bug.cgi?id=17478. Once a package is in this "
"mismatch state it may produce wrong results silently until you next upgrade "
"the package. Please help by adding precise circumstances to 17478 to move "
"the status to confirmed. This mismatch between R and C code can happen with "
"any package not just data.table. It is just that data.table has added this "
"check."
msgstr ""
"O data_table.%s versão (%s) não corresponde ao pacote (%s). Por favor, feche "
"todas as sessões do R para liberar a antiga %s e reinstale o data.table em "
"uma nova sessão do R. A causa raiz é que o instalador de pacotes do R pode, "
"em algumas circunstâncias não confirmadas, deixar um pacote em um estado "
"aparentemente funcional, mas onde o novo código R está chamando "
"silenciosamente o código C antigo: https://bugs.r-project.org/bugzilla/"
"show_bug.cgi?id=17478. Uma vez que um pacote esteja neste estado de "
"incompatibilidade, ele pode produzir resultados errados silenciosamente até "
"que você atualize o pacote novamente. Por favor, ajude adicionando "
"circunstâncias precisas ao 17478 para mover o status para confirmado. Essa "
"incompatibilidade entre o código R e C pode acontecer com qualquer pacote, "
"não apenas com o data.table. É apenas que o data.table adicionou essa "
"verificação."

#: onLoad.R:31
#, c-format
msgid ""
"This is R %s but data.table has been installed using R %s. The major version "
"must match. Please reinstall data.table."
msgstr ""
"Este é o R %s, mas o data.table foi instalado usando o R %s. A versão "
"principal deve corresponder. Por favor, reinstale o data.table."

#: onLoad.R:98
#, c-format
msgid "Unexpected base R behaviour: list(x) has copied x"
msgstr "Comportamento inesperado do R base: list(x) copiou x"

#: onLoad.R:106
#, c-format
msgid "Unexpected base R behaviour: names<- has copied column contents"
msgstr ""
"Comportamento inesperado do R base: names<- copiou o conteúdo da coluna"

#: onLoad.R:116
#, c-format
msgid ""
"Unexpected base R behaviour: DF[2,2]<- did not copy column 2 which was "
"assigned to"
msgstr ""
"Comportamento inesperado do R base: DF[2,2]<- não copiou a coluna 2 que foi "
"atribuída"

#: onLoad.R:117
#, c-format
msgid ""
"Unexpected base R behaviour: DF[2,2]<- copied the first column which was not "
"assigned to, too"
msgstr ""
"Comportamento inesperado do R base: DF[2,2]<- copiou também a primeira "
"coluna, que não foi atribuída"

#: onLoad.R:119
#, c-format
msgid "Unexpected base R behaviour: DF[2,2]<- has not copied address(DF)"
msgstr "Comportamento inesperado do R base: DF[2,2]<- não copiou address(DF)"

#: openmp-utils.R:3
#, c-format
msgid "Provide either threads= or percent= but not both"
msgstr "Forneça threads= ou percent=, mas não ambos"

#: openmp-utils.R:4
#, c-format
msgid "percent= is provided but is length %d"
msgstr "percent= foi fornecido, mas tem comprimento %d"

#: openmp-utils.R:6
#, c-format
msgid "percent==%d but should be a number between 2 and 100"
msgstr "percent==%d, mas deveria ser um número entre 2 e 100"

#: print.data.table.R:19
#, c-format
msgid "Valid options for col.names are 'auto', 'top', and 'none'"
msgstr "As opções válidas para col.names são 'auto', 'top', e 'none'"

#: print.data.table.R:21
#, c-format
msgid "Valid options for trunc.cols are TRUE and FALSE"
msgstr "Opções válidas para trunc.cols são TRUE e FALSE"

#: print.data.table.R:23
#, c-format
msgid "Column classes will be suppressed when col.names is 'none'"
msgstr "As classes de colunas serão suprimidas quando col.names for 'none'"

#: print.data.table.R:156
#, c-format
msgid ""
"Internal structure doesn't seem to be a list. Possibly corrupt data.table."
msgstr ""
"A estrutura interna não parece ser uma lista. Possivelmente data.table "
"corrompida."

#: programming.R:14 programming.R:40
#, c-format
msgid "'x' must be a list"
msgstr "'x' deve ser uma lista"

#: programming.R:22
#, c-format
msgid ""
"Character objects provided in the input are not scalar objects, if you need "
"them as character vector rather than a name, then wrap each into 'I' call: %s"
msgstr ""
"Objetos de caracteres fornecidos na entrada não são objetos escalares, se "
"você precisar deles como vetor de caracteres em vez de um nome, então "
"envolva cada um 'I' na chamada: %s"

#: programming.R:50
#, c-format
msgid "'env' must not be missing"
msgstr "'env' não deve estar ausente"

#: programming.R:56
#, c-format
msgid "'env' must be a list or an environment"
msgstr "'env' deve ser uma lista ou um ambiente"

#: programming.R:63
#, c-format
msgid "'env' argument does not have names"
msgstr "argumento 'env' não tem nomes"

#: programming.R:65
#, c-format
msgid "'env' argument has zero char names"
msgstr "argumento 'env' tem zero nomes de caracteres"

#: programming.R:67
#, c-format
msgid "'env' argument has NA names"
msgstr "argumento 'env' tem nomes NA"

#: programming.R:69
#, c-format
msgid "'env' argument has duplicated names"
msgstr "argumento 'env' tem nomes duplicados"

#: setkey.R:3
#, c-format
msgid ""
"x may no longer be the character name of the data.table. The possibility was "
"undocumented and has been removed."
msgstr ""
"x pode não ser mais o nome da data.table do tipo caractere. A possibilidade "
"não era documentada e foi removida."

#: setkey.R:23
#, c-format
msgid ""
"key(x)<-value is deprecated and not supported. Please change to use setkey() "
"with perhaps copy(). Has been warning since 2012."
msgstr ""
"key(x)<-value está obsoleto e não é suportado. Por favor, mude para usar "
"setkey() com talvez copy(). Tem sido um aviso desde 2012."

#: setkey.R:39
#, c-format
msgid "x is not a data.table"
msgstr "x não é uma data.table"

#: setkey.R:40
#, c-format
msgid ""
"cols is not a character vector. Please see further information in ?setkey."
msgstr ""
"cols não é um vetor de caracteres. Por favor, veja mais informações em ?"
"setkey."

#: setkey.R:41
#, c-format
msgid ""
"Setting a physical key on .SD is reserved for possible future use; to modify "
"the original data's order by group. Try setindex() instead. Or, set*(copy(."
"SD)) as a (slow) last resort."
msgstr ""
"Definir uma chave física em .SD está reservado para possível uso futuro; "
"para modificar a ordem dos dados originais por grupo. Tente setindex() em "
"vez disso. Ou, set*(copy(.SD)) como último recurso (lento)."

#: setkey.R:43
#, c-format
msgid ""
"cols is a character vector of zero length. Removed the key, but use NULL "
"instead, or wrap with suppressWarnings() to avoid this warning."
msgstr ""
"cols é um vetor de caracteres de comprimento zero. A chave foi removida, mas "
"use NULL em vez disso, ou envolva com suppressWarnings() para evitar este "
"aviso."

#: setkey.R:47
#, c-format
msgid "cols is the empty string. Use NULL to remove the key."
msgstr "cols é uma string vazia. Use NULL para remover a chave."

#: setkey.R:48 setkey.R:262
#, c-format
msgid "cols contains some blanks."
msgstr "cols contém alguns espaços em branco."

#: setkey.R:51 setkey.R:266
#, c-format
msgid "some columns are not in the data.table: %s"
msgstr "algumas colunas não estão na data.table: %s"

#: setkey.R:59 setkey.R:267
#, c-format
msgid ""
"x contains a column called '.xi'. Conflicts with internal use by data.table."
msgstr ""
"x contém uma coluna chamada '.xi'. Conflita com o uso interno do data.table."

#: setkey.R:62
#, c-format
msgid ""
"Column '%s' is type '%s' which is not supported as a key column type, "
"currently."
msgstr ""
"Coluna '%s' é do tipo '%s', que atualmente não é suportado como tipo de "
"coluna chave."

#: setkey.R:137
#, c-format
msgid "x is vector but 'by' is supplied"
msgstr "x é um vetor, mas 'by' foi fornecido"

#: setkey.R:153
#, c-format
msgid "x is a single vector, non-NULL 'by' doesn't make sense"
msgstr "x é um único vetor, 'by' não NULL não faz sentido."

#: setkey.R:184
#, c-format
msgid "Attempting to order a 0-column data.table or data.frame."
msgstr "Tentativa de ordenar uma data.table ou um data.frame com 0 colunas."

#: setkey.R:189
#, c-format
msgid ""
"The first item passed to [f]order is a plain list but there are more items. "
"It should be a data.table or data.frame."
msgstr ""
"O primeiro item passado para [f]order é uma lista simples, mas há mais "
"itens. Deve ser uma data.table ou um data.frame."

#: setkey.R:206
#, c-format
msgid "Internal code should not be being called on type double"
msgstr "Código interno não deveria estar sendo chamado em um tipo double"

#: setkey.R:214
#, c-format
msgid ""
"Input is not a vector of type double. New parallel sort has only been done "
"for double vectors so far. Using one thread."
msgstr ""
"Entrada não é um vetor do tipo double. A nova ordenação paralela só foi "
"feita para vetores do tipo double até agora. Usando uma thread."

#: setkey.R:215
#, c-format
msgid ""
"New parallel sort has not been implemented for decreasing=TRUE so far. Using "
"one thread."
msgstr ""
"A nova ordenação paralela ainda não foi implementada para decreasing=TRUE "
"até o momento. Usando uma thread."

#: setkey.R:216
#, c-format
msgid ""
"New parallel sort has not been implemented for vectors containing NA values "
"so far. Using one thread."
msgstr ""
"A nova ordenação paralela ainda não foi implementada para vetores contendo "
"valores NA até o momento. Usando uma thread."

#: setkey.R:228 setkey.R:254
#, c-format
msgid "x must be a data.frame or data.table"
msgstr "x deve ser uma data.frame ou um data.table"

#: setkey.R:256
#, c-format
msgid "na.last must be logical TRUE/FALSE"
msgstr "na.last deve ser lógico TRUE/FALSE"

#: setkey.R:257
#, c-format
msgid ""
"cols is not a character vector. Please see further information in ?setorder."
msgstr ""
"cols não é um vetor de caracteres. Por favor, veja mais informações em ?"
"setorder."

#: setkey.R:259
#, c-format
msgid ""
"cols is a character vector of zero length. Use NULL instead, or wrap with "
"suppressWarnings() to avoid this warning."
msgstr ""
"cols é um vetor de caracteres de comprimento zero. Use NULL em vez disso, ou "
"envolva com suppressWarnings() para evitar este aviso."

#: setkey.R:270
#, c-format
msgid "Column '%s' is type '%s' which is not supported for ordering currently."
msgstr ""
"Coluna '%s' é do tipo '%s', que atualmente não é suportado para ordenação."

#: setkey.R:314
#, c-format
msgid ""
"'sorted' is TRUE but element %d is non-atomic, which can't be sorted; try "
"setting sorted = FALSE"
msgstr ""
"'sorted' é TRUE, mas o elemento %d é não atômico, o que não pode ser "
"ordenado; tente definir sorted = FALSE"

#: setkey.R:329
#, c-format
msgid ""
"Cross product of elements provided to CJ() would result in %.0f rows which "
"exceeds .Machine$integer.max == %d"
msgstr ""
"Produto cruzado dos elementos fornecidos a CJ() resultaria em %.0f linhas "
"que excedem .Machine$integer.max == %d"

#: setops.R:3 setops.R:40
#, c-format
msgid "x and y must both be data.tables"
msgstr "x e y devem ser ambos data.tables"

#: setops.R:9
#, c-format
msgid "length(by.x) != length(by.y)"
msgstr "length(by.x) != length(by.y)"

#: setops.R:17
#, c-format
msgid ""
"When x's column ('%s') is character, the corresponding column in y ('%s') "
"should be factor or character, but found incompatible type '%s'."
msgstr ""
"Quando a coluna de x ('%s') é do tipo caractere, a coluna correspondente em "
"y ('%s') deve ser do tipo fator ou caractere, mas foi encontrado um tipo "
"incompatível '%s'."

#: setops.R:19
#, c-format
msgid ""
"When x's column ('%s') is factor, the corresponding column in y ('%s') "
"should be character or factor, but found incompatible type '%s'."
msgstr ""
"Quando a coluna de x ('%s') é do tipo fator, a coluna correspondente em y "
"('%s') deve ser do tipo caractere ou fator, mas foi encontrado um tipo "
"incompatível '%s'."

#: setops.R:21
#, c-format
msgid ""
"When x's column ('%s') is integer or numeric, the corresponding column in y "
"('%s') can not be character or logical types, but found incompatible type "
"'%s'."
msgstr ""
"Quando a coluna de x ('%s') é do tipo inteiro ou numérico, a coluna "
"correspondente em y ('%s') não pode ser do tipo caractere ou lógico, mas foi "
"encontrado um tipo incompatível '%s'."

#: setops.R:39
#, c-format
msgid "argument 'all' should be logical of length one"
msgstr "argumento 'all' deve ser lógico de comprimento um"

#: setops.R:41
#, c-format
msgid "x and y must have the same column names"
msgstr "x e y devem ter os mesmos nomes de colunas"

#: setops.R:42
#, c-format
msgid "x and y must have the same column order"
msgstr "x e y devem ter a mesma ordem de colunas"

#: setops.R:45
#, c-format
msgid "unsupported column type(s) found in x or y: %s"
msgstr "tipo(s) de coluna não suportados encontrados em x ou y: %s"

#: setops.R:53
#, c-format
msgid "Item %d of x is '%s' but the corresponding item of y is '%s'."
msgstr "Item %d de x é '%s', mas o item correspondente de y é '%s'."

#: setops.R:55
#, c-format
msgid "None of the datasets should contain a column named '.seqn'"
msgstr "Nenhum dos conjuntos de dados deve conter uma coluna chamada '.seqn'"

#: setops.R:159 setops.R:170
#, c-format
msgid "Datasets have different %s. 'target': %s. 'current': %s."
msgstr "Conjuntos de dados têm diferente %s. 'target': %s. 'current': %s."

#: setops.R:161 setops.R:162
#, c-format
msgid "has no key"
msgstr "não tem chave"

#: setops.R:172 setops.R:173
#, c-format
msgid "has no index"
msgstr "não tem índice"

#: setops.R:190
#, c-format
msgid "None of the datasets to compare should contain a column named '.seqn'"
msgstr ""
"Nenhum dos conjuntos de dados a serem comparados deve conter uma coluna "
"chamada '.seqn'"

#: setops.R:193
#, c-format
msgid ""
"Datasets to compare with 'ignore.row.order' must not have unsupported column "
"types: %s"
msgstr ""
"Conjuntos de dados a serem comparados com 'ignore.row.order' não devem ter "
"tipos de colunas não suportados:%s"

#: setops.R:195
#, c-format
msgid ""
"Argument 'tolerance' was forced to lowest accepted value `sqrt(."
"Machine$double.eps)` from provided %s"
msgstr ""
"Argumento 'tolerance' foi forçado ao valor mínimo aceito de `sqrt(."
"Machine$double.eps)` a partir do fornecido %s"

#: setops.R:208
#, c-format
msgid ""
"Duplicate rows in datasets, numeric columns and ignore.row.order cannot be "
"used with non 0 tolerance argument"
msgstr ""
"Linhas duplicadas nos conjuntos de dados, colunas numéricas e ignore.row."
"order não podem ser usadas com argumento de tolerância diferente de 0"

#: setops.R:222
#, c-format
msgid ""
"Factor columns and ignore.row.order cannot be used with non 0 tolerance "
"argument"
msgstr ""
"Colunas de fator e ignore.row.order não podem ser usadas com argumento de "
"tolerância diferente de 0"

#: shift.R:3
#, c-format
msgid "Provided argument fill=%s will be ignored since type='cyclic'."
msgstr "O argumento fornecido fill=%s será ignorado, pois type='cyclic'."

#: tables.R:46
#, c-format
msgid "order.col='%s' not a column name of info"
msgstr "order.col='%s' não é um nome de coluna de info"

#: test.data.table.R:17
#, c-format
msgid "data.table package is loaded. Unload or start a fresh R session."
msgstr ""
"Pacote data.table está carregado. Descarregue ou inicie uma nova sessão do R."

#: test.data.table.R:33
#, c-format
msgid ""
"script must end with '.Rraw'. If a file ending '.Rraw.bz2' exists, that will "
"be found and used."
msgstr ""
"script deve terminar com '.Rraw'. Se existir um arquivo terminando em '.Rraw."
"bz2', ele será encontrado e usado."

#: test.data.table.R:63
#, c-format
msgid "Neither %s nor %s exist in %s"
msgstr "Nem %s ou %sexistem em %s"

#: test.data.table.R:118
msgid "object '%s' not found"
msgstr "objeto '%s' não encontrado"

#: test.data.table.R:142
#, c-format
msgid ""
"memtest intended for Linux. Step through data.table:::rss() to see what went "
"wrong."
msgstr ""
"memtest destinado para Linux. Percorra data.table:::rss() para ver o que deu "
"errado."

#: test.data.table.R:196
#, c-format
msgid "Attempt to subset to %d tests matching '%s' failed, running full suite."
msgstr ""
"A tentativa de obter subconjunto de %d testes correspondendo a '%s' falhou, "
"executando a suíte completa."

#: test.data.table.R:245
#, c-format
msgid "Failed in %s after test %s before the next test() call in %s"
msgstr "Falhou em %s após o teste %s antes da próxima chamada de test() em %s"

#: test.data.table.R:255
#, c-format
msgid "%d error(s) out of %d. Search %s for test number(s) %s. Duration: %s."
msgstr "%d erro(s) de %d. Pesquise %s por número(s) de teste %s. Duração: %s."

#: test.data.table.R:268
#, c-format
msgid "Timings count mismatch: %d vs %d"
msgstr "Contagem de tempos não corresponde: %d vs %d"

#: test.data.table.R:399
#, c-format
msgid ""
"Test %s is invalid: when error= is provided it does not make sense to pass y "
"as well"
msgstr ""
"Teste %s é inválido: quando error= é fornecido, não faz sentido passar y "
"também"

#: timetaken.R:3
#, c-format
msgid "Use started.at=proc.time() not Sys.time() (POSIXt and slow)"
msgstr "Use started.at=proc.time(), não Sys.time() (POSIXt and slow)"

#: transpose.R:7
#, c-format
msgid "make.names='%s' not found in names of input"
msgstr "make.names='%s' não encontrado nos nomes da entrada"

#: transpose.R:12
#, c-format
msgid "make.names=%d is out of range [1,ncol=%d]"
msgstr "make.names=%d está fora do intervalo [1, ncol=%d]"

#: transpose.R:28
#, c-format
msgid "'names' must be TRUE/FALSE or a character vector."
msgstr "'names' deve ser TRUE/FALSE ou um vetor de caracteres."

#: transpose.R:34
#, c-format
msgid "'keep' should contain integer values between %d and %d."
msgstr "'keep' deve conter valores inteiros entre %d e %d."

#: transpose.R:51
#, c-format
msgid "The argument 'type.convert' does not support empty list."
msgstr "O argumento 'type.convert' não suporta lista vazia."

#: transpose.R:57
#, c-format
msgid ""
"When the argument 'type.convert' contains an unnamed element, it is expected "
"to be the last element and should be a function. More than one unnamed "
"element is not allowed unless all elements are functions with length equal "
"to %d (the length of the transpose list or 'keep' argument if it is "
"specified)."
msgstr ""
"Quando o argumento 'type.convert' contém um elemento não nomeado, espera-se "
"que seja o último elemento e deve ser uma função. Mais de um elemento não "
"nomeado não é permitido, a menos que todos os elementos sejam funções com "
"comprimento igual a %d (o comprimento da lista de transposição ou argumento "
"'keep', se especificado)."

#: transpose.R:66
#, c-format
msgid ""
"When the argument 'type.convert' contains transpose list indices, it should "
"be a named list of non-missing integer values (with no duplicate) except the "
"last element that should be unnamed if it is a function."
msgstr ""
"Quando o argumento 'type.convert' contém índices de lista de transposição, "
"ele deve ser uma lista nomeada de valores inteiros não ausentes (sem "
"duplicatas), exceto o último elemento, que deve ser não nomeado se for uma "
"função."

#: transpose.R:68
#, c-format
msgid ""
"When the argument 'type.convert' contains transpose list indices, they "
"should be integer values contained in the argument 'keep' (if it is "
"specified) or be between %d and %d (if it is not). But '%s' is/are not "
"contained in '%s'."
msgstr ""
"Quando o argumento 'type.convert' contém índices de lista de transposição, "
"eles devem ser valores inteiros contidos no argumento 'keep' (se "
"especificado) ou estar entre %d e %d (se não especificado). Mas '%s' não "
"está(ão) contido(s) em '%s'."

#: transpose.R:74
#, c-format
msgid ""
"In the argument 'type.convert', '%s' was ignored because all elements in the "
"transpose list or elements corresponding to indices specified in the 'keep' "
"argument have already been converted."
msgstr ""
"No argumento 'type.convert', '%s' foi ignorado porque todos os elementos na "
"lista de transposição ou elementos correspondentes aos índices especificados "
"no argumento 'keep' já foram convertidos."

#: transpose.R:83
#, c-format
msgid ""
"The argument 'type.convert' should be TRUE/FALSE, a function, a list of "
"functions, or a named list of pairs 'fun=indices' with optionally one "
"unnamed element (a function) but an object of type '%s' was provided."
msgstr ""
"O argumento 'type.convert' deve ser TRUE/FALSE, uma função, uma lista de "
"funções ou uma lista nomeada de pares 'fun=indices' com opcionalmente um "
"elemento não nomeado (uma função), mas foi fornecido um objeto do tipo '%s'."

#: transpose.R:88
#, c-format
msgid "length(names) (= %d) is not equal to length(%s) (= %d)."
msgstr "length(names) (= %d) não é igual a length(%s) (= %d)."

#: uniqlist.R:11
#, c-format
msgid "l not type list"
msgstr "l não é do tipo lista"

#: utils.R:18
#, c-format
msgid "Argument 'nan' must be length 1"
msgstr "Argumento 'nan' deve ter comprimento 1"

#: utils.R:21
#, c-format
msgid "Argument 'nan' must be NA or NaN"
msgstr "Argumento 'nan' deve ser NA ou NaN"

#: utils.R:25
msgid "Internal error in"
msgstr "Erro interno in"

#: utils.R:28
msgid "Please report to the data.table issues tracker."
msgstr ""

#: utils.R:57 utils.R:66
#, c-format
msgid "x not boolean"
msgstr "x não é booleano"

#: utils.R:77
#, c-format
msgid ""
"Some columns are type 'integer64' but package bit64 is not installed. Those "
"columns will print as strange looking floating point data. There is no need "
"to reload the data. Simply install.packages('bit64') to obtain the integer64 "
"print method and print the data again."
msgstr ""
"Algumas colunas são do tipo 'integer64', mas o pacote bit64 não está "
"instalado. Essas colunas serão exibidas como estranhos dados de ponto "
"flutuante. Não há necessidade de recarregar os dados. Simplesmente use "
"install.packages('bit64') para obter o método de impressão de integer64 e "
"imprima os dados novamente."

#: xts.R:3
#, c-format
msgid "keep.rownames must be length 1"
msgstr "keep.rownames deve ter comprimento 1"

#: xts.R:4
#, c-format
msgid "keep.rownames must not be NA"
msgstr "keep.rownames não deve ser NA"

#: xts.R:10
#, c-format
msgid ""
"Input xts object should not have '%s' column because it would result in "
"duplicate column names. Rename '%s' column in xts or use `keep.rownames` to "
"change the index column name."
msgstr ""
"O objeto xts de entrada não deve ter a coluna '%s' porque resultaria em "
"nomes de colunas duplicados. Renomeie a coluna '%s' no xts ou use `keep."
"rownames` para alterar o nome da coluna de índice."

#: xts.R:20
#, c-format
msgid ""
"data.table must have a time based column in first position, use "
"`setcolorder` function to change the order, or see ?timeBased for supported "
"types"
msgstr ""
"data.table deve ter uma coluna baseada em tempo na primeira posição, use a "
"função `setcolorder` para alterar a ordem, ou veja ?timeBased para os tipos "
"suportados."

#: xts.R:24
#, c-format
msgid "Following columns are not numeric and will be omitted: %s"
msgstr "As seguintes colunas não são numéricas e serão omitidas: %s"

#: print.data.table.R:53
msgid "Index: %s\n"
msgid_plural "Indices: %s\n"
msgstr[0] "Índice: %s\n"
msgstr[1] "Índices: %s\n"

#, c-format
#~ msgid ""
#~ "strptime() usage detected and wrapped with as.POSIXct(). This is to "
#~ "minimize the chance of assigning POSIXlt columns, which use 40+ bytes to "
#~ "store one date (versus 8 for POSIXct). Use as.POSIXct() (which will call "
#~ "strptime() as needed internally) to avoid this warning."
#~ msgstr ""
#~ "Uso de strptime() detectado e agrupado com as.POSIXct(). Isso minimiza a "
#~ "chance de atribuir colunas POSIXlt, que usam 40 ou mais bytes para "
#~ "armazenar uma data (contra 8 para POSIXct). Use as.POSIXct() (que chamará "
#~ "strptime() conforme necessário internamente) para evitar esse aviso."

#, c-format
#~ msgid ""
#~ "J() called outside of [.data.table. J() is only intended for use in i."
#~ msgstr "J() chamado fora de [.data.table. J() destina-se para usar no i."

#, c-format
#~ msgid ""
#~ ".() called outside of [.data.table. .() is only intended as an alias for "
#~ "list() inside DT[...]."
#~ msgstr ""
#~ ".() chamado fora de [.data.table. .() destina-se como um alias para "
#~ "list() dentr de DT[...]."

#, c-format
#~ msgid ""
#~ "Aggregating function(s) should take vector inputs and return a single "
#~ "value (length=1). However, function(s) returns length!=1. This value will "
#~ "have to be used to fill any missing combinations, and therefore must be "
#~ "length=1. Either override by setting the 'fill' argument explicitly or "
#~ "modify your function to handle this case appropriately."
#~ msgstr ""
#~ "Funções de agregação deveriam receber vetores e retornar valores únicos "
#~ "(comprimento=1). No entanto, o retorno da(s) função(ões) tem comprimento!"
#~ "=1. Esse valor terá que ser usado para preencher quaisquer combinações "
#~ "faltantes, e portanto deve ter comprimento=1. Ou contorne isso definindo "
#~ "o argumento 'fill' explicitamente, ou modifique sua função para lidar com "
#~ "esse caso apropriadamente."
