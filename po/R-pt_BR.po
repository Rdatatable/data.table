#
# Translators:
# Italo Santos <ids37@nau.edu>, 2024.
# Leonardo Fontenelle <leonardof@leonardof.med.br>, 2024-2025.
# Rafael Fontenelle <rffontenelle@gmail.com>, 2024-2025.
#
msgid ""
msgstr ""
"Project-Id-Version: data.table 1.15.99\n"
"POT-Creation-Date: 2025-02-02 23:58-0800\n"
"PO-Revision-Date: 2025-02-14 00:52-0300\n"
"Last-Translator: Rafael Fontenelle <rffontenelle@gmail.com>\n"
"Language-Team: Brazilian Portuguese\n"
"Language: pt_BR\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=2; plural=(n > 1)\n"
"X-Generator: Gtranslator 47.1\n"

#: AllS4.R:2
#, c-format
msgid "data.table package loaded. When developing don't load package"
msgstr "Pacote data.table carregado. Ao desenvolver, não carregue o pacote"

#: IDateTime.R:107
#, c-format
msgid "binary + is not defined for \"IDate\" objects"
msgstr "binário + não está definida para objetos \"IDate\""

#: IDateTime.R:114
#, c-format
msgid "can only subtract from \"IDate\" objects"
msgstr "pode apenas subtrair de objetos \"IDate\""

#: IDateTime.R:119
#, c-format
msgid "unary - is not defined for \"IDate\" objects"
msgstr "unário - não está definido para objetos \"IDate\""

#: IDateTime.R:309
#, c-format
msgid "Valid options for ms are 'truncate', 'nearest', and 'ceil'."
msgstr "Opções válidas para ms são 'truncate', 'nearest', e 'ceil'."

#: as.data.table.R:86
#, c-format
msgid ""
"as.data.table.array method should only be called for arrays with 3+ "
"dimensions; use the matrix method for 2-dimensional arrays"
msgstr ""
"O método as.data.table.array só deve ser chamado para arrays com mais de 3 "
"dimensões ou mais; use o método matrix para arrays de 2 dimensões"

#: as.data.table.R:88
#, c-format
msgid ""
"Argument 'value.name' must be scalar character, non-NA and at least one "
"character"
msgstr ""
"O argumento 'value.name' deve ser um caractere escalar, não-NA e ter pelo "
"menos um caractere"

#: as.data.table.R:90
#, c-format
msgid "Argument 'sorted' must be scalar logical and non-NA"
msgstr "O argumento 'sorted' deve ser lógico escalar e não-NA"

#: as.data.table.R:92
#, c-format
msgid "Argument 'na.rm' must be scalar logical and non-NA"
msgstr "O argumento 'na.rm' deve ser lógico escalar e não-NA"

#: as.data.table.R:94
#, c-format
msgid "Please provide either 'key' or 'sorted', but not both."
msgstr "Favor fornecer ou 'key' ou 'sorted', mas não ambos."

#: as.data.table.R:108
#, c-format
msgid ""
"Argument 'value.name' should not overlap with column names in result: %s"
msgstr ""
"O argumento 'value.name' não deve se sobrepor aos nomes das colunas no "
"resultado: %s"

#: as.data.table.R:140
#, c-format
msgid ""
"POSIXlt column type detected and converted to POSIXct. We do not recommend "
"use of POSIXlt at all because it uses 40 bytes to store one date."
msgstr ""
"Tipo de coluna POSIXlt detectado e convertido em POSIXct. Não recomendamos o "
"uso do POSIXlt porque ele usa 40 bytes para armazenar uma data."

#: as.data.table.R:181
#, c-format
msgid "Item %d has %d rows but longest item has %d; recycled with remainder."
msgstr ""
"O item %d possui %d linhas, mas o item mais longo possui %d; reciclado com o "
"restante."

#: as.data.table.R:196
#, c-format
msgid "A column may not be called .SD. That has special meaning."
msgstr ""
"Uma coluna não pode ser chamada de .SD. Esse nome tem um significado "
"especial."

#: as.data.table.R:210
#, c-format
msgid "class must be length 1"
msgstr "class deve ter comprimento 1"

#: between.R:3
#, c-format
msgid "between has been passed an argument x of type logical"
msgstr "between recebeu um argumento x do tipo lógico"

#: between.R:13 between.R:15
#, c-format
msgid ""
"The 'x' argument of the 'between' function is POSIXct while '%s' was not, "
"coercion to POSIXct failed with: %s"
msgstr ""
"O argumento 'x' da função 'between' é da classe POSIXct enquanto '%s' não "
"era, então a coerção para POSIXct falhou com: %s"

#: between.R:27
#, c-format
msgid ""
"'between' lower= and upper= are both POSIXct but have different tzone "
"attributes: %s. Please align their time zones."
msgstr ""
"lower= e upper= do 'between' são ambos POSIXct, mas possuem atributos tzone "
"diferentes: %s. Alinhe seus fusos horários."

#: between.R:31
#, c-format
msgid ""
"'between' arguments are all POSIXct but have mismatched tzone attributes: "
"%s. The UTC times will be compared."
msgstr ""
"os argumentos de 'between' são todos POSIXct, mas possuem atributos tzone "
"incompatíveis: %s. Os horários UTC serão comparados."

#: between.R:36
#, c-format
msgid "trying to use integer64 class when 'bit64' package is not installed"
msgstr ""
"tentando usar a classe integer64 quando o pacote 'bit64' não está instalado"

#: between.R:47
msgid ""
"optimised between not available for this data type, fallback to slow R "
"routine"
msgstr ""
"between otimizado não disponível para este tipo de dados, retrocedendo para "
"rotina R lenta"

#: between.R:48
#, c-format
msgid ""
"Not yet implemented NAbounds=TRUE for this non-numeric and non-character type"
msgstr ""
"Ainda não implementado NAbounds=TRUE para este tipo não numérico e não "
"caractere"

#: between.R:49
#, c-format
msgid "Some lower>upper for this non-numeric and non-character type"
msgstr "Alguns lower>upper para este tipo não numérico e não caractere"

#: between.R:63
#, c-format
msgid "Perhaps you meant %s?"
msgstr "Talvez você quis dizer %s?"

#: between.R:64
#, c-format
msgid ""
"RHS has length() %d; expecting length 2. %sThe first element should be the "
"lower bound(s); the second element should be the upper bound(s)."
msgstr ""
"O lado direito (RHS) tem length() %d; esperando comprimento 2. %sO primeiro "
"elemento deve ser o(s) limite(s) inferior(es); o segundo elemento deve ser "
"o(s) limite(s) superior(es)."

#: between.R:77
msgid "forderv(query) took ..."
msgstr "forderv(query) levou ..."

#: between.R:90
msgid "Generating final logical vector ..."
msgstr "Gerando vetor lógico final ..."

#: between.R:92 bmerge.R:200 bmerge.R:204 bmerge.R:211 data.table.R:496
msgid "done in %s"
msgstr "concluído em %s"

#: bmerge.R:21
msgid "Coercing %s column %s%s to type %s to match type of %s%s."
msgstr ""
"Fazendo coerção de %s coluna %s%s para o tipo %s para corresponder ao tipo "
"de %s%s."

#: bmerge.R:65 bmerge.R:66
#, c-format
msgid "%s is type %s which is not supported by data.table join"
msgstr "%s é do tipo %s, o qual não é suportado pela junção do data.table"

#: bmerge.R:69
#, c-format
msgid ""
"Attempting roll join on factor column when joining %s to %s. Only integer, "
"double or character columns may be roll joined."
msgstr ""
"Tentando uma junção por \"rolamento\" na coluna de fatores ao fazer a junção "
"entre %s e %s. Apenas colunas de inteiros, double ou caracteres podem ser "
"usadas na junção. "

#: bmerge.R:71
msgid "Matching %s factor levels to %s factor levels."
msgstr "Fazendo os níveis do fator %s corresponderem aos níveis do fator %s."

#: bmerge.R:80
msgid "Matching character column %s to factor levels in %s."
msgstr "Fazendo a coluna de caracteres %s corresponder aos níveis do fator %s."

#: bmerge.R:87
#, c-format
msgid ""
"Incompatible join types: %s (%s) and %s (%s). Factor columns must join to "
"factor or character columns."
msgstr ""
"Tipos de junção incompatíveis: %s (%s) e %s (%s). Colunas de fator devem "
"unir-se a colunas de caractere ou de fator."

#: bmerge.R:91
msgid "%s has same type (%s) as %s. No coercion needed."
msgstr "%s tem o mesmo tipo (%s) de %s. Nenhuma coerção necessária."

#: bmerge.R:97 bmerge.R:101
msgid "(all-NA)"
msgstr "(tudo NA)"

#: bmerge.R:104
#, c-format
msgid "Incompatible join types: %s (%s) and %s (%s)"
msgstr "Tipos de junção incompatíveis: %s (%s) e %s (%s)"

#: bmerge.R:110
msgid "(which has integer64 representation, e.g. no fractions)"
msgstr "(que tem representação integer64, ou seja, sem frações)"

#: bmerge.R:112
#, c-format
msgid ""
"Incompatible join types: %s is type integer64 but %s is type double and "
"cannot be coerced to integer64 (e.g. has fractions)"
msgstr ""
"Tipos de junção incompatíveis: %s é do tipo integer64 mas %s é do tipo "
"'double' e a coerção para integer64 não pode ser feita (p. ex. há frações)"

#: bmerge.R:132
msgid "(which contains no fractions)"
msgstr "(que não contém frações)"

#: bmerge.R:144
msgid "(which contains fractions)"
msgstr "(que contém frações)"

#: bmerge.R:147
msgid "(for join)"
msgstr "(para junção)"

#: bmerge.R:165
msgid "on= matches existing key, using key"
msgstr "on= corresponde à chave existente, usando chave"

#: bmerge.R:170
msgid "on= matches existing index, using index"
msgstr "on= corresponde ao índice existente, usando índice"

#: bmerge.R:175
msgid "Calculated ad hoc index in %s"
msgstr "Calculado índice ad hoc em %s"

#: bmerge.R:186
msgid "Non-equi join operators detected ..."
msgstr "Operadores de junção por desigualdade detectados ..."

#: bmerge.R:187
#, c-format
msgid "roll is not implemented for non-equi joins yet."
msgstr "'roll' ainda não está implementado para junções por desigualdade."

#: bmerge.R:188
msgid "forder took ..."
msgstr "forder levou ..."

#: bmerge.R:197
msgid "Generating group lengths ..."
msgstr "Gerando comprimentos de grupo ..."

#: bmerge.R:202
msgid "Generating non-equi group ids ..."
msgstr "Gerando ids de grupos por desigualdade ..."

#: bmerge.R:207
#, c-format
msgid "Column name '_nqgrp_' is reserved for non-equi joins."
msgstr ""
"O nome de coluna '_nqgrp_' está reservado para junções por desigualdade."

#: bmerge.R:208
msgid "Recomputing forder with non-equi ids ..."
msgstr "Recalculando forder com ids por desigualdade ..."

#: bmerge.R:217
msgid "Starting bmerge ..."
msgstr "Iniciando bmerge ..."

#: bmerge.R:219
msgid "bmerge done in %s"
msgstr "bmerge concluído em %s"

#: cedta.R:67
msgid ""
"cedta decided '%s' wasn't data.table aware. Here is call stack with [[1L]] "
"applied:"
msgstr ""
"cedta dediu que '%s' não estava ciente de data.table. Aqui está a pilha de "
"chamadas com [[1L]] aplicado:"

#: data.table.R:55
#, c-format
msgid "key argument of data.table() must be character"
msgstr "o argumento key do data.table() deve ser caractere"

#: data.table.R:121
#, c-format
msgid "Object '%s' not found. Perhaps you intended %s"
msgstr "Objeto '%s' não encontrado. Talvez sua intenção fosse %s"

#: data.table.R:123
#, c-format
msgid "Object '%s' not found amongst %s"
msgstr "Objeto '%s' não encontrado entre %s"

#: data.table.R:140
#, c-format
msgid ""
"[ was called on a data.table in an environment that is not data.table-aware "
"(i.e. cedta()), but '%s' was used, implying the owner of this call really "
"intended for data.table methods to be called. See vignette('datatable-"
"importing') for details on properly importing data.table."
msgstr ""
"[ foi chamado em uma data.table em um ambiente que não está ciente de data."
"table (p.ex. cedta()), mas '%s' foi usado, implicando que o dono desta "
"chamada realmente pretendia que métodos data.table fossem chamados. Veja "
"vignette('datatable-importing') para detalhes sobre importar uma data.table "
"apropriadamente."

#: data.table.R:151
#, c-format
msgid "verbose must be logical or integer"
msgstr "verbose deve ser lógico ou inteiro"

#: data.table.R:152
#, c-format
msgid "verbose must be length 1 non-NA"
msgstr "verbose deve ser não NA e de comprimento 1"

#: data.table.R:160
#, c-format
msgid "Ignoring by/keyby because 'j' is not supplied"
msgstr "Ignorando by/keyby porque 'j' não foi fornecido"

#: data.table.R:174
#, c-format
msgid "When by and keyby are both provided, keyby must be TRUE or FALSE"
msgstr "Quando by e keyby são ambos fornecidos, keyby deve ser TRUE ou FALSE"

#: data.table.R:177 data.table.R:242 data.table.R:331
msgid "Argument '%s' after substitute: %s"
msgstr "Argumento '%s' após substituto: %s"

#: data.table.R:186
#, c-format
msgid ""
"When on= is provided but not i=, on= must be a named list or data.table|"
"frame, and a natural join (i.e. join on common names) is invoked. Ignoring "
"on= which is '%s'."
msgstr ""
"Quando on= é fornecido, mas não i=, on= deve ser uma lista nomeada ou data."
"table|frame, e uma junção natural (ou seja, junção em nomes comuns) é "
"invocada. Ignorando on= , que é '%s'."

#: data.table.R:199
#, c-format
msgid ""
"i and j are both missing so ignoring the other arguments. This warning will "
"be upgraded to error in future."
msgstr ""
"i e j estão faltando, ignorando os outros argumentos. Este aviso será "
"atualizado para se tornar um erro no futuro."

#: data.table.R:203
#, c-format
msgid "mult argument can only be 'first', 'last' or 'all'"
msgstr "o argumento mult só pode ser 'first', 'last' ou 'all'"

#: data.table.R:205
#, c-format
msgid ""
"roll must be a single TRUE, FALSE, positive/negative integer/double "
"including +Inf and -Inf or 'nearest'"
msgstr ""
"roll deve ser TRUE, FALSE, número inteiro/duplo positivo/negativo, incluindo "
"+Inf e -Inf ou 'nearest'"

#: data.table.R:207
#, c-format
msgid "roll is '%s' (type character). Only valid character value is 'nearest'."
msgstr ""
"roll é '%s' (tipo caractere). O único valor de caractere válido é 'nearest'."

#: data.table.R:212
#, c-format
msgid "rollends must be a logical vector"
msgstr "rollends deve ser um vetor lógico"

#: data.table.R:213
#, c-format
msgid "rollends must be length 1 or 2"
msgstr "rollends deve ter comprimento 1 ou 2"

#: data.table.R:221
#, c-format
msgid ""
"nomatch= must be either NA or NULL (or 0 for backwards compatibility which "
"is the same as NULL but please use NULL)"
msgstr ""
"nomatch= deve ser NA ou NULL (ou 0 para compatibilidade com versões "
"anteriores, que é igual a NULL, mas use NULL)"

#: data.table.R:224
#, c-format
msgid "which= must be a logical vector length 1. Either FALSE, TRUE or NA."
msgstr "which= deve ser um vetor lógico de comprimento 1. FALSE, TRUE ou NA."

#: data.table.R:225
#, c-format
msgid ""
"which==%s (meaning return row numbers) but j is also supplied. Either you "
"need row numbers or the result of j, but only one type of result can be "
"returned."
msgstr ""
"which==%s (significando retornar números de linha), mas j também é "
"fornecido. Ou você precisa de números de linha ou do resultado de j, mas "
"apenas um tipo de resultado pode ser retornado."

#: data.table.R:226
#, c-format
msgid ""
"which=NA with nomatch=0|NULL would always return an empty vector. Please "
"change or remove either which or nomatch."
msgstr ""
"which=NA com nomatch=0|NULL sempre retornaria um vetor vazio. Favor alterar "
"ou remover ou which, ou nomatch."

#: data.table.R:227
#, c-format
msgid "j must be provided when with=FALSE"
msgstr "j deve ser fornecido quando with=FALSE"

#: data.table.R:228
#, c-format
msgid "%s must be TRUE or FALSE"
msgstr "%s deve ser TRUE ou FALSE"

#: data.table.R:270
#, c-format
msgid ""
"The symbol .. is invalid. The .. prefix must be followed by at least one "
"character."
msgstr ""
"O símbolo .. é inválido. O prefixo .. deve ser seguido por pelo menos um "
"caractere."

#: data.table.R:274
#, c-format
msgid ""
"Variable '..%s' does exist in calling scope though, so please just removed "
"the .. prefix from that variable name in calling scope."
msgstr ""
"A variável '..%s' existe no escopo de chamada, portanto, então favor "
"simplesmente remover o prefixo .. desse nome de variável no escopo de "
"chamada."

#: data.table.R:278
#, c-format
msgid ""
"Variable '%s' is not found in calling scope. Looking in calling scope "
"because you used the .. prefix.%s"
msgstr ""
"A variável '%s' não foi encontrada no escopo de chamada. Procurando no "
"escopo de chamada porque você usou .. como prefixo.%s"

#: data.table.R:280
#, c-format
msgid ""
"Both '%1$s' and '..%1$s' exist in calling scope. Please remove the '..%1$s' "
"variable in calling scope for clarity."
msgstr ""
"Tanto '%1$s' quanto '..%1$s' existem no escopo de chamada. Remova a variável "
"'..%1$s' na chamada do escopo para maior clareza."

#: data.table.R:288
#, c-format
msgid ""
"Variable '%s' is not found in calling scope. Looking in calling scope "
"because you set with=FALSE. Also, please use .. symbol prefix and remove "
"with=FALSE."
msgstr ""
"A variável '%s' não foi encontrada no escopo de chamada. Procurando no "
"escopo de chamada porque você definiu with=FALSE. Além disso, favor usr o "
"prefixo de símbolo .. e remover with=FALSE."

#: data.table.R:296
#, c-format
msgid ""
"You have wrapped := with {} which is ok but then := must be the only thing "
"inside {}. You have something else inside {} as well. Consider placing the "
"{} on the RHS of := instead; e.g. DT[,someCol:={tmpVar1<-...;tmpVar2<-...;"
"tmpVar1*tmpVar2}]"
msgstr ""
"Você envolveu := com {}, o que está tudo bem, mas := deve ser a única coisa "
"dentro de {}. Você também tem algo mais dentro de {}. Considere em vez disso "
"colocar {} ao lado direito de :=, como no exemplo "
"DT[,algumaCol:={tmpVar1<-...;tmpVar2<-...;tmpVar1*tmpVar2}]"

#: data.table.R:314
#, c-format
msgid ""
":= with keyby is only possible when i is not supplied since you can't setkey "
"on a subset of rows. Either change keyby to by or remove i"
msgstr ""
":= com keyby só é possível quando i não é fornecido, pois você não pode "
"definir a chave em um subconjunto de linhas. Ou altere keyby para by, ou "
"remova i"

#: data.table.R:316
#, c-format
msgid "nomatch isn't relevant together with :=, ignoring nomatch"
msgstr "nomatch não é relevante junto com :=, ignorando nomatch"

#: data.table.R:372
#, c-format
msgid ""
"not-join '!' prefix is present on i but nomatch is provided. Please remove "
"nomatch."
msgstr ""
"prefixo de não-junção '!' está presente em i, mas nomatch foi fornecido. Por "
"favor, remova nomatch."

#: data.table.R:400
#, c-format
msgid ""
"Operator := detected in i, the first argument inside DT[...], but is only "
"valid in the second argument, j. Most often, this happens when forgetting "
"the first comma (e.g. DT[newvar := 5] instead of DT[ , new_var := 5]). "
"Please double-check the syntax. Run traceback(), and debugger() to get a "
"line number."
msgstr ""
"Operador := detectado em i, o primeiro argumento dentro de DT[...], mas só é "
"válido no segundo argumento, j. Na maioria das vezes, isso acontece quando "
"se esquece a primeira vírgula (por exemplo, DT[nova_var := 5] em vez de "
"DT[ , nova_var := 5]). Verifique novamente a sintaxe. Execute traceback() e "
"debugger() para obter um número de linha."

#: data.table.R:410
#, c-format
msgid "'%s' is not found in calling scope and it is not a column name either"
msgstr ""
"'%s' não foi encontrado no escopo de chamada e também não é um nome de coluna"

#: data.table.R:413
#, c-format
msgid ""
"'%s' is not found in calling scope, but it is a column of type %s. If you "
"wish to select rows where that column contains TRUE, or perhaps that column "
"contains row numbers of itself to select, try DT[(col)], DT[DT$col], or "
"DT[col==TRUE] is particularly clear and is optimized"
msgstr ""
"'%s' não foi encontrado no escopo de chamada, mas é uma coluna do tipo %s. "
"Se você deseja selecionar linhas onde essa coluna contém TRUE, ou talvez "
"onde essa coluna contenha números de linha para selecionar, tente DT[(col)], "
"DT[DT$col] ou DT[col==TRUE}, o que é particularmente claro e otimizado"

#: data.table.R:416
#, c-format
msgid ""
"%s. When the first argument inside DT[...] is a single symbol (e.g. "
"DT[var]), data.table looks for var in calling scope."
msgstr ""
"%s. Quando o primeiro argumento dentro de DT[...] é um único símbolo (por "
"exemplo, DT[var]), data.table procura por var na chamada do escopo."

#: data.table.R:428
#, c-format
msgid ""
"i is invalid type (matrix). Perhaps in future a 2 column matrix could return "
"a list of elements of DT (in the spirit of A[B] in FAQ 2.14). Please report "
"to data.table issue tracker if you'd like this, or add your comments to FR "
"#657."
msgstr ""
"i é um tipo inválido (matrix). Talvez no futuro uma matriz de 2 colunas "
"possa retornar uma lista de elementos de DT (no espírito de A[B] no FAQ "
"2.14). Por favor, relate no rastreador de problemas do data.table se desejar "
"isso, ou adicione seus comentários ao FR #657."

#: data.table.R:451
#, c-format
msgid ""
"When i is a data.table (or character vector), the columns to join by must be "
"specified using 'on=' argument (see ?data.table), by keying x (i.e. sorted, "
"and, marked as sorted, see ?setkey), or by sharing column names between x "
"and i (i.e., a natural join). Keyed joins might have further speed benefits "
"on very large data due to x being sorted in RAM."
msgstr ""
"Quando i é uma data.table (ou vetor de caracteres), as colunas nas quais "
"fazer a junção devem ser especificadas usando o argumento 'on=' (consulte ?"
"data.table), por meio de chaveamento de x (ou seja, ordenado e marcado como "
"ordenado, consulte ?setkey) ou compartilhando de nomes de colunas entre x e "
"i (ou seja, uma junção natural). As junções chaveadas podem ter benefícios "
"adicionais de velocidade em dados muito grandes devido ao x estar ordenado "
"na RAM."

#: data.table.R:459
#, c-format
msgid "Attempting to do natural join but no common columns in provided tables"
msgstr ""
"Tentando fazer junção natural, mas não há colunas comuns nas tabelas "
"fornecidas"

#: data.table.R:462
msgid "Joining but 'x' has no key, natural join using all 'x' columns"
msgstr ""
"Fazendo junção, mas 'x' não tem chave; junção natural usando todas as "
"colunas de 'x'"

#: data.table.R:464
msgid "Joining but 'x' has no key, natural join using: %s"
msgstr "Fazendo junção, mas 'x' não tem chave; junção natural usando: %s"

#: data.table.R:493
msgid "not-join called with 'by=.EACHI'; Replacing !i with i=setdiff_(x,i) ..."
msgstr ""
"não-junção chamada com 'by=.EACHI'; Substituindo !i com i=setdiff_(x,i) ..."

#: data.table.R:523
msgid "Constructing irows for '!byjoin || nqbyjoin' ..."
msgstr "Construindo irows para '!byjoin || nqbyjoin' ..."

#: data.table.R:562
msgid "Reorder irows for 'mult==\"all\" && !allGrp1' ..."
msgstr "Reordenar irows para 'mult==\"all\" && !allGrp1' ..."

#: data.table.R:574
msgid "Reordering %d rows after bmerge done in ..."
msgstr "Reordenando %d linhas após bmerge ser concluído em ..."

#: data.table.R:591
#, c-format
msgid "logical error. i is not a data.table, but 'on' argument is provided."
msgstr ""
"erro lógico. i não é uma data.table, mas o argumento 'on' foi fornecido."

#: data.table.R:595
#, c-format
msgid "i has evaluated to type %s. Expecting logical, integer or double."
msgstr "i foi avaliado para o tipo %s. Esperava lógico, inteiro ou 'double'."

#: data.table.R:617
#, c-format
msgid ""
"i evaluates to a logical vector length %d but there are %d rows. Recycling "
"of logical i is no longer allowed as it hides more bugs than is worth the "
"rare convenience. Explicitly use rep(...,length=.N) if you really need to "
"recycle."
msgstr ""
"i foi avaliado como um vetor lógico de comprimento %d, mas há %d linhas. A "
"reciclagem do i lógico não é mais permitida, pois mais esconde bugs do que "
"vale a rara conveniência. Use explicitamente rep(...,length=.N) se você "
"realmente precisar reciclar."

#: data.table.R:620
#, c-format
msgid ""
"Please use nomatch=NULL instead of nomatch=0; see news item 5 in v1.12.0 "
"(Jan 2019)"
msgstr ""
"Favor usar nomatch=NULL em vez de nomatch=0; veja o item 5 das novidades da "
"v1.12.0 (jan 2019)"

#: data.table.R:635
msgid "Inverting irows for notjoin done in ..."
msgstr "Inversão de irows para não-junção concluída em ..."

#: data.table.R:691
#, c-format
msgid ""
"with=FALSE together with := was deprecated in v1.9.4 released Oct 2014; this "
"has been warning since v1.15.0. Please wrap the LHS of := with parentheses; "
"e.g., DT[,(myVar):=sum(b),by=a] to assign to column name(s) held in variable "
"myVar. See ?':=' for other examples."
msgstr ""
"O uso de with=FALSE junto com := está obsoleto desde v1.9.4, lançada em "
"outubro de 2014; isso é um aviso desde a v.1.15.0. Por favor, envolva o lado "
"à esquerda de := entre parênteses; por exemplo, DT[,(minhaVar):=sum(b),by=a] "
"para atribuir para nomes de colunas mantidos na variável minhaVar. "
"Veja ?':=' para outros exemplos."

#: data.table.R:734
#, c-format
msgid "Item %d of j is %d which is outside the column number range [1,ncol=%d]"
msgstr ""
"O item %d de j é %d, o qual está fora do intervalo de números de colunas [1,"
"ncol=%d]"

#: data.table.R:737
#, c-format
msgid "j mixes positives and negatives"
msgstr "j mistura positivos e negativos"

#: data.table.R:745
#, c-format
msgid ""
"When with=FALSE, j-argument should be of type logical/character/integer "
"indicating the columns to select."
msgstr ""
"Quando with=FALSE, o argumento j deve ser do tipo lógico/caractere/inteiro "
"indicando as colunas a serem selecionadas."

#: data.table.R:759
#, c-format
msgid ""
"'by' contains .I but only the following are currently supported: by=.I, by=."
"(.I), by=c(.I), by=list(.I)"
msgstr ""
"'by' contém .I, mas atualmente só há suporte aos seguintes: by=.I, by=.(.I), "
"by=c(.I), by=list(.I)"

#: data.table.R:783
#, c-format
msgid "by=c(...), key(...) or names(...) must evaluate to 'character'"
msgstr "by=c(...), key(...) ou names(...) devem ser avaliados para 'character'"

#: data.table.R:793
#, c-format
msgid ""
"'by' is a character vector length %d but one or more items include a comma. "
"Either pass a vector of column names (which can contain spaces, but no "
"commas), or pass a vector length 1 containing comma separated column names. "
"See ?data.table for other possibilities."
msgstr ""
"'by' é um vetor de caracteres de comprimento %d, mas um ou mais itens "
"incluem uma vírgula. Passe um vetor de nomes de colunas (que pode conter "
"espaços, mas nenhuma vírgula) ou passe um vetor de comprimento 1 contendo "
"nomes de colunas separados por vírgula. Veja ?data.table para outras "
"possibilidades."

#: data.table.R:800
#, c-format
msgid "At least one entry of by is empty"
msgstr "Ao menos uma entrada de by está vazia"

#: data.table.R:827
msgid "by index '%s' but that index has 0 length. Ignoring."
msgstr "índice by '%s', mas aquele índice tem comprimento 0. Ignorando."

#: data.table.R:850
msgid "i clause present and columns used in by detected, only these subset: %s"
msgstr ""
"cláusula de i presente e colunas usadas em by detectadas, apenas estes "
"subconjuntos: %s"

#: data.table.R:853
msgid ""
"i clause present but columns used in by not detected. Having to subset all "
"columns before evaluating 'by': '%s'"
msgstr ""
"cláusula de i presente, mas colunas usadas em by não detectadas. Tendo "
"que obter um subconjunto de todas as colunas antes de avaliar 'by': '%s'"

#: data.table.R:875
#, c-format
msgid ""
"'by' appears to evaluate to column names but isn't c() or key(). Use "
"by=list(...) if you can. Otherwise, by=eval%s should work. This is for "
"efficiency so data.table can detect which columns are needed."
msgstr ""
"'by' parece ser avaliado para nomes de colunas, mas não é c() ou key(). Use "
"by=list(...) se puder. Caso contrário, by=eval%s deveria funcionar. Isso é "
"para maior eficiência, para que data.table possa detectar quais colunas são "
"necessárias."

#: data.table.R:886
#, c-format
msgid ""
"'by' or 'keyby' must evaluate to a vector or a list of vectors (where 'list' "
"includes data.table and data.frame which are lists, too)"
msgstr ""
"'by' ou 'keyby' deve ser avaliado como um vetor ou uma lista de vetores "
"(onde 'list' inclui data.table e data.frame, que também são listas)"

#: data.table.R:890
#, c-format
msgid ""
"Column or expression %d of 'by' or 'keyby' is type '%s' which is not "
"currently supported. If you have a compelling use case, please add it to "
"https://github.com/Rdatatable/data.table/issues/1597. As a workaround, "
"consider converting the column to a supported type, e.g. by=sapply(list_col, "
"toString), whilst taking care to maintain distinctness in the process."
msgstr ""
"A coluna ou expressão %d de 'by' ou 'keyby' é do tipo '%s' e não é suportada "
"atualmente. Se você tiver um caso de uso atraente, adicione-o a https://"
"github.com/Rdatatable/data.table/issues/1597. Como solução alternativa, "
"considere converter a coluna em um tipo compatível, como "
"by=sapply(lista_colunas, toString), tomando cuidado para manter a distinção "
"no processo."

#: data.table.R:916
msgid ""
"by-expression '%s' is not named, and the auto-generated name '%s' clashed "
"with variable(s) in j. Therefore assigning the entire by-expression as name."
msgstr ""
"expressão by '%s' não nomeada, e o nome gerado automaticamente '%s' entrou "
"em conflito com a(s) variável(eis) em j. Portanto, atribuindo toda a "
"expressão by como nome."

#: data.table.R:950
#, c-format
msgid "Item %d of the .() or list() passed to j is missing"
msgstr "O item %d de .() ou list() passado para j está ausente"

#: data.table.R:956
#, c-format
msgid ""
"j may not evaluate to the same number of columns for each group; if you're "
"sure this warning is in error, please put the branching logic outside of "
"[ for efficiency"
msgstr ""
"j pode não ser avaliado com o mesmo número de colunas para cada grupo; se "
"você tiver certeza de que este aviso está errado, coloque a lógica de "
"branching fora de [ para eficiência"

#: data.table.R:958
#, c-format
msgid ""
"Different branches of j expression produced different auto-named columns: "
"%s; using the most \"last\" names. If this was intentional (e.g., you know "
"only one branch will ever be used in a given query because the branch is "
"controlled by a function argument), please (1) pull this branch out of the "
"call; (2) explicitly provide missing defaults for each branch in all cases; "
"or (3) use the same name for each branch and re-name it in a follow-up call."
msgstr ""
"Diferentes branches da expressão j produziram diferentes colunas nomeadas "
"automaticamente: %s; usando os nomes definidos por último. Se isso foi "
"intencional (por exemplo, você sabe que apenas um branch será usado em uma "
"determinada consulta porque o branch é controlado por um argumento de "
"função), favor, (1) retirar esse branch da chamada; (2) fornecer "
"explicitamente os valores padrão faltantes para cada branch em todos os "
"casos; ou (3) use o mesmo nome para cada branch e renomeie-o em uma chamada "
"seguinte."

#: data.table.R:1028
#, c-format
msgid ""
"When .SDcols is a function, it is applied to each column; the output of this "
"function must be a non-missing boolean scalar signalling inclusion/exclusion "
"of the column. However, these conditions were not met for: %s"
msgstr ""
"Quando .SDcols é uma função, ela é aplicada a cada coluna; a saída desta "
"função deve ser um escalar booleano não NA sinalizando inclusão/exclusão da "
"coluna. No entanto, estas condições não foram cumpridas para: %s"

#: data.table.R:1034
#, c-format
msgid ".SDcols missing at the following indices: %s"
msgstr ".SDcols ausentes nos seguintes índices: %s"

#: data.table.R:1036
#, c-format
msgid ".SDcols is a logical vector of length %d but there are %d columns"
msgstr ".SDcols é um vetor lógico de comprimento %d, mas existem %d colunas"

#: data.table.R:1042
#, c-format
msgid ".SDcols is numeric but has both +ve and -ve indices"
msgstr ".SDcols é numérico, mas possui índices positivos e negativos"

#: data.table.R:1044
#, c-format
msgid ".SDcols is numeric but out of bounds [1, %d] at: %s"
msgstr ".SDcols é numérico, mas está fora dos limites [1, %d] em: %s"

#: data.table.R:1048
#, c-format
msgid ".SDcols should be column numbers or names"
msgstr ".SDcols deve consistir em números ou nomes de colunas"

#: data.table.R:1050
#, c-format
msgid "Some items of .SDcols are not column names: %s"
msgstr "Alguns itens de .SDcols não são nomes de colunas: %s"

#: data.table.R:1063
msgid ""
"'(m)get' found in j. ansvars being set to all columns. Use .SDcols or a "
"single j=eval(macro) instead. Both will detect the columns used which is "
"important for efficiency.\n"
"Old ansvars: %s"
msgstr ""
"'(m)get' encontrado em j. ansvars sendo definido para todas as colunas. "
"Use .SDcols ou um único j=eval(macro) em vez disso. Ambos detectarão as "
"colunas usadas, o que é importante para a eficiência.\n"
"ansvars antigo: %s"

#: data.table.R:1083
msgid "New ansvars: %s"
msgstr "Novo ansvars: %s"

#: data.table.R:1092
#, c-format
msgid ""
"This j doesn't use .SD but .SDcols has been supplied. Ignoring .SDcols. See ?"
"data.table."
msgstr ""
"Este j não usa .SD, mas .SDcols foi fornecido. Ignorando .SDcols. Consulte ?"
"data.table."

#: data.table.R:1095
msgid "Detected that j uses these columns: %s"
msgstr "Detectado que j usa estas colunas: %s"

#: data.table.R:1108
#, c-format
msgid ""
".SD is locked. Using := in .SD's j is reserved for possible future use; a "
"tortuously flexible way to modify by group. Use := in j directly to modify "
"by group by reference."
msgstr ""
".SD é travado. O uso de := no j de .SD está reservado para possível uso "
"futuro; uma maneira tortuosamente flexível de modificar por grupo. Use := in "
"j diretamente para modificar por grupo por referência."

#: data.table.R:1119
#, c-format
msgid "In %s(col1=val1, col2=val2, ...) form, all arguments must be named."
msgstr ""
"Na forma %s(col1=val1, col2=val2, ...), todos os argumentos devem ser "
"nomeados."

#: data.table.R:1142
#, c-format
msgid ""
"In %s(col1=val1, col2=val2, ...) form, all arguments must be named, but the "
"last argument has no name. Did you forget a trailing comma?"
msgstr ""
"Na forma %s(col1=val1, col2=val2, ...), todos os argumentos devem ser "
"nomeados, mas o último argumento não tem nome. Você se esqueceu de uma "
"vírgula final?"

#: data.table.R:1144
#, c-format
msgid ""
"In %s(col1=val1, col2=val2, ...) form, all arguments must be named, but "
"these arguments lack names: %s."
msgstr ""
"Na forma %s(col1=val1, col2=val2, ...), todos os argumentos devem ser "
"nomeados, mas estes elementos estão sem nome: %s."

#: data.table.R:1151
#, c-format
msgid ""
"LHS of := must be a symbol, or an atomic vector (column names or positions)."
msgstr ""
"O lado esquerdo de := deve ser um símbolo ou um vetor atômico (nomes de "
"colunas ou posições)."

#: data.table.R:1156
#, c-format
msgid ""
"LHS of := appears to be column positions but are outside [1,ncol] range. New "
"columns can only be added by name."
msgstr ""
"Parece que o lado esquerdo de := são posições de coluna, mas estão fora do "
"intervalo [1,ncol]. Novas colunas só podem ser adicionadas por nome."

#: data.table.R:1159
#, c-format
msgid ""
"LHS of := isn't column names ('character') or positions ('integer' or "
"'numeric')"
msgstr ""
"O lado esquerdo de := não são nomes de colunas ('character') ou posições "
"('integer' ou 'numeric')"

#: data.table.R:1175
msgid ""
"No rows match i. No new columns to add so not evaluating RHS of :=\n"
"Assigning to 0 row subset of %d rows"
msgstr ""
"Nenhuma linha corresponde a i. Nenhuma coluna nova para adicionar, portanto, "
"não será avaliado o lado direito de :=\n"
"Atribuindo a um subconjunto com 0 linha das %d linhas"

#: data.table.R:1190
#, c-format
msgid ""
"A shallow copy of this data.table was taken so that := can add or remove %d "
"columns by reference. At an earlier point, this data.table was copied by R "
"(or was created manually using structure() or similar). Avoid names<- and "
"attr<- which in R currently (and oddly) may copy the whole data.table. Use "
"set* syntax instead to avoid copying: ?set, ?setnames and ?setattr. It's "
"also not unusual for data.table-agnostic packages to produce tables affected "
"by this issue. If this message doesn't help, please report your use case to "
"the data.table issue tracker so the root cause can be fixed or this message "
"improved."
msgstr ""
"Uma cópia rasa desta data.table foi feita de forma que := possa adicionar ou "
"remover %d colunas por referência. Anteriormente, esta data.table foi "
"copiada pelo R (ou foi criado manualmente usando structure() ou similar). "
"Evite names<- e attr<-, que no R atualmente (e estranhamente) podem copiar "
"toda a data.table. Use em vez disso a sintaxe set* para evitar copiar: ?"
"set, ?setnames e ?setattr. Também não é incomum que pacotes que desconhecem "
"o data.table produzam tabelas afetadas por essa questão. Se esta mensagem "
"não ajudar, por favor, relate isso no rastreador de problemas do data.table "
"para que a causa raiz possa ser corrigida ou esta mensagem melhorada."

#: data.table.R:1198
msgid ""
"Growing vector of column pointers from truelength %d to %d. A shallow copy "
"has been taken, see ?setalloccol. Only a potential issue if two variables "
"point to the same data (we can't yet detect that well) and if not you can "
"safely ignore this. To avoid this message you could setalloccol() first, "
"deep copy first using copy(), wrap with suppressWarnings() or increase the "
"'datatable.alloccol' option."
msgstr ""
"Vetor crescente de ponteiros de coluna de truelength %d para %d. Uma cópia "
"rasa foi feita, veja ?setalloccol. Apenas um problema potencial se duas "
"variáveis ​​apontarem para os mesmos dados (ainda não conseguimos detectar "
"isso bem) e se não, você pode ignorar isso com segurança. Para evitar essa "
"mensagem, você pode fazer setalloccol() primeiro, fazer uma cópia profunda "
"primeiro usando copy(), encapsular com suppressWarnings() ou aumentar a "
"opção 'datatable.alloccol'."

#: data.table.R:1200
msgid ""
"Note that the shallow copy will assign to the environment from which := was "
"called. That means for example that if := was called within a function, the "
"original table may be unaffected."
msgstr ""
"Note que a cópia rasa será atribuída ao ambiente do qual := foi chamado. "
"Isso significa, por exemplo, que se := foi chamado dentro de uma função, a "
"tabela original pode não ser afetada."

#: data.table.R:1221
#, c-format
msgid ""
"Cannot assign to an under-allocated recursively indexed list -- L[[i]][,:=] "
"syntax is only valid when i is length 1, but its length is %d"
msgstr ""
"Não é possível atribuir a uma lista indexada recursivamente subalocada - a "
"sintaxe L[[i]][,:=] só é válida quando i tem comprimento 1, mas seu "
"comprimento é %d"

#: data.table.R:1292
#, c-format
msgid ""
"Variable '%s' is not found in calling scope. Looking in calling scope "
"because this symbol was prefixed with .. in the j= parameter."
msgstr ""
"A variável '%s' não foi encontrada no escopo de chamada. Procurando no "
"escopo de chamada porque este símbolo foi prefixado com .. no parâmetro j=."

#: data.table.R:1378
#, c-format
msgid ""
"j (the 2nd argument inside [...]) is a single symbol but column name '%1$s' "
"is not found. If you intended to select columns using a variable in calling "
"scope, please try DT[, ..%1$s]. The .. prefix conveys one-level-up similar "
"to a file system path."
msgstr ""
"j (o 2º argumento dentro de [...]) é um símbolo único, mas o nome da coluna "
"'%1$s' não foi encontrado. Se você pretendia selecionar colunas usando uma "
"variável na chamada do escopo, tente DT[, ..%1$s]. O prefixo .. transmite um "
"nível superior semelhante a um caminho do sistema de arquivos."

#: data.table.R:1466
#, c-format
msgid ""
"The column '.N' can't be grouped because it conflicts with the special .N "
"variable. Try setnames(DT,'.N','N') first."
msgstr ""
"A coluna '.N' não pode ser agrupada porque conflita com a variável especial ."
"N. Tente setnames(DT,'.N','N') primeiro."

#: data.table.R:1467
#, c-format
msgid ""
"The column '.I' can't be grouped because it conflicts with the special .I "
"variable. Try setnames(DT,'.I','I') first."
msgstr ""
"A coluna '.I' não pode ser agrupada porque conflita com a variável especial ."
"I. Tente setnames(DT,'.I','I') primeiro."

#: data.table.R:1486
msgid ""
"Note: forcing units=\"secs\" on implicit difftime by group; call difftime "
"explicitly to choose custom units"
msgstr ""
"Nota: forçando unidades=\"secs\" em difftime implícito por grupo; chame "
"difftime explicitamente para escolher unidades personalizadas"

#: data.table.R:1495
#, c-format
msgid "logical error. i is not a data.table, but mult='all' and 'by'=.EACHI"
msgstr "erro lógico. i não é uma data.table, mas mult='all' e 'by'=.EACHI"

#: data.table.R:1522
msgid "Finding groups using forderv ..."
msgstr "Encontrando grupos usando forderv ..."

#: data.table.R:1536 data.table.R:1568
msgid "Finding group sizes from the positions (can be avoided to save RAM) ..."
msgstr ""
"Encontrando tamanhos de grupo a partir das posições (pode ser evitado para "
"economizar RAM) ..."

#: data.table.R:1544
msgid "Getting back original order ..."
msgstr "Retornando a ordem original..."

#: data.table.R:1556
msgid "Finding groups using uniqlist on key ..."
msgstr "Encontrando grupos usando uniqlist na chave ..."

#: data.table.R:1560
msgid "Finding groups using uniqlist on index '%s' ..."
msgstr "Encontrando grupos usando uniqlist no índice '%s' ..."

#: data.table.R:1779
msgid "lapply optimization changed j from '%s' to '%s'"
msgstr "otimização lapply mudou j de '%s' para '%s'"

#: data.table.R:1781
msgid "lapply optimization is on, j unchanged as '%s'"
msgstr "otimização lapply está ativada, j inalterado como '%s'"

#: data.table.R:1790 data.table.R:1814
msgid "GForce optimized j to '%s' (see ?GForce)"
msgstr "GForce otimizou j para '%s' (veja ?GForce)"

#: data.table.R:1815
msgid ""
"GForce is on, but not activated for this query; left j unchanged (see ?"
"GForce)"
msgstr ""
"GForce está ligado, mas não ativado para esta consulta; j deixado "
"inalterado (veja ?GForce)"

#: data.table.R:1834
#, c-format
msgid ""
"Unable to optimize call to mean() and could be very slow. You must name 'na."
"rm' like that otherwise if you do mean(x,TRUE) the TRUE is taken to mean "
"'trim' which is the 2nd argument of mean. 'trim' is not yet optimized."
msgstr ""
"Não foi possível otimizar a chamada de mean() e pode ser muito lento. Você "
"deve nomear 'na.rm' como tal, caso contrário, se você usar mean(x,TRUE), o "
"TRUE é obtido para fazer uma média truncada, pois 'trim' é o 2º argumento de "
"mean. 'trim' ainda não está otimizado."

#: data.table.R:1838
msgid "Old mean optimization changed j from '%s' to '%s'"
msgstr "A otimização média antiga mudou j de '%s' para '%s'"

#: data.table.R:1840
msgid "Old mean optimization is on, left j unchanged."
msgstr "A antiga otimização de mean está ativa, j deixado inalterado."

#: data.table.R:1850
msgid "All optimizations are turned off"
msgstr "Todas as otimizações estão desativadas"

#: data.table.R:1851
msgid "Optimization is on but left j unchanged (single plain symbol): '%s'"
msgstr ""
"A otimização está ativa, mas j deixado inalterado (símbolo simples "
"único): '%s'"

#: data.table.R:1880
msgid "Making each group and running j (GForce %s) ..."
msgstr "Criando cada grupo e executando j (GForce %s) ..."

#: data.table.R:1976
msgid "setkey() after the := with keyby= ..."
msgstr "setkey() depois de := com keyby= ..."

#: data.table.R:1980
#, c-format
msgid ""
"The setkey() normally performed by keyby= has been skipped (as if by= was "
"used) because := is being used together with keyby= but the keyby= contains "
"some expressions. To avoid this warning, use by= instead, or provide "
"existing column names to keyby=."
msgstr ""
"O setkey() normalmente executado por keyby= foi ignorado (como se by= fosse "
"usado) porque := está sendo usado junto com keyby= mas keyby= contém algumas "
"expressões. Para evitar esse aviso, use by= ou forneça nomes de colunas "
"existentes para keyby=."

#: data.table.R:2006
msgid "setkey() afterwards for keyby=.EACHI ..."
msgstr "setkey() depois para keyby=.EACHI ..."

#: data.table.R:2072
#, c-format
msgid "rownames and rownames.value cannot both be used at the same time"
msgstr "rownames e rownames.value não podem ser usados ao mesmo tempo"

#: data.table.R:2075
#, c-format
msgid ""
"length(rownames)==%d but nrow(DT)==%d. The rownames argument specifies a "
"single column name or number. Consider rownames.value= instead."
msgstr ""
"length(rownames)==%d, mas nrow(DT)==%d. O argumento rownames especifica um "
"único nome ou número de coluna. Considere usar rownames.value= em vez disso."

#: data.table.R:2079
#, c-format
msgid ""
"length(rownames)==0 but should be a single column name or number, or NULL"
msgstr ""
"length(rownames)==0, mas deve ser um nome ou número de única coluna, ou NULL"

#: data.table.R:2083
#, c-format
msgid ""
"rownames is TRUE but key has multiple columns %s; taking first column x[,1] "
"as rownames"
msgstr ""
"rownames é TRUE, mas a chave possui múltiplas colunas %s; usando primeira "
"coluna x[,1] como rownames"

#: data.table.R:2093
#, c-format
msgid "'%s' is not a column of x"
msgstr "'%s' não é uma coluna de x"

#: data.table.R:2099
#, c-format
msgid ""
"as.integer(rownames)==%d which is outside the column number range [1,"
"ncol=%d]."
msgstr ""
"as.integer(rownames)==%d que está fora do intervalo de números de coluna [1,"
"ncol=%d]."

#: data.table.R:2104
#, c-format
msgid "length(rownames.value)==%d but should be nrow(x)==%d"
msgstr "length(rownames.value)==%d, mas deveria ser nrow(x)==%d"

#: data.table.R:2200
#, c-format
msgid ""
"When i is a matrix in DT[i]<-value syntax, it doesn't make sense to provide j"
msgstr ""
"Quando i é uma matriz na sintaxe DT[i]<-valor, não faz sentido fornecer j"

#: data.table.R:2210
#, c-format
msgid "j must be an atomic vector, see ?is.atomic"
msgstr "j deve ser um vetor atômico, veja ?is.atomic"

#: data.table.R:2211
#, c-format
msgid "NA in j"
msgstr "NA em j"

#: data.table.R:2217
#, c-format
msgid "j must be vector of column name or positions"
msgstr "j deve ser um vetor de posições ou nome de coluna"

#: data.table.R:2218
#, c-format
msgid ""
"Attempt to assign to column position greater than ncol(x). Create the column "
"by name, instead. This logic intends to catch (most likely) user errors."
msgstr ""
"Tentativa de atribuir a uma posição de coluna maior que ncol(x). Em vez "
"disso, crie a coluna por nome. Esta lógica pretende capturar (prováveis) "
"erros do usuário."

#: data.table.R:2285
#, c-format
msgid ""
"data.table inherits from data.frame (from v1.5), but this data.table does "
"not. Has it been created manually (e.g. by using 'structure' rather than "
"'data.table') or saved to disk using a prior version of data.table?"
msgstr ""
"data.table herda de data.frame (desde v1.5), mas esta data.table não. Ela "
"foi criado=a manualmente (por exemplo, usando 'structure' em vez de 'data."
"table') ou salvo=a em disco usando uma versão anterior do data.table?"

#: data.table.R:2294
#, c-format
msgid "attempting to assign invalid object to dimnames of a data.table"
msgstr "tentando atribuir objeto inválido a dimnames de uma data.table"

#: data.table.R:2295
#, c-format
msgid "data.tables do not have rownames"
msgstr "data.tables não têm rownames"

#: data.table.R:2296 data.table.R:2665
#, c-format
msgid "Can't assign %d names to a %d-column data.table"
msgstr "Não é possível atribuir %d nomes a uma data.table de %d colunas"

#: data.table.R:2360
#, c-format
msgid "'subset' must evaluate to logical"
msgstr "'subset' deve ser avaliado para tipo lógico"

#: data.table.R:2403
#, c-format
msgid "Argument 'invert' must be logical TRUE/FALSE"
msgstr "Argumento 'invert' deve ser lógico TRUE/FALSE"

#: data.table.R:2444
#, c-format
msgid "x argument must be a data.table"
msgstr "o argumento x deve ser uma data.table"

#: data.table.R:2449
#, c-format
msgid "group length is 0 but data nrow > 0"
msgstr "o comprimento do grupo é 0, mas os dados têm nrow > 0"

#: data.table.R:2451
#, c-format
msgid ""
"passing 'f' argument together with 'by' is not allowed, use 'by' when split "
"by column in data.table and 'f' when split by external factor"
msgstr ""
"passar o argumento 'f' junto com 'by' não é permitido, use 'by' quando "
"dividido por uma coluna na data.table e 'f' quando dividido por fator externo"

#: data.table.R:2459
#, c-format
msgid "Either 'by' or 'f' argument must be supplied"
msgstr "O argumento 'by' ou 'f' deve ser fornecido"

#: data.table.R:2461
#, c-format
msgid "Column '.ll.tech.split' is reserved for split.data.table processing"
msgstr ""
"A coluna '.ll.tech.split' é reservada para processamento em split.data.table"

#: data.table.R:2462
#, c-format
msgid "Column '.nm.tech.split' is reserved for split.data.table processing"
msgstr ""
"A coluna '.nm.tech.split' é reservada para processamento em split.data.table"

#: data.table.R:2463
#, c-format
msgid "Argument 'by' must refer to column names in x"
msgstr "O argumento 'by' deve referir-se a nomes das colunas em x"

#: data.table.R:2464
#, c-format
msgid ""
"Argument 'by' must refer only to atomic-type columns, but the following "
"columns are non-atomic: %s"
msgstr ""
"O argumento 'by' deve referir-se apenas a colunas do tipo atômico, mas as "
"seguintes colunas não são atômicas: %s"

#: data.table.R:2511
msgid "Processing split.data.table with: %s"
msgstr "Processando split.data.table com: %s"

#: data.table.R:2596
#, c-format
msgid ""
"x is not a data.table|frame. Shallow copy is a copy of the vector of column "
"pointers (only), so is only meaningful for data.table|frame"
msgstr ""
"x não é um data.table|frame. A cópia rasa é uma cópia do vetor de ponteiros "
"de coluna (apenas), portanto, só é significativa para data.table|frame"

#: data.table.R:2605
#, c-format
msgid "setalloccol attempting to modify `*tmp*`"
msgstr "setalloccol tentando modificar `*tmp*`"

#: data.table.R:2640
#, c-format
msgid ""
"Input is a length=1 logical that points to the same address as R's global "
"value. Therefore the attribute has not been set by reference, rather on a "
"copy. You will need to assign the result back to a variable. See issue #1281."
msgstr ""
"A entrada é um tipo lógico de comprimento 1 que aponta para o mesmo endereço "
"que o valor global do R. Portanto, o atributo não foi definido por "
"referência, mas sim por uma cópia. Você precisará atribuir o resultado de "
"volta a uma variável. Consulte o issue #1281."

#: data.table.R:2655
#, c-format
msgid "x is not a data.table or data.frame"
msgstr "x não é um data.table ou data.frame"

#: data.table.R:2657
#, c-format
msgid "x has %d columns but its names are length %d"
msgstr "x tem %d colunas, mas seus nomes têm comprimento %d"

#: data.table.R:2664
#, c-format
msgid "Passed a vector of type '%s'. Needs to be type 'character'."
msgstr "Passou um vetor do tipo '%s'. Precisa ser do tipo 'character'."

#: data.table.R:2677
#, c-format
msgid "'new' is not a character vector or a function"
msgstr "'new' não é um vetor de caracteres ou uma função"

#: data.table.R:2679
#, c-format
msgid "NA in 'new' at positions %s"
msgstr "NA em 'new' nas posições %s"

#: data.table.R:2680
#, c-format
msgid "Some duplicates exist in 'old': %s"
msgstr "Existem algumas duplicatas em 'old': %s"

#: data.table.R:2682
#, c-format
msgid "'old' is type %s but should be integer, double or character"
msgstr "'old' é do tipo %s, mas deve ser inteiro, double ou caractere"

#: data.table.R:2683
#, c-format
msgid "'old' is length %d but 'new' is length %d"
msgstr "'old' tem comprimento %d, mas 'new' tem comprimento %d"

#: data.table.R:2684
#, c-format
msgid "NA (or out of bounds) in 'old' at positions %s"
msgstr "NA (ou fora dos limites) em 'old' nas posições %s"

#: data.table.R:2687
#, c-format
msgid ""
"Item %d of 'old' is '%s' which appears several times in column names. Just "
"the first will be changed. There are %d other items in 'old' that are also "
"duplicated in column names."
msgstr ""
"O item %d de 'old' é '%s', que aparece várias vezes nos nomes das colunas. "
"Apenas o primeiro será alterado. Existem %d outros itens em 'old' que também "
"estão duplicados nos nomes das colunas."

#: data.table.R:2695
#, c-format
msgid ""
"Items of 'old' not found in column names: %s. Consider skip_absent=TRUE."
msgstr ""
"Itens de 'old' não encontrados nos nomes das colunas: %s. Considere "
"skip_absent=TRUE."

#: data.table.R:2736
#, c-format
msgid "Provide either before= or after= but not both"
msgstr "Forneça before= ou after=, mas não ambos"

#: data.table.R:2738
#, c-format
msgid "before=/after= accept a single column name or number, not more than one"
msgstr ""
"before=/after= aceitam um único nome ou número de coluna, não mais do que um"

#: data.table.R:2795
#, c-format
msgid "Input is %s but should be a plain list of items to be stacked"
msgstr ""
"A entrada é %s, mas deve ser uma lista simples de itens a serem empilhados"

#: data.table.R:2799
#, c-format
msgid ""
"idcol must be a logical or character vector of length 1. If logical TRUE the "
"id column will named '.id'."
msgstr ""
"idcol deve ser um vetor de valores lógicos ou caracteres de comprimento 1. "
"Se for lógico TRUE, a coluna de identificação denominada '.id'."

#: data.table.R:2804
#, c-format
msgid "use.names=NA invalid"
msgstr "use.names=NA inválido"

#: data.table.R:2806
#, c-format
msgid ""
"use.names='check' cannot be used explicitly because the value 'check' is new "
"in v1.12.2 and subject to change. It is just meant to convey default "
"behavior. See ?rbindlist."
msgstr ""
"use.names='check' não pode ser usado explicitamente porque o valor 'check' é "
"novo na v1.12.2 e está sujeito a alterações. O objetivo é apenas transmitir "
"o comportamento padrão. Consulte ?rbindlist."

#: data.table.R:2821
#, c-format
msgid ""
"Check that is.data.table(DT) == TRUE. Otherwise, :=, `:=`(...) and let(...) "
"are defined for use in j, once only and in particular ways. Note that "
"namespace-qualification like data.table::`:=`(...) is not supported. See "
"help(\":=\")."
msgstr ""
"Verifique se is.data.table(DT) == TRUE. De qualquer forma, :=, `:=`(...) e "
"let(...) são definidos para uso em j, apenas uma vez e de maneiras "
"específicas. Note que qualificação de namespace como data.table::`:=`(...) "
"não é suportado. Veja help(\":=\")."

#: data.table.R:2838
#, c-format
msgid ""
"setDF only accepts data.table, data.frame or list of equal length as input"
msgstr ""
"setDF aceita apenas data.table, data.frame ou lista de igual comprimento "
"como entrada"

#: data.table.R:2839
#, c-format
msgid "rownames contains duplicates"
msgstr "rownames contém duplicatas"

#: data.table.R:2846 data.table.R:2857 data.table.R:2880
#, c-format
msgid "rownames incorrect length; expected %d names, got %d"
msgstr "rownames com comprimento incorreto; esperava %d nomes, obteve %d"

#: data.table.R:2865
#, c-format
msgid "All elements in argument 'x' to 'setDF' must be of same length"
msgstr ""
"Todos os elementos no argumento 'x' para 'setDF' devem ter o mesmo "
"comprimento"

#: data.table.R:2894
#, c-format
msgid "Cannot find symbol %s"
msgstr "Não foi possível encontrar o símbolo %s"

#: data.table.R:2901
#, c-format
msgid ""
"Cannot convert '%1$s' to data.table by reference because binding is locked. "
"It is very likely that '%1$s' resides within a package (or an environment) "
"that is locked to prevent modifying its variable bindings. Try copying the "
"object to your current environment, ex: var <- copy(var) and then using "
"setDT again."
msgstr ""
"Não é possível converter '%1$s' em data.table por referência porque o "
"vínculo está travado. É muito provável que '%1$s' resida em um pacote (ou "
"ambiente) que esteja travado para evitar a modificação de seus vínculos de "
"variáveis. Experimente copiar o objeto para o seu ambiente atual, ex: var <- "
"copy(var) e depois usar setDT novamente."

#: data.table.R:2955
#, c-format
msgid ""
"Argument 'x' to 'setDT' should be a 'list', 'data.frame' or 'data.table'"
msgstr ""
"O argumento 'x' para 'setDT' deve ser uma 'list', 'data.frame' ou 'data."
"table'"

#: data.table.R:2970
#, c-format
msgid "Item '%s' not found in names of input list"
msgstr "Item '%s' não encontrado nos nomes da lista recebida"

#: data.table.R:3003 data.table.R:3028
#, c-format
msgid "'prefix' must be NULL or a character vector of length 1."
msgstr "'prefix' deve ser NULL ou um vetor de caracteres de comprimento 1."

#: data.table.R:3006 data.table.R:3031
#, c-format
msgid "x is a single vector, non-NULL 'cols' doesn't make sense."
msgstr "x é um único vetor, 'cols' não NULL não faz sentido."

#: data.table.R:3010 data.table.R:3035
#, c-format
msgid "x is a list, 'cols' cannot be 0-length."
msgstr "x é uma lista, 'cols' não pode ter comprimento 0."

#: data.table.R:3190
#, c-format
msgid ""
"It looks like you re-used `:=` in argument %d a functional assignment call "
"-- use `=` instead: %s(col1=val1, col2=val2, ...)"
msgstr ""
"Parece que você reutilizou `:=` no argumento %d, uma chamada de atribuição "
"funcional -- use `=` em vez disso: %s(col1=val1, col2=val2, ...)"

#: data.table.R:3256
#, c-format
msgid ""
"RHS of %s is length %d which is not 1 or nrow (%d). For robustness, no "
"recycling is allowed (other than of length 1 RHS). Consider %%in%% instead."
msgstr ""
"Lado direito (RHS) de %s tem comprimento %d que não é 1 ou nrow (%d). Para "
"maior robustez, nenhuma reciclagem é permitida (exceto em lado direito de "
"comprimento 1). Considere %%in%% em vez disso."

#: data.table.R:3288
msgid ""
"Subsetting optimization disabled because the cross-product of RHS values "
"exceeds 1e4, causing memory problems."
msgstr ""
"Otimização de subconjuntos desabilitada porque o produto cruzado dos valores "
"do lado direito excede 1e4, causando problemas de memória."

#: data.table.R:3306
msgid "Optimized subsetting with key %s"
msgstr "Obtendo subconjunto de forma otimizada com chave %s"

#: data.table.R:3325 data.table.R:3337
msgid "Optimized subsetting with index '%s'"
msgstr "Obtendo subconjunto de forma otimizada com índice '%s'"

#: data.table.R:3332
msgid "Creating new index '%s'"
msgstr "Criando novo índice '%s'"

#: data.table.R:3333
msgid "Creating index %s done in ..."
msgstr "Criação de índice %s concluída em ..."

#: data.table.R:3371
#, c-format
msgid ""
"'on' argument should be a named atomic vector of column names indicating "
"which columns in 'i' should be joined with which columns in 'x'."
msgstr ""
"O argumento 'on' deve ser um vetor atômico nomeado de nomes de colunas "
"indicando quais colunas em 'i' correspondem a quais colunas em 'x' para a "
"junção."

#: data.table.R:3412
#, c-format
msgid ""
"Found more than one operator in one 'on' statement: %s. Please specify a "
"single operator."
msgstr ""
"Encontrado mais de um operador em uma instrução 'on': %s. Especifique um "
"único operador."

#: data.table.R:3435
#, c-format
msgid ""
"'on' contains no column name: %s. Each 'on' clause must contain one or two "
"column names."
msgstr ""
"'on' não contém nome de coluna: %s. Cada cláusula 'on' deve conter um ou "
"dois nomes de coluna."

#: data.table.R:3437
#, c-format
msgid ""
"'on' contains more than 2 column names: %s. Each 'on' clause must contain "
"one or two column names."
msgstr ""
"'on' contém mais de 2 nomes de colunas: %s. Cada cláusula 'on' deve conter "
"um ou dois nomes de coluna."

#: data.table.R:3442
#, c-format
msgid "Invalid join operators %s. Only allowed operators are %s."
msgstr ""
"Operadores de junção inválidos: %s. Os únicos operadores permitidos são %s."

#: devel.R:16
#, c-format
msgid "There is no package %s in provided repository."
msgstr "Não há um pacote %s no repositório fornecido."

#: devel.R:30
msgid ""
"No revision information found in DESCRIPTION file for %s package. Make sure "
"that '%s' is correct field in PACKAGES file in your package repository '%s'. "
"Otherwise package will be re-installed every time, proceeding to "
"installation."
msgstr ""
"Nenhuma informação de revisão encontrada no arquivo DESCRIPTION para o "
"pacote %s. Certifique-se de que '%s' é o campo correto no arquivo PACKAGES "
"no seu repositório de pacotes '%s'. Caso contrário, o pacote será "
"reinstalado todas as vezes, prosseguindo para a instalação."

#: devel.R:39
msgid "R %s package has been updated to %s (%s)"
msgstr "Pacote %s do R foi atualizado para %s (%s)"

#: devel.R:41
msgid "R %s package is up-to-date at %s (%s)"
msgstr "Pacote %s do R está atualizado para %s (%s)"

#: devel.R:53
msgid ""
"Git revision is not available. Most likely data.table was installed from "
"CRAN or local archive.\n"
"Git revision is available when installing from our repositories 'https://"
"Rdatatable.gitlab.io/data.table' and 'https://Rdatatable.github.io/data."
"table'."
msgstr ""
"A revisão do Git não está disponível. Provavelmente data.table foi instalado "
"do CRAN ou do arquivo local.\n"
"A revisão do Git está disponível ao instalar de nossos repositórios 'https://"
"Rdatatable.gitlab.io/data.table' e 'https://Rdatatable.github.io/data.table'."

#: duplicated.R:7
#, c-format
msgid "'fromLast' must be TRUE or FALSE"
msgstr "'fromLast' deve ser TRUE ou FALSE"

#: duplicated.R:105
#, c-format
msgid "x must be an atomic vector or a data.frame/data.table"
msgstr "x deve ser um vetor atômico ou uma data.frame/data.table"

#: fcast.R:7
#, c-format
msgid "Using '%s' as value column. Use 'value.var' to override"
msgstr "Usando '%s'como coluna do valor. Use 'value.var' para contornar"

#: fcast.R:17
#, c-format
msgid ""
"The %1$s generic in data.table has been passed a %2$s, but data.table::%1$s "
"currently only has a method for data.tables. Please confirm your input is a "
"data.table, with setDT(%3$s) or as.data.table(%3$s). If you intend to use a "
"method from reshape2, try installing that package first, but do note that "
"reshape2 is superseded and is no longer actively developed."
msgstr ""
"Um %2$s foi passado para o genérico %1$s em data.table, mas atualmente data."
"table::%1$s só tem um método para data.tables. Favor garantir que a entrada "
"seja uma data.table, com setDT(%3$s) ou as.data.table(%3$s). Se você "
"pretende usar um método de reshape2, tente instalar aquele pacote primeiro, "
"mas note que reshape2 foi substituído e não está mais em desenvolvimento "
"ativo."

#: fcast.R:24
#, c-format
msgid ""
"Invalid formula. Cast formula should be of the form LHS ~ RHS, for e.g., a + "
"b ~ c."
msgstr ""
"Fórmula inválida. A fórmula do cast deveria ter o formato LHS ~ RHS (lado "
"esquerdo ~ lado direito), p. ex. a + b ~ c."

#: fcast.R:31
#, c-format
msgid "data.table to cast must have unique column names"
msgstr "a data.table a ser \"moldada\" deve ter nomes de coluna únicos"

#: fcast.R:76
#, c-format
msgid "value.var values %s are not found in 'data'."
msgstr "os valores de value.var  %s não se encontram em 'data'."

#: fcast.R:92
#, c-format
msgid ""
"When 'fun.aggregate' and 'value.var' are both lists, 'value.var' must be "
"either of length =1 or =length(fun.aggregate)."
msgstr ""
"Quando 'fun.aggregate' e 'value.var' são listas, o comprimento de 'value."
"var' deve ser ou =1 ou  =length(fun.aggregate)."

#: fcast.R:125
#, c-format
msgid "'data' must be a data.table."
msgstr "'data' deve ser uma data.table."

#: fcast.R:127
#, c-format
msgid "'drop' must be logical TRUE/FALSE"
msgstr "'drop' deve ser lógico TRUE/FALSE"

#: fcast.R:129
#, c-format
msgid "Argument 'value.var.in.dots' should be logical TRUE/FALSE"
msgstr "Argumento 'value.var.in.dots' deveria ser lógico TRUE/FALSE"

#: fcast.R:131
#, c-format
msgid ""
"Arguments 'value.var.in.LHSdots', 'value.var.in.RHSdots' should be logical "
"TRUE/FALSE"
msgstr ""
"Os argumentos 'value.var.in.LHSdots', 'value.var.in.RHSdots' deveriam ser "
"lógicos TRUE/FALSE"

#: fcast.R:148
#, c-format
msgid "Column [%s] not found or of unknown type."
msgstr "Coluna [%s] não encontrada ou de tipo desconhecido."

#: fcast.R:163
#, c-format
msgid "Columns specified in formula can not be of type list"
msgstr "Colunas especificadas na formula não podem ser do tipo lista"

#: fcast.R:178
#, c-format
msgid ""
"'fun.aggregate' is NULL, but found duplicate row/column combinations, so "
"defaulting to length(). That is, the variables %s used in 'formula' do not "
"uniquely identify rows in the input 'data'. In such cases, 'fun.aggregate' "
"is used to derive a single representative value for each combination in the "
"output data.table, for example by summing or averaging (fun.aggregate=sum or "
"fun.aggregate=mean, respectively). Check the resulting table for values "
"larger than 1 to see which combinations were not unique. See ?dcast.data."
"table for more details."
msgstr ""
"'fun.aggregate' é NULL, mas foram encontradas combinações duplicadas de "
"linha/coluna, então usando length() por padrão. Isso é, as variáveis %s "
"usadas em 'formula' não identificam de forma única as linhas na entrada "
"'data'. Em tais casos, 'fun.aggregate' é usado para derivar um único valor "
"representativo para cada combinação na data.table de saída, por exemplo "
"somando ou tirando a média (fun.aggregate=sum ou fun.aggregate=mean, "
"respectivamente). Verifique a tabela resultante por valores maiores do que 1 "
"para ver quais combinações não foram únicas. Veja ?dcast.data.table para "
"mais detalhes."

#: fcast.R:188
msgid ""
"Aggregating functions should take a vector as input and return a single "
"value (length=1), but they do not, so the result is undefined. Please fix by "
"modifying your function so that a single value is always returned."
msgstr ""
"Funções de agregação devem receber um vetor como entrada e retornar um único "
"valor (length=1), mas elas não o fazem, então o resultado é indefinido. "
"Favor corrigir isso modificando sua função de forma que um único valor seja "
"sempre retornado."

#: fdroplevels.R:12
#, c-format
msgid ""
"droplevels() with in.place=TRUE is deprecated. Use setdroplevels() instead."
msgstr ""
"droplevels() com in.place=TRUE está obsoleto. Use setdroplevels() em vez "
"disso."

#: fmelt.R:12
#, c-format
msgid ""
"The %1$s generic in data.table has been passed a %2$s and will attempt to "
"redirect to the relevant reshape2 method; please note that reshape2 is "
"superseded and is no longer actively developed, and this redirection is now "
"deprecated. To continue using melt methods from reshape2 while both packages "
"are attached, e.g. melt.list, you can prepend the namespace, i.e. reshape2::"
"%1$s(%3$s). In the next version, this warning will become an error."
msgstr ""
"Um %2$s foi passado para o genérico %1$s em data.table, que vai tentar "
"redirecionar para o método relevante no pacote reshape2; favor notar que "
"reshape2 foi substituído e não está mais em desenvolvimento ativo, e que "
"esse redirecionamento agora está obsoleto. Para continuar usando métodos "
"melt de reshape2 enquanto ambos os pacotes estão anexados, p.ex. melt.list, "
"você pode prefixar com o namespace, p.ex. reshape2::%1$s(%3$s). Na próxima "
"versão, este aviso se tornará um erro."

#: fmelt.R:19 fmelt.R:73
#, c-format
msgid "cols must be a character vector of column names"
msgstr "cols deve ser um vetor de caracteres de nomes de coluna"

#: fmelt.R:24
#, c-format
msgid "Input patterns must be of type character."
msgstr "Padrões de entrada devem ser do tipo caractere."

#: fmelt.R:42
#, c-format
msgid ""
"each ... argument to measure must be either a symbol without argument name, "
"or a function with argument name, problems: %s"
msgstr ""
"cada argumento ... para measure deve ser ou um símbolo sem nome de "
"argumento, ou uma função com nome de argumento, problemas: %s"

#: fmelt.R:50
#, c-format
msgid ""
"group names specified in ... conflict with measure argument names; please "
"fix by changing group names: %s"
msgstr ""
"nomes de grupo especificados em ... conflitam com nomes de argumento de "
"measures; favor consertar trocando os nomes de grupo: %s"

#: fmelt.R:56
#, c-format
msgid ""
"each ... argument to measure must be a function with at least one argument, "
"problem: %s"
msgstr ""
"cada ... argumento para measure deve ser uma função com ao menos um "
"argumento, problema: %s"

#: fmelt.R:67
#, c-format
msgid ""
"both sep and pattern arguments used; must use either sep or pattern (not "
"both)"
msgstr ""
"ambos os argumentos sep e pattern usados; deve usar ou sep, ou pattern (não "
"os dois)"

#: fmelt.R:70
#, c-format
msgid "multiple.keyword must be a character string with nchar>0"
msgstr "multiple.keyword deve ser uma string de caracteres com nchar>0"

#: fmelt.R:81
#, c-format
msgid "in measurev, elements of fun.list must be named, problems: %s"
msgstr "em measurev, elementos de fun.list devem ser nomeados, problemas: %s"

#: fmelt.R:84
#, c-format
msgid "elements of fun.list should be uniquely named, problems: %s"
msgstr ""
"elementos de fun.list devem ser nomeados de forma unívoca, problemas: %s"

#: fmelt.R:89
#, c-format
msgid "pattern must be character string"
msgstr "pattern deve ser uma string de caracteres"

#: fmelt.R:94
#, c-format
msgid ""
"pattern did not match any cols, so nothing would be melted; fix by changing "
"pattern"
msgstr ""
"pattern não coincidiu com nenhuma coluna, então nada será \"derretido\"; "
"corrija mudando o padrão"

#: fmelt.R:98
#, c-format
msgid ""
"pattern must contain at least one capture group (parenthesized sub-pattern)"
msgstr ""
"pattern deve conter pelo menos um grupo de captura (subpadrão entre "
"parênteses)"

#: fmelt.R:101
#, c-format
msgid ""
"number of elements of fun.list (%d) must be the same as the number of "
"capture groups in pattern (%d)"
msgstr ""
"número de elementos de fun.list (%d) deve ser o mesmo que o número de grupos "
"de captura no padrão (%d)"

#: fmelt.R:109
#, c-format
msgid "sep must be character string"
msgstr "sep deve ser uma string de caracteres"

#: fmelt.R:115
#, c-format
msgid ""
"each column name results in only one item after splitting using sep, which "
"means that all columns would be melted; to fix please either specify melt on "
"all columns directly without using measure, or use a different sep/pattern "
"specification"
msgstr ""
"cada nome de coluna resulta em apenas um item após dividir usando sep, o que "
"significa que todas as colunas seriam \"derretidas\"; para consertar, favor "
"ou especificar o \"derretimento\" em todas as colunas diretamente sem usar "
"'measure', ou especifique um sep/pattern diferente"

#: fmelt.R:118
#, c-format
msgid ""
"number of elements of fun.list (%d) must be the same as the max number of "
"items after splitting column names (%d)"
msgstr ""
"número de elementos de fun.list (%d) deve ser o mesmo que o número máximo de "
"itens após dividir os nomes de coluna (%d)"

#: fmelt.R:125
#, c-format
msgid "measured columns should be uniquely named, problems: %s"
msgstr "colunas de medida deveriam receber nomes únicos, problemas: %s"

#: fmelt.R:129
#, c-format
msgid ""
"number of unique column IDs =%d is less than number of melted columns =%d; "
"fix by changing pattern/sep"
msgstr ""
"o número de colunas de identificação únicas = %d é menor do que o número de "
"colunas \"derretidas\" = %d; conserte trocando pattern/sep"

#: fmelt.R:139
#, c-format
msgid ""
"in the measurev fun.list, each non-NULL element must be a function with at "
"least one argument, problem: %s"
msgstr ""
"na fun.list de measurev, cada elemento não-NULL deve ser uma função com ao "
"menos um argumento, problema: %s"

#: fmelt.R:143
#, c-format
msgid ""
"each conversion function must return an atomic vector with same length as "
"its first argument, problem: %s"
msgstr ""
"cada função de conversão deve retornar um vetor atômico com o mesmo "
"comprimento que seu primeiro argumento, problema: %s"

#: fmelt.R:146
#, c-format
msgid "%s conversion function returned vector of all NA"
msgstr "função de conversão %s retornou um vetor inteiro de NA"

#: fmelt.R:152
#, c-format
msgid ""
"number of unique groups after applying type conversion functions less than "
"number of groups, change type conversion"
msgstr ""
"o número de grupos únicos depois de aplicar funções de conversão de tipo é "
"menor do que o número de grupos, mude a conversão de tipo"

#: fmelt.R:157
#, c-format
msgid ""
"%s column class=%s after applying conversion function, but must be character"
msgstr ""
"coluna %s com classe=%s depois de aplicar função de conversão, mas tem que "
"ser caractere"

#: fmelt.R:161
#, c-format
msgid "%s is the only group; fix by creating at least one more group"
msgstr "%s é o único grupo; conserte criando ao menos mais um grupo"

#: fmelt.R:184
#, c-format
msgid "'data' must be a data.table"
msgstr "'data' deve ser uma data.table"

#: fmelt.R:203
#, c-format
msgid ""
"'value.name' provided in both 'measure.vars' and 'value.name argument'; "
"value provided in 'measure.vars' is given precedence."
msgstr ""
"'value.name' fornecido tanto em 'measure.vars' quanto no argumento 'value."
"name'; o valor fornecido em 'measure.vars' tem precedência"

#: fmelt.R:206
#, c-format
msgid "Please provide a name to each element of 'measure.vars'."
msgstr "Favor fornecer um nome para cada elemento de 'measure.vars'."

#: fmelt.R:217
msgid ""
"Duplicate column names found in molten data.table. Setting unique names "
"using 'make.names'"
msgstr ""
"Nomes de colunas duplicados encontrados em data.table 'derretida'. Definindo "
"nomes exclusivos usando 'make.names'"

#: foverlaps.R:3
#, c-format
msgid ""
"y and x must both be data.tables. Use `setDT()` to convert list/data.frames "
"to data.tables by reference or as.data.table() to convert to data.tables by "
"copying."
msgstr ""
"y e x devem ambos serem data.tables. Use `setDT()` para converter listas e "
"data.frames para data.tables por referência ou as.data.table() para "
"converter para data.tables copiando."

#: foverlaps.R:9
#, c-format
msgid "maxgap must be a non-negative integer value of length 1"
msgstr "maxgap deve ser um valor inteiro não-negativo de comprimento 1"

#: foverlaps.R:11
#, c-format
msgid "minoverlap must be a positive integer value of length 1"
msgstr "minoverlap deve ser um valor inteiro positivo de comprimento 1"

#: foverlaps.R:13
#, c-format
msgid "which must be a logical vector of length 1. Either TRUE/FALSE"
msgstr "which deve ser um vetor lógico de comprimento 1. TRUE ou FALSE"

#: foverlaps.R:15
#, c-format
msgid "nomatch must either be NA or NULL"
msgstr "nomatch deve ser ou NA ou NULL"

#: foverlaps.R:20
#, c-format
msgid "maxgap and minoverlap arguments are not yet implemented."
msgstr "argumentos maxgap e minoverlap  ainda não estão implementados."

#: foverlaps.R:22
#, c-format
msgid ""
"y must be keyed (i.e., sorted, and, marked as sorted). Call setkey(y, ...) "
"first, see ?setkey. Also check the examples in ?foverlaps."
msgstr ""
"y deve ser chaveada (ou seja, ordenada e marcada como ordenada). Chame "
"setkey(y, …) primeiro, veja ?setkey. Também confira os exemplos em ?"
"foverlaps."

#: foverlaps.R:24
#, c-format
msgid ""
"'by.x' and 'by.y' should contain at least two column names (or numbers) each "
"- corresponding to 'start' and 'end' points of intervals. Please see ?"
"foverlaps and examples for more info."
msgstr ""
"'by.x' e 'by.y' deveriam conter ao menos dois nomes de coluna (ou números) "
"cada - correspondendo aos pontos de início e fim dos intervalos. Favor ver ?"
"foverlaps e exemplos para mais informação. "

#: foverlaps.R:27
#, c-format
msgid ""
"Invalid numeric value for 'by.x'; it should be a vector with values 1 <= by."
"x <= length(x)"
msgstr ""
"Valor numérico inválido para 'by.x'; deveria ser um vetor com valores 1 <= "
"by.x <= length(x)"

#: foverlaps.R:32
#, c-format
msgid ""
"Invalid numeric value for 'by.y'; it should be a vector with values 1 <= by."
"y <= length(y)"
msgstr ""
"Valor numérico inválido para 'by.y'; deveria ser um vetor com valores 1 <= "
"by.y <= length(y)"

#: foverlaps.R:36
#, c-format
msgid "A non-empty vector of column names or numbers is required for by.x"
msgstr ""
"Um vetor não-vazio de nomes ou números de coluna é necessário para by.x"

#: foverlaps.R:38
#, c-format
msgid "A non-empty vector of column names or numbers is required for by.y"
msgstr ""
"Um vetor não-vazio de nomes ou números de coluna é necessário para by.y"

#: foverlaps.R:40
#, c-format
msgid ""
"The first %d columns of y's key must be identical to the columns specified "
"in by.y."
msgstr ""
"As primeiras %d colunas da chave de y devem ser idênticas às colunas "
"especificadas em by.y."

#: foverlaps.R:42
#, c-format
msgid "Elements listed in 'by.x' must be valid names in data.table x"
msgstr "Elementos listados em 'by.x' devem ser nomes válidos na data.table x"

#: foverlaps.R:44
#, c-format
msgid ""
"Duplicate columns are not allowed in overlap joins. This may change in the "
"future."
msgstr ""
"Colunas duplicadas não são permitidas em junções de sobreposição. Isso pode "
"mudar no futuro."

#: foverlaps.R:46
#, c-format
msgid ""
"length(by.x) != length(by.y). Columns specified in by.x should correspond to "
"columns specified in by.y and should be of same lengths."
msgstr ""
"length(by.x) != length(by.y). As colunas especificadas em by.x deveriam "
"corresponder às colunas especificadas em by.y, e os argumentos deveriam ser "
"do mesmo comprimento."

#: foverlaps.R:57
#, c-format
msgid ""
"The last two columns in by.x should correspond to the 'start' and 'end' "
"intervals in data.table x and must be integer/numeric type."
msgstr ""
"As últimas duas colunas em by.x deveriam corresponder às colunas de início e "
"de fim dos intervalos na data.table x e devem ser do tipo inteiro/numérico."

#: foverlaps.R:61 foverlaps.R:63 foverlaps.R:70 foverlaps.R:72
#, c-format
msgid ""
"NA values in data.table %s '%s' column: '%s'. All rows with NA values in the "
"range columns must be removed for foverlaps() to work."
msgstr ""
"Valores NA na coluna %s '%s' da data.table: '%s'. Todas as linhas com "
"valores NA nas colunas de intervalo devem ser removidas para o foverlaps() "
"funcionar."

#: foverlaps.R:64
#, c-format
msgid ""
"All entries in column '%s' should be <= corresponding entries in column '%s' "
"in data.table x."
msgstr ""
"Todas as entradas na coluna '%s' deveriam ser <= as entradas correspondentes "
"na coluna '%s' na data.table x."

#: foverlaps.R:67
#, c-format
msgid ""
"The last two columns in by.y should correspond to the 'start' and 'end' "
"intervals in data.table y and must be integer/numeric type."
msgstr ""
"As últimas duas colunas em by.y deveriam corresponder às colunas de início e "
"de fim dos intervalos na data.table y e devem ser do tipo inteiro/numérico."

#: foverlaps.R:73
#, c-format
msgid ""
"All entries in column '%s' should be <= corresponding entries in column '%s' "
"in data.table y."
msgstr ""
"Todas as entradas na coluna '%s' deveriam ser <= as entradas correspondentes "
"na coluna '%s' na data.table y."

#: foverlaps.R:78
#, c-format
msgid ""
"Some interval cols are of type POSIXct while others are not. Please ensure "
"all interval cols are (or are not) of POSIXct type"
msgstr ""
"Algumas colunas de intervalo são do tipo POSIXct, enquanto outras não são. "
"Favor garantir que todas as colunas de intervalo sejam (ou todas não sejam) "
"to tipo POSIXct"

#: foverlaps.R:84
#, c-format
msgid ""
"POSIXct interval cols have mixed timezones. Overlaps are performed on the "
"internal numerical representation of POSIXct objects (always in UTC epoch "
"time), therefore printed values may give the impression that values don't "
"overlap but their internal representations do Please ensure that POSIXct "
"type interval cols have identical 'tzone' attributes to avoid confusion."
msgstr ""
"Colunas de intervalo POSIXct têm fusos horários diferentes. As sobreposições "
"são realizadas na representação numérica dos objetos POSIXct (sempre em UTC, "
"era UNIX), de forma que os valores exibidos podem dar a impressão de que os "
"valores não se sobrepõem mas suas representações internas se sobrepõem. "
"Favor garantir que as colunas de intervalo do tipo POSIXct tenham atributos "
"'tzone' idênticos para evitar confusão."

#: foverlaps.R:132
msgid "unique() + setkey() operations done in ..."
msgstr "operações unique() + setkey() concluídas em ..."

#: foverlaps.R:158
msgid "binary search(es) done in ..."
msgstr "pesquisa(s) binária(s) concluída(s) em ..."

#: foverlaps.R:165 foverlaps.R:167 foverlaps.R:171
#, c-format
msgid "Not yet implemented"
msgstr "Ainda não implementado"

#: foverlaps.R:170
#, c-format
msgid "maxgap > minoverlap. maxgap will have no effect here."
msgstr "maxgap > minoverlap. maxgap não terá efeito aqui."

#: frank.R:3
#, c-format
msgid "length(na.last) = 0"
msgstr "length(na.last) = 0"

#: frank.R:5
#, c-format
msgid "length(na.last) > 1, only the first element will be used"
msgstr "length(na.last) > 1, apenas o primeiro item será usado"

#: frank.R:17
#, c-format
msgid "x is a single vector, non-NULL 'cols' doesn't make sense"
msgstr "x é um vetor simples, 'cols' não-NULL não faz sentido"

#: frank.R:23
#, c-format
msgid "x is a list, 'cols' can not be 0-length"
msgstr "x é uma lista, 'cols' não pode ser de comprimento 0"

#: frank.R:31
#, c-format
msgid ""
"Input column '..na_prefix..' conflicts with data.table internal usage; "
"please rename"
msgstr ""
"Coluna de entrada '..na_prefix..' conflita com utilização interna por data."
"table; favor renomear"

#: frank.R:46
#, c-format
msgid ""
"Input column '..stats_runif..' conflicts with data.table internal usage; "
"please rename"
msgstr ""
"Coluna de entrada '..stats_runif..' conflita com utilização interna por data."
"table; favor renomear"

#: fread.R:12
#, c-format
msgid "Used more than one of the arguments input=, file=, text= and cmd=."
msgstr "Usados mais de um dos argumentos input=, file=, text= e cmd=."

#: fread.R:25
#, c-format
msgid "Argument 'encoding' must be 'unknown', 'UTF-8' or 'Latin-1'."
msgstr "Argumento 'encoding' deve ser 'unknown', 'UTF-8' ou 'Latin-1'."

#: fread.R:44
#, c-format
msgid "'text=' is type %s but must be character."
msgstr "'text=' é do tipo %s, mas deve ser caractere."

#: fread.R:57
#, c-format
msgid ""
"input= must be a single character string containing a file name, a system "
"command containing at least one space, a URL starting 'http[s]://', "
"'ftp[s]://' or 'file://', or, the input data itself containing at least one "
"\\n or \\r"
msgstr ""
"input= deve ser uma única sequência de caracteres contendo um nome de "
"arquivo, um comando do sistema contendo pelo menos um espaço, uma URL "
"começando com 'http[s]://', ​​'ftp[s]://' ou 'file://', ou os próprios dados "
"de entrada contendo pelo menos um entre \\n ou \\r"

#: fread.R:62
#, c-format
msgid ""
"input= contains no \\n or \\r, but starts with a space. Please remove the "
"leading space, or use text=, file= or cmd="
msgstr ""
"input= não contém \\n ou \\r, mas começa com um espaço. Por favor, remova o "
"espaço inicial ou use text=, file= ou cmd="

#: fread.R:66
#, c-format
msgid ""
"Taking input= as a system command because it contains a space ('%s'). If "
"it's a filename please remove the space, or use file= explicitly. A variable "
"is being passed to input= and when this is taken as a system command there "
"is a security concern if you are creating an app, the app could have a "
"malicious user, and the app is not running in a secure environment; e.g. the "
"app is running as root. Please read item 5 in the NEWS file for v1.11.6 for "
"more information and for the option to suppress this message."
msgstr ""
"Considerando input= como um comando do sistema porque contém um espaço "
"('%s'). Se for um nome de arquivo, remova o espaço ou use file= "
"explicitamente. Uma variável está sendo passada para input= e quando isso é "
"considerado um comando do sistema, há uma preocupação de segurança se você "
"estiver criando um aplicativo, o aplicativo pode ter um usuário mal-"
"intencionado e o aplicativo não está sendo executado em um ambiente seguro; "
"por exemplo. o aplicativo está sendo executado como root. Leia o item 5 no "
"arquivo NEWS da versão 1.11.6 para obter mais informações e para a opção de "
"suprimir esta mensagem."

#: fread.R:79
#, c-format
msgid ""
"file= must be a single character string containing a filename, or URL "
"starting 'http[s]://', 'ftp[s]://' or 'file://'"
msgstr ""
"file= deve ser uma única sequência de caracteres contendo um nome de arquivo "
"ou URL começando com 'http[s]://', ​​'ftp[s]://' ou 'file://'"

#: fread.R:92
#, c-format
msgid "File '%s' does not exist or is non-readable. getwd()=='%s'"
msgstr "O arquivo '%s' não existe ou não é legível. getwd()=='%s'"

#: fread.R:93
#, c-format
msgid "File '%s' is a directory. Not yet implemented."
msgstr "O arquivo '%s' é um diretório. Ainda não implementado."

#: fread.R:95
#, c-format
msgid "File '%s' has size 0. Returning a NULL %s."
msgstr "O arquivo '%s' tem tamanho 0. Retornando NULL %s."

#: fread.R:107
#, c-format
msgid ""
"Compressed files containing more than 1 file are currently not supported."
msgstr ""
"Arquivos compactados contendo mais de 1 arquivo não são suportados "
"atualmente."

#: fread.R:117
#, c-format
msgid ""
"To read %s files directly, fread() requires 'R.utils' package which cannot "
"be found. Please install 'R.utils' using 'install.packages('R.utils')'."
msgstr ""
"Para ler arquivos %s diretamente, fread() requer o pacote 'R.utils' que não "
"pôde ser encontrado. Instale 'R.utils' usando 'install.packages('R.utils')'."

#: fread.R:127
#, c-format
msgid ""
"'autostart' is deprecated. Consider skip='string' or skip=n. This argument "
"will be removed in the next release."
msgstr ""
"'autostart' é obsoleto. Considere skip='string' ou skip=n. Esse argumento "
"será removido no próximo lançamento."

#: fread.R:129
#, c-format
msgid ""
"colClasses is type 'logical' which is ok if all NA but it has some TRUE or "
"FALSE values in it which is not allowed. Please consider the drop= or "
"select= argument instead. See ?fread."
msgstr ""
"colClasses é do tipo 'logical', que está tudo bem se for todo NA, mas "
"contiver alguns valores TRUE ou FALSE que não são permitidos. Por favor, "
"considere o argumento drop= ou select=. Veja ?fread."

#: fread.R:133
#, c-format
msgid "colClasses is not type list or character vector"
msgstr "colClasses não é lista de tipos ou vetor de caracteres"

#: fread.R:138
#, c-format
msgid ""
"colClasses=\"NULL\" (quoted) is interpreted as colClasses=NULL (the default) "
"as opposed to dropping every column."
msgstr ""
"colClasses=\"NULL\" (entre aspas) é interpretado como colClasses=NULL (o "
"padrão) em vez de descartar todas as colunas."

#: fread.R:150
#, c-format
msgid "na.strings[%d]==\"%s\" consists only of whitespace, ignoring"
msgstr "na.strings[%d]==\"%s\" consiste apenas em espaços em branco, ignorando"

#: fread.R:153
#, c-format
msgid ""
"%s. Since strip.white=TRUE (default), use na.strings=\"\" to specify that "
"any number of spaces in a string column should be read as <NA>."
msgstr ""
"%s. Como strip.white=TRUE (padrão), use na.strings=\"\" para especificar que "
"qualquer número de espaços em uma coluna de string deve ser lido como <NA>."

#: fread.R:155
#, c-format
msgid ""
"%s. strip.white==TRUE (default) and \"\" is present in na.strings, so any "
"number of spaces in string columns will already be read as <NA>."
msgstr ""
"%s. strip.white==TRUE (padrão) e \"\" está presente em na.strings, portanto "
"qualquer número de espaços nas colunas de string já será lido como <NA>."

#: fread.R:159
#, c-format
msgid ""
"%s. But strip.white=FALSE. Use strip.white=TRUE (default) together with na."
"strings=\"\" to turn any number of spaces in string columns into <NA>"
msgstr ""
"%s. Mas strip.white=FALSE. Use strip.white=TRUE (padrão) junto com na."
"strings=\"\" para transformar qualquer número de espaços em colunas de "
"strings em <NA>"

#: fread.R:166
#, c-format
msgid ""
"'data.table' relies on the package 'yaml' to parse the file header; please "
"add this to your library with install.packages('yaml') and try again."
msgstr ""
"'data.table' depende do pacote 'yaml' para analisar o cabeçalho do arquivo; "
"adicione isso à sua biblioteca com install.packages('yaml') e tente "
"novamente."

#: fread.R:170
#, c-format
msgid ""
"Combining a search string as 'skip' and reading a YAML header may not work "
"as expected -- currently, reading will proceed to search for 'skip' from the "
"beginning of the file, NOT from the end of the metadata; please file an "
"issue on GitHub if you'd like to see more intuitive behavior supported."
msgstr ""
"Combinar uma string de pesquisa como 'skip' e ler um cabeçalho YAML pode não "
"funcionar como esperado -- atualmente, a leitura continuará a procurar por "
"'skip' desde o início do arquivo, NÃO a partir do final dos metadados; por "
"favor, registre um issue no GitHub se desejar ver suporte para um "
"comportamento mais intuitivo."

#: fread.R:180
#, c-format
msgid ""
"Encountered <%s%s> at the first unskipped line (%d), which does not "
"constitute the start to a valid YAML header (expecting something matching "
"regex \"%s\"); please check your input and try again."
msgstr ""
"Encontrado <%s%s> na primeira linha não ignorada (%d), que não constitui o "
"início de um cabeçalho YAML válido (esperando algo correspondente à regex "
"\"%s\"); verifique sua entrada e tente novamente."

#: fread.R:192
#, c-format
msgid ""
"Reached the end of the file before finding a completion to the YAML header. "
"A valid YAML header is bookended by lines matching the regex \"%s\". Please "
"double check the input file is a valid csvy."
msgstr ""
"Chegou ao final do arquivo antes de encontrar uma conclusão no cabeçalho "
"YAML. Um cabeçalho YAML válido é delimitado por linhas que correspondem à "
"regex \"%s\". Verifique novamente se o arquivo de entrada é um csvy válido."

#: fread.R:203
msgid ""
"Processed %d lines of YAML metadata with the following top-level fields: %s"
msgstr ""
"Processadas %d linhas de metadados YAML com os seguintes campos de nível "
"superior: %s"

#: fread.R:206
#, c-format
msgid "User-supplied 'header' will override that found in metadata."
msgstr ""
"O 'header' fornecido pelo usuário substituirá o encontrado nos metadados."

#: fread.R:224
#, c-format
msgid ""
"User-supplied column names in 'col.names' will override those found in YAML "
"metadata."
msgstr ""
"Os nomes de colunas fornecidos pelo usuário em 'col.names' substituirão "
"aqueles encontrados nos metadados YAML."

#: fread.R:233
#, c-format
msgid ""
"colClasses dictated by user input and those read from YAML header are in "
"conflict (specifically, for column(s) [%s]); the proceeding assumes the user "
"input was an intentional override and will ignore the type(s) implied by the "
"YAML header; please exclude the column(s) from colClasses if this was "
"unintentional."
msgstr ""
"colClasses ditadas pela entrada do usuário e aquelas lidas do cabeçalho YAML "
"estão em conflito (especificamente, para coluna(s) [%s]); o processo "
"pressupõe que a entrada do(a) usuário(a) foi uma substituição intencional e "
"ignorará o(s) tipo(s) implícito(s) no cabeçalho YAML; exclua a(s) coluna(s) "
"de colClasses se isso não for intencional."

#: fread.R:254
#, c-format
msgid "User-supplied 'sep' will override that found in metadata."
msgstr "O 'sep' fornecido pelo usuário substituirá o encontrado nos metadados."

#: fread.R:259
#, c-format
msgid "User-supplied 'quote' will override that found in metadata."
msgstr ""
"O 'quote' fornecido pelo(a) usuário(a) substituirá a encontrada nos "
"metadados."

#: fread.R:264
#, c-format
msgid "User-supplied 'dec' will override that found in metadata."
msgstr ""
"O 'dec' fornecido pelo(a) usuário(a) substituirá o encontrado nos metadados."

#: fread.R:268
#, c-format
msgid "User-supplied 'na.strings' will override that found in metadata."
msgstr ""
"O 'na.strings' fornecido pelo(a) usuário(a) substituirá a encontrada nos "
"metadados."

#: fread.R:320
msgid ""
"Column '%s' was requested to be '%s' but fread encountered the following "
"warning:\n"
"\t%s\n"
"so the column has been left as type '%s'"
msgstr ""
"Foi solicitado que a coluna '%s' seja '%s', mas fread encontrou o seguinte "
"aviso:\n"
"\t%s\n"
"então a coluna foi deixada como tipo '%s'"

#: fread.R:322
msgid ""
"Column '%s' was requested to be '%s' but fread encountered the following "
"error:\n"
"\t%s\n"
"so the column has been left as type '%s'"
msgstr ""
"Foi solicitado que a coluna '%s' seja '%s', mas fread encontrou o seguinte "
"erro:\n"
"\t%s\n"
"então a coluna foi deixada como tipo '%s'"

#: fread.R:349
#, c-format
msgid ""
"key argument of data.table() must be a character vector naming columns (NB: "
"col.names are applied before this)"
msgstr ""
"O argumento key de data.table() deve ser um vetor de caracteres que nomeia "
"colunas (Nota: col.names são aplicados antes disso)"

#: fread.R:357
#, c-format
msgid ""
"index argument of data.table() must be a character vector naming columns "
"(NB: col.names are applied before this)"
msgstr ""
"O argumento index do data.table() deve ser um vetor de caracteres que nomeia "
"colunas (Nota: col.names são aplicados antes disso)"

#: fwrite.R:20
#, c-format
msgid "Argument 'encoding' must be '', 'UTF-8' or 'native'."
msgstr "Argumento 'encoding' deve ser '', 'UTF-8' ou 'native'."

#: fwrite.R:27
#, c-format
msgid "logicalAsInt has been renamed logical01 for consistency with fread."
msgstr "logicalAsInt foi renomeado para logical01 para consistência com fread."

#: fwrite.R:36
#, c-format
msgid "x being coerced from class: matrix to data.table"
msgstr "fazendo coerção de x da classe matrix para data.table"

#: fwrite.R:70
msgid "Appending to existing file so setting bom=FALSE and yaml=FALSE"
msgstr "Anexando ao arquivo existente, definindo bom=FALSE e yaml=FALSE"

#: fwrite.R:83
#, c-format
msgid ""
"If you intended to overwrite the file at %s with an empty one, please use "
"file.remove first."
msgstr ""
"Se você pretendia sobrescrever o arquivo em %s com um vazio, por favor, use "
"file.remove primeiro."

#: fwrite.R:84
#, c-format
msgid "Input has no columns; doing nothing.%s"
msgstr "Entrada não tem colunas; não há nada a fazer.%s"

#: fwrite.R:87
#, c-format
msgid "Input has no columns; creating an empty file at '%s' and exiting."
msgstr "Entrada não tem colunas; criando um arquivo vazio em '%s' e saindo."

#: fwrite.R:95
#, c-format
msgid ""
"'data.table' relies on the package 'yaml' to write the file header; please "
"add this to your library with install.packages('yaml') and try again."
msgstr ""
"'data.table' depende do pacote 'yaml' para escrever o cabeçalho do arquivo; "
"por favor, adicione isso à sua biblioteca com install.packages('yaml') e "
"tente novamente."

#: groupingsets.R:7 groupingsets.R:25 groupingsets.R:47
#, c-format
msgid "Argument 'x' must be a data.table object"
msgstr "Argumento 'x' deve ser um objeto data.table"

#: groupingsets.R:9 groupingsets.R:27 groupingsets.R:53
#, c-format
msgid ""
"Argument 'by' must be a character vector of column names used in grouping."
msgstr ""
"Argumento 'by' deve ser um vetor de caracteres de nomes de colunas usados em "
"agrupamento."

#: groupingsets.R:11 groupingsets.R:29 groupingsets.R:59
#, c-format
msgid "Argument 'id' must be a logical scalar."
msgstr "Argumento 'id' deve ser um escalar lógico."

#: groupingsets.R:31
#, c-format
msgid "Argument 'j' is required"
msgstr "Argumento 'j' é obrigatório"

#: groupingsets.R:49
#, c-format
msgid ""
"Argument 'x' is a 0-column data.table; no measure to apply grouping over."
msgstr ""
"Argumento 'x' é um data.table com 0 colunas; nenhuma medida para aplicar "
"sobre o agrupamento."

#: groupingsets.R:51
#, c-format
msgid "Input data.table must not contain duplicate column names."
msgstr "A data.table de entrada não deve conter nomes de colunas duplicados."

#: groupingsets.R:55
#, c-format
msgid "Argument 'by' must have unique column names for grouping."
msgstr "Argumento 'by' deve ter nomes de colunas únicos para agrupamento."

#: groupingsets.R:57
#, c-format
msgid "Argument 'sets' must be a list of character vectors."
msgstr "Argumento 'sets' deve ser uma lista de vetores de caracteres."

#: groupingsets.R:63
#, c-format
msgid ""
"Argument 'label', if not NULL, must be a scalar or a named list of scalars."
msgstr ""
"O argumento 'label', se não NULL, deve ser um escalar ou uma lista nomeada "
"de escalares."

#: groupingsets.R:65
#, c-format
msgid ""
"When argument 'label' is a list, all of the list elements must be named."
msgstr ""
"Quando o argumento 'label' é uma lista, todos os elementos da lista devem "
"ser nomeados."

#: groupingsets.R:67
#, c-format
msgid ""
"When argument 'label' is a list, the element names must not contain "
"duplicates."
msgstr ""
"Quando o argumento 'label' é uma lista, os nomes dos elementos não devem "
"conter duplicatas."

#: groupingsets.R:70
#, c-format
msgid ""
"All columns used in 'sets' argument must be in 'by' too. Columns used in "
"'sets' but not present in 'by': %s"
msgstr ""
"Todas as colunas usadas no argumento 'sets' também devem estar em 'by'. "
"Colunas usadas em 'sets', mas não presentes em 'by': %s"

#: groupingsets.R:72
#, c-format
msgid ""
"When using `id=TRUE` the 'x' data.table must not have a column named "
"'grouping'."
msgstr ""
"Ao usar `id=TRUE`, o data.table 'x' não deve ter uma coluna chamada "
"'grouping'."

#: groupingsets.R:74
#, c-format
msgid ""
"Character vectors in 'sets' list must not have duplicated column names "
"within a single grouping set."
msgstr ""
"Vetores de caracteres na lista 'sets' não devem ter nomes de colunas "
"duplicados dentro de um único conjunto de agrupamento."

#: groupingsets.R:76
#, c-format
msgid ""
"'sets' contains a duplicate (i.e., equivalent up to sorting) element at "
"index %d; as such, there will be duplicate rows in the output -- note that "
"grouping by A,B and B,A will produce the same aggregations. Use "
"`sets=unique(lapply(sets, sort))` to eliminate duplicates."
msgstr ""
"'sets' contém um elemento duplicado (isto é, equivalente até a ordenação) no "
"índice %d; assim, haverá linhas duplicadas na saída -- note que agrupar por "
"A,B e B,A produzirá as mesmas agregações. Use `sets=unique(lapply(sets, "
"sort))` para eliminar duplicados."

#: groupingsets.R:82
#, c-format
msgid ""
"When argument 'label' is a list, all element names must be (1) in 'by', or "
"(2) the first element of the class in the data.table 'x' of a variable in "
"'by', or (3) one of %s. Element names not satisfying this condition: %s"
msgstr ""
"Quando o argumento 'label' é uma lista, todos os elementos devem (1) estar "
"em 'by', ou (2) ser o primeiro elemento da classe na data.table 'x' da "
"variável em 'by', ou (3) ser um de %s. Nomes de elementos que não satisfazem "
"essa condição: %s"

#: groupingsets.R:92
#, c-format
msgid "%s (label: %s; data: %s)"
msgstr "%s (label: %s; dados: %s)"

#: groupingsets.R:96
#, c-format
msgid ""
"When argument 'label' is a list, the class of each 'label' element with name "
"in 'by' must match the class of the corresponding column of the data.table "
"'x'. Class mismatch for: %s"
msgstr ""
"Quando o argumento 'label' é uma lista, a classe de cada elemento 'label' "
"com nome em 'by' deve corresponder à classe da respectiva coluna na "
"data.table 'x'. Incompatibilidade de classe para: %s"

#. Mantendo 'label' em inglês porque isto enumera erros no argumento 'label' de
#.   uma função. class[1] se refere ao primeiro item da saída da função class().
#.   Dá para jogar a primeira parte mais para o inglês e a segunda mais para o
#.   português
#: groupingsets.R:100
#, c-format
msgid "(label name: %s; label class[1]: %s)"
msgstr "(label com nome %s e class[1]: %s)"

#: groupingsets.R:103
#, c-format
msgid ""
"When argument 'label' is a list, the name of each element of 'label' not in "
"'by' must match the first element of the class of the element value. "
"Mismatches: %s"
msgstr ""
"Quando o argumento 'label' é uma lista, o nome de cada elemento de 'label' "
"não em 'by' deve corresponder ao primeiro elemento de cada classe do valor "
"do elemento. Incompatibilidades: %s"

#: groupingsets.R:110
#, c-format
msgid ""
"Expression passed to grouping sets function must not update by reference. "
"Use ':=' on results of your grouping function."
msgstr ""
"Expressão passada para a função de conjuntos de agrupamento não deve "
"atualizar por referência. Use ':=' nos resultados da sua função de "
"agrupamento."

#: groupingsets.R:117
#, c-format
msgid ""
"When using `id=TRUE` the 'j' expression must not evaluate to a column named "
"'grouping'."
msgstr ""
"Ao usar `id=TRUE`, a expressão 'j' não deve avaliar para uma coluna chamada "
"'grouping'."

#: groupingsets.R:119
#, c-format
msgid ""
"There exists duplicated column names in the results, ensure the column "
"passed/evaluated in `j` and those in `by` are not overlapping."
msgstr ""
"Existem nomes de colunas duplicados nos resultados, certifique-se de que a "
"coluna passada/avaliada em `j` e as em `by` não se sobreponham."

#: groupingsets.R:142
#, c-format
msgid "%s (label: %s)"
msgstr "%s (label: %s)"

#: groupingsets.R:143
#, c-format
msgid ""
"For the following variables, the 'label' value was already in the data: %s"
msgstr "Para as seguintes variáveis, o valor 'label' já estava nos dados: %s"

#: groupingsets.R:150
#, c-format
msgid ""
"Using integer64 class columns require to have 'bit64' package installed."
msgstr ""
"Utilizando colunas da classe integer64 requer a instalação do pacote 'bit64'."

#: last.R:11 last.R:16 last.R:24 last.R:29 last.R:33 last.R:41 last.R:52
#: last.R:57 last.R:65 last.R:70 last.R:74 last.R:82
msgid "%s: using %s: %s"
msgstr "%s: usando %s: %s"

#: last.R:39 last.R:80
#, c-format
msgid ""
"'xts' class passed to %s function but 'xts' is not available, you should "
"have 'xts' installed already"
msgstr ""
"classe 'xts' foi passada para a função %s, mas 'xts' não está disponível. "
"Você deveria já ter 'xts' instalado"

#: merge.R:4
#, c-format
msgid "Argument 'sort' should be logical TRUE/FALSE"
msgstr "Argumento 'sort' deve ser lógico TRUE/FALSE"

#: merge.R:6
#, c-format
msgid "Argument 'no.dups' should be logical TRUE/FALSE"
msgstr "Argumento 'no.dups' deve ser lógico TRUE/FALSE"

#: merge.R:18
#, c-format
msgid "Neither of the input data.tables to join have columns."
msgstr "Nenhuma das data.tables de entrada para junção tem colunas."

#: merge.R:20 merge.R:22
#, c-format
msgid "Input data.table '%s' has no columns."
msgstr "data.table de entrada '%s' não tem colunas."

#: merge.R:32
#, c-format
msgid "`by.x` and `by.y` must be of same length."
msgstr "`by.x` e `by.y` devem ter o mesmo comprimento."

#: merge.R:34
#, c-format
msgid "Supplied both `by` and `by.x`/`by.y`. `by` argument will be ignored."
msgstr ""
"Foram fornecidos ambos `by` e `by.x/by.y`. O argumento `by` será ignorado."

#: merge.R:37
#, c-format
msgid "A non-empty vector of column names is required for `by.x` and `by.y`."
msgstr ""
"Um vetor não vazio de nomes de colunas é necessário para `by.x` e `by.y`."

#: merge.R:39 merge.R:42 merge.R:56 merge.R:59
#, c-format
msgid "The following columns listed in `%s` are missing from %s: %s"
msgstr "As seguintes colunas listadas em `%s` estão faltando em %s: %s"

#: merge.R:54
#, c-format
msgid "A non-empty vector of column names for `by` is required."
msgstr "É necessário um vetor não vazio de nomes de colunas para `by`."

#: merge.R:68
#, c-format
msgid "Unknown argument '%s' has been passed."
msgstr "Argumento desconhecido '%s' foi passado."

#: merge.R:71
#, c-format
msgid "Passed %d unknown and unnamed arguments."
msgstr "Passado %d argumentos desconhecidos e sem nome."

#: merge.R:121
#, c-format
msgid "column names %s are duplicated in the result"
msgstr "nomes das colunas %s estão duplicados no resultado"

#: onAttach.R:23
#, c-format
msgid ""
"data.table %s IN DEVELOPMENT built %s%s using %d threads (see ?getDTthreads)."
msgstr ""
"data.table %s EM DESENVOLVIMENTO construído %s%s usando %d threads (veja ?"
"getDTthreads)."

#: onAttach.R:25
#, c-format
msgid "data.table %s using %d threads (see ?getDTthreads)."
msgstr "data.table %s usando %d threads (veja ?getDTthreads)."

#: onAttach.R:26
#, c-format
msgid "Latest news: r-datatable.com"
msgstr "Últimas notícias: r-datatable.com"

#: onAttach.R:27
msgid "TRANSLATION CHECK"
msgstr "VERIFICAÇÃO DE TRADUÇÃO"

#: onAttach.R:29
#, c-format
msgid ""
"**********\n"
"Running data.table in English; package support is available in English only. "
"When searching for online help, be sure to also check for the English error "
"message. This can be obtained by looking at the po/R-<locale>.po and po/"
"<locale>.po files in the package source, where the native language and "
"English error messages can be found side-by-side.%s\n"
"**********"
msgstr ""
"**********\n"
"Executando data.table em português; o suporte ao pacote está disponível "
"apenas em inglês. Ao procurar ajuda online, certifique-se de verificar "
"também a mensagem de erro em inglês. Isso pode ser obtido examinando os "
"arquivos po/R-pt_BR.po e po/pt_BR.po no código-fonte do pacote, onde as "
"mensagens de erro no idioma nativo e em inglês podem ser encontradas lado a "
"lado.%s\n"
"**********"

#: onAttach.R:34
#, c-format
msgid ""
"**********\n"
"This development version of data.table was built more than 4 weeks ago. "
"Please update: data.table::update_dev_pkg()\n"
"**********"
msgstr ""
"**********\n"
"Esta versão de desenvolvimento do data.table foi construída há mais de 4 "
"semanas. Por favor, atualize: data.table::update_dev_pkg()\n"
"**********"

#: onAttach.R:36
#, c-format
msgid ""
"**********\n"
"This installation of data.table has not detected OpenMP support. It should "
"still work but in single-threaded mode."
msgstr ""
"**********\n"
"Esta instalação do data.table não detectou suporte ao OpenMP. Ainda deve "
"funcionar, mas em modo de single-threaded."

#: onAttach.R:38
#, c-format
msgid ""
"This is a Mac. Please read https://mac.r-project.org/openmp/. Please engage "
"with Apple and ask them for support. Check r-datatable.com for updates, and "
"our Mac instructions here: https://github.com/Rdatatable/data.table/wiki/"
"Installation. After several years of many reports of installation problems "
"on Mac, it's time to gingerly point out that there have been no similar "
"problems on Windows or Linux.\n"
"**********"
msgstr ""
"Este é um Mac. Por favor, leia https://mac.r-project.org/openmp/. Por favor, "
"envolva-se com a Apple e peça suporte. Verifique r-datatable.com para "
"atualizações e nossas instruções para Mac aqui: https://github.com/"
"Rdatatable/data.table/wiki/Installation. Após vários anos de muitos relatos "
"de problemas de instalação no Mac, é hora de apontar cuidadosamente que não "
"houve problemas semelhantes no Windows ou Linux.\n"
"**********"

#: onAttach.R:40
#, c-format
msgid ""
"This is %s. This warning should not normally occur on Windows or Linux where "
"OpenMP is turned on by data.table's configure script by passing -fopenmp to "
"the compiler. If you see this warning on Windows or Linux, please file a "
"GitHub issue.\n"
"**********"
msgstr ""
"Este é %s. Este aviso normalmente não deve ocorrer no Windows ou Linux, onde "
"o OpenMP é ativado pelo script de configuração do data.table passando -"
"fopenmp para o compilador. Se você vir este aviso no Windows ou Linux, por "
"favor, relate no rastreador de problemas no GitHub.\n"
"**********"

#: onAttach.R:44
#, c-format
msgid ""
"**********\n"
"This data.table installation was compiled for R < 3.4.0 (Apr 2017) and is "
"known to leak memory. Please upgrade R and reinstall data.table to fix the "
"leak. Maintaining and testing code branches to support very old versions "
"increases development time so please do upgrade R. We intend to bump data."
"table's dependency from 8 year old R 3.1.0 (Apr 2014) to 5 year old R 3.4.0 "
"(Apr 2017).\n"
"**********"
msgstr ""
"**********\n"
"Esta instalação do data.table foi compilada para o R < 3.4.0 (Abr 2017) e é "
"conhecida por vazar memória. Por favor, atualize o R e reinstale o data."
"table para corrigir o vazamento. Manter e testar ramificações de código para "
"suportar versões muito antigas aumenta o tempo de desenvolvimento, então, "
"por favor, atualize o R. Pretendemos aumentar a dependência do data.table de "
"R 3.1.0 (Abr 2014), de 8 anos, para R 3.4.0 (Abr 2017), de 5 anos.\n"
"**********"

#: onLoad.R:9
#, c-format
msgid ""
"Option 'datatable.nomatch' is defined but is now ignored. Please see note 11 "
"in v1.12.4 NEWS (Oct 2019), and note 14 in v1.14.2."
msgstr ""
"Opção 'datatable.nomatch' está definida, mas agora é ignorada. Por favor, "
"veja a nota 11 nas notícias de v1.12.4 (Outubro de 2019) e a nota 14 em "
"v1.14.2."

#. data_table.%s é data_table.dll ou data_table.so
#: onLoad.R:28
#, c-format
msgid ""
"The data_table.%s version (%s) does not match the package (%s). Please close "
"all R sessions to release the old %s and reinstall data.table in a fresh R "
"session. Prior to R version 3.6.0 patched, R's package installer could leave "
"a package in an apparently functional state where new R code was calling old "
"C code silently: https://bugs.r-project.org/bugzilla/show_bug.cgi?id=17478. "
"Once a package is in this mismatch state it may produce wrong results "
"silently until you next upgrade the package. This mismatch between R and C "
"code can happen with any package not just data.table. It is just that data."
"table has added this check."
msgstr ""
"A versão do data_table.%s (%s) não corresponde à do pacote (%s). Por favor, "
"feche todas as sessões do R para liberar a antiga %s e reinstale o "
"data.table em uma nova sessão do R. Antes da versão 3.6.0 patched, o "
"instalador de pacotes do R podia deixar um pacote em um estado aparentemente "
"funcional onde o novo código R estava silenciosamente chamando o código C "
"antigo: https://bugs.r-project.org/bugzilla/show_bug.cgi?id=17478. Uma vez "
"que um pacote esteja neste estado de incompatibilidade, ele pode produzir "
"resultados errados silenciosamente até que você atualize o pacote novamente. "
"Essa incompatibilidade entre o código R e C pode acontecer com qualquer "
"pacote, não apenas com o data.table. É apenas que o data.table adicionou "
"essa verificação."

#: onLoad.R:32
#, c-format
msgid ""
"This is R %s but data.table has been installed using R %s. The major version "
"must match. Please reinstall data.table."
msgstr ""
"Este é o R %s, mas o data.table foi instalado usando o R %s. A versão "
"principal deve corresponder. Por favor, reinstale o data.table."

#: onLoad.R:108
#, c-format
msgid "Unexpected base R behaviour: list(x) has copied x"
msgstr "Comportamento inesperado do R base: list(x) copiou x"

#: onLoad.R:116
#, c-format
msgid "Unexpected base R behaviour: names<- has copied column contents"
msgstr ""
"Comportamento inesperado do R base: names<- copiou o conteúdo da coluna"

#: onLoad.R:126
#, c-format
msgid ""
"Unexpected base R behaviour: DF[2,2]<- did not copy column 2 which was "
"assigned to"
msgstr ""
"Comportamento inesperado do R base: DF[2,2]<- não copiou a coluna 2 que foi "
"atribuída"

#: onLoad.R:127
#, c-format
msgid ""
"Unexpected base R behaviour: DF[2,2]<- copied the first column which was not "
"assigned to, too"
msgstr ""
"Comportamento inesperado do R base: DF[2,2]<- copiou também a primeira "
"coluna, que não foi atribuída"

#: onLoad.R:129
#, c-format
msgid "Unexpected base R behaviour: DF[2,2]<- has not copied address(DF)"
msgstr "Comportamento inesperado do R base: DF[2,2]<- não copiou address(DF)"

#: openmp-utils.R:3
#, c-format
msgid "Provide either threads= or percent= but not both"
msgstr "Forneça threads= ou percent=, mas não ambos"

#: openmp-utils.R:4
#, c-format
msgid "percent= is provided but is length %d"
msgstr "percent= foi fornecido, mas tem comprimento %d"

#: openmp-utils.R:6
#, c-format
msgid "percent==%d but should be a number between 2 and 100"
msgstr "percent==%d, mas deveria ser um número entre 2 e 100"

#: print.data.table.R:19
#, c-format
msgid "Valid options for col.names are 'auto', 'top', and 'none'"
msgstr "As opções válidas para col.names são 'auto', 'top', e 'none'"

#: print.data.table.R:21
#, c-format
msgid "Valid options for trunc.cols are TRUE and FALSE"
msgstr "Opções válidas para trunc.cols são TRUE e FALSE"

#: print.data.table.R:23
#, c-format
msgid "Column classes will be suppressed when col.names is 'none'"
msgstr "As classes de colunas serão suprimidas quando col.names for 'none'"

#: print.data.table.R:47
msgid "Key: <%s>"
msgstr "Chave: <%s>"

#: print.data.table.R:57
msgid "Null data.%s (0 rows and 0 cols)"
msgstr "data.%s nula (0 linha e 0 coluna)"

#: print.data.table.R:59
msgid "Empty data.%s (%d rows and %d cols)"
msgstr "data.%s vazia (%d linhas e %d colunas)"

#: print.data.table.R:153
#, c-format
msgid ""
"Internal structure doesn't seem to be a list. Possibly corrupt data.table."
msgstr ""
"A estrutura interna não parece ser uma lista. Possivelmente data.table "
"corrompida."

#: programming.R:14 programming.R:40
#, c-format
msgid "'x' must be a list"
msgstr "'x' deve ser uma lista"

#: programming.R:22
#, c-format
msgid ""
"Character objects provided in the input are not scalar objects, if you need "
"them as character vector rather than a name, then wrap each into 'I' call: %s"
msgstr ""
"Objetos de caracteres fornecidos na entrada não são objetos escalares, se "
"você precisar deles como vetor de caracteres em vez de um nome, então "
"envolva cada um 'I' na chamada: %s"

#: programming.R:50
#, c-format
msgid "'env' must not be missing"
msgstr "'env' não deve estar ausente"

#: programming.R:56
#, c-format
msgid "'env' must be a list or an environment"
msgstr "'env' deve ser uma lista ou um ambiente"

#: programming.R:63
#, c-format
msgid "'env' argument does not have names"
msgstr "argumento 'env' não tem nomes"

#: programming.R:65
#, c-format
msgid "'env' argument has zero char names"
msgstr "argumento 'env' tem zero nomes de caracteres"

#: programming.R:67
#, c-format
msgid "'env' argument has NA names"
msgstr "argumento 'env' tem nomes NA"

#: programming.R:69
#, c-format
msgid "'env' argument has duplicated names"
msgstr "argumento 'env' tem nomes duplicados"

#: rowwiseDT.R:4
#, c-format
msgid ""
"Must provide at least one column (use `name=`). See ?rowwiseDT for details"
msgstr ""
"É necessário fornecer ao menos uma coluna (use `name=`). Veja ?rowwiseDT "
"para detalhes"

#: rowwiseDT.R:7
#, c-format
msgid "Named arguments must be empty"
msgstr "o argumento x deve ser uma data.table"

#: rowwiseDT.R:9
#, c-format
msgid "Header must be the first N arguments"
msgstr "O cabeçalho deve ser os primeiros N argumentos"

#: rowwiseDT.R:15
#, c-format
msgid ""
"There are %d columns but the number of cells is %d, which is not an integer "
"multiple of the columns"
msgstr ""
"Há %d colunas mas o número de células é %d, que não é um múltiplo inteiro "
"das colunas"

#: setkey.R:3
#, c-format
msgid ""
"x may no longer be the character name of the data.table. The possibility was "
"undocumented and has been removed."
msgstr ""
"x pode não ser mais o nome da data.table do tipo caractere. A possibilidade "
"não era documentada e foi removida."

#: setkey.R:34
#, c-format
msgid "x is not a data.table"
msgstr "x não é uma data.table"

#: setkey.R:35
#, c-format
msgid ""
"cols is not a character vector. Please see further information in ?setkey."
msgstr ""
"cols não é um vetor de caracteres. Por favor, veja mais informações em ?"
"setkey."

#: setkey.R:36
#, c-format
msgid ""
"Setting a physical key on .SD is reserved for possible future use; to modify "
"the original data's order by group. Try setindex() instead. Or, set*(copy(."
"SD)) as a (slow) last resort."
msgstr ""
"Definir uma chave física em .SD está reservado para possível uso futuro; "
"para modificar a ordem dos dados originais por grupo. Tente setindex() em "
"vez disso. Ou, set*(copy(.SD)) como último recurso (lento)."

#: setkey.R:38
#, c-format
msgid ""
"cols is a character vector of zero length. Removed the key, but use NULL "
"instead, or wrap with suppressWarnings() to avoid this warning."
msgstr ""
"cols é um vetor de caracteres de comprimento zero. A chave foi removida, mas "
"use NULL em vez disso, ou envolva com suppressWarnings() para evitar este "
"aviso."

#: setkey.R:42
#, c-format
msgid "cols is the empty string. Use NULL to remove the key."
msgstr "cols é uma string vazia. Use NULL para remover a chave."

#: setkey.R:43 setkey.R:267
#, c-format
msgid "cols contains some blanks."
msgstr "cols contém alguns espaços em branco."

#: setkey.R:46 setkey.R:271
#, c-format
msgid "some columns are not in the data.table: %s"
msgstr "algumas colunas não estão na data.table: %s"

#: setkey.R:54 setkey.R:272
#, c-format
msgid ""
"x contains a column called '.xi'. Conflicts with internal use by data.table."
msgstr ""
"x contém uma coluna chamada '.xi'. Conflita com o uso interno do data.table."

#: setkey.R:57
#, c-format
msgid ""
"Column '%s' is type '%s' which is not supported as a key column type, "
"currently."
msgstr ""
"Coluna '%s' é do tipo '%s', que atualmente não é suportado como tipo de "
"coluna chave."

#: setkey.R:65
msgid "forder took %.03f sec"
msgstr "forder levou %.03f s"

#: setkey.R:77
msgid "reorder took %s"
msgstr "reorder levou %s"

#: setkey.R:79
msgid "x is already ordered by these columns, no need to call reorder"
msgstr ""
"x já está ordenado por essas colunas, não há necessidade de chamar reorder"

#: setkey.R:132
#, c-format
msgid "x is vector but 'by' is supplied"
msgstr "x é um vetor, mas 'by' foi fornecido"

#: setkey.R:148
#, c-format
msgid "x is a single vector, non-NULL 'by' doesn't make sense"
msgstr "x é um único vetor, 'by' não NULL não faz sentido."

#: setkey.R:160
#, c-format
msgid ""
"data.table has no support for sorting by method='%s'. Use base::order(), not "
"order(), if you really need this."
msgstr ""
"data.table não tem suporte a ordenar pelo method='%s'. Use base::order(), "
"não order(), se você realmente precisar disso."

#: setkey.R:181
#, c-format
msgid "Attempting to order a 0-column data.table or data.frame."
msgstr "Tentativa de ordenar uma data.table ou um data.frame com 0 colunas."

#: setkey.R:186
#, c-format
msgid ""
"The first item passed to [f]order is a plain list but there are more items. "
"It should be a data.table or data.frame."
msgstr ""
"O primeiro item passado para [f]order é uma lista simples, mas há mais "
"itens. Deve ser uma data.table ou um data.frame."

#: setkey.R:194
#, c-format
msgid "Mixing '-' with vector decreasing= is not supported."
msgstr "Sem suporte a misturar '-' com vetor decreasing=."

#: setkey.R:195
#, c-format
msgid "decreasing= has length %d applied to sorting %d columns."
msgstr "decreasing= tem comprimento %d aplicado a ordenar %d colunas."

#: setkey.R:211
#, c-format
msgid "Internal code should not be being called on type double"
msgstr "Código interno não deveria estar sendo chamado em um tipo double"

#: setkey.R:219
#, c-format
msgid ""
"Input is not a vector of type double. New parallel sort has only been done "
"for double vectors so far. Using one thread."
msgstr ""
"Entrada não é um vetor do tipo double. A nova ordenação paralela só foi "
"feita para vetores do tipo double até agora. Usando uma thread."

#: setkey.R:220
#, c-format
msgid ""
"New parallel sort has not been implemented for decreasing=TRUE so far. Using "
"one thread."
msgstr ""
"A nova ordenação paralela ainda não foi implementada para decreasing=TRUE "
"até o momento. Usando uma thread."

#: setkey.R:221
#, c-format
msgid ""
"New parallel sort has not been implemented for vectors containing NA values "
"so far. Using one thread."
msgstr ""
"A nova ordenação paralela ainda não foi implementada para vetores contendo "
"valores NA até o momento. Usando uma thread."

#: setkey.R:233 setkey.R:259
#, c-format
msgid "x must be a data.frame or data.table"
msgstr "x deve ser uma data.frame ou um data.table"

#: setkey.R:261
#, c-format
msgid "na.last must be logical TRUE/FALSE"
msgstr "na.last deve ser lógico TRUE/FALSE"

#: setkey.R:262
#, c-format
msgid ""
"cols is not a character vector. Please see further information in ?setorder."
msgstr ""
"cols não é um vetor de caracteres. Por favor, veja mais informações em ?"
"setorder."

#: setkey.R:264
#, c-format
msgid ""
"cols is a character vector of zero length. Use NULL instead, or wrap with "
"suppressWarnings() to avoid this warning."
msgstr ""
"cols é um vetor de caracteres de comprimento zero. Use NULL em vez disso, ou "
"envolva com suppressWarnings() para evitar este aviso."

#: setkey.R:275
#, c-format
msgid "Column '%s' is type '%s' which is not supported for ordering currently."
msgstr ""
"Coluna '%s' é do tipo '%s', que atualmente não é suportado para ordenação."

#: setkey.R:319
#, c-format
msgid ""
"'sorted' is TRUE but element %d is non-atomic, which can't be sorted; try "
"setting sorted = FALSE"
msgstr ""
"'sorted' é TRUE, mas o elemento %d é não atômico, o que não pode ser "
"ordenado; tente definir sorted = FALSE"

#: setkey.R:334
#, c-format
msgid ""
"Cross product of elements provided to CJ() would result in %.0f rows which "
"exceeds .Machine$integer.max == %d"
msgstr ""
"Produto cruzado dos elementos fornecidos a CJ() resultaria em %.0f linhas "
"que excedem .Machine$integer.max == %d"

#: setops.R:3 setops.R:40
#, c-format
msgid "x and y must both be data.tables"
msgstr "x e y devem ser ambos data.tables"

#: setops.R:17
#, c-format
msgid ""
"When x's column ('%s') is character, the corresponding column in y ('%s') "
"should be factor or character, but found incompatible type '%s'."
msgstr ""
"Quando a coluna de x ('%s') é do tipo caractere, a coluna correspondente em "
"y ('%s') deve ser do tipo fator ou caractere, mas foi encontrado um tipo "
"incompatível '%s'."

#: setops.R:19
#, c-format
msgid ""
"When x's column ('%s') is factor, the corresponding column in y ('%s') "
"should be character or factor, but found incompatible type '%s'."
msgstr ""
"Quando a coluna de x ('%s') é do tipo fator, a coluna correspondente em y "
"('%s') deve ser do tipo caractere ou fator, mas foi encontrado um tipo "
"incompatível '%s'."

#: setops.R:21
#, c-format
msgid ""
"When x's column ('%s') is integer or numeric, the corresponding column in y "
"('%s') can not be character or logical types, but found incompatible type "
"'%s'."
msgstr ""
"Quando a coluna de x ('%s') é do tipo inteiro ou numérico, a coluna "
"correspondente em y ('%s') não pode ser do tipo caractere ou lógico, mas foi "
"encontrado um tipo incompatível '%s'."

#: setops.R:39
#, c-format
msgid "argument 'all' should be logical of length one"
msgstr "argumento 'all' deve ser lógico de comprimento um"

#: setops.R:41
#, c-format
msgid "x and y must have the same column names"
msgstr "x e y devem ter os mesmos nomes de colunas"

#: setops.R:42
#, c-format
msgid "x and y must have the same column order"
msgstr "x e y devem ter a mesma ordem de colunas"

#: setops.R:55
#, c-format
msgid "Item %d of x is '%s' but the corresponding item of y is '%s'."
msgstr "Item %d de x é '%s', mas o item correspondente de y é '%s'."

#: setops.R:57
#, c-format
msgid "None of the datasets should contain a column named '.seqn'"
msgstr "Nenhum dos conjuntos de dados deve conter uma coluna chamada '.seqn'"

#: setops.R:162
msgid "Datasets have different keys"
msgstr "Conjuntos de dados têm diferente chaves"

#: setops.R:163 setops.R:164
#, c-format
msgid "has no key"
msgstr "não tem chave"

#: setops.R:173
msgid "Datasets have different indices"
msgstr "Conjuntos de dados têm diferentes índices"

#: setops.R:174 setops.R:175
#, c-format
msgid "has no index"
msgstr "não tem índice"

#: setops.R:192
#, c-format
msgid "None of the datasets to compare should contain a column named '.seqn'"
msgstr ""
"Nenhum dos conjuntos de dados a serem comparados deve conter uma coluna "
"chamada '.seqn'"

#: setops.R:195
#, c-format
msgid ""
"Datasets to compare with 'ignore.row.order' must not have unsupported column "
"types: %s"
msgstr ""
"Conjuntos de dados a serem comparados com 'ignore.row.order' não devem ter "
"tipos de colunas não suportados:%s"

#: setops.R:197
#, c-format
msgid ""
"Argument 'tolerance' was forced to lowest accepted value `sqrt(."
"Machine$double.eps)` from provided %s"
msgstr ""
"Argumento 'tolerance' foi forçado ao valor mínimo aceito de `sqrt(."
"Machine$double.eps)` a partir do fornecido %s"

#: setops.R:210
#, c-format
msgid ""
"Duplicate rows in datasets, numeric columns and ignore.row.order cannot be "
"used with non 0 tolerance argument"
msgstr ""
"Linhas duplicadas nos conjuntos de dados, colunas numéricas e ignore.row."
"order não podem ser usadas com argumento de tolerância diferente de 0"

#: setops.R:224
#, c-format
msgid ""
"Factor columns and ignore.row.order cannot be used with non 0 tolerance "
"argument"
msgstr ""
"Colunas de fator e ignore.row.order não podem ser usadas com argumento de "
"tolerância diferente de 0"

#: shift.R:3
#, c-format
msgid "Provided argument fill=%s will be ignored since type='cyclic'."
msgstr "O argumento fornecido fill=%s será ignorado, pois type='cyclic'."

#: tables.R:31
msgid "No objects of class data.table exist in %s"
msgstr "Não existem objetos da classe data.table em %s"

#: tables.R:46
#, c-format
msgid "order.col='%s' not a column name of info"
msgstr "order.col='%s' não é um nome de coluna de info"

#: tables.R:59
msgid "Total: %sMB using %s"
msgstr "Total: %sMB usando %s"

#: test.data.table.R:17
#, c-format
msgid "data.table package is loaded. Unload or start a fresh R session."
msgstr ""
"Pacote data.table está carregado. Descarregue ou inicie uma nova sessão do R."

#: test.data.table.R:33
#, c-format
msgid ""
"script must end with '.Rraw'. If a file ending '.Rraw.bz2' exists, that will "
"be found and used."
msgstr ""
"script deve terminar com '.Rraw'. Se existir um arquivo terminando em '.Rraw."
"bz2', ele será encontrado e usado."

#: test.data.table.R:63
#, c-format
msgid "Neither %s nor %s exist in %s"
msgstr "Nem %s ou %sexistem em %s"

#: test.data.table.R:115
msgid "test.data.table() running: %s"
msgstr "test.data.table() em execução: %s"

#: test.data.table.R:119
msgid "object '%s' not found"
msgstr "objeto '%s' não encontrado"

#: test.data.table.R:122
msgid ""
"**** This R session's language is not English. Each test will still check "
"that the correct number of errors and/or\n"
"**** warnings are produced. However, to test the text of each error/warning "
"too, please restart R with LANGUAGE=en"
msgstr ""
"**** O idioma desta sessão R não é inglês. Cada teste ainda verificará se o "
"número correto de erros e/ou avisos\n"
"**** são produzidos. No entanto, para testar o texto de cada erro/aviso "
"também, reinicie o R com LANGUAGE=en"

#: test.data.table.R:142
msgid ""
"***\n"
"*** memtest=%d. This should be the first call in a fresh R_GC_MEM_GROW=0 R "
"session for best results. Ctrl-C now if not.\n"
"***"
msgstr ""
"***\n"
"*** memtest=%d. Esta deve ser a primeira chamada em uma nova sessão "
"R_GC_MEM_GROW=0 R para melhores resultados.\n"
"*** Ctrl-C agora se não for o caso.\n"
"***"

#: test.data.table.R:143
#, c-format
msgid ""
"memtest intended for Linux. Step through data.table:::rss() to see what went "
"wrong."
msgstr ""
"memtest destinado para Linux. Percorra data.table:::rss() para ver o que deu "
"errado."

#: test.data.table.R:197
#, c-format
msgid "Attempt to subset to %d tests matching '%s' failed, running full suite."
msgstr ""
"A tentativa de obter subconjunto de %d testes correspondendo a '%s' falhou, "
"executando a suíte completa."

#: test.data.table.R:202
msgid "Running %d of %d tests matching '%s'"
msgstr "Executando %d de %d testes correspondendo a '%s'"

#: test.data.table.R:248
#, c-format
msgid "Failed in %s after test %s before the next test() call in %s"
msgstr "Falhou em %s após o teste %s antes da próxima chamada de test() em %s"

#: test.data.table.R:271
#, c-format
msgid "Timings count mismatch: %d vs %d"
msgstr "Contagem de tempos não corresponde: %d vs %d"

#: test.data.table.R:273
msgid "10 longest running tests took %ds (%d%% of %ds)"
msgstr "10 testes de execução mais longa levaram %ds (%d%% de %ds)"

#: test.data.table.R:279
msgid "10 largest RAM increases (MB); see plot for cumulative effect (if any)"
msgstr ""
"10 maiores aumentos de RAM (MB); veja o gráfico para efeito cumulativo (se "
"houver)"

#: test.data.table.R:289
msgid "All %d tests (last %.8g) in %s completed ok in %s"
msgstr "Todos os %d testes (último %.8g) em %s concluíram corretamente em %s"

#: test.data.table.R:388
msgid "Running test id"
msgstr "Executando id de teste"

#: test.data.table.R:404
#, c-format
msgid ""
"Test %s is invalid: when error= is provided it does not make sense to pass y "
"as well"
msgstr ""
"Teste %s é inválido: quando error= é fornecido, não faz sentido passar y "
"também"

#: test.data.table.R:439
msgid "Test id %s is not in increasing order"
msgstr "O id de teste %s não está em ordem crescente"

#: test.data.table.R:456
msgid ""
"Test %s produced %d %ss but expected %d\n"
"%s\n"
"%s"
msgstr ""
"O teste %s produziu %d %ss, mas esperava-se %d\n"
"%s\n"
"%s"

#: test.data.table.R:464
msgid ""
"Test %s didn't produce the correct %s:\n"
"Expected: %s\n"
"Observed: %s"
msgstr ""
"O teste %s não produziu o %s correto:\n"
"Esperado: %s\n"
"Observado: %s"

#: test.data.table.R:473
msgid "Output captured before unexpected warning/error/message:"
msgstr "Saída capturada antes de aviso/erro/mensagem inesperado:"

#: test.data.table.R:483
msgid "Test %s did not produce correct output:"
msgstr "O teste %s não produziu saída correta:"

#: test.data.table.R:484
msgid "Expected: <<%s>>"
msgstr "Esperado: <<%s>>"

#: test.data.table.R:485 test.data.table.R:497
msgid "Observed: <<%s>>"
msgstr "Observado: <<%s>>"

#: test.data.table.R:487
msgid "Expected (raw): <<%s>>"
msgstr "Esperado (bruto): <<%s>>"

#: test.data.table.R:488 test.data.table.R:500
msgid "Observed (raw): <<%s>>"
msgstr "Observado (bruto): <<%s>>"

#: test.data.table.R:495
msgid "Test %s produced output but should not have:"
msgstr "O teste %s produziu uma saída, mas não deveria ter:"

#: test.data.table.R:496
msgid "Expected absent (case insensitive): <<%s>>"
msgstr ""
"Ausência esperada (sem distinção entre maiúsculas e minúsculas): <<%s>>"

#: test.data.table.R:499
msgid "Expected absent (raw): <<%s>>"
msgstr "Ausência esperada (bruto): <<%s>>"

#: test.data.table.R:513
msgid "Test %s ran without errors but selfrefok(%s) is FALSE"
msgstr "O teste %s foi executado sem erros, mas selfrefok(%s) é FALSE"

#: test.data.table.R:538
msgid "Test %s ran without errors but failed check that x equals y:"
msgstr ""
"O teste %s foi executado sem erros, mas falhou na verificação de x "
"ser igual a y:"

#: test.data.table.R:543
msgid "First %d of %d (type '%s'):"
msgstr "Primeiros %d de %d (tipo '%s'):"

#: test.data.table.R:548
msgid "Non-ASCII string detected, raw representation:"
msgstr "Sequência de caracteres não ASCII detectada, representação bruta:"

#: timetaken.R:3
#, c-format
msgid "Use started.at=proc.time() not Sys.time() (POSIXt and slow)"
msgstr "Use started.at=proc.time(), não Sys.time() (POSIXt and slow)"

#: transpose.R:7
#, c-format
msgid "make.names='%s' not found in names of input"
msgstr "make.names='%s' não encontrado nos nomes da entrada"

#: transpose.R:12
#, c-format
msgid "make.names=%d is out of range [1,ncol=%d]"
msgstr "make.names=%d está fora do intervalo [1, ncol=%d]"

#: transpose.R:28
#, c-format
msgid "'names' must be TRUE/FALSE or a character vector."
msgstr "'names' deve ser TRUE/FALSE ou um vetor de caracteres."

#: transpose.R:34
#, c-format
msgid "'keep' should contain integer values between %d and %d."
msgstr "'keep' deve conter valores inteiros entre %d e %d."

#: transpose.R:51
#, c-format
msgid "The argument 'type.convert' does not support empty list."
msgstr "O argumento 'type.convert' não suporta lista vazia."

#: transpose.R:57
#, c-format
msgid ""
"When the argument 'type.convert' contains an unnamed element, it is expected "
"to be the last element and should be a function. More than one unnamed "
"element is not allowed unless all elements are functions with length equal "
"to %d (the length of the transpose list or 'keep' argument if it is "
"specified)."
msgstr ""
"Quando o argumento 'type.convert' contém um elemento não nomeado, espera-se "
"que seja o último elemento e deve ser uma função. Mais de um elemento não "
"nomeado não é permitido, a menos que todos os elementos sejam funções com "
"comprimento igual a %d (o comprimento da lista de transposição ou argumento "
"'keep', se especificado)."

#: transpose.R:66
#, c-format
msgid ""
"When the argument 'type.convert' contains transpose list indices, it should "
"be a named list of non-missing integer values (with no duplicate) except the "
"last element that should be unnamed if it is a function."
msgstr ""
"Quando o argumento 'type.convert' contém índices de lista de transposição, "
"ele deve ser uma lista nomeada de valores inteiros não ausentes (sem "
"duplicatas), exceto o último elemento, que deve ser não nomeado se for uma "
"função."

#: transpose.R:68
#, c-format
msgid ""
"When the argument 'type.convert' contains transpose list indices, they "
"should be integer values contained in the argument 'keep' (if it is "
"specified) or be between %d and %d (if it is not). But '%s' is/are not "
"contained in '%s'."
msgstr ""
"Quando o argumento 'type.convert' contém índices de lista de transposição, "
"eles devem ser valores inteiros contidos no argumento 'keep' (se "
"especificado) ou estar entre %d e %d (se não especificado). Mas '%s' não "
"está(ão) contido(s) em '%s'."

#: transpose.R:74
#, c-format
msgid ""
"In the argument 'type.convert', '%s' was ignored because all elements in the "
"transpose list or elements corresponding to indices specified in the 'keep' "
"argument have already been converted."
msgstr ""
"No argumento 'type.convert', '%s' foi ignorado porque todos os elementos na "
"lista de transposição ou elementos correspondentes aos índices especificados "
"no argumento 'keep' já foram convertidos."

#: transpose.R:83
#, c-format
msgid ""
"The argument 'type.convert' should be TRUE/FALSE, a function, a list of "
"functions, or a named list of pairs 'fun=indices' with optionally one "
"unnamed element (a function) but an object of type '%s' was provided."
msgstr ""
"O argumento 'type.convert' deve ser TRUE/FALSE, uma função, uma lista de "
"funções ou uma lista nomeada de pares 'fun=indices' com opcionalmente um "
"elemento não nomeado (uma função), mas foi fornecido um objeto do tipo '%s'."

#: transpose.R:88
#, c-format
msgid "length(names) (= %d) is not equal to length(%s) (= %d)."
msgstr "length(names) (= %d) não é igual a length(%s) (= %d)."

#: uniqlist.R:11
#, c-format
msgid "l not type list"
msgstr "l não é do tipo lista"

#: utils.R:18
#, c-format
msgid "Argument 'nan' must be length 1"
msgstr "Argumento 'nan' deve ter comprimento 1"

#: utils.R:21
#, c-format
msgid "Argument 'nan' must be NA or NaN"
msgstr "Argumento 'nan' deve ser NA ou NaN"

#: utils.R:25
msgid "Internal error in"
msgstr "Erro interno in"

#: utils.R:28
msgid "Please report to the data.table issues tracker."
msgstr "Por favor, relate isso no rastreador de problemas do data.table."

#: utils.R:72 utils.R:81
#, c-format
msgid "x not boolean"
msgstr "x não é booleano"

#: utils.R:92
#, c-format
msgid ""
"Some columns are type 'integer64' but package bit64 is not installed. Those "
"columns will print as strange looking floating point data. There is no need "
"to reload the data. Simply install.packages('bit64') to obtain the integer64 "
"print method and print the data again."
msgstr ""
"Algumas colunas são do tipo 'integer64', mas o pacote bit64 não está "
"instalado. Essas colunas serão exibidas como estranhos dados de ponto "
"flutuante. Não há necessidade de recarregar os dados. Simplesmente use "
"install.packages('bit64') para obter o método de impressão de integer64 e "
"imprima os dados novamente."

#: xts.R:4
#, c-format
msgid "keep.rownames must be length 1"
msgstr "keep.rownames deve ter comprimento 1"

#: xts.R:5
#, c-format
msgid "keep.rownames must not be NA"
msgstr "keep.rownames não deve ser NA"

#: xts.R:11
#, c-format
msgid ""
"Input xts object should not have '%s' column because it would result in "
"duplicate column names. Rename '%s' column in xts or use `keep.rownames` to "
"change the index column name."
msgstr ""
"O objeto xts de entrada não deve ter a coluna '%s' porque resultaria em "
"nomes de colunas duplicados. Renomeie a coluna '%s' no xts ou use `keep."
"rownames` para alterar o nome da coluna de índice."

#: xts.R:21
#, c-format
msgid ""
"data.table must have a time based column in first position, use "
"`setcolorder` function to change the order, or see ?timeBased for supported "
"types"
msgstr ""
"data.table deve ter uma coluna baseada em tempo na primeira posição, use a "
"função `setcolorder` para alterar a ordem, ou veja ?timeBased para os tipos "
"suportados."

#: xts.R:25
#, c-format
msgid "Following columns are not numeric and will be omitted: %s"
msgstr "As seguintes colunas não são numéricas e serão omitidas: %s"

#: bmerge.R:214
msgid "  Found %d non-equi group ...\n"
msgid_plural "  Found %d non-equi groups ...\n"
msgstr[0] "  Encontrado %d grupo por desigualdade ...\n"
msgstr[1] "  Encontrado %d grupos por desigualdade ...\n"

#: data.table.R:712
msgid "column not removed because not found: %s"
msgid_plural "columns not removed because not found: %s"
msgstr[0] "coluna não removida por não ter sido encontrada: %s"
msgstr[1] "colunas não removidas por não terem sido encontradas: %s"

#: data.table.R:727
msgid "column not found: %s"
msgid_plural "columns not found: %s"
msgstr[0] "coluna não encontrada: %s"
msgstr[1] "colunas não encontradas: %s"

#: data.table.R:895
msgid ""
"The item in the 'by' or 'keyby' list is length %s. Each must be length %d; "
"the same length as there are rows in x (after subsetting if i is provided)."
msgid_plural ""
"The items in the 'by' or 'keyby' list have lengths %s. Each must be length "
"%d; the same length as there are rows in x (after subsetting if i is "
"provided)."
msgstr[0] ""
"O item na lista 'by' ou 'keyby' tem comprimento %s. Cada um deve ter "
"comprimento %d; o mesmo comprimento que há linhas em x (após obter "
"subconjuntos se i for fornecido)."
msgstr[1] ""
"Os itens na lista 'by' ou 'keyby' têm comprimento(s) %s. Cada um deve ter "
"comprimento %d; o mesmo comprimento que há linhas em x (após obter "
"subconjuntos se i for fornecido)."

#: fmelt.R:27
msgid "Pattern not found: [%s]"
msgid_plural "Patterns not found: [%s]"
msgstr[0] "Padrão não encontrado: [%s]"
msgstr[1] "Padrões não encontrados: [%s]"

#: fread.R:340
msgid "stringsAsFactors=%s converted %d column: %s\n"
msgid_plural "stringsAsFactors=%s converted %d columns: %s\n"
msgstr[0] "stringsAsFactors=%s converteu %d coluna: %s\n"
msgstr[1] "stringsAsFactors=%s converteu %d colunas: %s\n"

#: print.data.table.R:50
msgid "Index: %s\n"
msgid_plural "Indices: %s\n"
msgstr[0] "Índice: %s\n"
msgstr[1] "Índices: %s\n"

#: print.data.table.R:285
msgid "%d variable not shown: %s\n"
msgid_plural "%d variables not shown: %s\n"
msgstr[0] "%d variável não mostrada: %s\n"
msgstr[1] "%d variáveis não mostradas: %s\n"

#: setops.R:46
msgid "unsupported column type found in x or y: %s"
msgid_plural "unsupported column types found in x or y: %s"
msgstr[0] "tipo de coluna não suportado encontrado em x ou y: %s"
msgstr[1] "tipos de coluna não suportados encontrados em x ou y: %s"

#: test.data.table.R:258
msgid "%d error out of %d. Search %s for test number %s. Duration: %s."
msgid_plural ""
"%d errors out of %d. Search %s for test numbers %s. Duration: %s."
msgstr[0] "%d erro de %d. Pesquisar %s por número de teste %s. Duração: %s."
msgstr[1] "%d erros de %d. Pesquisar %s por números de teste %s. Duração: %s."

#: utils.R:36
msgid ""
"%s has duplicated column name %s. Please remove or rename the duplicate and "
"try again."
msgid_plural ""
"%s has duplicated column names %s. Please remove or rename the duplicates "
"and try again."
msgstr[0] ""
"%s tem nome de coluna duplicado: %s. Por favor, remova ou renomeie a "
"duplicata e tente novamente."
msgstr[1] ""
"%s tem nomes de coluna duplicados: %s. Por favor, remova ou renomeie as "
"duplicatas e tente novamente."
