#
# Translators:
# Italo Santos <ids37@nau.edu>, 2024.
# Leonardo Fontenelle <leonardof@leonardof.med.br>, 2024-2025.
# Rafael Fontenelle <rffontenelle@gmail.com>, 2024-2025.
#
msgid ""
msgstr ""
"Project-Id-Version: data.table 1.18.0\n"
"POT-Creation-Date: 2025-12-13 17:01+0000\n"
"PO-Revision-Date: 2025-12-14 00:09-0300\n"
"Last-Translator: Rafael Fontenelle <rffontenelle@gmail.com>\n"
"Language-Team: Brazilian Portuguese\n"
"Language: pt_BR\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=2; plural=(n > 1);\n"
"X-Generator: Gtranslator 49.0\n"

#: AllS4.R:2
#, c-format
msgid "data.table package loaded. When developing don't load package"
msgstr "Pacote data.table carregado. Ao desenvolver, não carregue o pacote"

#: IDateTime.R:108
#, c-format
msgid "binary + is not defined for \"IDate\" objects"
msgstr "binário + não está definida para objetos \"IDate\""

#: IDateTime.R:115
#, c-format
msgid "can only subtract from \"IDate\" objects"
msgstr "pode apenas subtrair de objetos \"IDate\""

#: IDateTime.R:120
#, c-format
msgid "unary - is not defined for \"IDate\" objects"
msgstr "unário - não está definido para objetos \"IDate\""

#: IDateTime.R:316
#, c-format
msgid "Valid options for ms are 'truncate', 'nearest', and 'ceil'."
msgstr "Opções válidas para ms são 'truncate', 'nearest', e 'ceil'."

#: as.data.table.R:89
#, c-format
msgid ""
"as.data.table.array method should only be called for arrays with 3+ "
"dimensions; use the matrix method for 2-dimensional arrays"
msgstr ""
"O método as.data.table.array só deve ser chamado para arrays com mais de 3 "
"dimensões ou mais; use o método matrix para arrays de 2 dimensões"

#: as.data.table.R:91
#, c-format
msgid ""
"Argument 'value.name' must be scalar character, non-NA and at least one "
"character"
msgstr ""
"O argumento 'value.name' deve ser um caractere escalar, não-NA e ter pelo "
"menos um caractere"

#: as.data.table.R:93
#, c-format
msgid "Argument 'sorted' must be scalar logical and non-NA"
msgstr "O argumento 'sorted' deve ser lógico escalar e não-NA"

#: as.data.table.R:95
#, c-format
msgid "Argument 'na.rm' must be scalar logical and non-NA"
msgstr "O argumento 'na.rm' deve ser lógico escalar e não-NA"

#: as.data.table.R:97
#, c-format
msgid "Please provide either 'key' or 'sorted', but not both."
msgstr "Favor fornecer ou 'key' ou 'sorted', mas não ambos."

#: as.data.table.R:111
#, c-format
msgid ""
"Argument 'value.name' should not overlap with column names in result: %s"
msgstr ""
"O argumento 'value.name' não deve se sobrepor aos nomes das colunas no "
"resultado: %s"

#: as.data.table.R:161
#, c-format
msgid ""
"POSIXlt column type detected and converted to POSIXct. We do not recommend "
"use of POSIXlt at all because it uses 40 bytes to store one date."
msgstr ""
"Tipo de coluna POSIXlt detectado e convertido em POSIXct. Não recomendamos o "
"uso do POSIXlt porque ele usa 40 bytes para armazenar uma data."

#: as.data.table.R:206
#, c-format
msgid "Item %d has %d rows but longest item has %d; recycled with remainder."
msgstr ""
"O item %d possui %d linhas, mas o item mais longo possui %d; reciclado com o "
"restante."

#: as.data.table.R:221
#, c-format
msgid "A column may not be called .SD. That has special meaning."
msgstr ""
"Uma coluna não pode ser chamada de .SD. Esse nome tem um significado "
"especial."

#: as.data.table.R:247
#, c-format
msgid "class must be length 1"
msgstr "class deve ter comprimento 1"

#: between.R:3
#, c-format
msgid "between has been passed an argument x of type logical"
msgstr "between recebeu um argumento x do tipo lógico"

#: between.R:13 between.R:15
#, c-format
msgid ""
"The 'x' argument of the 'between' function is POSIXct while '%s' was not, "
"coercion to POSIXct failed with: %s"
msgstr ""
"O argumento 'x' da função 'between' é da classe POSIXct enquanto '%s' não "
"era, então a coerção para POSIXct falhou com: %s"

#: between.R:24
#, c-format
msgid ""
"'between' lower= and upper= are both POSIXct but have different tzone "
"attributes: %s. Please align their time zones."
msgstr ""
"lower= e upper= do 'between' são ambos POSIXct, mas possuem atributos tzone "
"diferentes: %s. Alinhe seus fusos horários."

#: between.R:27
#, c-format
msgid ""
"'between' arguments are all POSIXct but have mismatched tzone attributes: "
"%s. The UTC times will be compared."
msgstr ""
"os argumentos de 'between' são todos POSIXct, mas possuem atributos tzone "
"incompatíveis: %s. Os horários UTC serão comparados."

#: between.R:32
#, c-format
msgid "trying to use integer64 class when 'bit64' package is not installed"
msgstr ""
"tentando usar a classe integer64 quando o pacote 'bit64' não está instalado"

#: between.R:43
msgid ""
"optimised between not available for this data type, fallback to slow R "
"routine"
msgstr ""
"between otimizado não disponível para este tipo de dados, retrocedendo para "
"rotina R lenta"

#: between.R:44
#, c-format
msgid ""
"Not yet implemented NAbounds=TRUE for this non-numeric and non-character type"
msgstr ""
"Ainda não implementado NAbounds=TRUE para este tipo não numérico e não "
"caractere"

#: between.R:45
#, c-format
msgid "Some lower>upper for this non-numeric and non-character type"
msgstr "Alguns lower>upper para este tipo não numérico e não caractere"

#: between.R:59
#, c-format
msgid "Perhaps you meant %s?"
msgstr "Talvez você quis dizer %s?"

#: between.R:60
#, c-format
msgid ""
"RHS has length() %d; expecting length 2. %sThe first element should be the "
"lower bound(s); the second element should be the upper bound(s)."
msgstr ""
"O lado direito (RHS) tem length() %d; esperando comprimento 2. %sO primeiro "
"elemento deve ser o(s) limite(s) inferior(es); o segundo elemento deve ser "
"o(s) limite(s) superior(es)."

#: between.R:73
msgid "forderv(query) took ..."
msgstr "forderv(query) levou ..."

#: between.R:86
msgid "Generating final logical vector ..."
msgstr "Gerando vetor lógico final ..."

#: between.R:88 bmerge.R:205 bmerge.R:209 bmerge.R:216 data.table.R:516
msgid "done in %s"
msgstr "concluído em %s"

#: bmerge.R:21
msgid "Coercing %s column %s%s to type %s to match type of %s%s."
msgstr ""
"Fazendo coerção de %s coluna %s%s para o tipo %s para corresponder ao tipo "
"de %s%s."

#: bmerge.R:34
#, c-format
msgid ""
"Attempting roll join on factor column when joining x.%s to i.%s. Only "
"integer, double or character columns may be roll joined."
msgstr ""
"Tentando uma junção por \"rolamento\" na coluna de fatores ao fazer a junção "
"entre x.%s e i.%s. Apenas colunas de inteiros, double ou caracteres podem "
"ser usadas na junção."

#: bmerge.R:72 bmerge.R:73
#, c-format
msgid "%s is type %s which is not supported by data.table join"
msgstr "%s é do tipo %s, o qual não é suportado pela junção do data.table"

#: bmerge.R:77
msgid "Matching %s factor levels to %s factor levels."
msgstr "Fazendo os níveis do fator %s corresponderem aos níveis do fator %s."

#: bmerge.R:86
msgid "Matching character column %s to factor levels in %s."
msgstr "Fazendo a coluna de caracteres %s corresponder aos níveis do fator %s."

#: bmerge.R:93
#, c-format
msgid ""
"Incompatible join types: %s (%s) and %s (%s). Factor columns must join to "
"factor or character columns."
msgstr ""
"Tipos de junção incompatíveis: %s (%s) e %s (%s). Colunas de fator devem "
"unir-se a colunas de caractere ou de fator."

#: bmerge.R:96
msgid "%s has same type (%s) as %s. No coercion needed."
msgstr "%s tem o mesmo tipo (%s) de %s. Nenhuma coerção necessária."

#: bmerge.R:102 bmerge.R:106
msgid "(all-NA)"
msgstr "(tudo NA)"

#: bmerge.R:109
#, c-format
msgid "Incompatible join types: %s (%s) and %s (%s)"
msgstr "Tipos de junção incompatíveis: %s (%s) e %s (%s)"

#: bmerge.R:115
msgid "(which has integer64 representation, e.g. no fractions)"
msgstr "(que tem representação integer64, ou seja, sem frações)"

#: bmerge.R:117
#, c-format
msgid ""
"Incompatible join types: %s is type integer64 but %s is type double and "
"cannot be coerced to integer64 (e.g. has fractions)"
msgstr ""
"Tipos de junção incompatíveis: %s é do tipo integer64 mas %s é do tipo "
"'double' e a coerção para integer64 não pode ser feita (p. ex. há frações)"

#: bmerge.R:137
msgid "(which contains no fractions)"
msgstr "(que não contém frações)"

#: bmerge.R:149
msgid "(which contains fractions)"
msgstr "(que contém frações)"

#: bmerge.R:152
msgid "(for join)"
msgstr "(para junção)"

#: bmerge.R:170
msgid "on= matches existing key, using key"
msgstr "on= corresponde à chave existente, usando chave"

#: bmerge.R:175
msgid "on= matches existing index, using index"
msgstr "on= corresponde ao índice existente, usando índice"

#: bmerge.R:180
msgid "Calculated ad hoc index in %s"
msgstr "Calculado índice ad hoc em %s"

#: bmerge.R:191
msgid "Non-equi join operators detected ..."
msgstr "Operadores de junção por desigualdade detectados ..."

#: bmerge.R:192
#, c-format
msgid "roll is not implemented for non-equi joins yet."
msgstr "'roll' ainda não está implementado para junções por desigualdade."

#: bmerge.R:193
msgid "forder took ..."
msgstr "forder levou ..."

#: bmerge.R:202
msgid "Generating group lengths ..."
msgstr "Gerando comprimentos de grupo ..."

#: bmerge.R:207
msgid "Generating non-equi group ids ..."
msgstr "Gerando ids de grupos por desigualdade ..."

#: bmerge.R:212
#, c-format
msgid "Column name '_nqgrp_' is reserved for non-equi joins."
msgstr ""
"O nome de coluna '_nqgrp_' está reservado para junções por desigualdade."

#: bmerge.R:213
msgid "Recomputing forder with non-equi ids ..."
msgstr "Recalculando forder com ids por desigualdade ..."

#: bmerge.R:222
msgid "Starting bmerge ..."
msgstr "Iniciando bmerge ..."

#: bmerge.R:224
msgid "bmerge done in %s"
msgstr "bmerge concluído em %s"

#: cedta.R:77
msgid ""
"cedta decided '%s' wasn't data.table aware. Here is call stack with [[1L]] "
"applied:"
msgstr ""
"cedta dediu que '%s' não estava ciente de data.table. Aqui está a pilha de "
"chamadas com [[1L]] aplicado:"

#: data.table.R:55
#, c-format
msgid "key argument of data.table() must be character"
msgstr "o argumento key do data.table() deve ser caractere"

#: data.table.R:123
#, c-format
msgid "Object '%s' not found. Perhaps you intended %s"
msgstr "Objeto '%s' não encontrado. Talvez sua intenção fosse %s"

#: data.table.R:125
#, c-format
msgid "Object '%s' not found amongst %s"
msgstr "Objeto '%s' não encontrado entre %s"

#: data.table.R:134
#, c-format
msgid ""
"Invalid set* operation on a recursive index L[[i]] where i has length %d. "
"Chain [[ instead."
msgstr ""
"Operação set* inválida em um índice recursivo L[[i]] sendo que i tem "
"comprimento %d. Encadeie [[ em vez disso."

#: data.table.R:139
#, c-format
msgid "Item '%s' not found in names of input list"
msgstr "Item '%s' não encontrado nos nomes da lista recebida"

#: data.table.R:159
#, c-format
msgid ""
"[ was called on a data.table in an environment that is not data.table-aware "
"(i.e. cedta()), but '%s' was used, implying the owner of this call really "
"intended for data.table methods to be called. See vignette('datatable-"
"importing') for details on properly importing data.table."
msgstr ""
"[ foi chamado em uma data.table em um ambiente que não está ciente de "
"data.table (p.ex. cedta()), mas '%s' foi usado, implicando que o dono desta "
"chamada realmente pretendia que métodos data.table fossem chamados. Veja "
"vignette('datatable-importing') para detalhes sobre importar uma data.table "
"apropriadamente."

#: data.table.R:170
#, c-format
msgid "verbose must be logical or integer"
msgstr "verbose deve ser lógico ou inteiro"

#: data.table.R:171
#, c-format
msgid "verbose must be length 1 non-NA"
msgstr "verbose deve ser não NA e de comprimento 1"

#: data.table.R:179
#, c-format
msgid "Ignoring by/keyby because 'j' is not supplied"
msgstr "Ignorando by/keyby porque 'j' não foi fornecido"

#: data.table.R:193
#, c-format
msgid "When by and keyby are both provided, keyby must be TRUE or FALSE"
msgstr "Quando by e keyby são ambos fornecidos, keyby deve ser TRUE ou FALSE"

#: data.table.R:196 data.table.R:261 data.table.R:351
msgid "Argument '%s' after substitute: %s"
msgstr "Argumento '%s' após substituto: %s"

#: data.table.R:205
#, c-format
msgid ""
"When on= is provided but not i=, on= must be a named list or data.table|"
"frame, and a natural join (i.e. join on common names) is invoked. Ignoring "
"on= which is '%s'."
msgstr ""
"Quando on= é fornecido, mas não i=, on= deve ser uma lista nomeada ou "
"data.table|frame, e uma junção natural (ou seja, junção em nomes comuns) é "
"invocada. Ignorando on= , que é '%s'."

#: data.table.R:218
#, c-format
msgid ""
"i and j are both missing so ignoring the other arguments. This warning will "
"be upgraded to error in future."
msgstr ""
"i e j estão faltando, ignorando os outros argumentos. Este aviso será "
"atualizado para se tornar um erro no futuro."

#: data.table.R:222
#, c-format
msgid "mult argument can only be 'first', 'last', 'all' or 'error'"
msgstr "o argumento mult só pode ser 'first', 'last', 'all' ou 'error'"

#: data.table.R:224
#, c-format
msgid ""
"roll must be a single TRUE, FALSE, positive/negative integer/double "
"including +Inf and -Inf or 'nearest'"
msgstr ""
"roll deve ser TRUE, FALSE, número inteiro/duplo positivo/negativo, incluindo "
"+Inf e -Inf ou 'nearest'"

#: data.table.R:226
#, c-format
msgid "roll is '%s' (type character). Only valid character value is 'nearest'."
msgstr ""
"roll é '%s' (tipo caractere). O único valor de caractere válido é 'nearest'."

#: data.table.R:231
#, c-format
msgid "rollends must be a logical vector"
msgstr "rollends deve ser um vetor lógico"

#: data.table.R:232
#, c-format
msgid "rollends must be length 1 or 2"
msgstr "rollends deve ter comprimento 1 ou 2"

#: data.table.R:240
#, c-format
msgid ""
"nomatch= must be either NA or NULL (or 0 for backwards compatibility which "
"is the same as NULL but please use NULL)"
msgstr ""
"nomatch= deve ser NA ou NULL (ou 0 para compatibilidade com versões "
"anteriores, que é igual a NULL, mas use NULL)"

#: data.table.R:243
#, c-format
msgid "which= must be a logical vector length 1. Either FALSE, TRUE or NA."
msgstr "which= deve ser um vetor lógico de comprimento 1. FALSE, TRUE ou NA."

#: data.table.R:244
#, c-format
msgid ""
"which==%s (meaning return row numbers) but j is also supplied. Either you "
"need row numbers or the result of j, but only one type of result can be "
"returned."
msgstr ""
"which==%s (significando retornar números de linha), mas j também é "
"fornecido. Ou você precisa de números de linha ou do resultado de j, mas "
"apenas um tipo de resultado pode ser retornado."

#: data.table.R:245
#, c-format
msgid ""
"which=NA with nomatch=0|NULL would always return an empty vector. Please "
"change or remove either which or nomatch."
msgstr ""
"which=NA com nomatch=0|NULL sempre retornaria um vetor vazio. Favor alterar "
"ou remover ou which, ou nomatch."

#: data.table.R:246
#, c-format
msgid "j must be provided when with=FALSE"
msgstr "j deve ser fornecido quando with=FALSE"

#: data.table.R:247
#, c-format
msgid "%s must be TRUE or FALSE"
msgstr "%s deve ser TRUE ou FALSE"

#: data.table.R:290
#, c-format
msgid ""
"The symbol .. is invalid. The .. prefix must be followed by at least one "
"character."
msgstr ""
"O símbolo .. é inválido. O prefixo .. deve ser seguido por pelo menos um "
"caractere."

#: data.table.R:294
#, c-format
msgid ""
"Variable '..%s' does exist in calling scope though, so please just removed "
"the .. prefix from that variable name in calling scope."
msgstr ""
"A variável '..%s' existe no escopo de chamada, portanto, então favor "
"simplesmente remover o prefixo .. desse nome de variável no escopo de "
"chamada."

#: data.table.R:298
#, c-format
msgid ""
"Variable '%s' is not found in calling scope. Looking in calling scope "
"because you used the .. prefix.%s"
msgstr ""
"A variável '%s' não foi encontrada no escopo de chamada. Procurando no "
"escopo de chamada porque você usou .. como prefixo.%s"

#: data.table.R:300
#, c-format
msgid ""
"Both '%1$s' and '..%1$s' exist in calling scope. Please remove the '..%1$s' "
"variable in calling scope for clarity."
msgstr ""
"Tanto '%1$s' quanto '..%1$s' existem no escopo de chamada. Remova a variável "
"'..%1$s' na chamada do escopo para maior clareza."

#: data.table.R:308
#, c-format
msgid ""
"Variable '%s' is not found in calling scope. Looking in calling scope "
"because you set with=FALSE. Also, please use .. symbol prefix and remove "
"with=FALSE."
msgstr ""
"A variável '%s' não foi encontrada no escopo de chamada. Procurando no "
"escopo de chamada porque você definiu with=FALSE. Além disso, favor usr o "
"prefixo de símbolo .. e remover with=FALSE."

#: data.table.R:316
#, c-format
msgid ""
"Invalid use of `:=` inside `{}`. `:=` must be the only expression inside `{}"
"` when used in `j`. Instead of: DT[{tmp1 <- ...; tmp2 <- ...; someCol := "
"tmp1 * tmp2}], Use: DT[, someCol := {tmp1 <- ...; tmp2 <- ...; tmp1 * tmp2}]"
msgstr ""
"Uso inválido de `:=` dentro de `{}`. `:=` deve ser a única expressão dentro "
"de  `{}` quando usado em `j`. Em vez de: DT[{tmp1 <- ...; tmp2 <- ...; "
"someCol := tmp1 * tmp2}], use: DT[, someCol := {tmp1 <- ...; tmp2 <- ...; "
"tmp1 * tmp2}]"

#: data.table.R:334
#, c-format
msgid ""
":= with keyby is only possible when i is not supplied since you can't setkey "
"on a subset of rows. Either change keyby to by or remove i"
msgstr ""
":= com keyby só é possível quando i não é fornecido, pois você não pode "
"definir a chave em um subconjunto de linhas. Ou altere keyby para by, ou "
"remova i"

#: data.table.R:336
#, c-format
msgid "nomatch isn't relevant together with :=, ignoring nomatch"
msgstr "nomatch não é relevante junto com :=, ignorando nomatch"

#: data.table.R:392
#, c-format
msgid ""
"not-join '!' prefix is present on i but nomatch is provided. Please remove "
"nomatch."
msgstr ""
"prefixo de não-junção '!' está presente em i, mas nomatch foi fornecido. Por "
"favor, remova nomatch."

#: data.table.R:420
#, c-format
msgid ""
"Operator := detected in i, the first argument inside DT[...], but is only "
"valid in the second argument, j. Most often, this happens when forgetting "
"the first comma (e.g. DT[newvar := 5] instead of DT[ , new_var := 5]). "
"Please double-check the syntax. Run traceback(), and debugger() to get a "
"line number."
msgstr ""
"Operador := detectado em i, o primeiro argumento dentro de DT[...], mas só é "
"válido no segundo argumento, j. Na maioria das vezes, isso acontece quando "
"se esquece a primeira vírgula (por exemplo, DT[nova_var := 5] em vez de "
"DT[ , nova_var := 5]). Verifique novamente a sintaxe. Execute traceback() e "
"debugger() para obter um número de linha."

#: data.table.R:430
#, c-format
msgid "'%s' is not found in calling scope and it is not a column name either"
msgstr ""
"'%s' não foi encontrado no escopo de chamada e também não é um nome de coluna"

#: data.table.R:433
#, c-format
msgid ""
"'%s' is not found in calling scope, but it is a column of type %s. If you "
"wish to select rows where that column contains TRUE, or perhaps that column "
"contains row numbers of itself to select, try DT[(col)], DT[DT$col], or "
"DT[col==TRUE] is particularly clear and is optimized"
msgstr ""
"'%s' não foi encontrado no escopo de chamada, mas é uma coluna do tipo %s. "
"Se você deseja selecionar linhas onde essa coluna contém TRUE, ou talvez "
"onde essa coluna contenha números de linha para selecionar, tente DT[(col)], "
"DT[DT$col] ou DT[col==TRUE}, o que é particularmente claro e otimizado"

#: data.table.R:436
#, c-format
msgid ""
"%s. When the first argument inside DT[...] is a single symbol (e.g. "
"DT[var]), data.table looks for var in calling scope."
msgstr ""
"%s. Quando o primeiro argumento dentro de DT[...] é um único símbolo (por "
"exemplo, DT[var]), data.table procura por var na chamada do escopo."

#: data.table.R:448
#, c-format
msgid ""
"i is invalid type (matrix). Perhaps in future a 2 column matrix could return "
"a list of elements of DT (in the spirit of A[B] in FAQ 2.14). Please report "
"to data.table issue tracker if you'd like this, or add your comments to FR "
"#657."
msgstr ""
"i é um tipo inválido (matrix). Talvez no futuro uma matriz de 2 colunas "
"possa retornar uma lista de elementos de DT (no espírito de A[B] no FAQ "
"2.14). Por favor, relate no rastreador de problemas do data.table se desejar "
"isso, ou adicione seus comentários ao FR #657."

#: data.table.R:471
#, c-format
msgid ""
"When i is a data.table (or character vector), the columns to join by must be "
"specified using the 'on=' argument (see ?data.table); by keying x (i.e., x "
"is sorted and marked as such, see ?setkey); or by using 'on = .NATURAL' to "
"indicate using the shared column names between x and i (i.e., a natural "
"join). Keyed joins might have further speed benefits on very large data due "
"to x being sorted in RAM."
msgstr ""
"Quando i é uma data.table (ou vetor de caracteres), as colunas nas quais "
"fazer a junção devem ser especificadas usando o argumento 'on=' (consulte ?"
"data.table), por meio de chaveamento de x (ou seja, x é ordenado e marcado "
"como ordenado, consulte ?setkey) ou usando 'on = .NATURAL' para indicar "
"usando os nomes de colunas compartilhados entre x e i (ou seja, uma junção "
"natural). As junções chaveadas podem ter benefícios adicionais de velocidade "
"em dados muito grandes devido ao x estar ordenado na RAM."

#: data.table.R:479
#, c-format
msgid "Attempting to do natural join but no common columns in provided tables"
msgstr ""
"Tentando fazer junção natural, mas não há colunas comuns nas tabelas "
"fornecidas"

#: data.table.R:482
msgid "Joining but 'x' has no key, natural join using all 'x' columns"
msgstr ""
"Fazendo junção, mas 'x' não tem chave; junção natural usando todas as "
"colunas de 'x'"

#: data.table.R:484
msgid "Joining but 'x' has no key, natural join using: %s"
msgstr "Fazendo junção, mas 'x' não tem chave; junção natural usando: %s"

#: data.table.R:513
msgid "not-join called with 'by=.EACHI'; Replacing !i with i=setdiff_(x,i) ..."
msgstr ""
"não-junção chamada com 'by=.EACHI'; Substituindo !i com i=setdiff_(x,i) ..."

#: data.table.R:544
msgid "Constructing irows for '!byjoin || nqbyjoin' ..."
msgstr "Construindo irows para '!byjoin || nqbyjoin' ..."

#: data.table.R:558 mergelist.R:124
#, c-format
msgid ""
"Joining resulted in many-to-many join. Perform quality check on your data, "
"use mult!='all', or set 'datatable.join.many' option to TRUE to allow rows "
"explosion."
msgstr ""
"A junção resultou em uma junção muitos-para-muitos. Realize uma verificação "
"de qualidade nos seus dados, use mult!='all' ou defina a opção "
"'datatable.join.many' como TRUE para permitir a expansão de linhas."

#: data.table.R:596
msgid "Reorder irows for 'mult==\"all\" && !allGrp1' ..."
msgstr "Reordenar irows para 'mult==\"all\" && !allGrp1' ..."

#: data.table.R:608
msgid "Reordering %d rows after bmerge done in ..."
msgstr "Reordenando %d linhas após bmerge ser concluído em ..."

#: data.table.R:625
#, c-format
msgid "logical error. i is not a data.table, but 'on' argument is provided."
msgstr ""
"erro lógico. i não é uma data.table, mas o argumento 'on' foi fornecido."

#: data.table.R:629
#, c-format
msgid "i has evaluated to type %s. Expecting logical, integer or double."
msgstr "i foi avaliado para o tipo %s. Esperava lógico, inteiro ou 'double'."

#: data.table.R:651
#, c-format
msgid ""
"i evaluates to a logical vector length %d but there are %d rows. Recycling "
"of logical i is no longer allowed as it hides more bugs than is worth the "
"rare convenience. Explicitly use rep(...,length=.N) if you really need to "
"recycle."
msgstr ""
"i foi avaliado como um vetor lógico de comprimento %d, mas há %d linhas. A "
"reciclagem do i lógico não é mais permitida, pois mais esconde bugs do que "
"vale a rara conveniência. Use explicitamente rep(...,length=.N) se você "
"realmente precisar reciclar."

#: data.table.R:654
#, c-format
msgid ""
"Please use nomatch=NULL instead of nomatch=0; see news item 5 in v1.12.0 "
"(Jan 2019)"
msgstr ""
"Favor usar nomatch=NULL em vez de nomatch=0; veja o item 5 das novidades da "
"v1.12.0 (jan 2019)"

#: data.table.R:669
msgid "Inverting irows for notjoin done in ..."
msgstr "Inversão de irows para não-junção concluída em ..."

#: data.table.R:725
#, c-format
msgid "`:=` is only supported under with=TRUE, see ?`:=`."
msgstr "`:=` só é suportado sob with=TRUE, veja ?`:=`."

#: data.table.R:767
#, c-format
msgid "Item %d of j is %d which is outside the column number range [1,ncol=%d]"
msgstr ""
"O item %d de j é %d, o qual está fora do intervalo de números de colunas "
"[1,ncol=%d]"

#: data.table.R:770
#, c-format
msgid "j mixes positives and negatives"
msgstr "j mistura positivos e negativos"

#: data.table.R:778
#, c-format
msgid ""
"When with=FALSE, j-argument should be of type logical/character/integer "
"indicating the columns to select."
msgstr ""
"Quando with=FALSE, o argumento j deve ser do tipo lógico/caractere/inteiro "
"indicando as colunas a serem selecionadas."

#: data.table.R:792
#, c-format
msgid ""
"'by' contains .I but only the following are currently supported: by=.I, by=."
"(.I), by=c(.I), by=list(.I)"
msgstr ""
"'by' contém .I, mas atualmente só há suporte aos seguintes: by=.I, by=.(.I), "
"by=c(.I), by=list(.I)"

#: data.table.R:816
#, c-format
msgid "by=c(...), key(...) or names(...) must evaluate to 'character'"
msgstr "by=c(...), key(...) ou names(...) devem ser avaliados para 'character'"

#: data.table.R:826
#, c-format
msgid ""
"'by' is a character vector length %d but one or more items include a comma. "
"Either pass a vector of column names (which can contain spaces, but no "
"commas), or pass a vector length 1 containing comma separated column names. "
"See ?data.table for other possibilities."
msgstr ""
"'by' é um vetor de caracteres de comprimento %d, mas um ou mais itens "
"incluem uma vírgula. Passe um vetor de nomes de colunas (que pode conter "
"espaços, mas nenhuma vírgula) ou passe um vetor de comprimento 1 contendo "
"nomes de colunas separados por vírgula. Veja ?data.table para outras "
"possibilidades."

#: data.table.R:833
#, c-format
msgid "At least one entry of by is empty"
msgstr "Ao menos uma entrada de by está vazia"

#: data.table.R:860
msgid "by index '%s' but that index has 0 length. Ignoring."
msgstr "índice by '%s', mas aquele índice tem comprimento 0. Ignorando."

#: data.table.R:883
msgid "i clause present and columns used in by detected, only these subset: %s"
msgstr ""
"cláusula de i presente e colunas usadas em by detectadas, apenas estes "
"subconjuntos: %s"

#: data.table.R:886
msgid ""
"i clause present but columns used in by not detected. Having to subset all "
"columns before evaluating 'by': '%s'"
msgstr ""
"cláusula de i presente, mas colunas usadas em by não detectadas. Tendo que "
"obter um subconjunto de todas as colunas antes de avaliar 'by': '%s'"

#: data.table.R:908
#, c-format
msgid ""
"'by' appears to evaluate to column names but isn't c() or key(). Use "
"by=list(...) if you can. Otherwise, by=eval%s should work. This is for "
"efficiency so data.table can detect which columns are needed."
msgstr ""
"'by' parece ser avaliado para nomes de colunas, mas não é c() ou key(). Use "
"by=list(...) se puder. Caso contrário, by=eval%s deveria funcionar. Isso é "
"para maior eficiência, para que data.table possa detectar quais colunas são "
"necessárias."

#: data.table.R:919
#, c-format
msgid ""
"'by' or 'keyby' must evaluate to a vector or a list of vectors (where 'list' "
"includes data.table and data.frame which are lists, too)"
msgstr ""
"'by' ou 'keyby' deve ser avaliado como um vetor ou uma lista de vetores "
"(onde 'list' inclui data.table e data.frame, que também são listas)"

#: data.table.R:923
#, c-format
msgid ""
"Column or expression %d of 'by' or 'keyby' is type '%s' which is not "
"currently supported. If you have a compelling use case, please add it to "
"https://github.com/Rdatatable/data.table/issues/1597. As a workaround, "
"consider converting the column to a supported type, e.g. by=sapply(list_col, "
"toString), whilst taking care to maintain distinctness in the process."
msgstr ""
"A coluna ou expressão %d de 'by' ou 'keyby' é do tipo '%s' e não é suportada "
"atualmente. Se você tiver um caso de uso atraente, adicione-o a https://"
"github.com/Rdatatable/data.table/issues/1597. Como solução alternativa, "
"considere converter a coluna em um tipo compatível, como "
"by=sapply(lista_colunas, toString), tomando cuidado para manter a distinção "
"no processo."

#: data.table.R:951
msgid ""
"by-expression '%s' is not named, and the auto-generated name '%s' clashed "
"with variable(s) in j. Therefore assigning the entire by-expression as name."
msgstr ""
"expressão by '%s' não nomeada, e o nome gerado automaticamente '%s' entrou "
"em conflito com a(s) variável(eis) em j. Portanto, atribuindo toda a "
"expressão by como nome."

#: data.table.R:985
#, c-format
msgid "Item %d of the .() or list() passed to j is missing"
msgstr "O item %d de .() ou list() passado para j está ausente"

#: data.table.R:991
#, c-format
msgid ""
"j may not evaluate to the same number of columns for each group; if you're "
"sure this warning is in error, please put the branching logic outside of "
"[ for efficiency"
msgstr ""
"j pode não ser avaliado com o mesmo número de colunas para cada grupo; se "
"você tiver certeza de que este aviso está errado, coloque a lógica de "
"branching fora de [ para eficiência"

#: data.table.R:993
#, c-format
msgid ""
"Different branches of j expression produced different auto-named columns: "
"%s; using the most \"last\" names. If this was intentional (e.g., you know "
"only one branch will ever be used in a given query because the branch is "
"controlled by a function argument), please (1) pull this branch out of the "
"call; (2) explicitly provide missing defaults for each branch in all cases; "
"or (3) use the same name for each branch and re-name it in a follow-up call."
msgstr ""
"Diferentes branches da expressão j produziram diferentes colunas nomeadas "
"automaticamente: %s; usando os nomes definidos por último. Se isso foi "
"intencional (por exemplo, você sabe que apenas um branch será usado em uma "
"determinada consulta porque o branch é controlado por um argumento de "
"função), favor, (1) retirar esse branch da chamada; (2) fornecer "
"explicitamente os valores padrão faltantes para cada branch em todos os "
"casos; ou (3) use o mesmo nome para cada branch e renomeie-o em uma chamada "
"seguinte."

#: data.table.R:1063
#, c-format
msgid ""
"When .SDcols is a function, it is applied to each column; the output of this "
"function must be a non-missing boolean scalar signalling inclusion/exclusion "
"of the column. However, these conditions were not met for: %s"
msgstr ""
"Quando .SDcols é uma função, ela é aplicada a cada coluna; a saída desta "
"função deve ser um escalar booleano não NA sinalizando inclusão/exclusão da "
"coluna. No entanto, estas condições não foram cumpridas para: %s"

#: data.table.R:1069
#, c-format
msgid ".SDcols missing at the following indices: %s"
msgstr ".SDcols ausentes nos seguintes índices: %s"

#: data.table.R:1071
#, c-format
msgid ".SDcols is a logical vector of length %d but there are %d columns"
msgstr ".SDcols é um vetor lógico de comprimento %d, mas existem %d colunas"

#: data.table.R:1077
#, c-format
msgid ".SDcols is numeric but has both +ve and -ve indices"
msgstr ".SDcols é numérico, mas possui índices positivos e negativos"

#: data.table.R:1079
#, c-format
msgid ".SDcols is numeric but out of bounds [1, %d] at: %s"
msgstr ".SDcols é numérico, mas está fora dos limites [1, %d] em: %s"

#: data.table.R:1083
#, c-format
msgid ".SDcols should be column numbers or names"
msgstr ".SDcols deve consistir em números ou nomes de colunas"

#: data.table.R:1085
#, c-format
msgid "Some items of .SDcols are not column names: %s"
msgstr "Alguns itens de .SDcols não são nomes de colunas: %s"

#: data.table.R:1098
msgid ""
"'(m)get' found in j. ansvars being set to all columns. Use .SDcols or a "
"single j=eval(macro) instead. Both will detect the columns used which is "
"important for efficiency.\n"
"Old ansvars: %s"
msgstr ""
"'(m)get' encontrado em j. ansvars sendo definido para todas as colunas. "
"Use .SDcols ou um único j=eval(macro) em vez disso. Ambos detectarão as "
"colunas usadas, o que é importante para a eficiência.\n"
"ansvars antigo: %s"

#: data.table.R:1118
msgid "New ansvars: %s"
msgstr "Novo ansvars: %s"

#: data.table.R:1127
#, c-format
msgid ""
"This j doesn't use .SD but .SDcols has been supplied. Ignoring .SDcols. See ?"
"data.table."
msgstr ""
"Este j não usa .SD, mas .SDcols foi fornecido. Ignorando .SDcols. Consulte ?"
"data.table."

#: data.table.R:1130
msgid "Detected that j uses these columns: %s"
msgstr "Detectado que j usa estas colunas: %s"

#: data.table.R:1143
#, c-format
msgid ""
".SD is locked. Using := in .SD's j is reserved for possible future use; a "
"tortuously flexible way to modify by group. Use := in j directly to modify "
"by group by reference."
msgstr ""
".SD é travado. O uso de := no j de .SD está reservado para possível uso "
"futuro; uma maneira tortuosamente flexível de modificar por grupo. Use := in "
"j diretamente para modificar por grupo por referência."

#: data.table.R:1154
#, c-format
msgid "In %s(col1=val1, col2=val2, ...) form, all arguments must be named."
msgstr ""
"Na forma %s(col1=val1, col2=val2, ...), todos os argumentos devem ser "
"nomeados."

#: data.table.R:1177
#, c-format
msgid ""
"In %s(col1=val1, col2=val2, ...) form, all arguments must be named, but the "
"last argument has no name. Did you forget a trailing comma?"
msgstr ""
"Na forma %s(col1=val1, col2=val2, ...), todos os argumentos devem ser "
"nomeados, mas o último argumento não tem nome. Você se esqueceu de uma "
"vírgula final?"

#: data.table.R:1179
#, c-format
msgid ""
"In %s(col1=val1, col2=val2, ...) form, all arguments must be named, but "
"these arguments lack names: %s."
msgstr ""
"Na forma %s(col1=val1, col2=val2, ...), todos os argumentos devem ser "
"nomeados, mas estes elementos estão sem nome: %s."

#: data.table.R:1186
#, c-format
msgid ""
"LHS of := must be a symbol, or an atomic vector (column names or positions)."
msgstr ""
"O lado esquerdo de := deve ser um símbolo ou um vetor atômico (nomes de "
"colunas ou posições)."

#: data.table.R:1191
#, c-format
msgid ""
"LHS of := appears to be column positions but are outside [1,ncol] range. New "
"columns can only be added by name."
msgstr ""
"Parece que o lado esquerdo de := são posições de coluna, mas estão fora do "
"intervalo [1,ncol]. Novas colunas só podem ser adicionadas por nome."

#: data.table.R:1193
#, c-format
msgid ""
"LHS of := isn't column names ('character') or positions ('integer' or "
"'numeric')"
msgstr ""
"O lado esquerdo de := não são nomes de colunas ('character') ou posições "
"('integer' ou 'numeric')"

#: data.table.R:1209
msgid ""
"No rows match i. No new columns to add so not evaluating RHS of :=\n"
"Assigning to 0 row subset of %d rows"
msgstr ""
"Nenhuma linha corresponde a i. Nenhuma coluna nova para adicionar, portanto, "
"não será avaliado o lado direito de :=\n"
"Atribuindo a um subconjunto com 0 linha das %d linhas"

#: data.table.R:1225
#, c-format
msgid ""
"A shallow copy of this data.table was taken so that := can add or remove %d "
"columns by reference. At an earlier point, this data.table was copied by R "
"(or was created manually using structure() or similar). Avoid names<- and "
"attr<- which in R currently (and oddly) may copy the whole data.table. Use "
"set* syntax instead to avoid copying: ?set, ?setnames and ?setattr. It's "
"also not unusual for data.table-agnostic packages to produce tables affected "
"by this issue. If this message doesn't help, please report your use case to "
"the data.table issue tracker so the root cause can be fixed or this message "
"improved."
msgstr ""
"Uma cópia rasa desta data.table foi feita de forma que := possa adicionar ou "
"remover %d colunas por referência. Anteriormente, esta data.table foi "
"copiada pelo R (ou foi criado manualmente usando structure() ou similar). "
"Evite names<- e attr<-, que no R atualmente (e estranhamente) podem copiar "
"toda a data.table. Use em vez disso a sintaxe set* para evitar copiar: ?"
"set, ?setnames e ?setattr. Também não é incomum que pacotes que desconhecem "
"o data.table produzam tabelas afetadas por essa questão. Se esta mensagem "
"não ajudar, por favor, relate isso no rastreador de problemas do data.table "
"para que a causa raiz possa ser corrigida ou esta mensagem melhorada."

#: data.table.R:1285
#, c-format
msgid ""
"Variable '%s' is not found in calling scope. Looking in calling scope "
"because this symbol was prefixed with .. in the j= parameter."
msgstr ""
"A variável '%s' não foi encontrada no escopo de chamada. Procurando no "
"escopo de chamada porque este símbolo foi prefixado com .. no parâmetro j=."

#: data.table.R:1358
#, c-format
msgid ""
"j (the 2nd argument inside [...]) is a single symbol but column name '%1$s' "
"is not found. If you intended to select columns using a variable in calling "
"scope, please try DT[, ..%1$s]. The .. prefix conveys one-level-up similar "
"to a file system path."
msgstr ""
"j (o 2º argumento dentro de [...]) é um símbolo único, mas o nome da coluna "
"'%1$s' não foi encontrado. Se você pretendia selecionar colunas usando uma "
"variável na chamada do escopo, tente DT[, ..%1$s]. O prefixo .. transmite um "
"nível superior semelhante a um caminho do sistema de arquivos."

#: data.table.R:1408
msgid ""
"Growing vector of column pointers from truelength %d to %d. A shallow copy "
"has been taken, see ?setalloccol. Only a potential issue if two variables "
"point to the same data (we can't yet detect that well) and if not you can "
"safely ignore this. To avoid this message you could setalloccol() first, "
"deep copy first using copy(), wrap with suppressWarnings() or increase the "
"'datatable.alloccol' option."
msgstr ""
"Vetor crescente de ponteiros de coluna de truelength %d para %d. Uma cópia "
"rasa foi feita, veja ?setalloccol. Apenas um problema potencial se duas "
"variáveis ​​apontarem para os mesmos dados (ainda não conseguimos detectar "
"isso bem) e se não, você pode ignorar isso com segurança. Para evitar essa "
"mensagem, você pode fazer setalloccol() primeiro, fazer uma cópia profunda "
"primeiro usando copy(), encapsular com suppressWarnings() ou aumentar a "
"opção 'datatable.alloccol'."

#: data.table.R:1410
msgid ""
"Note that the shallow copy will assign to the environment from which := was "
"called. That means for example that if := was called within a function, the "
"original table may be unaffected."
msgstr ""
"Note que a cópia rasa será atribuída ao ambiente do qual := foi chamado. "
"Isso significa, por exemplo, que se := foi chamado dentro de uma função, a "
"tabela original pode não ser afetada."

#: data.table.R:1495
#, c-format
msgid ""
"The column '.N' can't be grouped because it conflicts with the special .N "
"variable. Try setnames(DT,'.N','N') first."
msgstr ""
"A coluna '.N' não pode ser agrupada porque conflita com a variável "
"especial .N. Tente setnames(DT,'.N','N') primeiro."

#: data.table.R:1496
#, c-format
msgid ""
"The column '.I' can't be grouped because it conflicts with the special .I "
"variable. Try setnames(DT,'.I','I') first."
msgstr ""
"A coluna '.I' não pode ser agrupada porque conflita com a variável "
"especial .I. Tente setnames(DT,'.I','I') primeiro."

#: data.table.R:1515
msgid ""
"Note: forcing units=\"secs\" on implicit difftime by group; call difftime "
"explicitly to choose custom units"
msgstr ""
"Nota: forçando unidades=\"secs\" em difftime implícito por grupo; chame "
"difftime explicitamente para escolher unidades personalizadas"

#: data.table.R:1524
#, c-format
msgid "logical error. i is not a data.table, but mult='all' and 'by'=.EACHI"
msgstr "erro lógico. i não é uma data.table, mas mult='all' e 'by'=.EACHI"

#: data.table.R:1551
msgid "Finding groups using forderv ..."
msgstr "Encontrando grupos usando forderv ..."

#: data.table.R:1565 data.table.R:1597
msgid "Finding group sizes from the positions (can be avoided to save RAM) ..."
msgstr ""
"Encontrando tamanhos de grupo a partir das posições (pode ser evitado para "
"economizar RAM) ..."

#: data.table.R:1573
msgid "Getting back original order ..."
msgstr "Retornando a ordem original..."

#: data.table.R:1585
msgid "Finding groups using uniqlist on key ..."
msgstr "Encontrando grupos usando uniqlist na chave ..."

#: data.table.R:1589
msgid "Finding groups using uniqlist on index '%s' ..."
msgstr "Encontrando grupos usando uniqlist no índice '%s' ..."

#: data.table.R:1808
msgid "lapply optimization changed j from '%s' to '%s'"
msgstr "otimização lapply mudou j de '%s' para '%s'"

#: data.table.R:1810
msgid "lapply optimization is on, j unchanged as '%s'"
msgstr "otimização lapply está ativada, j inalterado como '%s'"

#: data.table.R:1819 data.table.R:1843
msgid "GForce optimized j to '%s' (see ?GForce)"
msgstr "GForce otimizou j para '%s' (veja ?GForce)"

#: data.table.R:1844
msgid ""
"GForce is on, but not activated for this query; left j unchanged (see ?"
"GForce)"
msgstr ""
"GForce está ligado, mas não ativado para esta consulta; j deixado inalterado "
"(veja ?GForce)"

#: data.table.R:1863
#, c-format
msgid ""
"Unable to optimize call to mean() and could be very slow. You must name "
"'na.rm' like that otherwise if you do mean(x,TRUE) the TRUE is taken to mean "
"'trim' which is the 2nd argument of mean. 'trim' is not yet optimized."
msgstr ""
"Não foi possível otimizar a chamada de mean() e pode ser muito lento. Você "
"deve nomear 'na.rm' como tal, caso contrário, se você usar mean(x,TRUE), o "
"TRUE é obtido para fazer uma média truncada, pois 'trim' é o 2º argumento de "
"mean. 'trim' ainda não está otimizado."

#: data.table.R:1867
msgid "Old mean optimization changed j from '%s' to '%s'"
msgstr "A otimização média antiga mudou j de '%s' para '%s'"

#: data.table.R:1869
msgid "Old mean optimization is on, left j unchanged."
msgstr "A antiga otimização de mean está ativa, j deixado inalterado."

#: data.table.R:1879
msgid "All optimizations are turned off"
msgstr "Todas as otimizações estão desativadas"

#: data.table.R:1880
msgid "Optimization is on but left j unchanged (single plain symbol): '%s'"
msgstr ""
"A otimização está ativa, mas j deixado inalterado (símbolo simples único): "
"'%s'"

#: data.table.R:1909
msgid "Making each group and running j (GForce %s) ..."
msgstr "Criando cada grupo e executando j (GForce %s) ..."

#: data.table.R:2005
msgid "setkey() after the := with keyby= ..."
msgstr "setkey() depois de := com keyby= ..."

#: data.table.R:2009
#, c-format
msgid ""
"The setkey() normally performed by keyby= has been skipped (as if by= was "
"used) because := is being used together with keyby= but the keyby= contains "
"some expressions. To avoid this warning, use by= instead, or provide "
"existing column names to keyby=."
msgstr ""
"O setkey() normalmente executado por keyby= foi ignorado (como se by= fosse "
"usado) porque := está sendo usado junto com keyby= mas keyby= contém algumas "
"expressões. Para evitar esse aviso, use by= ou forneça nomes de colunas "
"existentes para keyby=."

#: data.table.R:2035
msgid "setkey() afterwards for keyby=.EACHI ..."
msgstr "setkey() depois para keyby=.EACHI ..."

#: data.table.R:2144
#, c-format
msgid "rownames and rownames.value cannot both be used at the same time"
msgstr "rownames e rownames.value não podem ser usados ao mesmo tempo"

#: data.table.R:2147
#, c-format
msgid ""
"length(rownames)==%d but nrow(DT)==%d. The rownames argument specifies a "
"single column name or number. Consider rownames.value= instead."
msgstr ""
"length(rownames)==%d, mas nrow(DT)==%d. O argumento rownames especifica um "
"único nome ou número de coluna. Considere usar rownames.value= em vez disso."

#: data.table.R:2151
#, c-format
msgid ""
"length(rownames)==0 but should be a single column name or number, or NULL"
msgstr ""
"length(rownames)==0, mas deve ser um nome ou número de única coluna, ou NULL"

#: data.table.R:2155
#, c-format
msgid ""
"rownames is TRUE but key has multiple columns %s; taking first column x[,1] "
"as rownames"
msgstr ""
"rownames é TRUE, mas a chave possui múltiplas colunas %s; usando primeira "
"coluna x[,1] como rownames"

#: data.table.R:2165
#, c-format
msgid "'%s' is not a column of x"
msgstr "'%s' não é uma coluna de x"

#: data.table.R:2171
#, c-format
msgid ""
"as.integer(rownames)==%d which is outside the column number range "
"[1,ncol=%d]."
msgstr ""
"as.integer(rownames)==%d que está fora do intervalo de números de coluna "
"[1,ncol=%d]."

#: data.table.R:2176
#, c-format
msgid "length(rownames.value)==%d but should be nrow(x)==%d"
msgstr "length(rownames.value)==%d, mas deveria ser nrow(x)==%d"

#: data.table.R:2272
#, c-format
msgid ""
"When i is a matrix in DT[i]<-value syntax, it doesn't make sense to provide j"
msgstr ""
"Quando i é uma matriz na sintaxe DT[i]<-valor, não faz sentido fornecer j"

#: data.table.R:2282
#, c-format
msgid "j must be an atomic vector, see ?is.atomic"
msgstr "j deve ser um vetor atômico, veja ?is.atomic"

#: data.table.R:2283
#, c-format
msgid "NA in j"
msgstr "NA em j"

#: data.table.R:2289
#, c-format
msgid "j must be vector of column name or positions"
msgstr "j deve ser um vetor de posições ou nome de coluna"

#: data.table.R:2290
#, c-format
msgid ""
"Attempt to assign to column position greater than ncol(x). Create the column "
"by name, instead. This logic intends to catch (most likely) user errors."
msgstr ""
"Tentativa de atribuir a uma posição de coluna maior que ncol(x). Em vez "
"disso, crie a coluna por nome. Esta lógica pretende capturar (prováveis) "
"erros do usuário."

#: data.table.R:2357
#, c-format
msgid ""
"data.table inherits from data.frame (from v1.5), but this data.table does "
"not. Has it been created manually (e.g. by using 'structure' rather than "
"'data.table') or saved to disk using a prior version of data.table?"
msgstr ""
"data.table herda de data.frame (desde v1.5), mas esta data.table não. Ela "
"foi criado=a manualmente (por exemplo, usando 'structure' em vez de "
"'data.table') ou salvo=a em disco usando uma versão anterior do data.table?"

#: data.table.R:2366
#, c-format
msgid "attempting to assign invalid object to dimnames of a data.table"
msgstr "tentando atribuir objeto inválido a dimnames de uma data.table"

#: data.table.R:2367
#, c-format
msgid "data.tables do not have rownames"
msgstr "data.tables não têm rownames"

#: data.table.R:2368 data.table.R:2752
#, c-format
msgid "Can't assign %d names to a %d-column data.table"
msgstr "Não é possível atribuir %d nomes a uma data.table de %d colunas"

#: data.table.R:2432
#, c-format
msgid "'subset' must evaluate to logical"
msgstr "'subset' deve ser avaliado para tipo lógico"

#: data.table.R:2475
#, c-format
msgid "Argument 'invert' must be logical TRUE/FALSE"
msgstr "Argumento 'invert' deve ser lógico TRUE/FALSE"

#: data.table.R:2521
#, c-format
msgid "group length is 0 but data nrow > 0"
msgstr "o comprimento do grupo é 0, mas os dados têm nrow > 0"

#: data.table.R:2523
#, c-format
msgid ""
"passing 'f' argument together with 'by' is not allowed, use 'by' when split "
"by column in data.table and 'f' when split by external factor"
msgstr ""
"passar o argumento 'f' junto com 'by' não é permitido, use 'by' quando "
"dividido por uma coluna na data.table e 'f' quando dividido por fator externo"

#: data.table.R:2531
#, c-format
msgid "Either 'by' or 'f' argument must be supplied"
msgstr "O argumento 'by' ou 'f' deve ser fornecido"

#: data.table.R:2533
#, c-format
msgid "Column '.ll.tech.split' is reserved for split.data.table processing"
msgstr ""
"A coluna '.ll.tech.split' é reservada para processamento em split.data.table"

#: data.table.R:2534
#, c-format
msgid "Column '.nm.tech.split' is reserved for split.data.table processing"
msgstr ""
"A coluna '.nm.tech.split' é reservada para processamento em split.data.table"

#: data.table.R:2535
#, c-format
msgid "Argument 'by' must refer to column names in x"
msgstr "O argumento 'by' deve referir-se a nomes das colunas em x"

#: data.table.R:2536
#, c-format
msgid ""
"Argument 'by' must refer only to atomic-type columns, but the following "
"columns are non-atomic: %s"
msgstr ""
"O argumento 'by' deve referir-se apenas a colunas do tipo atômico, mas as "
"seguintes colunas não são atômicas: %s"

#: data.table.R:2583
msgid "Processing split.data.table with: %s"
msgstr "Processando split.data.table com: %s"

#: data.table.R:2683
#, c-format
msgid ""
"x is not a data.table|frame. Shallow copy is a copy of the vector of column "
"pointers (only), so is only meaningful for data.table|frame"
msgstr ""
"x não é uma data.table|frame. A cópia rasa é uma cópia do vetor de ponteiros "
"de coluna (apenas), portanto, só é significativa para data.table|frame"

#: data.table.R:2692
#, c-format
msgid "setalloccol attempting to modify `*tmp*`"
msgstr "setalloccol tentando modificar `*tmp*`"

#: data.table.R:2727
#, c-format
msgid ""
"Input is a length=1 logical that points to the same address as R's global "
"value. Therefore the attribute has not been set by reference, rather on a "
"copy. You will need to assign the result back to a variable. See issue #1281."
msgstr ""
"A entrada é um tipo lógico de comprimento 1 que aponta para o mesmo endereço "
"que o valor global do R. Portanto, o atributo não foi definido por "
"referência, mas sim por uma cópia. Você precisará atribuir o resultado de "
"volta a uma variável. Consulte o issue #1281."

#: data.table.R:2742
#, c-format
msgid "x is not a data.table or data.frame"
msgstr "x não é uma data.table ou data.frame"

#: data.table.R:2744
#, c-format
msgid "x has %d columns but its names are length %d"
msgstr "x tem %d colunas, mas seus nomes têm comprimento %d"

#: data.table.R:2751
#, c-format
msgid "Passed a vector of type '%s'. Needs to be type 'character'."
msgstr "Passou um vetor do tipo '%s'. Precisa ser do tipo 'character'."

#: data.table.R:2764
#, c-format
msgid "'new' is not a character vector or a function"
msgstr "'new' não é um vetor de caracteres ou uma função"

#: data.table.R:2766
#, c-format
msgid "NA in 'new' at positions %s"
msgstr "NA em 'new' nas posições %s"

#: data.table.R:2767
#, c-format
msgid "Some duplicates exist in 'old': %s"
msgstr "Existem algumas duplicatas em 'old': %s"

#: data.table.R:2769
#, c-format
msgid "'old' is type %s but should be integer, double or character"
msgstr "'old' é do tipo %s, mas deve ser inteiro, double ou caractere"

#: data.table.R:2770
#, c-format
msgid "'old' is length %d but 'new' is length %d"
msgstr "'old' tem comprimento %d, mas 'new' tem comprimento %d"

#: data.table.R:2771
#, c-format
msgid "NA (or out of bounds) in 'old' at positions %s"
msgstr "NA (ou fora dos limites) em 'old' nas posições %s"

#: data.table.R:2774
#, c-format
msgid ""
"Item %d of 'old' is '%s' which appears several times in column names. Just "
"the first will be changed. There are %d other items in 'old' that are also "
"duplicated in column names."
msgstr ""
"O item %d de 'old' é '%s', que aparece várias vezes nos nomes das colunas. "
"Apenas o primeiro será alterado. Existem %d outros itens em 'old' que também "
"estão duplicados nos nomes das colunas."

#: data.table.R:2782
#, c-format
msgid ""
"Items of 'old' not found in column names: %s. Consider skip_absent=TRUE."
msgstr ""
"Itens de 'old' não encontrados nos nomes das colunas: %s. Considere "
"skip_absent=TRUE."

#: data.table.R:2823
#, c-format
msgid "Provide either before= or after= but not both"
msgstr "Forneça before= ou after=, mas não ambos"

#: data.table.R:2825
#, c-format
msgid "before=/after= accept a single column name or number, not more than one"
msgstr ""
"before=/after= aceitam um único nome ou número de coluna, não mais do que um"

#: data.table.R:2882
#, c-format
msgid "Input is %s but should be a plain list of items to be stacked"
msgstr ""
"A entrada é %s, mas deve ser uma lista simples de itens a serem empilhados"

#: data.table.R:2886
#, c-format
msgid ""
"idcol must be a logical or character vector of length 1. If logical TRUE the "
"id column will named '.id'."
msgstr ""
"idcol deve ser um vetor de valores lógicos ou caracteres de comprimento 1. "
"Se for lógico TRUE, a coluna de identificação denominada '.id'."

#: data.table.R:2891
#, c-format
msgid "use.names=NA invalid"
msgstr "use.names=NA inválido"

#: data.table.R:2893
#, c-format
msgid ""
"use.names='check' cannot be used explicitly because the value 'check' is new "
"in v1.12.2 and subject to change. It is just meant to convey default "
"behavior. See ?rbindlist."
msgstr ""
"use.names='check' não pode ser usado explicitamente porque o valor 'check' é "
"novo na v1.12.2 e está sujeito a alterações. O objetivo é apenas transmitir "
"o comportamento padrão. Consulte ?rbindlist."

#: data.table.R:2908
#, c-format
msgid ""
"Check that is.data.table(DT) == TRUE. Otherwise, `:=` is defined for use in "
"j, once only and in particular ways. See help(\":=\", \"data.table\"). A "
"common reason for this error is allocating a new column in `j` and using `<-"
"` instead of `:=`; e.g., `DT[, new_col <- 1]` should be `DT[, new_col := "
"1]`. Another is using `:=` in a multi-statement `{...}` block; please use "
"`:=` as the only statement in `j`."
msgstr ""
"Verifique se is.data.table(DT) == TRUE. Caso contrário, `:=` está definido "
"para uso em j, apenas uma vez e de maneiras específicas. Veja help(\":=\", "
"\"data.table\"). Um motivo comum para esse erro é alocar uma nova coluna em "
"`j` e usar `<-` em vez de `:=`; por exemplo, `DT[, new_col <- 1]` deveria "
"ser `DT[, new_col := 1]`. Outro motivo é usar `:=` em um bloco de múltiplas "
"instruções `{...}`; use `:=` como a única instrução em `j`."

#: data.table.R:2925
#, c-format
msgid ""
"setDF only accepts data.table, data.frame or list of equal length as input"
msgstr ""
"setDF aceita apenas data.table, data.frame ou lista de igual comprimento "
"como entrada"

#: data.table.R:2926
#, c-format
msgid "rownames contains duplicates"
msgstr "rownames contém duplicatas"

#: data.table.R:2933 data.table.R:2944 data.table.R:2967
#, c-format
msgid "rownames incorrect length; expected %d names, got %d"
msgstr "rownames com comprimento incorreto; esperava %d nomes, obteve %d"

#: data.table.R:2952
#, c-format
msgid "All elements in argument 'x' to 'setDF' must be of same length"
msgstr ""
"Todos os elementos no argumento 'x' para 'setDF' devem ter o mesmo "
"comprimento"

#: data.table.R:2981
#, c-format
msgid "Cannot find symbol %s"
msgstr "Não foi possível encontrar o símbolo %s"

#: data.table.R:2988
#, c-format
msgid ""
"Cannot convert '%1$s' to data.table by reference because binding is locked. "
"It is very likely that '%1$s' resides within a package (or an environment) "
"that is locked to prevent modifying its variable bindings. Try copying the "
"object to your current environment, ex: var <- copy(var) and then using "
"setDT again."
msgstr ""
"Não é possível converter '%1$s' em data.table por referência porque o "
"vínculo está travado. É muito provável que '%1$s' resida em um pacote (ou "
"ambiente) que esteja travado para evitar a modificação de seus vínculos de "
"variáveis. Experimente copiar o objeto para o seu ambiente atual, ex: var <- "
"copy(var) e depois usar setDT novamente."

#: data.table.R:3042
#, c-format
msgid ""
"Argument 'x' to 'setDT' should be a 'list', 'data.frame' or 'data.table'"
msgstr ""
"O argumento 'x' para 'setDT' deve ser uma 'list', 'data.frame' ou "
"'data.table'"

#: data.table.R:3075 data.table.R:3100
#, c-format
msgid "'prefix' must be NULL or a character vector of length 1."
msgstr "'prefix' deve ser NULL ou um vetor de caracteres de comprimento 1."

#: data.table.R:3078 data.table.R:3103
#, c-format
msgid "x is a single vector, non-NULL 'cols' doesn't make sense."
msgstr "x é um único vetor, 'cols' não NULL não faz sentido."

#: data.table.R:3082 data.table.R:3107
#, c-format
msgid "x is a list, 'cols' cannot be 0-length."
msgstr "x é uma lista, 'cols' não pode ter comprimento 0."

#: data.table.R:3262
#, c-format
msgid ""
"It looks like you re-used `:=` in argument %d a functional assignment call "
"-- use `=` instead: %s(col1=val1, col2=val2, ...)"
msgstr ""
"Parece que você reutilizou `:=` no argumento %d, uma chamada de atribuição "
"funcional -- use `=` em vez disso: %s(col1=val1, col2=val2, ...)"

#: data.table.R:3328
#, c-format
msgid ""
"RHS of %s is length %d which is not 1 or nrow (%d). For robustness, no "
"recycling is allowed (other than of length 1 RHS). Consider %%in%% instead."
msgstr ""
"Lado direito (RHS) de %s tem comprimento %d que não é 1 ou nrow (%d). Para "
"maior robustez, nenhuma reciclagem é permitida (exceto em lado direito de "
"comprimento 1). Considere %%in%% em vez disso."

#: data.table.R:3360
msgid ""
"Subsetting optimization disabled because the cross-product of RHS values "
"exceeds 1e4, causing memory problems."
msgstr ""
"Otimização de subconjuntos desabilitada porque o produto cruzado dos valores "
"do lado direito excede 1e4, causando problemas de memória."

#: data.table.R:3378
msgid "Optimized subsetting with key %s"
msgstr "Obtendo subconjunto de forma otimizada com chave %s"

#: data.table.R:3397 data.table.R:3409
msgid "Optimized subsetting with index '%s'"
msgstr "Obtendo subconjunto de forma otimizada com índice '%s'"

#: data.table.R:3404
msgid "Creating new index '%s'"
msgstr "Criando novo índice '%s'"

#: data.table.R:3405
msgid "Creating index %s done in ..."
msgstr "Criação de índice %s concluída em ..."

#: data.table.R:3438
#, c-format
msgid ""
"'on' argument should be a named atomic vector of column names indicating "
"which columns in 'i' should be joined with which columns in 'x'."
msgstr ""
"O argumento 'on' deve ser um vetor atômico nomeado de nomes de colunas "
"indicando quais colunas em 'i' correspondem a quais colunas em 'x' para a "
"junção."

#: data.table.R:3479
#, c-format
msgid ""
"Found more than one operator in one 'on' statement: %s. Please specify a "
"single operator."
msgstr ""
"Encontrado mais de um operador em uma instrução 'on': %s. Especifique um "
"único operador."

#: data.table.R:3502
#, c-format
msgid ""
"'on' contains no column name: %s. Each 'on' clause must contain one or two "
"column names."
msgstr ""
"'on' não contém nome de coluna: %s. Cada cláusula 'on' deve conter um ou "
"dois nomes de coluna."

#: data.table.R:3504
#, c-format
msgid ""
"'on' contains more than 2 column names: %s. Each 'on' clause must contain "
"one or two column names."
msgstr ""
"'on' contém mais de 2 nomes de colunas: %s. Cada cláusula 'on' deve conter "
"um ou dois nomes de coluna."

#: data.table.R:3509
#, c-format
msgid "Invalid join operators %s. Only allowed operators are %s."
msgstr ""
"Operadores de junção inválidos: %s. Os únicos operadores permitidos são %s."

#: devel.R:16
#, c-format
msgid "There is no package %s in provided repository."
msgstr "Não há um pacote %s no repositório fornecido."

#: devel.R:30
msgid ""
"No revision information found in DESCRIPTION file for %s package. Make sure "
"that '%s' is correct field in PACKAGES file in your package repository '%s'. "
"Otherwise package will be re-installed every time, proceeding to "
"installation."
msgstr ""
"Nenhuma informação de revisão encontrada no arquivo DESCRIPTION para o "
"pacote %s. Certifique-se de que '%s' é o campo correto no arquivo PACKAGES "
"no seu repositório de pacotes '%s'. Caso contrário, o pacote será "
"reinstalado todas as vezes, prosseguindo para a instalação."

#: devel.R:39
msgid "R %s package has been updated to %s (%s)"
msgstr "Pacote %s do R foi atualizado para %s (%s)"

#: devel.R:41
msgid "R %s package is up-to-date at %s (%s)"
msgstr "Pacote %s do R está atualizado para %s (%s)"

#: devel.R:53
msgid ""
"Git revision is not available. Most likely data.table was installed from "
"CRAN or local archive.\n"
"Git revision is available when installing from our repositories 'https://"
"Rdatatable.gitlab.io/data.table' and 'https://Rdatatable.github.io/"
"data.table'."
msgstr ""
"A revisão do Git não está disponível. Provavelmente data.table foi instalado "
"do CRAN ou do arquivo local.\n"
"A revisão do Git está disponível ao instalar de nossos repositórios 'https://"
"Rdatatable.gitlab.io/data.table' e 'https://Rdatatable.github.io/data.table'."

#: duplicated.R:7
#, c-format
msgid "'fromLast' must be TRUE or FALSE"
msgstr "'fromLast' deve ser TRUE ou FALSE"

#: duplicated.R:105
#, c-format
msgid "x must be an atomic vector or a data.frame/data.table"
msgstr "x deve ser um vetor atômico ou uma data.frame/data.table"

#: fcast.R:7
#, c-format
msgid "Using '%s' as value column. Use 'value.var' to override"
msgstr "Usando '%s'como coluna do valor. Use 'value.var' para contornar"

#: fcast.R:17
#, c-format
msgid ""
"The %1$s generic in data.table has been passed a %2$s, but data.table::%1$s "
"currently only has a method for data.tables. Please confirm your input is a "
"data.table, with setDT(%3$s) or as.data.table(%3$s). If you intend to use a "
"method from reshape2, try installing that package first, but do note that "
"reshape2 is superseded and is no longer actively developed."
msgstr ""
"Um %2$s foi passado para o genérico %1$s em data.table, mas atualmente "
"data.table::%1$s só tem um método para data.tables. Favor garantir que a "
"entrada seja uma data.table, com setDT(%3$s) ou as.data.table(%3$s). Se você "
"pretende usar um método de reshape2, tente instalar aquele pacote primeiro, "
"mas note que reshape2 foi substituído e não está mais em desenvolvimento "
"ativo."

#: fcast.R:24
#, c-format
msgid ""
"Invalid formula. Cast formula should be of the form LHS ~ RHS, for e.g., a + "
"b ~ c."
msgstr ""
"Fórmula inválida. A fórmula do cast deveria ter o formato LHS ~ RHS (lado "
"esquerdo ~ lado direito), p. ex. a + b ~ c."

#: fcast.R:31
#, c-format
msgid "data.table to cast must have unique column names"
msgstr "a data.table a ser \"moldada\" deve ter nomes de coluna únicos"

#: fcast.R:76
#, c-format
msgid "value.var values %s are not found in 'data'."
msgstr "os valores de value.var  %s não se encontram em 'data'."

#: fcast.R:92
#, c-format
msgid ""
"When 'fun.aggregate' and 'value.var' are both lists, 'value.var' must be "
"either of length =1 or =length(fun.aggregate)."
msgstr ""
"Quando 'fun.aggregate' e 'value.var' são listas, o comprimento de "
"'value.var' deve ser ou =1 ou  =length(fun.aggregate)."

#: fcast.R:125
#, c-format
msgid "'data' must be a data.table."
msgstr "'data' deve ser uma data.table."

#: fcast.R:127
#, c-format
msgid "'drop' must be logical TRUE/FALSE"
msgstr "'drop' deve ser lógico TRUE/FALSE"

#: fcast.R:129
#, c-format
msgid "Argument 'value.var.in.dots' should be logical TRUE/FALSE"
msgstr "Argumento 'value.var.in.dots' deveria ser lógico TRUE/FALSE"

#: fcast.R:131
#, c-format
msgid ""
"Arguments 'value.var.in.LHSdots', 'value.var.in.RHSdots' should be logical "
"TRUE/FALSE"
msgstr ""
"Os argumentos 'value.var.in.LHSdots', 'value.var.in.RHSdots' deveriam ser "
"lógicos TRUE/FALSE"

#: fcast.R:148
#, c-format
msgid "Column [%s] not found or of unknown type."
msgstr "Coluna [%s] não encontrada ou de tipo desconhecido."

#: fcast.R:163
#, c-format
msgid "Columns specified in formula can not be of type list"
msgstr "Colunas especificadas na formula não podem ser do tipo lista"

#: fcast.R:178
#, c-format
msgid ""
"'fun.aggregate' is NULL, but found duplicate row/column combinations, so "
"defaulting to length(). That is, the variables %s used in 'formula' do not "
"uniquely identify rows in the input 'data'. In such cases, 'fun.aggregate' "
"is used to derive a single representative value for each combination in the "
"output data.table, for example by summing or averaging (fun.aggregate=sum or "
"fun.aggregate=mean, respectively). Check the resulting table for values "
"larger than 1 to see which combinations were not unique. See ?"
"dcast.data.table for more details."
msgstr ""
"'fun.aggregate' é NULL, mas foram encontradas combinações duplicadas de "
"linha/coluna, então usando length() por padrão. Isso é, as variáveis %s "
"usadas em 'formula' não identificam de forma única as linhas na entrada "
"'data'. Em tais casos, 'fun.aggregate' é usado para derivar um único valor "
"representativo para cada combinação na data.table de saída, por exemplo "
"somando ou tirando a média (fun.aggregate=sum ou fun.aggregate=mean, "
"respectivamente). Verifique a tabela resultante por valores maiores do que 1 "
"para ver quais combinações não foram únicas. Veja ?dcast.data.table para "
"mais detalhes."

#: fcast.R:188
msgid ""
"Aggregating functions should take a vector as input and return a single "
"value (length=1), but they do not, so the result is undefined. Please fix by "
"modifying your function so that a single value is always returned."
msgstr ""
"Funções de agregação devem receber um vetor como entrada e retornar um único "
"valor (length=1), mas elas não o fazem, então o resultado é indefinido. "
"Favor corrigir isso modificando sua função de forma que um único valor seja "
"sempre retornado."

#: fmelt.R:12
#, c-format
msgid ""
"The %1$s generic in data.table has been passed a %2$s and will attempt to "
"redirect to the relevant reshape2 method; please note that reshape2 is "
"superseded and is no longer actively developed, and this redirection is now "
"deprecated. To continue using melt methods from reshape2 while both packages "
"are attached, e.g. melt.list, you can prepend the namespace, i.e. "
"reshape2::%1$s(%3$s). In the next version, this warning will become an error."
msgstr ""
"Um %2$s foi passado para o genérico %1$s em data.table, que vai tentar "
"redirecionar para o método relevante no pacote reshape2; favor notar que "
"reshape2 foi substituído e não está mais em desenvolvimento ativo, e que "
"esse redirecionamento agora está obsoleto. Para continuar usando métodos "
"melt de reshape2 enquanto ambos os pacotes estão anexados, p.ex. melt.list, "
"você pode prefixar com o namespace, p.ex. reshape2::%1$s(%3$s). Na próxima "
"versão, este aviso se tornará um erro."

#: fmelt.R:19 fmelt.R:73
#, c-format
msgid "cols must be a character vector of column names"
msgstr "cols deve ser um vetor de caracteres de nomes de coluna"

#: fmelt.R:24
#, c-format
msgid "Input patterns must be of type character."
msgstr "Padrões de entrada devem ser do tipo caractere."

#: fmelt.R:42
#, c-format
msgid ""
"each ... argument to measure must be either a symbol without argument name, "
"or a function with argument name, problems: %s"
msgstr ""
"cada argumento ... para measure deve ser ou um símbolo sem nome de "
"argumento, ou uma função com nome de argumento, problemas: %s"

#: fmelt.R:50
#, c-format
msgid ""
"group names specified in ... conflict with measure argument names; please "
"fix by changing group names: %s"
msgstr ""
"nomes de grupo especificados em ... conflitam com nomes de argumento de "
"measures; favor consertar trocando os nomes de grupo: %s"

#: fmelt.R:56
#, c-format
msgid ""
"each ... argument to measure must be a function with at least one argument, "
"problem: %s"
msgstr ""
"cada ... argumento para measure deve ser uma função com ao menos um "
"argumento, problema: %s"

#: fmelt.R:67
#, c-format
msgid ""
"both sep and pattern arguments used; must use either sep or pattern (not "
"both)"
msgstr ""
"ambos os argumentos sep e pattern usados; deve usar ou sep, ou pattern (não "
"os dois)"

#: fmelt.R:70
#, c-format
msgid "multiple.keyword must be a character string with nchar>0"
msgstr "multiple.keyword deve ser uma string de caracteres com nchar>0"

#: fmelt.R:81
#, c-format
msgid "in measurev, elements of fun.list must be named, problems: %s"
msgstr "em measurev, elementos de fun.list devem ser nomeados, problemas: %s"

#: fmelt.R:84
#, c-format
msgid "elements of fun.list should be uniquely named, problems: %s"
msgstr ""
"elementos de fun.list devem ser nomeados de forma unívoca, problemas: %s"

#: fmelt.R:89
#, c-format
msgid "pattern must be character string"
msgstr "pattern deve ser uma string de caracteres"

#: fmelt.R:94
#, c-format
msgid ""
"pattern did not match any cols, so nothing would be melted; fix by changing "
"pattern"
msgstr ""
"pattern não coincidiu com nenhuma coluna, então nada será \"derretido\"; "
"corrija mudando o padrão"

#: fmelt.R:98
#, c-format
msgid ""
"pattern must contain at least one capture group (parenthesized sub-pattern)"
msgstr ""
"pattern deve conter pelo menos um grupo de captura (subpadrão entre "
"parênteses)"

#: fmelt.R:101
#, c-format
msgid ""
"number of elements of fun.list (%d) must be the same as the number of "
"capture groups in pattern (%d)"
msgstr ""
"número de elementos de fun.list (%d) deve ser o mesmo que o número de grupos "
"de captura no padrão (%d)"

#: fmelt.R:109
#, c-format
msgid "sep must be character string"
msgstr "sep deve ser uma string de caracteres"

#: fmelt.R:115
#, c-format
msgid ""
"each column name results in only one item after splitting using sep, which "
"means that all columns would be melted; to fix please either specify melt on "
"all columns directly without using measure, or use a different sep/pattern "
"specification"
msgstr ""
"cada nome de coluna resulta em apenas um item após dividir usando sep, o que "
"significa que todas as colunas seriam \"derretidas\"; para consertar, favor "
"ou especificar o \"derretimento\" em todas as colunas diretamente sem usar "
"'measure', ou especifique um sep/pattern diferente"

#: fmelt.R:118
#, c-format
msgid ""
"number of elements of fun.list (%d) must be the same as the max number of "
"items after splitting column names (%d)"
msgstr ""
"número de elementos de fun.list (%d) deve ser o mesmo que o número máximo de "
"itens após dividir os nomes de coluna (%d)"

#: fmelt.R:125
#, c-format
msgid "measured columns should be uniquely named, problems: %s"
msgstr "colunas de medida deveriam receber nomes únicos, problemas: %s"

#: fmelt.R:129
#, c-format
msgid ""
"number of unique column IDs =%d is less than number of melted columns =%d; "
"fix by changing pattern/sep"
msgstr ""
"o número de colunas de identificação únicas = %d é menor do que o número de "
"colunas \"derretidas\" = %d; conserte trocando pattern/sep"

#: fmelt.R:139
#, c-format
msgid ""
"in the measurev fun.list, each non-NULL element must be a function with at "
"least one argument, problem: %s"
msgstr ""
"na fun.list de measurev, cada elemento não-NULL deve ser uma função com ao "
"menos um argumento, problema: %s"

#: fmelt.R:143
#, c-format
msgid ""
"each conversion function must return an atomic vector with same length as "
"its first argument, problem: %s"
msgstr ""
"cada função de conversão deve retornar um vetor atômico com o mesmo "
"comprimento que seu primeiro argumento, problema: %s"

#: fmelt.R:146
#, c-format
msgid "%s conversion function returned vector of all NA"
msgstr "função de conversão %s retornou um vetor inteiro de NA"

#: fmelt.R:152
#, c-format
msgid ""
"number of unique groups after applying type conversion functions less than "
"number of groups, change type conversion"
msgstr ""
"o número de grupos únicos depois de aplicar funções de conversão de tipo é "
"menor do que o número de grupos, mude a conversão de tipo"

#: fmelt.R:157
#, c-format
msgid ""
"%s column class=%s after applying conversion function, but must be character"
msgstr ""
"coluna %s com classe=%s depois de aplicar função de conversão, mas tem que "
"ser caractere"

#: fmelt.R:161
#, c-format
msgid "%s is the only group; fix by creating at least one more group"
msgstr "%s é o único grupo; conserte criando ao menos mais um grupo"

#: fmelt.R:184
#, c-format
msgid "'data' must be a data.table"
msgstr "'data' deve ser uma data.table"

#: fmelt.R:207
#, c-format
msgid ""
"'value.name' provided in both 'measure.vars' and 'value.name argument'; "
"value provided in 'measure.vars' is given precedence."
msgstr ""
"'value.name' fornecido tanto em 'measure.vars' quanto no argumento "
"'value.name'; o valor fornecido em 'measure.vars' tem precedência"

#: fmelt.R:210
#, c-format
msgid "Please provide a name to each element of 'measure.vars'."
msgstr "Favor fornecer um nome para cada elemento de 'measure.vars'."

#: fmelt.R:221
msgid ""
"Duplicate column names found in molten data.table. Setting unique names "
"using 'make.names'"
msgstr ""
"Nomes de colunas duplicados encontrados em data.table 'derretida'. Definindo "
"nomes exclusivos usando 'make.names'"

#: foverlaps.R:3
#, c-format
msgid ""
"y and x must both be data.tables. Use `setDT()` to convert list/data.frames "
"to data.tables by reference or as.data.table() to convert to data.tables by "
"copying."
msgstr ""
"y e x devem ambos serem data.tables. Use `setDT()` para converter listas e "
"data.frames para data.tables por referência ou as.data.table() para "
"converter para data.tables copiando."

#: foverlaps.R:9
#, c-format
msgid "maxgap must be a non-negative integer value of length 1"
msgstr "maxgap deve ser um valor inteiro não-negativo de comprimento 1"

#: foverlaps.R:11
#, c-format
msgid "minoverlap must be a positive integer value of length 1"
msgstr "minoverlap deve ser um valor inteiro positivo de comprimento 1"

#: foverlaps.R:13
#, c-format
msgid "which must be a logical vector of length 1. Either TRUE/FALSE"
msgstr "which deve ser um vetor lógico de comprimento 1. TRUE ou FALSE"

#: foverlaps.R:15
#, c-format
msgid "nomatch must either be NA or NULL"
msgstr "nomatch deve ser ou NA ou NULL"

#: foverlaps.R:20
#, c-format
msgid "maxgap and minoverlap arguments are not yet implemented."
msgstr "argumentos maxgap e minoverlap  ainda não estão implementados."

#: foverlaps.R:22
#, c-format
msgid ""
"y must be keyed (i.e., sorted, and, marked as sorted). Call setkey(y, ...) "
"first, see ?setkey. Also check the examples in ?foverlaps."
msgstr ""
"y deve ser chaveada (ou seja, ordenada e marcada como ordenada). Chame "
"setkey(y, …) primeiro, veja ?setkey. Também confira os exemplos em ?"
"foverlaps."

#: foverlaps.R:24
#, c-format
msgid ""
"'by.x' and 'by.y' should contain at least two column names (or numbers) each "
"- corresponding to 'start' and 'end' points of intervals. Please see ?"
"foverlaps and examples for more info."
msgstr ""
"'by.x' e 'by.y' deveriam conter ao menos dois nomes de coluna (ou números) "
"cada - correspondendo aos pontos de início e fim dos intervalos. Favor ver ?"
"foverlaps e exemplos para mais informação. "

#: foverlaps.R:27
#, c-format
msgid ""
"Invalid numeric value for 'by.x'; it should be a vector with values 1 <= "
"by.x <= length(x)"
msgstr ""
"Valor numérico inválido para 'by.x'; deveria ser um vetor com valores 1 <= "
"by.x <= length(x)"

#: foverlaps.R:32
#, c-format
msgid ""
"Invalid numeric value for 'by.y'; it should be a vector with values 1 <= "
"by.y <= length(y)"
msgstr ""
"Valor numérico inválido para 'by.y'; deveria ser um vetor com valores 1 <= "
"by.y <= length(y)"

#: foverlaps.R:36
#, c-format
msgid "A non-empty vector of column names or numbers is required for by.x"
msgstr ""
"Um vetor não-vazio de nomes ou números de coluna é necessário para by.x"

#: foverlaps.R:38
#, c-format
msgid "A non-empty vector of column names or numbers is required for by.y"
msgstr ""
"Um vetor não-vazio de nomes ou números de coluna é necessário para by.y"

#: foverlaps.R:40
#, c-format
msgid ""
"The first %d columns of y's key must be identical to the columns specified "
"in by.y."
msgstr ""
"As primeiras %d colunas da chave de y devem ser idênticas às colunas "
"especificadas em by.y."

#: foverlaps.R:42
#, c-format
msgid "Elements listed in 'by.x' must be valid names in data.table x"
msgstr "Elementos listados em 'by.x' devem ser nomes válidos na data.table x"

#: foverlaps.R:44
#, c-format
msgid ""
"Duplicate columns are not allowed in overlap joins. This may change in the "
"future."
msgstr ""
"Colunas duplicadas não são permitidas em junções de sobreposição. Isso pode "
"mudar no futuro."

#: foverlaps.R:46
#, c-format
msgid ""
"length(by.x) != length(by.y). Columns specified in by.x should correspond to "
"columns specified in by.y and should be of same lengths."
msgstr ""
"length(by.x) != length(by.y). As colunas especificadas em by.x deveriam "
"corresponder às colunas especificadas em by.y, e os argumentos deveriam ser "
"do mesmo comprimento."

#: foverlaps.R:57
#, c-format
msgid ""
"The last two columns in by.x should correspond to the 'start' and 'end' "
"intervals in data.table x and must be integer/numeric type."
msgstr ""
"As últimas duas colunas em by.x deveriam corresponder às colunas de início e "
"de fim dos intervalos na data.table x e devem ser do tipo inteiro/numérico."

#: foverlaps.R:61 foverlaps.R:63 foverlaps.R:70 foverlaps.R:72
#, c-format
msgid ""
"NA values in data.table %s '%s' column: '%s'. All rows with NA values in the "
"range columns must be removed for foverlaps() to work."
msgstr ""
"Valores NA na coluna %s '%s' da data.table: '%s'. Todas as linhas com "
"valores NA nas colunas de intervalo devem ser removidas para o foverlaps() "
"funcionar."

#: foverlaps.R:64
#, c-format
msgid ""
"All entries in column '%s' should be <= corresponding entries in column '%s' "
"in data.table x."
msgstr ""
"Todas as entradas na coluna '%s' deveriam ser <= as entradas correspondentes "
"na coluna '%s' na data.table x."

#: foverlaps.R:67
#, c-format
msgid ""
"The last two columns in by.y should correspond to the 'start' and 'end' "
"intervals in data.table y and must be integer/numeric type."
msgstr ""
"As últimas duas colunas em by.y deveriam corresponder às colunas de início e "
"de fim dos intervalos na data.table y e devem ser do tipo inteiro/numérico."

#: foverlaps.R:73
#, c-format
msgid ""
"All entries in column '%s' should be <= corresponding entries in column '%s' "
"in data.table y."
msgstr ""
"Todas as entradas na coluna '%s' deveriam ser <= as entradas correspondentes "
"na coluna '%s' na data.table y."

#: foverlaps.R:78
#, c-format
msgid ""
"Some interval cols are of type POSIXct while others are not. Please ensure "
"all interval cols are (or are not) of POSIXct type"
msgstr ""
"Algumas colunas de intervalo são do tipo POSIXct, enquanto outras não são. "
"Favor garantir que todas as colunas de intervalo sejam (ou todas não sejam) "
"to tipo POSIXct"

#: foverlaps.R:84
#, c-format
msgid ""
"POSIXct interval cols have mixed timezones. Overlaps are performed on the "
"internal numerical representation of POSIXct objects (always in UTC epoch "
"time), therefore printed values may give the impression that values don't "
"overlap but their internal representations do Please ensure that POSIXct "
"type interval cols have identical 'tzone' attributes to avoid confusion."
msgstr ""
"Colunas de intervalo POSIXct têm fusos horários diferentes. As sobreposições "
"são realizadas na representação numérica dos objetos POSIXct (sempre em UTC, "
"era UNIX), de forma que os valores exibidos podem dar a impressão de que os "
"valores não se sobrepõem mas suas representações internas se sobrepõem. "
"Favor garantir que as colunas de intervalo do tipo POSIXct tenham atributos "
"'tzone' idênticos para evitar confusão."

#: foverlaps.R:132
msgid "unique() + setkey() operations done in ..."
msgstr "operações unique() + setkey() concluídas em ..."

#: foverlaps.R:158
msgid "binary search(es) done in ..."
msgstr "pesquisa(s) binária(s) concluída(s) em ..."

#: foverlaps.R:165 foverlaps.R:167 foverlaps.R:171
#, c-format
msgid "Not yet implemented"
msgstr "Ainda não implementado"

#: foverlaps.R:170
#, c-format
msgid "maxgap > minoverlap. maxgap will have no effect here."
msgstr "maxgap > minoverlap. maxgap não terá efeito aqui."

#: frank.R:3
#, c-format
msgid "length(na.last) = 0"
msgstr "length(na.last) = 0"

#: frank.R:5
#, c-format
msgid "length(na.last) > 1, only the first element will be used"
msgstr "length(na.last) > 1, apenas o primeiro item será usado"

#: frank.R:17
#, c-format
msgid "x is a single vector, non-NULL 'cols' doesn't make sense"
msgstr "x é um vetor simples, 'cols' não-NULL não faz sentido"

#: frank.R:23
#, c-format
msgid "x is a list, 'cols' can not be 0-length"
msgstr "x é uma lista, 'cols' não pode ser de comprimento 0"

#: frank.R:31
#, c-format
msgid ""
"Input column '..na_prefix..' conflicts with data.table internal usage; "
"please rename"
msgstr ""
"Coluna de entrada '..na_prefix..' conflita com utilização interna por "
"data.table; favor renomear"

#: frank.R:46
#, c-format
msgid ""
"Input column '..stats_runif..' conflicts with data.table internal usage; "
"please rename"
msgstr ""
"Coluna de entrada '..stats_runif..' conflita com utilização interna por "
"data.table; favor renomear"

#: fread.R:12
#, c-format
msgid "Used more than one of the arguments input=, file=, text= and cmd=."
msgstr "Usados mais de um dos argumentos input=, file=, text= e cmd=."

#: fread.R:25
#, c-format
msgid "Argument 'encoding' must be 'unknown', 'UTF-8' or 'Latin-1'."
msgstr "Argumento 'encoding' deve ser 'unknown', 'UTF-8' ou 'Latin-1'."

#: fread.R:34
#, c-format
msgid "comment.char= must be a single non-NA character."
msgstr "comment.char= deve ser um único caractere não-NA."

#: fread.R:47
#, c-format
msgid "'text=' is type %s but must be character."
msgstr "'text=' é do tipo %s, mas deve ser caractere."

#: fread.R:60
#, c-format
msgid ""
"input= must be a single character string containing a file name, a system "
"command containing at least one space, a URL starting 'http[s]://', "
"'ftp[s]://' or 'file://', or, the input data itself containing at least one "
"\\n or \\r"
msgstr ""
"input= deve ser uma única sequência de caracteres contendo um nome de "
"arquivo, um comando do sistema contendo pelo menos um espaço, uma URL "
"começando com 'http[s]://', ​​'ftp[s]://' ou 'file://', ou os próprios dados "
"de entrada contendo pelo menos um entre \\n ou \\r"

#: fread.R:65
#, c-format
msgid ""
"input= contains no \\n or \\r, but starts with a space. Please remove the "
"leading space, or use text=, file= or cmd="
msgstr ""
"input= não contém \\n ou \\r, mas começa com um espaço. Por favor, remova o "
"espaço inicial ou use text=, file= ou cmd="

#: fread.R:69
#, c-format
msgid ""
"Taking input= as a system command because it contains a space ('%s'). If "
"it's a filename please remove the space, or use file= explicitly. A variable "
"is being passed to input= and when this is taken as a system command there "
"is a security concern if you are creating an app, the app could have a "
"malicious user, and the app is not running in a secure environment; e.g. the "
"app is running as root. Please read item 5 in the NEWS file for v1.11.6 for "
"more information and for the option to suppress this message."
msgstr ""
"Considerando input= como um comando do sistema porque contém um espaço "
"('%s'). Se for um nome de arquivo, remova o espaço ou use file= "
"explicitamente. Uma variável está sendo passada para input= e quando isso é "
"considerado um comando do sistema, há uma preocupação de segurança se você "
"estiver criando um aplicativo, o aplicativo pode ter um usuário mal-"
"intencionado e o aplicativo não está sendo executado em um ambiente seguro; "
"por exemplo. o aplicativo está sendo executado como root. Leia o item 5 no "
"arquivo NEWS da versão 1.11.6 para obter mais informações e para a opção de "
"suprimir esta mensagem."

#: fread.R:80
#, c-format
msgid ""
"External command failed with exit code %d. This can happen when the disk is "
"full in the temporary directory ('%s'). See ?fread for the tmpdir argument."
msgstr ""
"O comando externo falhou com o código de saída %d. Isso pode ocorrer quando "
"o disco estiver cheio no diretório temporário ('%s'). Consulte ?fread para "
"obter informações sobre o argumento tmpdir."

#: fread.R:86
#, c-format
msgid ""
"file= must be a single character string containing a filename, or URL "
"starting 'http[s]://', 'ftp[s]://' or 'file://'"
msgstr ""
"file= deve ser uma única sequência de caracteres contendo um nome de arquivo "
"ou URL começando com 'http[s]://', ​​'ftp[s]://' ou 'file://'"

#: fread.R:99
#, c-format
msgid "File '%s' does not exist or is non-readable. getwd()=='%s'"
msgstr "O arquivo '%s' não existe ou não é legível. getwd()=='%s'"

#: fread.R:100
#, c-format
msgid "File '%s' is a directory. Not yet implemented."
msgstr "O arquivo '%s' é um diretório. Ainda não implementado."

#: fread.R:102
#, c-format
msgid "File '%s' has size 0. Returning a NULL %s."
msgstr "O arquivo '%s' tem tamanho 0. Retornando NULL %s."

#: fread.R:114
#, c-format
msgid ""
"Compressed files containing more than 1 file are currently not supported."
msgstr ""
"Arquivos compactados contendo mais de 1 arquivo não são suportados "
"atualmente."

#: fread.R:124
#, c-format
msgid ""
"To read %s files directly, fread() requires 'R.utils' package which cannot "
"be found. Please install 'R.utils' using 'install.packages('R.utils')'."
msgstr ""
"Para ler arquivos %s diretamente, fread() requer o pacote 'R.utils' que não "
"pôde ser encontrado. Instale 'R.utils' usando 'install.packages('R.utils')'."

#: fread.R:127
#, c-format
msgid ""
"Reading compressed files in fread requires R.utils version 2.13.0 or higher. "
"Please upgrade R.utils."
msgstr ""
"A leitura de arquivos compactados em fread requer a versão 2.13.0 ou "
"superior do R.utils. Por favor, atualize o R.utils."

#: fread.R:134
#, c-format
msgid ""
"R.utils::decompressFile failed to decompress file '%s':\n"
"  %s\n"
". This can happen when the disk is full in the temporary directory ('%s'). "
"See ?fread for the tmpdir argument."
msgstr ""
"R.utils::decompressFile falhou ao descompactar o arquivo '%s':\n"
" %s\n"
". Isso pode ocorrer quando o disco está cheio no diretório temporário "
"('%s'). Consulte ?fread para obter informações sobre o argumento tmpdir."

#: fread.R:143
#, c-format
msgid ""
"colClasses is type 'logical' which is ok if all NA but it has some TRUE or "
"FALSE values in it which is not allowed. Please consider the drop= or "
"select= argument instead. See ?fread."
msgstr ""
"colClasses é do tipo 'logical', que está tudo bem se for todo NA, mas "
"contiver alguns valores TRUE ou FALSE que não são permitidos. Por favor, "
"considere o argumento drop= ou select=. Veja ?fread."

#: fread.R:147
#, c-format
msgid "colClasses is not type list or character vector"
msgstr "colClasses não é lista de tipos ou vetor de caracteres"

#: fread.R:152
#, c-format
msgid ""
"colClasses=\"NULL\" (quoted) is interpreted as colClasses=NULL (the default) "
"as opposed to dropping every column."
msgstr ""
"colClasses=\"NULL\" (entre aspas) é interpretado como colClasses=NULL (o "
"padrão) em vez de descartar todas as colunas."

#: fread.R:164
#, c-format
msgid "na.strings[%d]==\"%s\" consists only of whitespace, ignoring"
msgstr "na.strings[%d]==\"%s\" consiste apenas em espaços em branco, ignorando"

#: fread.R:167
#, c-format
msgid ""
"%s. Since strip.white=TRUE (default), use na.strings=\"\" to specify that "
"any number of spaces in a string column should be read as <NA>."
msgstr ""
"%s. Como strip.white=TRUE (padrão), use na.strings=\"\" para especificar que "
"qualquer número de espaços em uma coluna de string deve ser lido como <NA>."

#: fread.R:169
#, c-format
msgid ""
"%s. strip.white==TRUE (default) and \"\" is present in na.strings, so any "
"number of spaces in string columns will already be read as <NA>."
msgstr ""
"%s. strip.white==TRUE (padrão) e \"\" está presente em na.strings, portanto "
"qualquer número de espaços nas colunas de string já será lido como <NA>."

#: fread.R:173
#, c-format
msgid ""
"%s. But strip.white=FALSE. Use strip.white=TRUE (default) together with "
"na.strings=\"\" to turn any number of spaces in string columns into <NA>"
msgstr ""
"%s. Mas strip.white=FALSE. Use strip.white=TRUE (padrão) junto com "
"na.strings=\"\" para transformar qualquer número de espaços em colunas de "
"strings em <NA>"

#: fread.R:180
#, c-format
msgid ""
"'data.table' relies on the package 'yaml' to parse the file header; please "
"add this to your library with install.packages('yaml') and try again."
msgstr ""
"'data.table' depende do pacote 'yaml' para analisar o cabeçalho do arquivo; "
"adicione isso à sua biblioteca com install.packages('yaml') e tente "
"novamente."

#: fread.R:184
#, c-format
msgid ""
"Combining a search string as 'skip' and reading a YAML header may not work "
"as expected -- currently, reading will proceed to search for 'skip' from the "
"beginning of the file, NOT from the end of the metadata; please file an "
"issue on GitHub if you'd like to see more intuitive behavior supported."
msgstr ""
"Combinar uma string de pesquisa como 'skip' e ler um cabeçalho YAML pode não "
"funcionar como esperado -- atualmente, a leitura continuará a procurar por "
"'skip' desde o início do arquivo, NÃO a partir do final dos metadados; por "
"favor, registre um issue no GitHub se desejar ver suporte para um "
"comportamento mais intuitivo."

#: fread.R:194
#, c-format
msgid ""
"Encountered <%s%s> at the first unskipped line (%d), which does not "
"constitute the start to a valid YAML header (expecting something matching "
"regex \"%s\"); please check your input and try again."
msgstr ""
"Encontrado <%s%s> na primeira linha não ignorada (%d), que não constitui o "
"início de um cabeçalho YAML válido (esperando algo correspondente à regex "
"\"%s\"); verifique sua entrada e tente novamente."

#: fread.R:206
#, c-format
msgid ""
"Reached the end of the file before finding a completion to the YAML header. "
"A valid YAML header is bookended by lines matching the regex \"%s\". Please "
"double check the input file is a valid csvy."
msgstr ""
"Chegou ao final do arquivo antes de encontrar uma conclusão no cabeçalho "
"YAML. Um cabeçalho YAML válido é delimitado por linhas que correspondem à "
"regex \"%s\". Verifique novamente se o arquivo de entrada é um csvy válido."

#: fread.R:217
msgid ""
"Processed %d lines of YAML metadata with the following top-level fields: %s"
msgstr ""
"Processadas %d linhas de metadados YAML com os seguintes campos de nível "
"superior: %s"

#: fread.R:220
#, c-format
msgid "User-supplied 'header' will override that found in metadata."
msgstr ""
"O 'header' fornecido pelo usuário substituirá o encontrado nos metadados."

#: fread.R:238
#, c-format
msgid ""
"User-supplied column names in 'col.names' will override those found in YAML "
"metadata."
msgstr ""
"Os nomes de colunas fornecidos pelo usuário em 'col.names' substituirão "
"aqueles encontrados nos metadados YAML."

#: fread.R:247
#, c-format
msgid ""
"colClasses dictated by user input and those read from YAML header are in "
"conflict (specifically, for column(s) [%s]); the proceeding assumes the user "
"input was an intentional override and will ignore the type(s) implied by the "
"YAML header; please exclude the column(s) from colClasses if this was "
"unintentional."
msgstr ""
"colClasses ditadas pela entrada do usuário e aquelas lidas do cabeçalho YAML "
"estão em conflito (especificamente, para coluna(s) [%s]); o processo "
"pressupõe que a entrada do(a) usuário(a) foi uma substituição intencional e "
"ignorará o(s) tipo(s) implícito(s) no cabeçalho YAML; exclua a(s) coluna(s) "
"de colClasses se isso não for intencional."

#: fread.R:268
#, c-format
msgid "User-supplied 'sep' will override that found in metadata."
msgstr "O 'sep' fornecido pelo usuário substituirá o encontrado nos metadados."

#: fread.R:273
#, c-format
msgid "User-supplied 'quote' will override that found in metadata."
msgstr ""
"O 'quote' fornecido pelo(a) usuário(a) substituirá a encontrada nos "
"metadados."

#: fread.R:278
#, c-format
msgid "User-supplied 'dec' will override that found in metadata."
msgstr ""
"O 'dec' fornecido pelo(a) usuário(a) substituirá o encontrado nos metadados."

#: fread.R:282
#, c-format
msgid "User-supplied 'na.strings' will override that found in metadata."
msgstr ""
"O 'na.strings' fornecido pelo(a) usuário(a) substituirá a encontrada nos "
"metadados."

#: fread.R:334
msgid ""
"Column '%s' was requested to be '%s' but fread encountered the following "
"warning:\n"
"\t%s\n"
"so the column has been left as type '%s'"
msgstr ""
"Foi solicitado que a coluna '%s' seja '%s', mas fread encontrou o seguinte "
"aviso:\n"
"\t%s\n"
"então a coluna foi deixada como tipo '%s'"

#: fread.R:336
msgid ""
"Column '%s' was requested to be '%s' but fread encountered the following "
"error:\n"
"\t%s\n"
"so the column has been left as type '%s'"
msgstr ""
"Foi solicitado que a coluna '%s' seja '%s', mas fread encontrou o seguinte "
"erro:\n"
"\t%s\n"
"então a coluna foi deixada como tipo '%s'"

#: fread.R:363
#, c-format
msgid ""
"key argument of data.table() must be a character vector naming columns (NB: "
"col.names are applied before this)"
msgstr ""
"O argumento key de data.table() deve ser um vetor de caracteres que nomeia "
"colunas (Nota: col.names são aplicados antes disso)"

#: fread.R:371
#, c-format
msgid ""
"index argument of data.table() must be a character vector naming columns "
"(NB: col.names are applied before this)"
msgstr ""
"O argumento index do data.table() deve ser um vetor de caracteres que nomeia "
"colunas (Nota: col.names são aplicados antes disso)"

#: froll.R:30
#, c-format
msgid "n must be non 0 length"
msgstr "n deve ter comprimento 0"

#: froll.R:32
#, c-format
msgid "'partial' cannot be used together with align='center'"
msgstr "'partial' não pode ser usado junto com align='center'"

#: froll.R:35
#, c-format
msgid "'partial' does not support variable length of columns in x"
msgstr "'partial' não suporta a comprimento variável de colunas em x"

#: froll.R:37
#, c-format
msgid "'partial' does not support variable nrow of data.tables in x"
msgstr "'partial' não suporta nrow variável de data.tables em x"

#: froll.R:48
#, c-format
msgid "n must be an integer, list is accepted for adaptive TRUE"
msgstr "n deve ser um inteiro, lista é aceita para adaptative TRUE"

#: froll.R:50 froll.R:62
#, c-format
msgid "n must be an integer vector or a list of integer vectors"
msgstr "n deve ser um vetor de inteiros ou uma lista de vetores de inteiros"

#: froll.R:52
msgid ""
"partial2adaptive: froll partial=TRUE trimming n and redirecting to "
"adaptive=TRUE"
msgstr ""
"partial2adaptive: partial=TRUE de froll aparando n e redirecionando para "
"adaptive=TRUE"

#: froll.R:64
#, c-format
msgid "adaptive windows provided in n must not to have different lengths"
msgstr ""
"janelas adaptativas fornecidas em n não podem ter comprimentos diferentes"

#: froll.R:66
#, c-format
msgid ""
"length of n argument must be equal to number of observations provided in x"
msgstr ""
"comprimento do argumento n deve ser igual ao número de observações "
"fornecidas em x"

#: froll.R:68
#, c-format
msgid "length of vectors in x must match to length of adaptive window in n"
msgstr ""
"comprimento de vetores em x deve corresponder ao comprimento da janela "
"adaptativa em n"

#: froll.R:70
msgid "partial2adaptive: froll adaptive=TRUE and partial=TRUE trimming n"
msgstr "partial2adaptive: adaptive=TRUE e partial=TRUE de froll cortando n"

#: froll.R:86
#, c-format
msgid ""
"internal error: misuse of make.roll.names, n must be numeric for !adaptive"
msgstr ""
"erro interno: uso incorreto de make.roll.names, n deve ser numérico para !"
"adaptive"

#: froll.R:92
#, c-format
msgid ""
"internal error: misuse of make.roll.names, non-null length 0 n is not "
"possible for !adaptive"
msgstr ""
"erro interno: uso incorreto de make.roll.names, n com comprimento 0 não nulo "
"não é possível para !adaptive"

#: froll.R:106
#, c-format
msgid ""
"internal error: make.roll.names call should have been escaped in frollapply "
"during 'unpack atomic input'"
msgstr ""
"erro interno: chamada de make.roll.names deve ser escapada em frollapply "
"durante 'unpack atomic input'"

#: froll.R:110
#, c-format
msgid "internal error: make.roll.names generated names of wrong length"
msgstr "erro interno: make.roll.names gerou nomes com comprimento incorreto"

#: froll.R:118
#, c-format
msgid "'x' must be of a numeric type"
msgstr "'x' deve ser um tipo numérico"

#: froll.R:122 froll.R:127
#, c-format
msgid "'n' must be an integer"
msgstr "'x' deve ser um inteiro"

#: froll.R:132
#, c-format
msgid "'n' must be non 0 length"
msgstr "'x' deve ter comprimento não 0"

#: froll.R:134
#, c-format
msgid "'align' other than 'right' has not yet been implemented"
msgstr "'align' diferente de 'right' ainda não está implementado"

#: froll.R:136 froll.R:138 mergelist.R:61
#, c-format
msgid "'%s' must be TRUE or FALSE"
msgstr "'%s' deve ser TRUE ou FALSE"

#: froll.R:157 froll.R:158
#, c-format
msgid "hasNA is deprecated, use has.nf instead"
msgstr "hasNA foi descontinuado, use has.nf em vez disso"

#: froll.R:183
msgid "froll: adaptive=TRUE && align='left' pre-processing for align='right'"
msgstr ""
"froll: pré-processamento de adaptive=TRUE && align='left' para align='right'"

#: froll.R:191
msgid "froll: adaptive=TRUE && align='left' post-processing from align='right'"
msgstr ""
"froll: pós-processamento de adaptive=TRUE && align='left' a partir de "
"align='right'"

#: frollapply.R:130
#, c-format
msgid "'x' is deprecated in frollapply, use 'X' instead"
msgstr "'x' está descontinuado em frollapply, use 'X' em vez disso"

#: frollapply.R:134
#, c-format
msgid "'n' is deprecated in frollapply, use 'N' instead"
msgstr "'n' está descontinuado em frollapply, use 'N' em vez disso"

#: frollapply.R:138
#, c-format
msgid "'by.column' must be TRUE or FALSE"
msgstr "'by.column' deve ser TRUE ou FALSE"

#: frollapply.R:140
#, c-format
msgid "'adaptive' must be TRUE or FALSE"
msgstr "'adaptative' deve ser TRUE ou FALSE"

#: frollapply.R:142
#, c-format
msgid "'partial' must be TRUE or FALSE"
msgstr "'partial' deve ser TRUE ou FALSE"

#: frollapply.R:144
#, c-format
msgid "'give.names' must be TRUE or FALSE"
msgstr "'give.names' deve ser TRUE ou FALSE"

#: frollapply.R:146
#, c-format
msgid "'simplify' must be TRUE or FALSE or a function"
msgstr "'simplify' deve ser TRUE ou FALSE ou uma função"

#: frollapply.R:170
#, c-format
msgid ""
"frollapply by.column=TRUE requires 'X' argument to be atomic or a list of "
"those"
msgstr ""
"by.column=TRUE de frollapply requer que o argumento 'X' seja atômico ou uma "
"lista desses"

#: frollapply.R:182
#, c-format
msgid ""
"frollapply by.column=FALSE, when provided a list in 'X' then all vectors "
"must have equal lengths, like data.frame"
msgstr ""
"by.column=FALSE de frollapply, quando fornecida uma lista em 'X', todos os "
"vetores devem ter comprimentos iguais, como o data.frame"

#: frollapply.R:191
#, c-format
msgid ""
"frollapply by.column=FALSE got vectorized input in 'X', list of data.frames/"
"data.tables, but not all columns of data.frames/data.tables are atomic"
msgstr ""
"by.column=FALSE de frollapply recebeu entrada vetorizada em 'X', lista de "
"data.frames/data.tables, mas nem todas as colunas de data.frames/data.tables "
"são atômicas"

#: frollapply.R:197
#, c-format
msgid ""
"frollapply by.column=FALSE supports vectorized input in 'X' as a list of "
"data.frames/data.tables, not a list of lists. Turn nested lists into "
"data.frames/data.table and retry."
msgstr ""
"by.column=FALSE de frollapply suporta entrada vetorizada em 'X' como uma "
"lista de data.frames/data.tables, não uma lista de listas. Converta listas "
"aninhadas em data.frames/data.tables e tente novamente."

#: frollapply.R:199
#, c-format
msgid ""
"frollapply by.column=FALSE got list in 'X' but it is not valid one. If "
"intent is to pass a list as non-vectorized input, but a single object to "
"apply function to, then the list must have all its vectors atomic. For a "
"vectorized input, passing multiple objects to apply function to, it must be "
"a list of data.frames/data.tables."
msgstr ""
"by.column=FALSE de frollapply recebeu uma lista em 'X', mas ela não é "
"válida. Se a intenção é passar uma lista como entrada não-vetorizada, mas "
"como um único objeto para aplicar função, então a lista deve ter todos seus "
"vetores atômicos. Para uma entrada vetorizada, ao passar vários objetos para "
"aplicar função, a entrada deve ser uma lista de data.frames/data.tables."

#: frollapply.R:202
#, c-format
msgid ""
"frollapply by.column=FALSE requires 'X' argument to be a data.table/"
"data.frame or a list of equal length vectors. For vectorized input can be a "
"list of data.frames/data.tables, but not a list of lists. All columns/"
"vectors must be atomic."
msgstr ""
"by.column=FALSE de frollapply requer que o argumento 'X' seja uma data.table/"
"data.frame ou uma lista de vetores de comprimento igual. Para entrada "
"vetorizada isso pode ser uma lista de data.frames/data.tables, mas não uma "
"lista de listas. Todas colunas e todos vetores devem ser atômicos."

#: frollapply.R:206
#, c-format
msgid "'N' must be non 0 length"
msgstr "'N' deve ter comprimento não 0"

#: frollapply.R:209
#, c-format
msgid "'N' must be an integer, list is accepted for adaptive TRUE"
msgstr "'N' deve ser um inteiro, lista é aceita para adaptive TRUE"

#: frollapply.R:211
#, c-format
msgid "'N' must be an integer"
msgstr "'N' deve ser um inteiro"

#: frollapply.R:216 frollapply.R:227 frollapply.R:241
#, c-format
msgid "'N' must be non-negative integer values (>= 0)"
msgstr "'N' deve ser um valor inteiro não-negativo (>= 0)"

#: frollapply.R:220
#, c-format
msgid ""
"adaptive rolling function can only process 'X' having equal length of "
"elements; If you want to call rolling function on list having variable "
"length of elements call it for each field separately"
msgstr ""
"função de rolagem adaptativa só consegue processar 'X' que tenha comprimento "
"igual de elementos; se você quiser chamar a função de rolagem em uma lista "
"tendo comprimento variável de elementos, chame-a para cada campo "
"separadamente"

#: frollapply.R:223 frollapply.R:233
#, c-format
msgid ""
"length of integer vector(s) provided as list to 'N' argument must be equal "
"to number of observations provided in 'X'"
msgstr ""
"o comprimento de vetor(es) inteiro(s) fornecido(s) como lista ao argumento "
"'N' deve ser igual ao número de observações fornecidas em 'X'"

#: frollapply.R:235
#, c-format
msgid "adaptive windows provided in 'N' must not to have different lengths"
msgstr ""
"janelas adaptativas fornecidas em 'N' não podem ter comprimentos diferentes"

#: frollapply.R:237 frollapply.R:245
#, c-format
msgid "'N' must be an integer vector or list of integer vectors"
msgstr "'N' deve ser um vetor de inteiros ou lista de vetores de inteiros"

#: frollapply.R:257
#, c-format
msgid "using adaptive TRUE and align 'center' is not implemented"
msgstr "usando adaptative TRUE e align como 'center' não está implementado"

#: frollapply.R:262
msgid ""
"frollapply: adaptive=TRUE && align='left' pre-processing for align='right'"
msgstr ""
"frollapply: pré-processamento de adaptive=TRUE && align='left' para "
"align='right'"

#: frollapply.R:319
msgid ""
"frollapply calling parallel::mccollect to collect results from forked "
"processes raised an error.\n"
"%s"
msgstr ""
"frollapply chamando parallel::mccollect para coletar resultados a partir de "
"processos bifurcados levantaram um erro.\n"
"%s"

#: frollapply.R:320
msgid ""
"frollapply internal call to parallel::mccollect raised a warning, FUN "
"warnings should have been suppressed by parallel.\n"
"%s"
msgstr ""
"chamada interna de frollapply a parallel::mccollect levantou um aviso, "
"avisos FUN deveriam ter sido suprimidos por parallel.\n"
"%s"

#: frollapply.R:322
msgid ""
"frollapply completed successfully but raised an error when attempting to "
"simplify results using user specified function in 'simplify' argument. Be "
"sure to provide 'fill' argument matching the type and shape of results "
"returned by the your function. Use simplify=FALSE to obtain a list instead.\n"
"%s"
msgstr ""
"frollapply foi executado com sucesso, mas levantou um erro ao tentar "
"simplificar os resultados usando a função especificada pelo usuário no "
"argumento 'simplify'. Certifique-se de fornecer um argumento 'fill' que "
"corresponda ao tipo e formato dos resultados retornados pela sua função. Use "
"simplify=FALSE para obter uma lista.\n"
"%s"

#: frollapply.R:323
msgid ""
"frollapply completed successfully but raised a warning when attempting to "
"simplify results using user specified function in 'simplify' argument. Be "
"sure to provide 'fill' argument matching the type and shape of results "
"returned by the your function. Use simplify=FALSE to obtain a list instead.\n"
"%s"
msgstr ""
"frollapply foi executado com sucesso, mas levantou um aviso ao tentar "
"simplificar os resultados usando a função especificada pelo usuário no "
"argumento 'simplify'. Certifique-se de fornecer um argumento 'fill' que "
"corresponda ao tipo e formato dos resultados retornados pela sua função. Use "
"simplify=FALSE para obter uma lista.\n"
"%s"

#: frollapply.R:325
msgid ""
"frollapply completed successfully but raised an error when attempting to "
"simplify results using our internal 'simplifylist' function. Be sure to "
"provide 'fill' argument matching the type and shape of results returned by "
"the your function. Use simplify=FALSE to obtain a list instead. If you "
"believe your results could be automatically simplified please submit your "
"use case as new issue in our issue tracker.\n"
"%s"
msgstr ""
"frollapply foi concluído com sucesso, mas levantou um erro ao tentar "
"simplificar os resultados usando nossa função interna 'simplifylist'. "
"Certifique-se de fornecer um argumento 'fill' que corresponda ao tipo e "
"formato dos resultados retornados pela sua função. Use simplify=FALSE para "
"obter uma lista. Se você acredita que seus resultados podem ser "
"simplificados automaticamente, envie seu caso de uso como um novo problema "
"em nosso rastreador de problemas.\n"
"%s"

#: frollapply.R:326
msgid ""
"frollapply completed successfully but raised a warning when attempting to "
"simplify results using our internal 'simplifylist' function. Be sure to "
"provide 'fill' argument matching the type and shape of results returned by "
"the your function. Use simplify=FALSE to obtain a list instead. If you "
"believe your results could be automatically simplified please submit your "
"use case as new issue in our issue tracker.\n"
"%s"
msgstr ""
"frollapply foi concluído com sucesso, mas levantou um aviso ao tentar "
"simplificar os resultados usando nossa função interna 'simplifylist'. "
"Certifique-se de fornecer um argumento 'fill' que corresponda ao tipo e "
"formato dos resultados retornados pela sua função. Use simplify=FALSE para "
"obter uma lista. Se você acredita que seus resultados podem ser "
"simplificados automaticamente, envie seu caso de uso como um novo problema "
"em nosso rastreador de problemas.\n"
"%s"

#: frollapply.R:332
msgid "frollapply running on single CPU thread"
msgstr "frollapply sendo executado em uma única thread de CPU"

#: frollapply.R:348
msgid ""
"frollapply run on %d CPU threads throttled to %d threads, input length %d"
msgstr ""
"frollapply executado em %d threads de CPU foi limitado a %d threads, "
"comprimento de entrada %d"

#: frollapply.R:350
msgid "frollapply running on %d CPU threads"
msgstr "frollapply em execução em %d threads de CPU"

#: frollapply.R:409 frollapply.R:433
#, c-format
msgid ""
"frollapply received an error(s) when evaluating FUN:\n"
"%s"
msgstr ""
"frollapply recebeu um ou mais erros ao avaliar FUN:\n"
"%s"

#: fwrite.R:20
#, c-format
msgid "Argument 'encoding' must be '', 'UTF-8' or 'native'."
msgstr "Argumento 'encoding' deve ser '', 'UTF-8' ou 'native'."

#: fwrite.R:33
#, c-format
msgid "x being coerced from class: matrix to data.table"
msgstr "fazendo coerção de x da classe matrix para data.table"

#: fwrite.R:67
msgid "Appending to existing file so setting bom=FALSE and yaml=FALSE"
msgstr "Anexando ao arquivo existente, definindo bom=FALSE e yaml=FALSE"

#: fwrite.R:80
#, c-format
msgid ""
"If you intended to overwrite the file at %s with an empty one, please use "
"file.remove first."
msgstr ""
"Se você pretendia sobrescrever o arquivo em %s com um vazio, por favor, use "
"file.remove primeiro."

#: fwrite.R:81
#, c-format
msgid "Input has no columns; doing nothing.%s"
msgstr "Entrada não tem colunas; não há nada a fazer.%s"

#: fwrite.R:84
#, c-format
msgid "Input has no columns; creating an empty file at '%s' and exiting."
msgstr "Entrada não tem colunas; criando um arquivo vazio em '%s' e saindo."

#: fwrite.R:92
#, c-format
msgid ""
"'data.table' relies on the package 'yaml' to write the file header; please "
"add this to your library with install.packages('yaml') and try again."
msgstr ""
"'data.table' depende do pacote 'yaml' para escrever o cabeçalho do arquivo; "
"por favor, adicione isso à sua biblioteca com install.packages('yaml') e "
"tente novamente."

#: groupingsets.R:7 groupingsets.R:25 groupingsets.R:47
#, c-format
msgid "Argument 'x' must be a data.table object"
msgstr "Argumento 'x' deve ser um objeto data.table"

#: groupingsets.R:9 groupingsets.R:27 groupingsets.R:53
#, c-format
msgid ""
"Argument 'by' must be a character vector of column names used in grouping."
msgstr ""
"Argumento 'by' deve ser um vetor de caracteres de nomes de colunas usados em "
"agrupamento."

#: groupingsets.R:11 groupingsets.R:29 groupingsets.R:59
#, c-format
msgid "Argument 'id' must be a logical scalar."
msgstr "Argumento 'id' deve ser um escalar lógico."

#: groupingsets.R:31
#, c-format
msgid "Argument 'j' is required"
msgstr "Argumento 'j' é obrigatório"

#: groupingsets.R:49
#, c-format
msgid ""
"Argument 'x' is a 0-column data.table; no measure to apply grouping over."
msgstr ""
"Argumento 'x' é uma data.table com 0 colunas; nenhuma medida para aplicar "
"sobre o agrupamento."

#: groupingsets.R:51
#, c-format
msgid "Input data.table must not contain duplicate column names."
msgstr "A data.table de entrada não deve conter nomes de colunas duplicados."

#: groupingsets.R:55
#, c-format
msgid "Argument 'by' must have unique column names for grouping."
msgstr "Argumento 'by' deve ter nomes de colunas únicos para agrupamento."

#: groupingsets.R:57
#, c-format
msgid "Argument 'sets' must be a list of character vectors."
msgstr "Argumento 'sets' deve ser uma lista de vetores de caracteres."

#: groupingsets.R:63
#, c-format
msgid ""
"Argument 'label', if not NULL, must be a scalar or a named list of scalars."
msgstr ""
"O argumento 'label', se não NULL, deve ser um escalar ou uma lista nomeada "
"de escalares."

#: groupingsets.R:65
#, c-format
msgid ""
"When argument 'label' is a list, all of the list elements must be named."
msgstr ""
"Quando o argumento 'label' é uma lista, todos os elementos da lista devem "
"ser nomeados."

#: groupingsets.R:67
#, c-format
msgid ""
"When argument 'label' is a list, the element names must not contain "
"duplicates."
msgstr ""
"Quando o argumento 'label' é uma lista, os nomes dos elementos não devem "
"conter duplicatas."

#: groupingsets.R:70
#, c-format
msgid ""
"All columns used in 'sets' argument must be in 'by' too. Columns used in "
"'sets' but not present in 'by': %s"
msgstr ""
"Todas as colunas usadas no argumento 'sets' também devem estar em 'by'. "
"Colunas usadas em 'sets', mas não presentes em 'by': %s"

#: groupingsets.R:72
#, c-format
msgid ""
"When using `id=TRUE` the 'x' data.table must not have a column named "
"'grouping'."
msgstr ""
"Ao usar `id=TRUE`, o data.table 'x' não deve ter uma coluna chamada "
"'grouping'."

#: groupingsets.R:74
#, c-format
msgid ""
"Character vectors in 'sets' list must not have duplicated column names "
"within a single grouping set."
msgstr ""
"Vetores de caracteres na lista 'sets' não devem ter nomes de colunas "
"duplicados dentro de um único conjunto de agrupamento."

#: groupingsets.R:76
#, c-format
msgid ""
"'sets' contains a duplicate (i.e., equivalent up to sorting) element at "
"index %d; as such, there will be duplicate rows in the output -- note that "
"grouping by A,B and B,A will produce the same aggregations. Use "
"`sets=unique(lapply(sets, sort))` to eliminate duplicates."
msgstr ""
"'sets' contém um elemento duplicado (isto é, equivalente até a ordenação) no "
"índice %d; assim, haverá linhas duplicadas na saída -- note que agrupar por "
"A,B e B,A produzirá as mesmas agregações. Use `sets=unique(lapply(sets, "
"sort))` para eliminar duplicados."

#: groupingsets.R:82
#, c-format
msgid ""
"When argument 'label' is a list, all element names must be (1) in 'by', or "
"(2) the first element of the class in the data.table 'x' of a variable in "
"'by', or (3) one of %s. Element names not satisfying this condition: %s"
msgstr ""
"Quando o argumento 'label' é uma lista, todos os elementos devem (1) estar "
"em 'by', ou (2) ser o primeiro elemento da classe na data.table 'x' da "
"variável em 'by', ou (3) ser um de %s. Nomes de elementos que não satisfazem "
"essa condição: %s"

#: groupingsets.R:92
#, c-format
msgid "%s (label: %s; data: %s)"
msgstr "%s (label: %s; dados: %s)"

#: groupingsets.R:96
#, c-format
msgid ""
"When argument 'label' is a list, the class of each 'label' element with name "
"in 'by' must match the class of the corresponding column of the data.table "
"'x'. Class mismatch for: %s"
msgstr ""
"Quando o argumento 'label' é uma lista, a classe de cada elemento 'label' "
"com nome em 'by' deve corresponder à classe da respectiva coluna na "
"data.table 'x'. Incompatibilidade de classe para: %s"

#: groupingsets.R:100
#, c-format
msgid "(label name: %s; label class[1]: %s)"
msgstr "(label com nome %s e class[1]: %s)"

#: groupingsets.R:103
#, c-format
msgid ""
"When argument 'label' is a list, the name of each element of 'label' not in "
"'by' must match the first element of the class of the element value. "
"Mismatches: %s"
msgstr ""
"Quando o argumento 'label' é uma lista, o nome de cada elemento de 'label' "
"não em 'by' deve corresponder ao primeiro elemento de cada classe do valor "
"do elemento. Incompatibilidades: %s"

#: groupingsets.R:110
#, c-format
msgid ""
"Expression passed to grouping sets function must not update by reference. "
"Use ':=' on results of your grouping function."
msgstr ""
"Expressão passada para a função de conjuntos de agrupamento não deve "
"atualizar por referência. Use ':=' nos resultados da sua função de "
"agrupamento."

#: groupingsets.R:121
#, c-format
msgid ""
"When using `id=TRUE` the 'j' expression must not evaluate to a column named "
"'grouping'."
msgstr ""
"Ao usar `id=TRUE`, a expressão 'j' não deve avaliar para uma coluna chamada "
"'grouping'."

#: groupingsets.R:123
#, c-format
msgid ""
"There exists duplicated column names in the results, ensure the column "
"passed/evaluated in `j` and those in `by` are not overlapping."
msgstr ""
"Existem nomes de colunas duplicados nos resultados, certifique-se de que a "
"coluna passada/avaliada em `j` e as em `by` não se sobreponham."

#: groupingsets.R:146
#, c-format
msgid "%s (label: %s)"
msgstr "%s (label: %s)"

#: groupingsets.R:147
#, c-format
msgid ""
"For the following variables, the 'label' value was already in the data: %s"
msgstr "Para as seguintes variáveis, o valor 'label' já estava nos dados: %s"

#: groupingsets.R:154
#, c-format
msgid ""
"Using integer64 class columns require to have 'bit64' package installed."
msgstr ""
"Utilizando colunas da classe integer64 requer a instalação do pacote 'bit64'."

#: helpers.R:6
#, c-format
msgid "argument 'sort' must be TRUE or FALSE"
msgstr "argumento 'sort' deve ser TRUE ou FALSE"

#: helpers.R:8
#, c-format
msgid "argument 'rev' must be TRUE or FALSE"
msgstr "argumento 'rev' deve ser TRUE ou FALSE"

#: helpers.R:17
#, c-format
msgid ".selfref.ok expects data.table class object."
msgstr ".selfref.ok espera um objeto de classe data.table."

#: last.R:11 last.R:16 last.R:24 last.R:29 last.R:33 last.R:41 last.R:52
#: last.R:57 last.R:65 last.R:70 last.R:74 last.R:82
msgid "%s: using %s: %s"
msgstr "%s: usando %s: %s"

#: last.R:39 last.R:80
#, c-format
msgid ""
"'xts' class passed to %s function but 'xts' is not available, you should "
"have 'xts' installed already"
msgstr ""
"classe 'xts' foi passada para a função %s, mas 'xts' não está disponível. "
"Você deveria já ter 'xts' instalado"

#: merge.R:4
#, c-format
msgid "Argument 'sort' should be logical TRUE/FALSE"
msgstr "Argumento 'sort' deve ser lógico TRUE/FALSE"

#: merge.R:6
#, c-format
msgid "Argument 'no.dups' should be logical TRUE/FALSE"
msgstr "Argumento 'no.dups' deve ser lógico TRUE/FALSE"

#: merge.R:18
#, c-format
msgid "Neither of the input data.tables to join have columns."
msgstr "Nenhuma das data.tables de entrada para junção tem colunas."

#: merge.R:20 merge.R:22
#, c-format
msgid "Input data.table '%s' has no columns."
msgstr "data.table de entrada '%s' não tem colunas."

#: merge.R:32
#, c-format
msgid "`by.x` and `by.y` must be of same length."
msgstr "`by.x` e `by.y` devem ter o mesmo comprimento."

#: merge.R:34
#, c-format
msgid "Supplied both `by` and `by.x`/`by.y`. `by` argument will be ignored."
msgstr ""
"Foram fornecidos ambos `by` e `by.x/by.y`. O argumento `by` será ignorado."

#: merge.R:37
#, c-format
msgid "A non-empty vector of column names is required for `by.x` and `by.y`."
msgstr ""
"Um vetor não vazio de nomes de colunas é necessário para `by.x` e `by.y`."

#: merge.R:39 merge.R:42 merge.R:56 merge.R:59
#, c-format
msgid "The following columns listed in `%s` are missing from %s: %s"
msgstr "As seguintes colunas listadas em `%s` estão faltando em %s: %s"

#: merge.R:54
#, c-format
msgid "A non-empty vector of column names for `by` is required."
msgstr "É necessário um vetor não vazio de nomes de colunas para `by`."

#: merge.R:116
#, c-format
msgid "column names %s are duplicated in the result"
msgstr "nomes das colunas %s estão duplicados no resultado"

#: merge.R:146
#, c-format
msgid "merge.data.table() received %s and %s, all of which will be ignored: %s"
msgstr "merge.data.table() recebeu %s e %s, todos os quais serão ignorados: %s"

#: mergelist.R:52
#, c-format
msgid "'x' must be data.table"
msgstr "'x' deve ser uma data.table"

#: mergelist.R:54
#, c-format
msgid "'on' must be character column names of 'x' argument"
msgstr "'on' deve ser nomes de coluna de caracteres do argumento 'x'"

#: mergelist.R:59
#, c-format
msgid ""
"'cols' must be non-zero length, non-NA, integer or character columns of 'x' "
"argument"
msgstr ""
"'cols' deve ser colunas de comprimento não-zero, não-NA, inteiros ou "
"caracteres de argumento 'x'"

#: mergelist.R:98
#, c-format
msgid "cross join must be used with zero-length on, mult='all', join.many=TRUE"
msgstr ""
"junção cruzada deve ser usada com 'on' de comprimento zero, mult='all', "
"join.many=TRUE"

#: mergelist.R:104
#, c-format
msgid "'on' must be non-zero length character vector"
msgstr "'on' deve ser um vetor de caracteres com comprimento não-zero"

#: mergelist.R:106
#, c-format
msgid "semi and anti joins must be used with mult!='all'"
msgstr "semijunções ou antijunções devem ser usadas com mult!='all'"

#: mergelist.R:157
#, c-format
msgid "'on' is missing and necessary key is not present"
msgstr "'on' está faltando e a chave necessária não está presente"

#: mergelist.R:160 mergelist.R:162
#, c-format
msgid ""
"'on' argument specifies columns to join %s that are not present in %s table "
"%s"
msgstr ""
"o argumento 'on' especifica colunas para juntar %1s que não estão presentes "
"no %3s, tabela %2s"

#: mergelist.R:206
#, c-format
#| msgid ""
#| "%s has duplicated column name %s. Please remove or rename the duplicate "
#| "and try again."
#| msgid_plural ""
#| "%s has duplicated column names %s. Please remove or rename the duplicates "
#| "and try again."
msgid ""
"merge result has duplicated column names %s, use 'cols' argument or rename "
"columns in 'l' tables"
msgstr ""
"o resultado da mesclagem tem nomes de colunas %s duplicados, use o argumento "
"'cols' ou renomeie colunas nas tabelas 'l'"

#: mergelist.R:266 mergelist.R:304
#, c-format
msgid "'%s' must be a list"
msgstr "'%s' deve ser uma lista"

#: mergelist.R:268
#, c-format
msgid "Every element of 'l' list must be data.table objects"
msgstr "Todos os elementos da lista 'l' devem ser objetos data.table"

#: mergelist.R:270
#, c-format
msgid "Tables in 'l' must all have columns, but these entries have 0: %s"
msgstr "Tabelas em 'l' devem todas terem colunas, mas essas entradas têm 0: %s"

#: mergelist.R:272
#, c-format
msgid ""
"Column names in individual 'l' entries must be unique, but these have some "
"duplicates: %s"
msgstr ""
"Nomes de colunas em entradas individuais de 'l' devem ser únicos, mas estes "
"têm algumas duplicatas: %s"

#: mergelist.R:279
msgid "mergelist: merging %d table(s), took %.3fs"
msgstr "mergelist: mesclando %d tabela(s), levou %.3fs"

#: mergelist.R:286
#, c-format
msgid ""
"'join.many' must be TRUE or FALSE, or a list of such whose length must be "
"length(l)-1L"
msgstr ""
"'join.many' deve ser TRUE ou FALSE, ou uma lista de tais elementos cujo "
"comprimento deve ser length(l)-1L"

#: mergelist.R:293
#, c-format
msgid ""
"'mult' must be one of [error, all, first, last] or NULL, or a list of such "
"whose length must be length(l)-1L"
msgstr ""
"'mult' deve ser um entre [error, all, first, last] ou NULL, ou uma lista de "
"tais elementos cujo comprimento deve ser length(l)-1L"

#: mergelist.R:298
#, c-format
msgid ""
"'how' must be one of [left, inner, full, right, semi, anti, cross], or a "
"list of such whose length must be length(l)-1L"
msgstr ""
"'how' deve ser um entre [left, inner, full, right, semi, anti, cross], ou "
"uma lista de tais elementos cujo comprimento deve ser length(l)-1L"

#: mergelist.R:306
#, c-format
msgid "'cols' must be same length as 'l' (%d != %d)"
msgstr "'cols' deve ter o mesmo comprimento que 'l' (%d != %d)"

#: mergelist.R:309
#, c-format
msgid ""
"'cols' must be a list of non-zero length, non-NA, non-duplicated, character "
"vectors, or eventually NULLs (all columns)"
msgstr ""
"'cols' deve ser uma lista de comprimento não-zero, não-NA, não-duplicada, "
"vetores de caracteres ou eventualmente NULLs (todas colunas)"

#: mergelist.R:311
#, c-format
msgid "'cols' specify columns not present in corresponding table"
msgstr "'cols' especifica colunas não presentes na tabela correspondente"

#: mergelist.R:320
#, c-format
msgid ""
"'on' must be non-NA, non-duplicated, character vector, or a list of such "
"which length must be length(l)-1L"
msgstr ""
"'on' deve ser não-NA, não-duplicada, vetor de caracteres ou uma lista destes "
"cujo comprimento deve ser length(l)-1L"

#: mergelist.R:343
msgid "mergelist: merging %d tables, took %.3fs"
msgstr "mergelist: mesclando %d tabelas, levou %.3fs"

#: onAttach.R:23
#, c-format
msgid ""
"data.table %s IN DEVELOPMENT built %s%s using %d threads (see ?getDTthreads)."
msgstr ""
"data.table %s EM DESENVOLVIMENTO construído %s%s usando %d threads (veja ?"
"getDTthreads)."

#: onAttach.R:25
#, c-format
msgid "data.table %s using %d threads (see ?getDTthreads)."
msgstr "data.table %s usando %d threads (veja ?getDTthreads)."

#: onAttach.R:26
#, c-format
msgid "Latest news: r-datatable.com"
msgstr "Últimas notícias: r-datatable.com"

#: onAttach.R:27
msgid "TRANSLATION CHECK"
msgstr "VERIFICAÇÃO DE TRADUÇÃO"

#: onAttach.R:29
#, c-format
msgid ""
"**********\n"
"Running data.table in English; package support is available in English only. "
"When searching for online help, be sure to also check for the English error "
"message. This can be obtained by looking at the po/R-<locale>.po and po/"
"<locale>.po files in the package source, where the native language and "
"English error messages can be found side-by-side.%s\n"
"**********"
msgstr ""
"**********\n"
"Executando data.table em português; o suporte ao pacote está disponível "
"apenas em inglês. Ao procurar ajuda online, certifique-se de verificar "
"também a mensagem de erro em inglês. Isso pode ser obtido examinando os "
"arquivos po/R-pt_BR.po e po/pt_BR.po no código-fonte do pacote, onde as "
"mensagens de erro no idioma nativo e em inglês podem ser encontradas lado a "
"lado.%s\n"
"**********"

#: onAttach.R:30
msgid ""
"You can also try calling Sys.setLanguage('en') prior to reproducing the "
"error message."
msgstr ""
"Você também pode tentar chamar Sys.setLanguage('en') antes de reproduzir a "
"mensagem de erro."

#: onAttach.R:34
#, c-format
msgid ""
"**********\n"
"This development version of data.table was built more than 4 weeks ago. "
"Please update: data.table::update_dev_pkg()\n"
"**********"
msgstr ""
"**********\n"
"Esta versão de desenvolvimento do data.table foi construída há mais de 4 "
"semanas. Por favor, atualize: data.table::update_dev_pkg()\n"
"**********"

#: onAttach.R:36
#, c-format
msgid ""
"**********\n"
"This installation of data.table has not detected OpenMP support. It should "
"still work but in single-threaded mode."
msgstr ""
"**********\n"
"Esta instalação do data.table não detectou suporte ao OpenMP. Ainda deve "
"funcionar, mas em modo de single-threaded."

#: onAttach.R:38
#, c-format
msgid ""
"This is a Mac. Please read https://mac.r-project.org/openmp/. Please engage "
"with Apple and ask them for support. Check r-datatable.com for updates, and "
"our Mac instructions here: https://github.com/Rdatatable/data.table/wiki/"
"Installation. After several years of many reports of installation problems "
"on Mac, it's time to gingerly point out that there have been no similar "
"problems on Windows or Linux.\n"
"**********"
msgstr ""
"Este é um Mac. Por favor, leia https://mac.r-project.org/openmp/. Por favor, "
"envolva-se com a Apple e peça suporte. Verifique r-datatable.com para "
"atualizações e nossas instruções para Mac aqui: https://github.com/"
"Rdatatable/data.table/wiki/Installation. Após vários anos de muitos relatos "
"de problemas de instalação no Mac, é hora de apontar cuidadosamente que não "
"houve problemas semelhantes no Windows ou Linux.\n"
"**********"

#: onAttach.R:40
#, c-format
msgid ""
"This is %s. This warning should not normally occur on Windows or Linux where "
"OpenMP is turned on by data.table's configure script by passing -fopenmp to "
"the compiler. If you see this warning on Windows or Linux, please file a "
"GitHub issue.\n"
"**********"
msgstr ""
"Este é %s. Este aviso normalmente não deve ocorrer no Windows ou Linux, onde "
"o OpenMP é ativado pelo script de configuração do data.table passando "
"-fopenmp para o compilador. Se você vir este aviso no Windows ou Linux, por "
"favor, relate no rastreador de problemas no GitHub.\n"
"**********"

#: onLoad.R:5
#, c-format
msgid ""
"Option 'datatable.nomatch' is defined but is now ignored. Please see note 11 "
"in v1.12.4 NEWS (Oct 2019), and note 14 in v1.14.2."
msgstr ""
"Opção 'datatable.nomatch' está definida, mas agora é ignorada. Por favor, "
"veja a nota 11 nas notícias de v1.12.4 (Outubro de 2019) e a nota 14 em "
"v1.14.2."

#: onLoad.R:21
#, c-format
msgid ""
"The data_table.%s version (%s) does not match the package (%s). Please close "
"all R sessions to release the old %s and reinstall data.table in a fresh R "
"session. Prior to R version 3.6.0 patched, R's package installer could leave "
"a package in an apparently functional state where new R code was calling old "
"C code silently: https://bugs.r-project.org/bugzilla/show_bug.cgi?id=17478. "
"Once a package is in this mismatch state it may produce wrong results "
"silently until you next upgrade the package. This mismatch between R and C "
"code can happen with any package not just data.table. It is just that "
"data.table has added this check."
msgstr ""
"A versão do data_table.%s (%s) não corresponde à do pacote (%s). Por favor, "
"feche todas as sessões do R para liberar a antiga %s e reinstale o "
"data.table em uma nova sessão do R. Antes da versão 3.6.0 patched, o "
"instalador de pacotes do R podia deixar um pacote em um estado aparentemente "
"funcional onde o novo código R estava silenciosamente chamando o código C "
"antigo: https://bugs.r-project.org/bugzilla/show_bug.cgi?id=17478. Uma vez "
"que um pacote esteja neste estado de incompatibilidade, ele pode produzir "
"resultados errados silenciosamente até que você atualize o pacote novamente. "
"Essa incompatibilidade entre o código R e C pode acontecer com qualquer "
"pacote, não apenas com o data.table. É apenas que o data.table adicionou "
"essa verificação."

#: onLoad.R:25
#, c-format
msgid ""
"This is R %s but data.table has been installed using R %s. The major version "
"must match. Please reinstall data.table."
msgstr ""
"Este é o R %s, mas o data.table foi instalado usando o R %s. A versão "
"principal deve corresponder. Por favor, reinstale o data.table."

#: onLoad.R:103
#, c-format
msgid "Unexpected base R behaviour: list(x) has copied x"
msgstr "Comportamento inesperado do R base: list(x) copiou x"

#: onLoad.R:111
#, c-format
msgid "Unexpected base R behaviour: names<- has copied column contents"
msgstr ""
"Comportamento inesperado do R base: names<- copiou o conteúdo da coluna"

#: onLoad.R:121
#, c-format
msgid ""
"Unexpected base R behaviour: DF[2,2]<- did not copy column 2 which was "
"assigned to"
msgstr ""
"Comportamento inesperado do R base: DF[2,2]<- não copiou a coluna 2 que foi "
"atribuída"

#: onLoad.R:122
#, c-format
msgid ""
"Unexpected base R behaviour: DF[2,2]<- copied the first column which was not "
"assigned to, too"
msgstr ""
"Comportamento inesperado do R base: DF[2,2]<- copiou também a primeira "
"coluna, que não foi atribuída"

#: onLoad.R:124
#, c-format
msgid "Unexpected base R behaviour: DF[2,2]<- has not copied address(DF)"
msgstr "Comportamento inesperado do R base: DF[2,2]<- não copiou address(DF)"

#: openmp-utils.R:3
#, c-format
msgid "Provide either threads= or percent= but not both"
msgstr "Forneça threads= ou percent=, mas não ambos"

#: openmp-utils.R:4
#, c-format
msgid "percent= is provided but is length %d"
msgstr "percent= foi fornecido, mas tem comprimento %d"

#: openmp-utils.R:6
#, c-format
msgid "percent==%d but should be a number between 2 and 100"
msgstr "percent==%d, mas deveria ser um número entre 2 e 100"

#: print.data.table.R:19
#, c-format
msgid "Valid options for col.names are 'auto', 'top', and 'none'"
msgstr "As opções válidas para col.names são 'auto', 'top', e 'none'"

#: print.data.table.R:21
#, c-format
msgid "Valid options for trunc.cols are TRUE and FALSE"
msgstr "Opções válidas para trunc.cols são TRUE e FALSE"

#: print.data.table.R:24
#, c-format
msgid "Column classes will be suppressed when col.names is 'none'"
msgstr "As classes de colunas serão suprimidas quando col.names for 'none'"

#: print.data.table.R:48
msgid "Key: <%s>"
msgstr "Chave: <%s>"

#: print.data.table.R:58
msgid "Null %s (0 rows and 0 cols)"
msgstr "%s nula (0 linha e 0 coluna)"

#: print.data.table.R:60
msgid "Empty %s (%d rows and %d cols)"
msgstr "%s vazia (%d linhas e %d colunas)"

#: print.data.table.R:161
#, c-format
msgid ""
"Internal structure doesn't seem to be a list. Possibly corrupt data.table."
msgstr ""
"A estrutura interna não parece ser uma lista. Possivelmente data.table "
"corrompida."

#: programming.R:14 programming.R:40
#, c-format
msgid "'x' must be a list"
msgstr "'x' deve ser uma lista"

#: programming.R:22
#, c-format
msgid ""
"Character objects provided in the input are not scalar objects, if you need "
"them as character vector rather than a name, then wrap each into 'I' call: %s"
msgstr ""
"Objetos de caracteres fornecidos na entrada não são objetos escalares, se "
"você precisar deles como vetor de caracteres em vez de um nome, então "
"envolva cada um 'I' na chamada: %s"

#: programming.R:50
#, c-format
msgid "'env' must not be missing"
msgstr "'env' não deve estar ausente"

#: programming.R:56
#, c-format
msgid "'env' must be a list or an environment"
msgstr "'env' deve ser uma lista ou um ambiente"

#: programming.R:63
#, c-format
msgid "'env' argument does not have names"
msgstr "argumento 'env' não tem nomes"

#: programming.R:65
#, c-format
msgid "'env' argument has zero char names"
msgstr "argumento 'env' tem zero nomes de caracteres"

#: programming.R:67
#, c-format
msgid "'env' argument has NA names"
msgstr "argumento 'env' tem nomes NA"

#: programming.R:69
#, c-format
msgid "'env' argument has duplicated names"
msgstr "argumento 'env' tem nomes duplicados"

#: rowwiseDT.R:4
#, c-format
msgid ""
"Must provide at least one column (use `name=`). See ?rowwiseDT for details"
msgstr ""
"É necessário fornecer ao menos uma coluna (use `name=`). Veja ?rowwiseDT "
"para detalhes"

#: rowwiseDT.R:7
#, c-format
msgid "Named arguments must be empty"
msgstr "Argumentos nomeados devem estar vazios"

#: rowwiseDT.R:9
#, c-format
msgid "Header must be the first N arguments"
msgstr "O cabeçalho deve ser os primeiros N argumentos"

#: rowwiseDT.R:15
#, c-format
msgid ""
"There are %d columns but the number of cells is %d, which is not an integer "
"multiple of the columns"
msgstr ""
"Há %d colunas mas o número de células é %d, que não é um múltiplo inteiro "
"das colunas"

#: setkey.R:3
#, c-format
msgid ""
"x may no longer be the character name of the data.table. The possibility was "
"undocumented and has been removed."
msgstr ""
"x pode não ser mais o nome da data.table do tipo caractere. A possibilidade "
"não era documentada e foi removida."

#: setkey.R:34
#, c-format
msgid "x is not a data.table"
msgstr "x não é uma data.table"

#: setkey.R:35
#, c-format
msgid ""
"cols is not a character vector. Please see further information in ?setkey."
msgstr ""
"cols não é um vetor de caracteres. Por favor, veja mais informações em ?"
"setkey."

#: setkey.R:36
#, c-format
msgid ""
"Setting a physical key on .SD is reserved for possible future use; to modify "
"the original data's order by group. Try setindex() instead. Or, "
"set*(copy(.SD)) as a (slow) last resort."
msgstr ""
"Definir uma chave física em .SD está reservado para possível uso futuro; "
"para modificar a ordem dos dados originais por grupo. Tente setindex() em "
"vez disso. Ou, set*(copy(.SD)) como último recurso (lento)."

#: setkey.R:38
#, c-format
msgid ""
"cols is a character vector of zero length. Removed the key, but use NULL "
"instead, or wrap with suppressWarnings() to avoid this warning."
msgstr ""
"cols é um vetor de caracteres de comprimento zero. A chave foi removida, mas "
"use NULL em vez disso, ou envolva com suppressWarnings() para evitar este "
"aviso."

#: setkey.R:42
#, c-format
msgid "cols is the empty string. Use NULL to remove the key."
msgstr "cols é uma string vazia. Use NULL para remover a chave."

#: setkey.R:43 setkey.R:265
#, c-format
msgid "cols contains some blanks."
msgstr "cols contém alguns espaços em branco."

#: setkey.R:46 setkey.R:269
#, c-format
msgid "some columns are not in the data.table: %s"
msgstr "algumas colunas não estão na data.table: %s"

#: setkey.R:54 setkey.R:270
#, c-format
msgid ""
"x contains a column called '.xi'. Conflicts with internal use by data.table."
msgstr ""
"x contém uma coluna chamada '.xi'. Conflita com o uso interno do data.table."

#: setkey.R:57
#, c-format
msgid ""
"Column '%s' is type '%s' which is not supported as a key column type, "
"currently."
msgstr ""
"Coluna '%s' é do tipo '%s', que atualmente não é suportado como tipo de "
"coluna chave."

#: setkey.R:65
msgid "forder took %.03f sec"
msgstr "forder levou %.03f s"

#: setkey.R:77
msgid "reorder took %s"
msgstr "reorder levou %s"

#: setkey.R:79
msgid "x is already ordered by these columns, no need to call reorder"
msgstr ""
"x já está ordenado por essas colunas, não há necessidade de chamar reorder"

#: setkey.R:132
#, c-format
msgid "x is vector but 'by' is supplied"
msgstr "x é um vetor, mas 'by' foi fornecido"

#: setkey.R:148
#, c-format
msgid "x is a single vector, non-NULL 'by' doesn't make sense"
msgstr "x é um único vetor, 'by' não NULL não faz sentido."

#: setkey.R:160
#, c-format
msgid ""
"data.table has no support for sorting by method='%s'. Use base::order(), not "
"order(), if you really need this."
msgstr ""
"data.table não tem suporte a ordenar pelo method='%s'. Use base::order(), "
"não order(), se você realmente precisar disso."

#: setkey.R:181
#, c-format
msgid "Attempting to order a 0-column data.table or data.frame."
msgstr "Tentativa de ordenar uma data.table ou um data.frame com 0 colunas."

#: setkey.R:186
#, c-format
msgid ""
"The first item passed to [f]order is a plain list but there are more items. "
"It should be a data.table or data.frame."
msgstr ""
"O primeiro item passado para [f]order é uma lista simples, mas há mais "
"itens. Deve ser uma data.table ou um data.frame."

#: setkey.R:194
#, c-format
msgid "Mixing '-' with vector decreasing= is not supported."
msgstr "Sem suporte a misturar '-' com vetor decreasing=."

#: setkey.R:195
#, c-format
msgid "decreasing= has length %d applied to sorting %d columns."
msgstr "decreasing= tem comprimento %d aplicado a ordenar %d colunas."

#: setkey.R:211
#, c-format
msgid "Internal code should not be being called on type double"
msgstr "Código interno não deveria estar sendo chamado em um tipo double"

#: setkey.R:218
#, c-format
msgid ""
"Input is not a vector of type double. New parallel sort has only been done "
"for double vectors so far. Using one thread."
msgstr ""
"Entrada não é um vetor do tipo double. A nova ordenação paralela só foi "
"feita para vetores do tipo double até agora. Usando uma thread."

#: setkey.R:219
#, c-format
msgid ""
"New parallel sort has not been implemented for decreasing=TRUE so far. Using "
"one thread."
msgstr ""
"A nova ordenação paralela ainda não foi implementada para decreasing=TRUE "
"até o momento. Usando uma thread."

#: setkey.R:220
#, c-format
msgid ""
"New parallel sort has not been implemented for vectors containing NA values "
"so far. Using one thread."
msgstr ""
"A nova ordenação paralela ainda não foi implementada para vetores contendo "
"valores NA até o momento. Usando uma thread."

#: setkey.R:231 setkey.R:257
#, c-format
msgid "x must be a data.frame or data.table"
msgstr "x deve ser uma data.frame ou uma data.table"

#: setkey.R:259
#, c-format
msgid "na.last must be logical TRUE/FALSE"
msgstr "na.last deve ser lógico TRUE/FALSE"

#: setkey.R:260
#, c-format
msgid ""
"cols is not a character vector. Please see further information in ?setorder."
msgstr ""
"cols não é um vetor de caracteres. Por favor, veja mais informações em ?"
"setorder."

#: setkey.R:262
#, c-format
msgid ""
"cols is a character vector of zero length. Use NULL instead, or wrap with "
"suppressWarnings() to avoid this warning."
msgstr ""
"cols é um vetor de caracteres de comprimento zero. Use NULL em vez disso, ou "
"envolva com suppressWarnings() para evitar este aviso."

#: setkey.R:273
#, c-format
msgid "Column '%s' is type '%s' which is not supported for ordering currently."
msgstr ""
"Coluna '%s' é do tipo '%s', que atualmente não é suportado para ordenação."

#: setkey.R:317
#, c-format
msgid ""
"'sorted' is TRUE but element %d is non-atomic, which can't be sorted; try "
"setting sorted = FALSE"
msgstr ""
"'sorted' é TRUE, mas o elemento %d é não atômico, o que não pode ser "
"ordenado; tente definir sorted = FALSE"

#: setkey.R:332
#, c-format
msgid ""
"Cross product of elements provided to CJ() would result in %.0f rows which "
"exceeds .Machine$integer.max == %d"
msgstr ""
"Produto cruzado dos elementos fornecidos a CJ() resultaria em %.0f linhas "
"que excedem .Machine$integer.max == %d"

#: setops.R:3 setops.R:40
#, c-format
msgid "x and y must both be data.tables"
msgstr "x e y devem ser ambos data.tables"

#: setops.R:17
#, c-format
msgid ""
"When x's column ('%s') is character, the corresponding column in y ('%s') "
"should be factor or character, but found incompatible type '%s'."
msgstr ""
"Quando a coluna de x ('%s') é do tipo caractere, a coluna correspondente em "
"y ('%s') deve ser do tipo fator ou caractere, mas foi encontrado um tipo "
"incompatível '%s'."

#: setops.R:19
#, c-format
msgid ""
"When x's column ('%s') is factor, the corresponding column in y ('%s') "
"should be character or factor, but found incompatible type '%s'."
msgstr ""
"Quando a coluna de x ('%s') é do tipo fator, a coluna correspondente em y "
"('%s') deve ser do tipo caractere ou fator, mas foi encontrado um tipo "
"incompatível '%s'."

#: setops.R:21
#, c-format
msgid ""
"When x's column ('%s') is integer or numeric, the corresponding column in y "
"('%s') can not be character or logical types, but found incompatible type "
"'%s'."
msgstr ""
"Quando a coluna de x ('%s') é do tipo inteiro ou numérico, a coluna "
"correspondente em y ('%s') não pode ser do tipo caractere ou lógico, mas foi "
"encontrado um tipo incompatível '%s'."

#: setops.R:39
#, c-format
msgid "argument 'all' should be logical of length one"
msgstr "argumento 'all' deve ser lógico de comprimento um"

#: setops.R:41
#, c-format
msgid "x and y must have the same column names"
msgstr "x e y devem ter os mesmos nomes de colunas"

#: setops.R:42
#, c-format
msgid "x and y must have the same column order"
msgstr "x e y devem ter a mesma ordem de colunas"

#: setops.R:55
#, c-format
msgid "Item %d of x is '%s' but the corresponding item of y is '%s'."
msgstr "Item %d de x é '%s', mas o item correspondente de y é '%s'."

#: setops.R:57
#, c-format
msgid "None of the datasets should contain a column named '.seqn'"
msgstr "Nenhum dos conjuntos de dados deve conter uma coluna chamada '.seqn'"

#: setops.R:162
msgid "Datasets have different keys"
msgstr "Conjuntos de dados têm diferente chaves"

#: setops.R:163 setops.R:164
msgid "has no key"
msgstr "não tem chave"

#: setops.R:173
msgid "Datasets have different indices"
msgstr "Conjuntos de dados têm diferentes índices"

#: setops.R:174 setops.R:175
msgid "has no index"
msgstr "não tem índice"

#: setops.R:192
#, c-format
msgid "None of the datasets to compare should contain a column named '.seqn'"
msgstr ""
"Nenhum dos conjuntos de dados a serem comparados deve conter uma coluna "
"chamada '.seqn'"

#: setops.R:195
#, c-format
msgid ""
"Datasets to compare with 'ignore.row.order' must not have unsupported column "
"types: %s"
msgstr ""
"Conjuntos de dados a serem comparados com 'ignore.row.order' não devem ter "
"tipos de colunas não suportados:%s"

#: setops.R:197
#, c-format
msgid ""
"Argument 'tolerance' was forced to lowest accepted value "
"`sqrt(.Machine$double.eps)` from provided %s"
msgstr ""
"Argumento 'tolerance' foi forçado ao valor mínimo aceito de "
"`sqrt(.Machine$double.eps)` a partir do fornecido %s"

#: setops.R:210
#, c-format
msgid ""
"Duplicate rows in datasets, numeric columns and ignore.row.order cannot be "
"used with non 0 tolerance argument"
msgstr ""
"Linhas duplicadas nos conjuntos de dados, colunas numéricas e "
"ignore.row.order não podem ser usadas com argumento de tolerância diferente "
"de 0"

#: setops.R:224
#, c-format
msgid ""
"Factor columns and ignore.row.order cannot be used with non 0 tolerance "
"argument"
msgstr ""
"Colunas de fator e ignore.row.order não podem ser usadas com argumento de "
"tolerância diferente de 0"

#: shift.R:3
#, c-format
msgid "Provided argument fill=%s will be ignored since type='cyclic'."
msgstr "O argumento fornecido fill=%s será ignorado, pois type='cyclic'."

#: tables.R:31
msgid "No objects of class data.table exist in %s"
msgstr "Não existem objetos da classe data.table em %s"

#: tables.R:46
#, c-format
msgid "order.col='%s' not a column name of info"
msgstr "order.col='%s' não é um nome de coluna de info"

#: tables.R:59
msgid "Total: %sMB using %s"
msgstr "Total: %sMB usando %s"

#: test.data.table.R:23
#, c-format
msgid "data.table package is loaded. Unload or start a fresh R session."
msgstr ""
"Pacote data.table está carregado. Descarregue ou inicie uma nova sessão do R."

#: test.data.table.R:39
#, c-format
msgid ""
"script must end with '.Rraw'. If a file ending '.Rraw.bz2' exists, that will "
"be found and used."
msgstr ""
"script deve terminar com '.Rraw'. Se existir um arquivo terminando em "
"'.Rraw.bz2', ele será encontrado e usado."

#: test.data.table.R:69
#, c-format
msgid "Neither %s nor %s exist in %s"
msgstr "Nem %s ou %sexistem em %s"

#: test.data.table.R:121
msgid "test.data.table() running: %s"
msgstr "test.data.table() em execução: %s"

#: test.data.table.R:125
msgid "object '%s' not found"
msgstr "objeto '%s' não encontrado"

#: test.data.table.R:128
msgid ""
"**** This R session's language is not English. Each test will still check "
"that the correct number of errors and/or\n"
"**** warnings are produced. However, to test the text of each error/warning "
"too, please restart R with LANGUAGE=en"
msgstr ""
"**** O idioma desta sessão R não é inglês. Cada teste ainda verificará se o "
"número correto de erros e/ou avisos\n"
"**** são produzidos. No entanto, para testar o texto de cada erro/aviso "
"também, reinicie o R com LANGUAGE=en"

#: test.data.table.R:148
msgid ""
"***\n"
"*** memtest=%d. This should be the first call in a fresh R_GC_MEM_GROW=0 R "
"session for best results. Ctrl-C now if not.\n"
"***"
msgstr ""
"***\n"
"*** memtest=%d. Esta deve ser a primeira chamada em uma nova sessão "
"R_GC_MEM_GROW=0 R para melhores resultados.\n"
"*** Ctrl-C agora se não for o caso.\n"
"***"

#: test.data.table.R:149
#, c-format
msgid ""
"memtest intended for Linux. Step through data.table:::rss() to see what went "
"wrong."
msgstr ""
"memtest destinado para Linux. Percorra data.table:::rss() para ver o que deu "
"errado."

#: test.data.table.R:203
#, c-format
msgid "Attempt to subset to %d tests matching '%s' failed, running full suite."
msgstr ""
"A tentativa de obter subconjunto de %d testes correspondendo a '%s' falhou, "
"executando a suíte completa."

#: test.data.table.R:208
msgid "Running %d of %d tests matching '%s'"
msgstr "Executando %d de %d testes correspondendo a '%s'"

#: test.data.table.R:278
#, c-format
msgid "Failed in %s after test %s before the next test() call in %s"
msgstr "Falhou em %s após o teste %s antes da próxima chamada de test() em %s"

#: test.data.table.R:306
#, c-format
msgid ""
"Tests succeeded, but non-test code caused warnings. Search %s for tests "
"shown above."
msgstr ""
"Os testes foram bem-sucedidos, mas o código que não era de teste gerou "
"avisos. Pesquise %s pelos testes mostrados acima."

#: test.data.table.R:316
#, c-format
msgid "Timings count mismatch: %d vs %d"
msgstr "Contagem de tempos não corresponde: %d vs %d"

#: test.data.table.R:318
msgid "10 longest running tests took %ds (%d%% of %ds)"
msgstr "10 testes de execução mais longa levaram %ds (%d%% de %ds)"

#: test.data.table.R:324
msgid "10 largest RAM increases (MiB); see plot for cumulative effect (if any)"
msgstr ""
"10 maiores aumentos de RAM (MiB); veja o gráfico para efeito cumulativo (se "
"houver)"

#: test.data.table.R:334
msgid "All %d tests (last %.8g) in %s completed ok in %s"
msgstr "Todos os %d testes (último %.8g) em %s concluíram corretamente em %s"

#: test.data.table.R:430
msgid "Running test id %s"
msgstr "Executando teste de id %s"

#: test.data.table.R:448
#, c-format
msgid ""
"Test %s is invalid: when error= is provided it does not make sense to pass y "
"as well"
msgstr ""
"Teste %s é inválido: quando error= é fornecido, não faz sentido passar y "
"também"

#: test.data.table.R:493
msgid "Test id %s is not in increasing order"
msgstr "O id de teste %s não está em ordem crescente"

#: test.data.table.R:510
msgid ""
"Test %s produced %d %ss but expected %d\n"
"%s\n"
"%s"
msgstr ""
"O teste %s produziu %d %ss, mas esperava-se %d\n"
"%s\n"
"%s"

#: test.data.table.R:518
msgid ""
"Test %s didn't produce the correct %s:\n"
"Expected: %s\n"
"Observed: %s"
msgstr ""
"O teste %s não produziu o %s correto:\n"
"Esperado: %s\n"
"Observado: %s"

#: test.data.table.R:527
msgid "Output captured before unexpected warning/error/message:"
msgstr "Saída capturada antes de aviso/erro/mensagem inesperado:"

#: test.data.table.R:538
msgid "Test %s did not produce correct output:"
msgstr "O teste %s não produziu saída correta:"

#: test.data.table.R:539
msgid "Expected: <<%s>>"
msgstr "Esperado: <<%s>>"

#: test.data.table.R:540 test.data.table.R:552
msgid "Observed: <<%s>>"
msgstr "Observado: <<%s>>"

#: test.data.table.R:542
msgid "Expected (raw): <<%s>>"
msgstr "Esperado (bruto): <<%s>>"

#: test.data.table.R:543 test.data.table.R:555
msgid "Observed (raw): <<%s>>"
msgstr "Observado (bruto): <<%s>>"

#: test.data.table.R:550
msgid "Test %s produced output but should not have:"
msgstr "O teste %s produziu uma saída, mas não deveria ter:"

#: test.data.table.R:551
msgid "Expected absent (case insensitive): <<%s>>"
msgstr ""
"Ausência esperada (sem distinção entre maiúsculas e minúsculas): <<%s>>"

#: test.data.table.R:554
msgid "Expected absent (raw): <<%s>>"
msgstr "Ausência esperada (bruto): <<%s>>"

#: test.data.table.R:570
msgid "Test %s ran without errors but selfrefok(%s) is FALSE"
msgstr "O teste %s foi executado sem erros, mas selfrefok(%s) é FALSE"

#: test.data.table.R:595
msgid "Test %s ran without errors but failed check that x equals y:"
msgstr ""
"O teste %s foi executado sem erros, mas falhou na verificação de x ser igual "
"a y:"

#: test.data.table.R:600
msgid "First %d of %d (type '%s'):"
msgstr "Primeiros %d de %d (tipo '%s'):"

#: test.data.table.R:605
msgid "Non-ASCII string detected, raw representation:"
msgstr "Sequência de caracteres não ASCII detectada, representação bruta:"

#: timetaken.R:3
#, c-format
msgid "Use started.at=proc.time() not Sys.time() (POSIXt and slow)"
msgstr "Use started.at=proc.time(), não Sys.time() (POSIXt and slow)"

#: transpose.R:7
#, c-format
msgid "make.names='%s' not found in names of input"
msgstr "make.names='%s' não encontrado nos nomes da entrada"

#: transpose.R:12
#, c-format
msgid "make.names=%d is out of range [1,ncol=%d]"
msgstr "make.names=%d está fora do intervalo [1, ncol=%d]"

#: transpose.R:28
#, c-format
msgid "'names' must be TRUE/FALSE or a character vector."
msgstr "'names' deve ser TRUE/FALSE ou um vetor de caracteres."

#: transpose.R:34
#, c-format
msgid "'keep' should contain integer values between %d and %d."
msgstr "'keep' deve conter valores inteiros entre %d e %d."

#: transpose.R:51
#, c-format
msgid "The argument 'type.convert' does not support empty list."
msgstr "O argumento 'type.convert' não suporta lista vazia."

#: transpose.R:57
#, c-format
msgid ""
"When the argument 'type.convert' contains an unnamed element, it is expected "
"to be the last element and should be a function. More than one unnamed "
"element is not allowed unless all elements are functions with length equal "
"to %d (the length of the transpose list or 'keep' argument if it is "
"specified)."
msgstr ""
"Quando o argumento 'type.convert' contém um elemento não nomeado, espera-se "
"que seja o último elemento e deve ser uma função. Mais de um elemento não "
"nomeado não é permitido, a menos que todos os elementos sejam funções com "
"comprimento igual a %d (o comprimento da lista de transposição ou argumento "
"'keep', se especificado)."

#: transpose.R:66
#, c-format
msgid ""
"When the argument 'type.convert' contains transpose list indices, it should "
"be a named list of non-missing integer values (with no duplicate) except the "
"last element that should be unnamed if it is a function."
msgstr ""
"Quando o argumento 'type.convert' contém índices de lista de transposição, "
"ele deve ser uma lista nomeada de valores inteiros não ausentes (sem "
"duplicatas), exceto o último elemento, que deve ser não nomeado se for uma "
"função."

#: transpose.R:68
#, c-format
msgid ""
"When the argument 'type.convert' contains transpose list indices, they "
"should be integer values contained in the argument 'keep' (if it is "
"specified) or be between %d and %d (if it is not). But '%s' is/are not "
"contained in '%s'."
msgstr ""
"Quando o argumento 'type.convert' contém índices de lista de transposição, "
"eles devem ser valores inteiros contidos no argumento 'keep' (se "
"especificado) ou estar entre %d e %d (se não especificado). Mas '%s' não "
"está(ão) contido(s) em '%s'."

#: transpose.R:74
#, c-format
msgid ""
"In the argument 'type.convert', '%s' was ignored because all elements in the "
"transpose list or elements corresponding to indices specified in the 'keep' "
"argument have already been converted."
msgstr ""
"No argumento 'type.convert', '%s' foi ignorado porque todos os elementos na "
"lista de transposição ou elementos correspondentes aos índices especificados "
"no argumento 'keep' já foram convertidos."

#: transpose.R:83
#, c-format
msgid ""
"The argument 'type.convert' should be TRUE/FALSE, a function, a list of "
"functions, or a named list of pairs 'fun=indices' with optionally one "
"unnamed element (a function) but an object of type '%s' was provided."
msgstr ""
"O argumento 'type.convert' deve ser TRUE/FALSE, uma função, uma lista de "
"funções ou uma lista nomeada de pares 'fun=indices' com opcionalmente um "
"elemento não nomeado (uma função), mas foi fornecido um objeto do tipo '%s'."

#: transpose.R:88
#, c-format
msgid "length(names) (= %d) is not equal to length(%s) (= %d)."
msgstr "length(names) (= %d) não é igual a length(%s) (= %d)."

#: uniqlist.R:11
#, c-format
msgid "l not type list"
msgstr "l não é do tipo lista"

#: utils.R:19
#, c-format
msgid "Argument 'nan' must be length 1"
msgstr "Argumento 'nan' deve ter comprimento 1"

#: utils.R:22
#, c-format
msgid "Argument 'nan' must be NA or NaN"
msgstr "Argumento 'nan' deve ser NA ou NaN"

#: utils.R:32
msgid "Internal error in"
msgstr "Erro interno in"

#: utils.R:35
msgid "Please report to the data.table issues tracker."
msgstr "Por favor, relate isso no rastreador de problemas do data.table."

#: utils.R:79 utils.R:88
#, c-format
msgid "x not boolean"
msgstr "x não é booleano"

#: utils.R:99
#, c-format
msgid ""
"Some columns are type 'integer64' but package bit64 is not installed. Those "
"columns will print as strange looking floating point data. There is no need "
"to reload the data. Simply install.packages('bit64') to obtain the integer64 "
"print method and print the data again."
msgstr ""
"Algumas colunas são do tipo 'integer64', mas o pacote bit64 não está "
"instalado. Essas colunas serão exibidas como estranhos dados de ponto "
"flutuante. Não há necessidade de recarregar os dados. Simplesmente use "
"install.packages('bit64') para obter o método de impressão de integer64 e "
"imprima os dados novamente."

#: xts.R:4
#, c-format
msgid "keep.rownames must be length 1"
msgstr "keep.rownames deve ter comprimento 1"

#: xts.R:5
#, c-format
msgid "keep.rownames must not be NA"
msgstr "keep.rownames não deve ser NA"

#: xts.R:11
#, c-format
msgid ""
"Input xts object should not have '%s' column because it would result in "
"duplicate column names. Rename '%s' column in xts or use `keep.rownames` to "
"change the index column name."
msgstr ""
"O objeto xts de entrada não deve ter a coluna '%s' porque resultaria em "
"nomes de colunas duplicados. Renomeie a coluna '%s' no xts ou use "
"`keep.rownames` para alterar o nome da coluna de índice."

#: xts.R:21
#, c-format
msgid ""
"data.table must have a time based column in first position, use "
"`setcolorder` function to change the order, or see ?timeBased for supported "
"types"
msgstr ""
"data.table deve ter uma coluna baseada em tempo na primeira posição, use a "
"função `setcolorder` para alterar a ordem, ou veja ?timeBased para os tipos "
"suportados"

#: xts.R:25
#, c-format
msgid "Following columns are not numeric and will be omitted: %s"
msgstr "As seguintes colunas não são numéricas e serão omitidas: %s"

#: bmerge.R:219
msgid "  Found %d non-equi group ...\n"
msgid_plural "  Found %d non-equi groups ...\n"
msgstr[0] "  Encontrado %d grupo por desigualdade ...\n"
msgstr[1] "  Encontrado %d grupos por desigualdade ...\n"

#: data.table.R:745
msgid "column not removed because not found: %s"
msgid_plural "columns not removed because not found: %s"
msgstr[0] "coluna não removida por não ter sido encontrada: %s"
msgstr[1] "colunas não removidas por não terem sido encontradas: %s"

#: data.table.R:760
msgid "column not found: %s"
msgid_plural "columns not found: %s"
msgstr[0] "coluna não encontrada: %s"
msgstr[1] "colunas não encontradas: %s"

#: data.table.R:928
msgid ""
"The item in the 'by' or 'keyby' list is length %s. Each must be length %d; "
"the same length as there are rows in x (after subsetting if i is provided)."
msgid_plural ""
"The items in the 'by' or 'keyby' list have lengths %s. Each must be length "
"%d; the same length as there are rows in x (after subsetting if i is "
"provided)."
msgstr[0] ""
"O item na lista 'by' ou 'keyby' tem comprimento %s. Cada um deve ter "
"comprimento %d; o mesmo comprimento que há linhas em x (após obter "
"subconjuntos se i for fornecido)."
msgstr[1] ""
"Os itens na lista 'by' ou 'keyby' têm comprimento(s) %s. Cada um deve ter "
"comprimento %d; o mesmo comprimento que há linhas em x (após obter "
"subconjuntos se i for fornecido)."

#: fmelt.R:27
msgid "Pattern not found: [%s]"
msgid_plural "Patterns not found: [%s]"
msgstr[0] "Padrão não encontrado: [%s]"
msgstr[1] "Padrões não encontrados: [%s]"

#: fread.R:354
msgid "stringsAsFactors=%s converted %d column: %s\n"
msgid_plural "stringsAsFactors=%s converted %d columns: %s\n"
msgstr[0] "stringsAsFactors=%s converteu %d coluna: %s\n"
msgstr[1] "stringsAsFactors=%s converteu %d colunas: %s\n"

#: merge.R:131
msgid ""
"merge.data.table() received %d unnamed argument in '...' which will be "
"ignored."
msgid_plural ""
"merge.data.table() received %d unnamed arguments in '...' which will be "
"ignored."
msgstr[0] ""
"merge.data.table() recebeu %d argumento sem nome em '...' que será ignorado."
msgstr[1] ""
"merge.data.table() recebeu %d argumentos sem nome em '...' que será ignorado."

#: merge.R:138
msgid ""
"merge.data.table() received %d unknown keyword argument which will be "
"ignored: %s"
msgid_plural ""
"merge.data.table() received %d unknown keyword arguments which will be "
"ignored: %s"
msgstr[0] ""
"merge.data.table() recebeu %d argumento de palavra-chave desconhecido que "
"será ignorado: %s"
msgstr[1] ""
"merge.data.table() recebeu %d argumentos de palavra-chave desconhecidos que "
"serão ignorados: %s"

#: merge.R:144
msgid "%d unnamed argument in '...'"
msgid_plural "%d unnamed arguments in '...'"
msgstr[0] "%d argumento sem nome  em '...'"
msgstr[1] "%d argumentos sem nome em '...'"

#: merge.R:145
msgid "%d unknown keyword argument"
msgid_plural "%d unknown keyword arguments"
msgstr[0] "%d argumento de palavra-chave desconhecido"
msgstr[1] "%d argumentos de palavra-chave desconhecidos"

#: print.data.table.R:51
msgid "Index: %s\n"
msgid_plural "Indices: %s\n"
msgstr[0] "Índice: %s\n"
msgstr[1] "Índices: %s\n"

#: print.data.table.R:290
msgid "%d variable not shown: %s\n"
msgid_plural "%d variables not shown: %s\n"
msgstr[0] "%d variável não mostrada: %s\n"
msgstr[1] "%d variáveis não mostradas: %s\n"

#: setops.R:46
msgid "unsupported column type found in x or y: %s"
msgid_plural "unsupported column types found in x or y: %s"
msgstr[0] "tipo de coluna não suportado encontrado em x ou y: %s"
msgstr[1] "tipos de coluna não suportados encontrados em x ou y: %s"

#: test.data.table.R:288
msgid "%d error out of %d. Search %s for test number %s. Duration: %s."
msgid_plural ""
"%d errors out of %d. Search %s for test numbers %s. Duration: %s."
msgstr[0] "%d erro de %d. Pesquisar %s por número de teste %s. Duração: %s."
msgstr[1] "%d erros de %d. Pesquisar %s por números de teste %s. Duração: %s."

#: test.data.table.R:298
msgid "Caught %d warning outside the test() calls:\n"
msgid_plural "Caught %d warnings outside the test() calls:\n"
msgstr[0] "Capturado %d aviso fora das chamadas de test():\n"
msgstr[1] "Capturados %d avisos fora das chamadas de test():\n"

#: utils.R:43
msgid ""
"%s has duplicated column name %s. Please remove or rename the duplicate and "
"try again."
msgid_plural ""
"%s has duplicated column names %s. Please remove or rename the duplicates "
"and try again."
msgstr[0] ""
"%s tem nome de coluna duplicado: %s. Por favor, remova ou renomeie a "
"duplicata e tente novamente."
msgstr[1] ""
"%s tem nomes de coluna duplicados: %s. Por favor, remova ou renomeie as "
"duplicatas e tente novamente."
