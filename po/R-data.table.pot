msgid ""
msgstr ""
"Project-Id-Version: data.table 1.17.99\n"
"POT-Creation-Date: 2025-12-23 12:03-0700\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=INTEGER; plural=EXPRESSION;\n"

#: AllS4.R:2
#, c-format
msgid "data.table package loaded. When developing don't load package"
msgstr ""

#: IDateTime.R:108
#, c-format
msgid "binary + is not defined for \"IDate\" objects"
msgstr ""

#: IDateTime.R:115
#, c-format
msgid "can only subtract from \"IDate\" objects"
msgstr ""

#: IDateTime.R:120
#, c-format
msgid "unary - is not defined for \"IDate\" objects"
msgstr ""

#: IDateTime.R:316
#, c-format
msgid "Valid options for ms are 'truncate', 'nearest', and 'ceil'."
msgstr ""

#: as.data.table.R:89
#, c-format
msgid ""
"as.data.table.array method should only be called for arrays with 3+ "
"dimensions; use the matrix method for 2-dimensional arrays"
msgstr ""

#: as.data.table.R:91
#, c-format
msgid ""
"Argument 'value.name' must be scalar character, non-NA and at least one "
"character"
msgstr ""

#: as.data.table.R:93
#, c-format
msgid "Argument 'sorted' must be scalar logical and non-NA"
msgstr ""

#: as.data.table.R:95
#, c-format
msgid "Argument 'na.rm' must be scalar logical and non-NA"
msgstr ""

#: as.data.table.R:97
#, c-format
msgid "Please provide either 'key' or 'sorted', but not both."
msgstr ""

#: as.data.table.R:112
#, c-format
msgid ""
"Argument 'value.name' should not overlap with column names in result: %s"
msgstr ""

#: as.data.table.R:162
#, c-format
msgid ""
"POSIXlt column type detected and converted to POSIXct. We do not recommend "
"use of POSIXlt at all because it uses 40 bytes to store one date."
msgstr ""

#: as.data.table.R:207
#, c-format
msgid "Item %d has %d rows but longest item has %d; recycled with remainder."
msgstr ""

#: as.data.table.R:222
#, c-format
msgid "A column may not be called .SD. That has special meaning."
msgstr ""

#: as.data.table.R:248
#, c-format
msgid "class must be length 1"
msgstr ""

#: between.R:3
#, c-format
msgid "between has been passed an argument x of type logical"
msgstr ""

#: between.R:13 between.R:15
#, c-format
msgid ""
"The 'x' argument of the 'between' function is POSIXct while '%s' was not, "
"coercion to POSIXct failed with: %s"
msgstr ""

#: between.R:24
#, c-format
msgid ""
"'between' lower= and upper= are both POSIXct but have different tzone "
"attributes: %s. Please align their time zones."
msgstr ""

#: between.R:27
#, c-format
msgid ""
"'between' arguments are all POSIXct but have mismatched tzone attributes: "
"%s. The UTC times will be compared."
msgstr ""

#: between.R:32
#, c-format
msgid "trying to use integer64 class when 'bit64' package is not installed"
msgstr ""

#: between.R:43
msgid ""
"optimised between not available for this data type, fallback to slow R "
"routine"
msgstr ""

#: between.R:44
#, c-format
msgid ""
"Not yet implemented NAbounds=TRUE for this non-numeric and non-character type"
msgstr ""

#: between.R:45
#, c-format
msgid "Some lower>upper for this non-numeric and non-character type"
msgstr ""

#: between.R:59
#, c-format
msgid "Perhaps you meant %s?"
msgstr ""

#: between.R:60
#, c-format
msgid ""
"RHS has length() %d; expecting length 2. %sThe first element should be the "
"lower bound(s); the second element should be the upper bound(s)."
msgstr ""

#: between.R:73
msgid "forderv(query) took ..."
msgstr ""

#: between.R:86
msgid "Generating final logical vector ..."
msgstr ""

#: between.R:88 bmerge.R:205 bmerge.R:209 bmerge.R:216 data.table.R:516
msgid "done in %s"
msgstr ""

#: bmerge.R:21
msgid "Coercing %s column %s%s to type %s to match type of %s%s."
msgstr ""

#: bmerge.R:34
#, c-format
msgid ""
"Attempting roll join on factor column when joining x.%s to i.%s. Only "
"integer, double or character columns may be roll joined."
msgstr ""

#: bmerge.R:72 bmerge.R:73
#, c-format
msgid "%s is type %s which is not supported by data.table join"
msgstr ""

#: bmerge.R:77
msgid "Matching %s factor levels to %s factor levels."
msgstr ""

#: bmerge.R:86
msgid "Matching character column %s to factor levels in %s."
msgstr ""

#: bmerge.R:93
#, c-format
msgid ""
"Incompatible join types: %s (%s) and %s (%s). Factor columns must join to "
"factor or character columns."
msgstr ""

#: bmerge.R:96
msgid "%s has same type (%s) as %s. No coercion needed."
msgstr ""

#: bmerge.R:102 bmerge.R:106
msgid "(all-NA)"
msgstr ""

#: bmerge.R:109
#, c-format
msgid "Incompatible join types: %s (%s) and %s (%s)"
msgstr ""

#: bmerge.R:115
msgid "(which has integer64 representation, e.g. no fractions)"
msgstr ""

#: bmerge.R:117
#, c-format
msgid ""
"Incompatible join types: %s is type integer64 but %s is type double and "
"cannot be coerced to integer64 (e.g. has fractions)"
msgstr ""

#: bmerge.R:137
msgid "(which contains no fractions)"
msgstr ""

#: bmerge.R:149
msgid "(which contains fractions)"
msgstr ""

#: bmerge.R:152
msgid "(for join)"
msgstr ""

#: bmerge.R:170
msgid "on= matches existing key, using key"
msgstr ""

#: bmerge.R:175
msgid "on= matches existing index, using index"
msgstr ""

#: bmerge.R:180
msgid "Calculated ad hoc index in %s"
msgstr ""

#: bmerge.R:191
msgid "Non-equi join operators detected ..."
msgstr ""

#: bmerge.R:192
#, c-format
msgid "roll is not implemented for non-equi joins yet."
msgstr ""

#: bmerge.R:193
msgid "forder took ..."
msgstr ""

#: bmerge.R:202
msgid "Generating group lengths ..."
msgstr ""

#: bmerge.R:207
msgid "Generating non-equi group ids ..."
msgstr ""

#: bmerge.R:212
#, c-format
msgid "Column name '_nqgrp_' is reserved for non-equi joins."
msgstr ""

#: bmerge.R:213
msgid "Recomputing forder with non-equi ids ..."
msgstr ""

#: bmerge.R:222
msgid "Starting bmerge ..."
msgstr ""

#: bmerge.R:224
msgid "bmerge done in %s"
msgstr ""

#: cedta.R:77
msgid ""
"cedta decided '%s' wasn't data.table aware. Here is call stack with [[1L]] "
"applied:"
msgstr ""

#: data.table.R:55
#, c-format
msgid "key argument of data.table() must be character"
msgstr ""

#: data.table.R:123
#, c-format
msgid "Object '%s' not found. Perhaps you intended %s"
msgstr ""

#: data.table.R:125
#, c-format
msgid "Object '%s' not found amongst %s"
msgstr ""

#: data.table.R:134
#, c-format
msgid ""
"Invalid set* operation on a recursive index L[[i]] where i has length %d. "
"Chain [[ instead."
msgstr ""

#: data.table.R:139
#, c-format
msgid "Item '%s' not found in names of input list"
msgstr ""

#: data.table.R:159
#, c-format
msgid ""
"[ was called on a data.table in an environment that is not data.table-aware "
"(i.e. cedta()), but '%s' was used, implying the owner of this call really "
"intended for data.table methods to be called. See vignette('datatable-"
"importing') for details on properly importing data.table."
msgstr ""

#: data.table.R:170
#, c-format
msgid "verbose must be logical or integer"
msgstr ""

#: data.table.R:171
#, c-format
msgid "verbose must be length 1 non-NA"
msgstr ""

#: data.table.R:179
#, c-format
msgid "Ignoring by/keyby because 'j' is not supplied"
msgstr ""

#: data.table.R:193
#, c-format
msgid "When by and keyby are both provided, keyby must be TRUE or FALSE"
msgstr ""

#: data.table.R:196 data.table.R:261 data.table.R:351
msgid "Argument '%s' after substitute: %s"
msgstr ""

#: data.table.R:205
#, c-format
msgid ""
"When on= is provided but not i=, on= must be a named list or data.table|"
"frame, and a natural join (i.e. join on common names) is invoked. Ignoring "
"on= which is '%s'."
msgstr ""

#: data.table.R:218
#, c-format
msgid ""
"i and j are both missing so ignoring the other arguments. This warning will "
"be upgraded to error in future."
msgstr ""

#: data.table.R:222
#, c-format
msgid "mult argument can only be 'first', 'last', 'all' or 'error'"
msgstr ""

#: data.table.R:224
#, c-format
msgid ""
"roll must be a single TRUE, FALSE, positive/negative integer/double "
"including +Inf and -Inf or 'nearest'"
msgstr ""

#: data.table.R:226
#, c-format
msgid "roll is '%s' (type character). Only valid character value is 'nearest'."
msgstr ""

#: data.table.R:231
#, c-format
msgid "rollends must be a logical vector"
msgstr ""

#: data.table.R:232
#, c-format
msgid "rollends must be length 1 or 2"
msgstr ""

#: data.table.R:240
#, c-format
msgid ""
"nomatch= must be either NA or NULL (or 0 for backwards compatibility which "
"is the same as NULL but please use NULL)"
msgstr ""

#: data.table.R:243
#, c-format
msgid "which= must be a logical vector length 1. Either FALSE, TRUE or NA."
msgstr ""

#: data.table.R:244
#, c-format
msgid ""
"which==%s (meaning return row numbers) but j is also supplied. Either you "
"need row numbers or the result of j, but only one type of result can be "
"returned."
msgstr ""

#: data.table.R:245
#, c-format
msgid ""
"which=NA with nomatch=0|NULL would always return an empty vector. Please "
"change or remove either which or nomatch."
msgstr ""

#: data.table.R:246
#, c-format
msgid "j must be provided when with=FALSE"
msgstr ""

#: data.table.R:247
#, c-format
msgid "%s must be TRUE or FALSE"
msgstr ""

#: data.table.R:290
#, c-format
msgid ""
"The symbol .. is invalid. The .. prefix must be followed by at least one "
"character."
msgstr ""

#: data.table.R:294
#, c-format
msgid ""
"Variable '..%s' does exist in calling scope though, so please just removed "
"the .. prefix from that variable name in calling scope."
msgstr ""

#: data.table.R:298
#, c-format
msgid ""
"Variable '%s' is not found in calling scope. Looking in calling scope "
"because you used the .. prefix.%s"
msgstr ""

#: data.table.R:300
#, c-format
msgid ""
"Both '%1$s' and '..%1$s' exist in calling scope. Please remove the '..%1$s' "
"variable in calling scope for clarity."
msgstr ""

#: data.table.R:308
#, c-format
msgid ""
"Variable '%s' is not found in calling scope. Looking in calling scope "
"because you set with=FALSE. Also, please use .. symbol prefix and remove "
"with=FALSE."
msgstr ""

#: data.table.R:316
#, c-format
msgid ""
"Invalid use of `:=` inside `{}`. `:=` must be the only expression inside `{}"
"` when used in `j`. Instead of: DT[{tmp1 <- ...; tmp2 <- ...; someCol := "
"tmp1 * tmp2}], Use: DT[, someCol := {tmp1 <- ...; tmp2 <- ...; tmp1 * tmp2}]"
msgstr ""

#: data.table.R:334
#, c-format
msgid ""
":= with keyby is only possible when i is not supplied since you can't setkey "
"on a subset of rows. Either change keyby to by or remove i"
msgstr ""

#: data.table.R:336
#, c-format
msgid "nomatch isn't relevant together with :=, ignoring nomatch"
msgstr ""

#: data.table.R:392
#, c-format
msgid ""
"not-join '!' prefix is present on i but nomatch is provided. Please remove "
"nomatch."
msgstr ""

#: data.table.R:420
#, c-format
msgid ""
"Operator := detected in i, the first argument inside DT[...], but is only "
"valid in the second argument, j. Most often, this happens when forgetting "
"the first comma (e.g. DT[newvar := 5] instead of DT[ , new_var := 5]). "
"Please double-check the syntax. Run traceback(), and debugger() to get a "
"line number."
msgstr ""

#: data.table.R:430
#, c-format
msgid "'%s' is not found in calling scope and it is not a column name either"
msgstr ""

#: data.table.R:433
#, c-format
msgid ""
"'%s' is not found in calling scope, but it is a column of type %s. If you "
"wish to select rows where that column contains TRUE, or perhaps that column "
"contains row numbers of itself to select, try DT[(col)], DT[DT$col], or "
"DT[col==TRUE] is particularly clear and is optimized"
msgstr ""

#: data.table.R:436
#, c-format
msgid ""
"%s. When the first argument inside DT[...] is a single symbol (e.g. "
"DT[var]), data.table looks for var in calling scope."
msgstr ""

#: data.table.R:448
#, c-format
msgid ""
"i is invalid type (matrix). Perhaps in future a 2 column matrix could return "
"a list of elements of DT (in the spirit of A[B] in FAQ 2.14). Please report "
"to data.table issue tracker if you'd like this, or add your comments to FR "
"#657."
msgstr ""

#: data.table.R:471
#, c-format
msgid ""
"When i is a data.table (or character vector), the columns to join by must be "
"specified using the 'on=' argument (see ?data.table); by keying x (i.e., x "
"is sorted and marked as such, see ?setkey); or by using 'on = .NATURAL' to "
"indicate using the shared column names between x and i (i.e., a natural "
"join). Keyed joins might have further speed benefits on very large data due "
"to x being sorted in RAM."
msgstr ""

#: data.table.R:479
#, c-format
msgid "Attempting to do natural join but no common columns in provided tables"
msgstr ""

#: data.table.R:482
msgid "Joining but 'x' has no key, natural join using all 'x' columns"
msgstr ""

#: data.table.R:484
msgid "Joining but 'x' has no key, natural join using: %s"
msgstr ""

#: data.table.R:513
msgid "not-join called with 'by=.EACHI'; Replacing !i with i=setdiff_(x,i) ..."
msgstr ""

#: data.table.R:544
msgid "Constructing irows for '!byjoin || nqbyjoin' ..."
msgstr ""

#: data.table.R:558 mergelist.R:124
#, c-format
msgid ""
"Joining resulted in many-to-many join. Perform quality check on your data, "
"use mult!='all', or set 'datatable.join.many' option to TRUE to allow rows "
"explosion."
msgstr ""

#: data.table.R:596
msgid "Reorder irows for 'mult==\"all\" && !allGrp1' ..."
msgstr ""

#: data.table.R:608
msgid "Reordering %d rows after bmerge done in ..."
msgstr ""

#: data.table.R:625
#, c-format
msgid "logical error. i is not a data.table, but 'on' argument is provided."
msgstr ""

#: data.table.R:629
#, c-format
msgid "i has evaluated to type %s. Expecting logical, integer or double."
msgstr ""

#: data.table.R:651
#, c-format
msgid ""
"i evaluates to a logical vector length %d but there are %d rows. Recycling "
"of logical i is no longer allowed as it hides more bugs than is worth the "
"rare convenience. Explicitly use rep(...,length=.N) if you really need to "
"recycle."
msgstr ""

#: data.table.R:654
#, c-format
msgid ""
"Please use nomatch=NULL instead of nomatch=0; see news item 5 in v1.12.0 "
"(Jan 2019)"
msgstr ""

#: data.table.R:669
msgid "Inverting irows for notjoin done in ..."
msgstr ""

#: data.table.R:725
#, c-format
msgid "`:=` is only supported under with=TRUE, see ?`:=`."
msgstr ""

#: data.table.R:767
#, c-format
msgid "Item %d of j is %d which is outside the column number range [1,ncol=%d]"
msgstr ""

#: data.table.R:770
#, c-format
msgid "j mixes positives and negatives"
msgstr ""

#: data.table.R:778
#, c-format
msgid ""
"When with=FALSE, j-argument should be of type logical/character/integer "
"indicating the columns to select."
msgstr ""

#: data.table.R:792
#, c-format
msgid ""
"'by' contains .I but only the following are currently supported: by=.I, by=."
"(.I), by=c(.I), by=list(.I)"
msgstr ""

#: data.table.R:816
#, c-format
msgid "by=c(...), key(...) or names(...) must evaluate to 'character'"
msgstr ""

#: data.table.R:826
#, c-format
msgid ""
"'by' is a character vector length %d but one or more items include a comma. "
"Either pass a vector of column names (which can contain spaces, but no "
"commas), or pass a vector length 1 containing comma separated column names. "
"See ?data.table for other possibilities."
msgstr ""

#: data.table.R:833
#, c-format
msgid "At least one entry of by is empty"
msgstr ""

#: data.table.R:860
msgid "by index '%s' but that index has 0 length. Ignoring."
msgstr ""

#: data.table.R:883
msgid "i clause present and columns used in by detected, only these subset: %s"
msgstr ""

#: data.table.R:886
msgid ""
"i clause present but columns used in by not detected. Having to subset all "
"columns before evaluating 'by': '%s'"
msgstr ""

#: data.table.R:908
#, c-format
msgid ""
"'by' appears to evaluate to column names but isn't c() or key(). Use "
"by=list(...) if you can. Otherwise, by=eval%s should work. This is for "
"efficiency so data.table can detect which columns are needed."
msgstr ""

#: data.table.R:919
#, c-format
msgid ""
"'by' or 'keyby' must evaluate to a vector or a list of vectors (where 'list' "
"includes data.table and data.frame which are lists, too)"
msgstr ""

#: data.table.R:923
#, c-format
msgid ""
"Column or expression %d of 'by' or 'keyby' is type '%s' which is not "
"currently supported. If you have a compelling use case, please add it to "
"https://github.com/Rdatatable/data.table/issues/1597. As a workaround, "
"consider converting the column to a supported type, e.g. by=sapply(list_col, "
"toString), whilst taking care to maintain distinctness in the process."
msgstr ""

#: data.table.R:951
msgid ""
"by-expression '%s' is not named, and the auto-generated name '%s' clashed "
"with variable(s) in j. Therefore assigning the entire by-expression as name."
msgstr ""

#: data.table.R:985
#, c-format
msgid "Item %d of the .() or list() passed to j is missing"
msgstr ""

#: data.table.R:991
#, c-format
msgid ""
"j may not evaluate to the same number of columns for each group; if you're "
"sure this warning is in error, please put the branching logic outside of [ "
"for efficiency"
msgstr ""

#: data.table.R:993
#, c-format
msgid ""
"Different branches of j expression produced different auto-named columns: "
"%s; using the most \"last\" names. If this was intentional (e.g., you know "
"only one branch will ever be used in a given query because the branch is "
"controlled by a function argument), please (1) pull this branch out of the "
"call; (2) explicitly provide missing defaults for each branch in all cases; "
"or (3) use the same name for each branch and re-name it in a follow-up call."
msgstr ""

#: data.table.R:1063
#, c-format
msgid ""
"When .SDcols is a function, it is applied to each column; the output of this "
"function must be a non-missing boolean scalar signalling inclusion/exclusion "
"of the column. However, these conditions were not met for: %s"
msgstr ""

#: data.table.R:1069
#, c-format
msgid ".SDcols missing at the following indices: %s"
msgstr ""

#: data.table.R:1071
#, c-format
msgid ".SDcols is a logical vector of length %d but there are %d columns"
msgstr ""

#: data.table.R:1077
#, c-format
msgid ".SDcols is numeric but has both +ve and -ve indices"
msgstr ""

#: data.table.R:1079
#, c-format
msgid ".SDcols is numeric but out of bounds [1, %d] at: %s"
msgstr ""

#: data.table.R:1083
#, c-format
msgid ".SDcols should be column numbers or names"
msgstr ""

#: data.table.R:1085
#, c-format
msgid "Some items of .SDcols are not column names: %s"
msgstr ""

#: data.table.R:1098
msgid ""
"'(m)get' found in j. ansvars being set to all columns. Use .SDcols or a "
"single j=eval(macro) instead. Both will detect the columns used which is "
"important for efficiency.\n"
"Old ansvars: %s"
msgstr ""

#: data.table.R:1118
msgid "New ansvars: %s"
msgstr ""

#: data.table.R:1127
#, c-format
msgid ""
"This j doesn't use .SD but .SDcols has been supplied. Ignoring .SDcols. See ?"
"data.table."
msgstr ""

#: data.table.R:1130
msgid "Detected that j uses these columns: %s"
msgstr ""

#: data.table.R:1143
#, c-format
msgid ""
".SD is locked. Using := in .SD's j is reserved for possible future use; a "
"tortuously flexible way to modify by group. Use := in j directly to modify "
"by group by reference."
msgstr ""

#: data.table.R:1154
#, c-format
msgid "In %s(col1=val1, col2=val2, ...) form, all arguments must be named."
msgstr ""

#: data.table.R:1177
#, c-format
msgid ""
"In %s(col1=val1, col2=val2, ...) form, all arguments must be named, but the "
"last argument has no name. Did you forget a trailing comma?"
msgstr ""

#: data.table.R:1179
#, c-format
msgid ""
"In %s(col1=val1, col2=val2, ...) form, all arguments must be named, but "
"these arguments lack names: %s."
msgstr ""

#: data.table.R:1186
#, c-format
msgid ""
"LHS of := must be a symbol, or an atomic vector (column names or positions)."
msgstr ""

#: data.table.R:1191
#, c-format
msgid ""
"LHS of := appears to be column positions but are outside [1,ncol] range. New "
"columns can only be added by name."
msgstr ""

#: data.table.R:1193
#, c-format
msgid ""
"LHS of := isn't column names ('character') or positions ('integer' or "
"'numeric')"
msgstr ""

#: data.table.R:1210
msgid ""
"No rows match i. No new columns to add so not evaluating RHS of :=\n"
"Assigning to 0 row subset of %d rows"
msgstr ""

#: data.table.R:1226
#, c-format
msgid ""
"A shallow copy of this data.table was taken so that := can add or remove %d "
"columns by reference. At an earlier point, this data.table was copied by R "
"(or was created manually using structure() or similar). Avoid names<- and "
"attr<- which in R currently (and oddly) may copy the whole data.table. Use "
"set* syntax instead to avoid copying: ?set, ?setnames and ?setattr. It's "
"also not unusual for data.table-agnostic packages to produce tables affected "
"by this issue. If this message doesn't help, please report your use case to "
"the data.table issue tracker so the root cause can be fixed or this message "
"improved."
msgstr ""

#: data.table.R:1246
msgid ""
"Growing vector of column pointers from truelength %d to %d. A shallow copy "
"has been taken, see ?setalloccol. Only a potential issue if two variables "
"point to the same data (we can't yet detect that well) and if not you can "
"safely ignore this. To avoid this message you could setalloccol() first, "
"deep copy first using copy(), wrap with suppressWarnings() or increase the "
"'datatable.alloccol' option."
msgstr ""

#: data.table.R:1248
msgid ""
"Note that the shallow copy will assign to the environment from which := was "
"called. That means for example that if := was called within a function, the "
"original table may be unaffected."
msgstr ""

#: data.table.R:1326
#, c-format
msgid ""
"Variable '%s' is not found in calling scope. Looking in calling scope "
"because this symbol was prefixed with .. in the j= parameter."
msgstr ""

#: data.table.R:1399
#, c-format
msgid ""
"j (the 2nd argument inside [...]) is a single symbol but column name '%1$s' "
"is not found. If you intended to select columns using a variable in calling "
"scope, please try DT[, ..%1$s]. The .. prefix conveys one-level-up similar "
"to a file system path."
msgstr ""

#: data.table.R:1512
#, c-format
msgid ""
"The column '.N' can't be grouped because it conflicts with the special .N "
"variable. Try setnames(DT,'.N','N') first."
msgstr ""

#: data.table.R:1513
#, c-format
msgid ""
"The column '.I' can't be grouped because it conflicts with the special .I "
"variable. Try setnames(DT,'.I','I') first."
msgstr ""

#: data.table.R:1532
msgid ""
"Note: forcing units=\"secs\" on implicit difftime by group; call difftime "
"explicitly to choose custom units"
msgstr ""

#: data.table.R:1541
#, c-format
msgid "logical error. i is not a data.table, but mult='all' and 'by'=.EACHI"
msgstr ""

#: data.table.R:1568
msgid "Finding groups using forderv ..."
msgstr ""

#: data.table.R:1582 data.table.R:1614
msgid "Finding group sizes from the positions (can be avoided to save RAM) ..."
msgstr ""

#: data.table.R:1590
msgid "Getting back original order ..."
msgstr ""

#: data.table.R:1602
msgid "Finding groups using uniqlist on key ..."
msgstr ""

#: data.table.R:1606
msgid "Finding groups using uniqlist on index '%s' ..."
msgstr ""

#: data.table.R:1825
msgid "lapply optimization changed j from '%s' to '%s'"
msgstr ""

#: data.table.R:1827
msgid "lapply optimization is on, j unchanged as '%s'"
msgstr ""

#: data.table.R:1836 data.table.R:1860
msgid "GForce optimized j to '%s' (see ?GForce)"
msgstr ""

#: data.table.R:1861
msgid ""
"GForce is on, but not activated for this query; left j unchanged (see ?"
"GForce)"
msgstr ""

#: data.table.R:1880
#, c-format
msgid ""
"Unable to optimize call to mean() and could be very slow. You must name 'na."
"rm' like that otherwise if you do mean(x,TRUE) the TRUE is taken to mean "
"'trim' which is the 2nd argument of mean. 'trim' is not yet optimized."
msgstr ""

#: data.table.R:1884
msgid "Old mean optimization changed j from '%s' to '%s'"
msgstr ""

#: data.table.R:1886
msgid "Old mean optimization is on, left j unchanged."
msgstr ""

#: data.table.R:1896
msgid "All optimizations are turned off"
msgstr ""

#: data.table.R:1897
msgid "Optimization is on but left j unchanged (single plain symbol): '%s'"
msgstr ""

#: data.table.R:1926
msgid "Making each group and running j (GForce %s) ..."
msgstr ""

#: data.table.R:2022
msgid "setkey() after the := with keyby= ..."
msgstr ""

#: data.table.R:2026
#, c-format
msgid ""
"The setkey() normally performed by keyby= has been skipped (as if by= was "
"used) because := is being used together with keyby= but the keyby= contains "
"some expressions. To avoid this warning, use by= instead, or provide "
"existing column names to keyby=."
msgstr ""

#: data.table.R:2052
msgid "setkey() afterwards for keyby=.EACHI ..."
msgstr ""

#: data.table.R:2161
#, c-format
msgid "rownames and rownames.value cannot both be used at the same time"
msgstr ""

#: data.table.R:2164
#, c-format
msgid ""
"length(rownames)==%d but nrow(DT)==%d. The rownames argument specifies a "
"single column name or number. Consider rownames.value= instead."
msgstr ""

#: data.table.R:2168
#, c-format
msgid ""
"length(rownames)==0 but should be a single column name or number, or NULL"
msgstr ""

#: data.table.R:2172
#, c-format
msgid ""
"rownames is TRUE but key has multiple columns %s; taking first column x[,1] "
"as rownames"
msgstr ""

#: data.table.R:2182
#, c-format
msgid "'%s' is not a column of x"
msgstr ""

#: data.table.R:2188
#, c-format
msgid ""
"as.integer(rownames)==%d which is outside the column number range [1,ncol="
"%d]."
msgstr ""

#: data.table.R:2193
#, c-format
msgid "length(rownames.value)==%d but should be nrow(x)==%d"
msgstr ""

#: data.table.R:2289
#, c-format
msgid ""
"When i is a matrix in DT[i]<-value syntax, it doesn't make sense to provide j"
msgstr ""

#: data.table.R:2299
#, c-format
msgid "j must be an atomic vector, see ?is.atomic"
msgstr ""

#: data.table.R:2300
#, c-format
msgid "NA in j"
msgstr ""

#: data.table.R:2306
#, c-format
msgid "j must be vector of column name or positions"
msgstr ""

#: data.table.R:2307
#, c-format
msgid ""
"Attempt to assign to column position greater than ncol(x). Create the column "
"by name, instead. This logic intends to catch (most likely) user errors."
msgstr ""

#: data.table.R:2374
#, c-format
msgid ""
"data.table inherits from data.frame (from v1.5), but this data.table does "
"not. Has it been created manually (e.g. by using 'structure' rather than "
"'data.table') or saved to disk using a prior version of data.table?"
msgstr ""

#: data.table.R:2383
#, c-format
msgid "attempting to assign invalid object to dimnames of a data.table"
msgstr ""

#: data.table.R:2384
#, c-format
msgid "data.tables do not have rownames"
msgstr ""

#: data.table.R:2385 data.table.R:2769
#, c-format
msgid "Can't assign %d names to a %d-column data.table"
msgstr ""

#: data.table.R:2449
#, c-format
msgid "'subset' must evaluate to logical"
msgstr ""

#: data.table.R:2492
#, c-format
msgid "Argument 'invert' must be logical TRUE/FALSE"
msgstr ""

#: data.table.R:2538
#, c-format
msgid "group length is 0 but data nrow > 0"
msgstr ""

#: data.table.R:2540
#, c-format
msgid ""
"passing 'f' argument together with 'by' is not allowed, use 'by' when split "
"by column in data.table and 'f' when split by external factor"
msgstr ""

#: data.table.R:2548
#, c-format
msgid "Either 'by' or 'f' argument must be supplied"
msgstr ""

#: data.table.R:2550
#, c-format
msgid "Column '.ll.tech.split' is reserved for split.data.table processing"
msgstr ""

#: data.table.R:2551
#, c-format
msgid "Column '.nm.tech.split' is reserved for split.data.table processing"
msgstr ""

#: data.table.R:2552
#, c-format
msgid "Argument 'by' must refer to column names in x"
msgstr ""

#: data.table.R:2553
#, c-format
msgid ""
"Argument 'by' must refer only to atomic-type columns, but the following "
"columns are non-atomic: %s"
msgstr ""

#: data.table.R:2600
msgid "Processing split.data.table with: %s"
msgstr ""

#: data.table.R:2700
#, c-format
msgid ""
"x is not a data.table|frame. Shallow copy is a copy of the vector of column "
"pointers (only), so is only meaningful for data.table|frame"
msgstr ""

#: data.table.R:2709
#, c-format
msgid "setalloccol attempting to modify `*tmp*`"
msgstr ""

#: data.table.R:2744
#, c-format
msgid ""
"Input is a length=1 logical that points to the same address as R's global "
"value. Therefore the attribute has not been set by reference, rather on a "
"copy. You will need to assign the result back to a variable. See issue #1281."
msgstr ""

#: data.table.R:2759
#, c-format
msgid "x is not a data.table or data.frame"
msgstr ""

#: data.table.R:2761
#, c-format
msgid "x has %d columns but its names are length %d"
msgstr ""

#: data.table.R:2768
#, c-format
msgid "Passed a vector of type '%s'. Needs to be type 'character'."
msgstr ""

#: data.table.R:2781
#, c-format
msgid "'new' is not a character vector or a function"
msgstr ""

#: data.table.R:2783
#, c-format
msgid "NA in 'new' at positions %s"
msgstr ""

#: data.table.R:2784
#, c-format
msgid "Some duplicates exist in 'old': %s"
msgstr ""

#: data.table.R:2786
#, c-format
msgid "'old' is type %s but should be integer, double or character"
msgstr ""

#: data.table.R:2787
#, c-format
msgid "'old' is length %d but 'new' is length %d"
msgstr ""

#: data.table.R:2788
#, c-format
msgid "NA (or out of bounds) in 'old' at positions %s"
msgstr ""

#: data.table.R:2791
#, c-format
msgid ""
"Item %d of 'old' is '%s' which appears several times in column names. Just "
"the first will be changed. There are %d other items in 'old' that are also "
"duplicated in column names."
msgstr ""

#: data.table.R:2799
#, c-format
msgid ""
"Items of 'old' not found in column names: %s. Consider skip_absent=TRUE."
msgstr ""

#: data.table.R:2840
#, c-format
msgid "Provide either before= or after= but not both"
msgstr ""

#: data.table.R:2842
#, c-format
msgid "before=/after= accept a single column name or number, not more than one"
msgstr ""

#: data.table.R:2910
#, c-format
msgid "Input is %s but should be a plain list of items to be stacked"
msgstr ""

#: data.table.R:2914
#, c-format
msgid ""
"idcol must be a logical or character vector of length 1. If logical TRUE the "
"id column will named '.id'."
msgstr ""

#: data.table.R:2919
#, c-format
msgid "use.names=NA invalid"
msgstr ""

#: data.table.R:2921
#, c-format
msgid ""
"use.names='check' cannot be used explicitly because the value 'check' is new "
"in v1.12.2 and subject to change. It is just meant to convey default "
"behavior. See ?rbindlist."
msgstr ""

#: data.table.R:2936
#, c-format
msgid ""
"Check that is.data.table(DT) == TRUE. Otherwise, `:=` is defined for use in "
"j, once only and in particular ways. See help(\":=\", \"data.table\"). A "
"common reason for this error is allocating a new column in `j` and using `<-"
"` instead of `:=`; e.g., `DT[, new_col <- 1]` should be `DT[, new_col := "
"1]`. Another is using `:=` in a multi-statement `{...}` block; please use `:"
"=` as the only statement in `j`."
msgstr ""

#: data.table.R:2953
#, c-format
msgid ""
"setDF only accepts data.table, data.frame or list of equal length as input"
msgstr ""

#: data.table.R:2954
#, c-format
msgid "rownames contains duplicates"
msgstr ""

#: data.table.R:2961 data.table.R:2972 data.table.R:2995
#, c-format
msgid "rownames incorrect length; expected %d names, got %d"
msgstr ""

#: data.table.R:2980
#, c-format
msgid "All elements in argument 'x' to 'setDF' must be of same length"
msgstr ""

#: data.table.R:3009
#, c-format
msgid "Cannot find symbol %s"
msgstr ""

#: data.table.R:3016
#, c-format
msgid ""
"Cannot convert '%1$s' to data.table by reference because binding is locked. "
"It is very likely that '%1$s' resides within a package (or an environment) "
"that is locked to prevent modifying its variable bindings. Try copying the "
"object to your current environment, ex: var <- copy(var) and then using "
"setDT again."
msgstr ""

#: data.table.R:3070
#, c-format
msgid ""
"Argument 'x' to 'setDT' should be a 'list', 'data.frame' or 'data.table'"
msgstr ""

#: data.table.R:3103 data.table.R:3128
#, c-format
msgid "'prefix' must be NULL or a character vector of length 1."
msgstr ""

#: data.table.R:3106 data.table.R:3131
#, c-format
msgid "x is a single vector, non-NULL 'cols' doesn't make sense."
msgstr ""

#: data.table.R:3110 data.table.R:3135
#, c-format
msgid "x is a list, 'cols' cannot be 0-length."
msgstr ""

#: data.table.R:3290
#, c-format
msgid ""
"It looks like you re-used `:=` in argument %d a functional assignment "
"call -- use `=` instead: %s(col1=val1, col2=val2, ...)"
msgstr ""

#: data.table.R:3356
#, c-format
msgid ""
"RHS of %s is length %d which is not 1 or nrow (%d). For robustness, no "
"recycling is allowed (other than of length 1 RHS). Consider %%in%% instead."
msgstr ""

#: data.table.R:3388
msgid ""
"Subsetting optimization disabled because the cross-product of RHS values "
"exceeds 1e4, causing memory problems."
msgstr ""

#: data.table.R:3406
msgid "Optimized subsetting with key %s"
msgstr ""

#: data.table.R:3425 data.table.R:3437
msgid "Optimized subsetting with index '%s'"
msgstr ""

#: data.table.R:3432
msgid "Creating new index '%s'"
msgstr ""

#: data.table.R:3433
msgid "Creating index %s done in ..."
msgstr ""

#: data.table.R:3466
#, c-format
msgid ""
"'on' argument should be a named atomic vector of column names indicating "
"which columns in 'i' should be joined with which columns in 'x'."
msgstr ""

#: data.table.R:3507
#, c-format
msgid ""
"Found more than one operator in one 'on' statement: %s. Please specify a "
"single operator."
msgstr ""

#: data.table.R:3530
#, c-format
msgid ""
"'on' contains no column name: %s. Each 'on' clause must contain one or two "
"column names."
msgstr ""

#: data.table.R:3532
#, c-format
msgid ""
"'on' contains more than 2 column names: %s. Each 'on' clause must contain "
"one or two column names."
msgstr ""

#: data.table.R:3537
#, c-format
msgid "Invalid join operators %s. Only allowed operators are %s."
msgstr ""

#: devel.R:16
#, c-format
msgid "There is no package %s in provided repository."
msgstr ""

#: devel.R:30
msgid ""
"No revision information found in DESCRIPTION file for %s package. Make sure "
"that '%s' is correct field in PACKAGES file in your package repository '%s'. "
"Otherwise package will be re-installed every time, proceeding to "
"installation."
msgstr ""

#: devel.R:39
msgid "R %s package has been updated to %s (%s)"
msgstr ""

#: devel.R:41
msgid "R %s package is up-to-date at %s (%s)"
msgstr ""

#: devel.R:53
msgid ""
"Git revision is not available. Most likely data.table was installed from "
"CRAN or local archive.\n"
"Git revision is available when installing from our repositories 'https://"
"Rdatatable.gitlab.io/data.table' and 'https://Rdatatable.github.io/data."
"table'."
msgstr ""

#: duplicated.R:7
#, c-format
msgid "'fromLast' must be TRUE or FALSE"
msgstr ""

#: duplicated.R:105
#, c-format
msgid "x must be an atomic vector or a data.frame/data.table"
msgstr ""

#: fcast.R:7
#, c-format
msgid "Using '%s' as value column. Use 'value.var' to override"
msgstr ""

#: fcast.R:17
#, c-format
msgid ""
"The %1$s generic in data.table has been passed a %2$s, but data.table::%1$s "
"currently only has a method for data.tables. Please confirm your input is a "
"data.table, with setDT(%3$s) or as.data.table(%3$s). If you intend to use a "
"method from reshape2, try installing that package first, but do note that "
"reshape2 is superseded and is no longer actively developed."
msgstr ""

#: fcast.R:24
#, c-format
msgid ""
"Invalid formula. Cast formula should be of the form LHS ~ RHS, for e.g., a + "
"b ~ c."
msgstr ""

#: fcast.R:31
#, c-format
msgid "data.table to cast must have unique column names"
msgstr ""

#: fcast.R:76
#, c-format
msgid "value.var values %s are not found in 'data'."
msgstr ""

#: fcast.R:92
#, c-format
msgid ""
"When 'fun.aggregate' and 'value.var' are both lists, 'value.var' must be "
"either of length =1 or =length(fun.aggregate)."
msgstr ""

#: fcast.R:125
#, c-format
msgid "'data' must be a data.table."
msgstr ""

#: fcast.R:127
#, c-format
msgid "'drop' must be logical TRUE/FALSE"
msgstr ""

#: fcast.R:129
#, c-format
msgid "Argument 'value.var.in.dots' should be logical TRUE/FALSE"
msgstr ""

#: fcast.R:131
#, c-format
msgid ""
"Arguments 'value.var.in.LHSdots', 'value.var.in.RHSdots' should be logical "
"TRUE/FALSE"
msgstr ""

#: fcast.R:148
#, c-format
msgid "Column [%s] not found or of unknown type."
msgstr ""

#: fcast.R:163
#, c-format
msgid "Columns specified in formula can not be of type list"
msgstr ""

#: fcast.R:178
#, c-format
msgid ""
"'fun.aggregate' is NULL, but found duplicate row/column combinations, so "
"defaulting to length(). That is, the variables %s used in 'formula' do not "
"uniquely identify rows in the input 'data'. In such cases, 'fun.aggregate' "
"is used to derive a single representative value for each combination in the "
"output data.table, for example by summing or averaging (fun.aggregate=sum or "
"fun.aggregate=mean, respectively). Check the resulting table for values "
"larger than 1 to see which combinations were not unique. See ?dcast.data."
"table for more details."
msgstr ""

#: fcast.R:188
msgid ""
"Aggregating functions should take a vector as input and return a single "
"value (length=1), but they do not, so the result is undefined. Please fix by "
"modifying your function so that a single value is always returned."
msgstr ""

#: fmelt.R:12
#, c-format
msgid ""
"The %1$s generic in data.table has been passed a %2$s and will attempt to "
"redirect to the relevant reshape2 method; please note that reshape2 is "
"superseded and is no longer actively developed, and this redirection is now "
"deprecated. To continue using melt methods from reshape2 while both packages "
"are attached, e.g. melt.list, you can prepend the namespace, i.e. reshape2::"
"%1$s(%3$s). In the next version, this warning will become an error."
msgstr ""

#: fmelt.R:19 fmelt.R:73
#, c-format
msgid "cols must be a character vector of column names"
msgstr ""

#: fmelt.R:24
#, c-format
msgid "Input patterns must be of type character."
msgstr ""

#: fmelt.R:42
#, c-format
msgid ""
"each ... argument to measure must be either a symbol without argument name, "
"or a function with argument name, problems: %s"
msgstr ""

#: fmelt.R:50
#, c-format
msgid ""
"group names specified in ... conflict with measure argument names; please "
"fix by changing group names: %s"
msgstr ""

#: fmelt.R:56
#, c-format
msgid ""
"each ... argument to measure must be a function with at least one argument, "
"problem: %s"
msgstr ""

#: fmelt.R:67
#, c-format
msgid ""
"both sep and pattern arguments used; must use either sep or pattern (not "
"both)"
msgstr ""

#: fmelt.R:70
#, c-format
msgid "multiple.keyword must be a character string with nchar>0"
msgstr ""

#: fmelt.R:81
#, c-format
msgid "in measurev, elements of fun.list must be named, problems: %s"
msgstr ""

#: fmelt.R:84
#, c-format
msgid "elements of fun.list should be uniquely named, problems: %s"
msgstr ""

#: fmelt.R:89
#, c-format
msgid "pattern must be character string"
msgstr ""

#: fmelt.R:94
#, c-format
msgid ""
"pattern did not match any cols, so nothing would be melted; fix by changing "
"pattern"
msgstr ""

#: fmelt.R:98
#, c-format
msgid ""
"pattern must contain at least one capture group (parenthesized sub-pattern)"
msgstr ""

#: fmelt.R:101
#, c-format
msgid ""
"number of elements of fun.list (%d) must be the same as the number of "
"capture groups in pattern (%d)"
msgstr ""

#: fmelt.R:109
#, c-format
msgid "sep must be character string"
msgstr ""

#: fmelt.R:115
#, c-format
msgid ""
"each column name results in only one item after splitting using sep, which "
"means that all columns would be melted; to fix please either specify melt on "
"all columns directly without using measure, or use a different sep/pattern "
"specification"
msgstr ""

#: fmelt.R:118
#, c-format
msgid ""
"number of elements of fun.list (%d) must be the same as the max number of "
"items after splitting column names (%d)"
msgstr ""

#: fmelt.R:125
#, c-format
msgid "measured columns should be uniquely named, problems: %s"
msgstr ""

#: fmelt.R:129
#, c-format
msgid ""
"number of unique column IDs =%d is less than number of melted columns =%d; "
"fix by changing pattern/sep"
msgstr ""

#: fmelt.R:139
#, c-format
msgid ""
"in the measurev fun.list, each non-NULL element must be a function with at "
"least one argument, problem: %s"
msgstr ""

#: fmelt.R:143
#, c-format
msgid ""
"each conversion function must return an atomic vector with same length as "
"its first argument, problem: %s"
msgstr ""

#: fmelt.R:146
#, c-format
msgid "%s conversion function returned vector of all NA"
msgstr ""

#: fmelt.R:152
#, c-format
msgid ""
"number of unique groups after applying type conversion functions less than "
"number of groups, change type conversion"
msgstr ""

#: fmelt.R:157
#, c-format
msgid ""
"%s column class=%s after applying conversion function, but must be character"
msgstr ""

#: fmelt.R:161
#, c-format
msgid "%s is the only group; fix by creating at least one more group"
msgstr ""

#: fmelt.R:184
#, c-format
msgid "'data' must be a data.table"
msgstr ""

#: fmelt.R:207
#, c-format
msgid ""
"'value.name' provided in both 'measure.vars' and 'value.name argument'; "
"value provided in 'measure.vars' is given precedence."
msgstr ""

#: fmelt.R:210
#, c-format
msgid "Please provide a name to each element of 'measure.vars'."
msgstr ""

#: fmelt.R:221
msgid ""
"Duplicate column names found in molten data.table. Setting unique names "
"using 'make.names'"
msgstr ""

#: foverlaps.R:3
#, c-format
msgid ""
"y and x must both be data.tables. Use `setDT()` to convert list/data.frames "
"to data.tables by reference or as.data.table() to convert to data.tables by "
"copying."
msgstr ""

#: foverlaps.R:9
#, c-format
msgid "maxgap must be a non-negative integer value of length 1"
msgstr ""

#: foverlaps.R:11
#, c-format
msgid "minoverlap must be a positive integer value of length 1"
msgstr ""

#: foverlaps.R:13
#, c-format
msgid "which must be a logical vector of length 1. Either TRUE/FALSE"
msgstr ""

#: foverlaps.R:15
#, c-format
msgid "nomatch must either be NA or NULL"
msgstr ""

#: foverlaps.R:20
#, c-format
msgid "maxgap and minoverlap arguments are not yet implemented."
msgstr ""

#: foverlaps.R:22
#, c-format
msgid ""
"y must be keyed (i.e., sorted, and, marked as sorted). Call setkey(y, ...) "
"first, see ?setkey. Also check the examples in ?foverlaps."
msgstr ""

#: foverlaps.R:24
#, c-format
msgid ""
"'by.x' and 'by.y' should contain at least two column names (or numbers) "
"each - corresponding to 'start' and 'end' points of intervals. Please see ?"
"foverlaps and examples for more info."
msgstr ""

#: foverlaps.R:27
#, c-format
msgid ""
"Invalid numeric value for 'by.x'; it should be a vector with values 1 <= by."
"x <= length(x)"
msgstr ""

#: foverlaps.R:32
#, c-format
msgid ""
"Invalid numeric value for 'by.y'; it should be a vector with values 1 <= by."
"y <= length(y)"
msgstr ""

#: foverlaps.R:36
#, c-format
msgid "A non-empty vector of column names or numbers is required for by.x"
msgstr ""

#: foverlaps.R:38
#, c-format
msgid "A non-empty vector of column names or numbers is required for by.y"
msgstr ""

#: foverlaps.R:40
#, c-format
msgid ""
"The first %d columns of y's key must be identical to the columns specified "
"in by.y."
msgstr ""

#: foverlaps.R:42
#, c-format
msgid "Elements listed in 'by.x' must be valid names in data.table x"
msgstr ""

#: foverlaps.R:44
#, c-format
msgid ""
"Duplicate columns are not allowed in overlap joins. This may change in the "
"future."
msgstr ""

#: foverlaps.R:46
#, c-format
msgid ""
"length(by.x) != length(by.y). Columns specified in by.x should correspond to "
"columns specified in by.y and should be of same lengths."
msgstr ""

#: foverlaps.R:57
#, c-format
msgid ""
"The last two columns in by.x should correspond to the 'start' and 'end' "
"intervals in data.table x and must be integer/numeric type."
msgstr ""

#: foverlaps.R:61 foverlaps.R:63 foverlaps.R:70 foverlaps.R:72
#, c-format
msgid ""
"NA values in data.table %s '%s' column: '%s'. All rows with NA values in the "
"range columns must be removed for foverlaps() to work."
msgstr ""

#: foverlaps.R:64
#, c-format
msgid ""
"All entries in column '%s' should be <= corresponding entries in column '%s' "
"in data.table x."
msgstr ""

#: foverlaps.R:67
#, c-format
msgid ""
"The last two columns in by.y should correspond to the 'start' and 'end' "
"intervals in data.table y and must be integer/numeric type."
msgstr ""

#: foverlaps.R:73
#, c-format
msgid ""
"All entries in column '%s' should be <= corresponding entries in column '%s' "
"in data.table y."
msgstr ""

#: foverlaps.R:78
#, c-format
msgid ""
"Some interval cols are of type POSIXct while others are not. Please ensure "
"all interval cols are (or are not) of POSIXct type"
msgstr ""

#: foverlaps.R:84
#, c-format
msgid ""
"POSIXct interval cols have mixed timezones. Overlaps are performed on the "
"internal numerical representation of POSIXct objects (always in UTC epoch "
"time), therefore printed values may give the impression that values don't "
"overlap but their internal representations do Please ensure that POSIXct "
"type interval cols have identical 'tzone' attributes to avoid confusion."
msgstr ""

#: foverlaps.R:132
msgid "unique() + setkey() operations done in ..."
msgstr ""

#: foverlaps.R:158
msgid "binary search(es) done in ..."
msgstr ""

#: foverlaps.R:165 foverlaps.R:167 foverlaps.R:171
#, c-format
msgid "Not yet implemented"
msgstr ""

#: foverlaps.R:170
#, c-format
msgid "maxgap > minoverlap. maxgap will have no effect here."
msgstr ""

#: frank.R:3
#, c-format
msgid "length(na.last) = 0"
msgstr ""

#: frank.R:5
#, c-format
msgid "length(na.last) > 1, only the first element will be used"
msgstr ""

#: frank.R:17
#, c-format
msgid "x is a single vector, non-NULL 'cols' doesn't make sense"
msgstr ""

#: frank.R:23
#, c-format
msgid "x is a list, 'cols' can not be 0-length"
msgstr ""

#: frank.R:31
#, c-format
msgid ""
"Input column '..na_prefix..' conflicts with data.table internal usage; "
"please rename"
msgstr ""

#: frank.R:46
#, c-format
msgid ""
"Input column '..stats_runif..' conflicts with data.table internal usage; "
"please rename"
msgstr ""

#: fread.R:12
#, c-format
msgid "Used more than one of the arguments input=, file=, text= and cmd=."
msgstr ""

#: fread.R:25
#, c-format
msgid "Argument 'encoding' must be 'unknown', 'UTF-8' or 'Latin-1'."
msgstr ""

#: fread.R:34
#, c-format
msgid "comment.char= must be a single non-NA character."
msgstr ""

#: fread.R:47
#, c-format
msgid "'text=' is type %s but must be character."
msgstr ""

#: fread.R:60
#, c-format
msgid ""
"input= must be a single character string containing a file name, a system "
"command containing at least one space, a URL starting 'http[s]://', "
"'ftp[s]://' or 'file://', or, the input data itself containing at least one "
"\\n or \\r"
msgstr ""

#: fread.R:65
#, c-format
msgid ""
"input= contains no \\n or \\r, but starts with a space. Please remove the "
"leading space, or use text=, file= or cmd="
msgstr ""

#: fread.R:69
#, c-format
msgid ""
"Taking input= as a system command because it contains a space ('%s'). If "
"it's a filename please remove the space, or use file= explicitly. A variable "
"is being passed to input= and when this is taken as a system command there "
"is a security concern if you are creating an app, the app could have a "
"malicious user, and the app is not running in a secure environment; e.g. the "
"app is running as root. Please read item 5 in the NEWS file for v1.11.6 for "
"more information and for the option to suppress this message."
msgstr ""

#: fread.R:80
#, c-format
msgid ""
"External command failed with exit code %d. This can happen when the disk is "
"full in the temporary directory ('%s'). See ?fread for the tmpdir argument."
msgstr ""

#: fread.R:86
#, c-format
msgid ""
"file= must be a single character string containing a filename, or URL "
"starting 'http[s]://', 'ftp[s]://' or 'file://'"
msgstr ""

#: fread.R:99
#, c-format
msgid "File '%s' does not exist or is non-readable. getwd()=='%s'"
msgstr ""

#: fread.R:100
#, c-format
msgid "File '%s' is a directory. Not yet implemented."
msgstr ""

#: fread.R:102
#, c-format
msgid "File '%s' has size 0. Returning a NULL %s."
msgstr ""

#: fread.R:114
#, c-format
msgid ""
"Compressed files containing more than 1 file are currently not supported."
msgstr ""

#: fread.R:124
#, c-format
msgid ""
"To read %s files directly, fread() requires 'R.utils' package which cannot "
"be found. Please install 'R.utils' using 'install.packages('R.utils')'."
msgstr ""

#: fread.R:127
#, c-format
msgid ""
"Reading compressed files in fread requires R.utils version 2.13.0 or higher. "
"Please upgrade R.utils."
msgstr ""

#: fread.R:134
#, c-format
msgid ""
"R.utils::decompressFile failed to decompress file '%s':\n"
"  %s\n"
". This can happen when the disk is full in the temporary directory ('%s'). "
"See ?fread for the tmpdir argument."
msgstr ""

#: fread.R:143
#, c-format
msgid ""
"colClasses is type 'logical' which is ok if all NA but it has some TRUE or "
"FALSE values in it which is not allowed. Please consider the drop= or "
"select= argument instead. See ?fread."
msgstr ""

#: fread.R:147
#, c-format
msgid "colClasses is not type list or character vector"
msgstr ""

#: fread.R:152
#, c-format
msgid ""
"colClasses=\"NULL\" (quoted) is interpreted as colClasses=NULL (the default) "
"as opposed to dropping every column."
msgstr ""

#: fread.R:164
#, c-format
msgid "na.strings[%d]==\"%s\" consists only of whitespace, ignoring"
msgstr ""

#: fread.R:167
#, c-format
msgid ""
"%s. Since strip.white=TRUE (default), use na.strings=\"\" to specify that "
"any number of spaces in a string column should be read as <NA>."
msgstr ""

#: fread.R:169
#, c-format
msgid ""
"%s. strip.white==TRUE (default) and \"\" is present in na.strings, so any "
"number of spaces in string columns will already be read as <NA>."
msgstr ""

#: fread.R:173
#, c-format
msgid ""
"%s. But strip.white=FALSE. Use strip.white=TRUE (default) together with na."
"strings=\"\" to turn any number of spaces in string columns into <NA>"
msgstr ""

#: fread.R:180
#, c-format
msgid ""
"'data.table' relies on the package 'yaml' to parse the file header; please "
"add this to your library with install.packages('yaml') and try again."
msgstr ""

#: fread.R:184
#, c-format
msgid ""
"Combining a search string as 'skip' and reading a YAML header may not work "
"as expected -- currently, reading will proceed to search for 'skip' from the "
"beginning of the file, NOT from the end of the metadata; please file an "
"issue on GitHub if you'd like to see more intuitive behavior supported."
msgstr ""

#: fread.R:194
#, c-format
msgid ""
"Encountered <%s%s> at the first unskipped line (%d), which does not "
"constitute the start to a valid YAML header (expecting something matching "
"regex \"%s\"); please check your input and try again."
msgstr ""

#: fread.R:206
#, c-format
msgid ""
"Reached the end of the file before finding a completion to the YAML header. "
"A valid YAML header is bookended by lines matching the regex \"%s\". Please "
"double check the input file is a valid csvy."
msgstr ""

#: fread.R:217
msgid ""
"Processed %d lines of YAML metadata with the following top-level fields: %s"
msgstr ""

#: fread.R:220
#, c-format
msgid "User-supplied 'header' will override that found in metadata."
msgstr ""

#: fread.R:238
#, c-format
msgid ""
"User-supplied column names in 'col.names' will override those found in YAML "
"metadata."
msgstr ""

#: fread.R:247
#, c-format
msgid ""
"colClasses dictated by user input and those read from YAML header are in "
"conflict (specifically, for column(s) [%s]); the proceeding assumes the user "
"input was an intentional override and will ignore the type(s) implied by the "
"YAML header; please exclude the column(s) from colClasses if this was "
"unintentional."
msgstr ""

#: fread.R:268
#, c-format
msgid "User-supplied 'sep' will override that found in metadata."
msgstr ""

#: fread.R:273
#, c-format
msgid "User-supplied 'quote' will override that found in metadata."
msgstr ""

#: fread.R:278
#, c-format
msgid "User-supplied 'dec' will override that found in metadata."
msgstr ""

#: fread.R:282
#, c-format
msgid "User-supplied 'na.strings' will override that found in metadata."
msgstr ""

#: fread.R:334
msgid ""
"Column '%s' was requested to be '%s' but fread encountered the following "
"warning:\n"
"\t%s\n"
"so the column has been left as type '%s'"
msgstr ""

#: fread.R:336
msgid ""
"Column '%s' was requested to be '%s' but fread encountered the following "
"error:\n"
"\t%s\n"
"so the column has been left as type '%s'"
msgstr ""

#: fread.R:363
#, c-format
msgid ""
"key argument of data.table() must be a character vector naming columns (NB: "
"col.names are applied before this)"
msgstr ""

#: fread.R:371
#, c-format
msgid ""
"index argument of data.table() must be a character vector naming columns "
"(NB: col.names are applied before this)"
msgstr ""

#: froll.R:30
#, c-format
msgid "n must be non 0 length"
msgstr ""

#: froll.R:32
#, c-format
msgid "'partial' cannot be used together with align='center'"
msgstr ""

#: froll.R:35
#, c-format
msgid "'partial' does not support variable length of columns in x"
msgstr ""

#: froll.R:37
#, c-format
msgid "'partial' does not support variable nrow of data.tables in x"
msgstr ""

#: froll.R:48
#, c-format
msgid "n must be an integer, list is accepted for adaptive TRUE"
msgstr ""

#: froll.R:50 froll.R:62
#, c-format
msgid "n must be an integer vector or a list of integer vectors"
msgstr ""

#: froll.R:52
msgid ""
"partial2adaptive: froll partial=TRUE trimming n and redirecting to "
"adaptive=TRUE"
msgstr ""

#: froll.R:64
#, c-format
msgid "adaptive windows provided in n must not to have different lengths"
msgstr ""

#: froll.R:66
#, c-format
msgid ""
"length of n argument must be equal to number of observations provided in x"
msgstr ""

#: froll.R:68
#, c-format
msgid "length of vectors in x must match to length of adaptive window in n"
msgstr ""

#: froll.R:70
msgid "partial2adaptive: froll adaptive=TRUE and partial=TRUE trimming n"
msgstr ""

#: froll.R:86
#, c-format
msgid ""
"internal error: misuse of make.roll.names, n must be numeric for !adaptive"
msgstr ""

#: froll.R:92
#, c-format
msgid ""
"internal error: misuse of make.roll.names, non-null length 0 n is not "
"possible for !adaptive"
msgstr ""

#: froll.R:106
#, c-format
msgid ""
"internal error: make.roll.names call should have been escaped in frollapply "
"during 'unpack atomic input'"
msgstr ""

#: froll.R:110
#, c-format
msgid "internal error: make.roll.names generated names of wrong length"
msgstr ""

#: froll.R:118
#, c-format
msgid "'x' must be of a numeric type"
msgstr ""

#: froll.R:122 froll.R:127
#, c-format
msgid "'n' must be an integer"
msgstr ""

#: froll.R:132
#, c-format
msgid "'n' must be non 0 length"
msgstr ""

#: froll.R:134
#, c-format
msgid "'align' other than 'right' has not yet been implemented"
msgstr ""

#: froll.R:136 froll.R:138 mergelist.R:61
#, c-format
msgid "'%s' must be TRUE or FALSE"
msgstr ""

#: froll.R:157 froll.R:158
#, c-format
msgid "hasNA is deprecated, use has.nf instead"
msgstr ""

#: froll.R:183
msgid "froll: adaptive=TRUE && align='left' pre-processing for align='right'"
msgstr ""

#: froll.R:191
msgid "froll: adaptive=TRUE && align='left' post-processing from align='right'"
msgstr ""

#: frollapply.R:130
#, c-format
msgid "'x' is deprecated in frollapply, use 'X' instead"
msgstr ""

#: frollapply.R:134
#, c-format
msgid "'n' is deprecated in frollapply, use 'N' instead"
msgstr ""

#: frollapply.R:138
#, c-format
msgid "'by.column' must be TRUE or FALSE"
msgstr ""

#: frollapply.R:140
#, c-format
msgid "'adaptive' must be TRUE or FALSE"
msgstr ""

#: frollapply.R:142
#, c-format
msgid "'partial' must be TRUE or FALSE"
msgstr ""

#: frollapply.R:144
#, c-format
msgid "'give.names' must be TRUE or FALSE"
msgstr ""

#: frollapply.R:146
#, c-format
msgid "'simplify' must be TRUE or FALSE or a function"
msgstr ""

#: frollapply.R:170
#, c-format
msgid ""
"frollapply by.column=TRUE requires 'X' argument to be atomic or a list of "
"those"
msgstr ""

#: frollapply.R:182
#, c-format
msgid ""
"frollapply by.column=FALSE, when provided a list in 'X' then all vectors "
"must have equal lengths, like data.frame"
msgstr ""

#: frollapply.R:191
#, c-format
msgid ""
"frollapply by.column=FALSE got vectorized input in 'X', list of data.frames/"
"data.tables, but not all columns of data.frames/data.tables are atomic"
msgstr ""

#: frollapply.R:197
#, c-format
msgid ""
"frollapply by.column=FALSE supports vectorized input in 'X' as a list of "
"data.frames/data.tables, not a list of lists. Turn nested lists into data."
"frames/data.table and retry."
msgstr ""

#: frollapply.R:199
#, c-format
msgid ""
"frollapply by.column=FALSE got list in 'X' but it is not valid one. If "
"intent is to pass a list as non-vectorized input, but a single object to "
"apply function to, then the list must have all its vectors atomic. For a "
"vectorized input, passing multiple objects to apply function to, it must be "
"a list of data.frames/data.tables."
msgstr ""

#: frollapply.R:202
#, c-format
msgid ""
"frollapply by.column=FALSE requires 'X' argument to be a data.table/data."
"frame or a list of equal length vectors. For vectorized input can be a list "
"of data.frames/data.tables, but not a list of lists. All columns/vectors "
"must be atomic."
msgstr ""

#: frollapply.R:206
#, c-format
msgid "'N' must be non 0 length"
msgstr ""

#: frollapply.R:209
#, c-format
msgid "'N' must be an integer, list is accepted for adaptive TRUE"
msgstr ""

#: frollapply.R:211
#, c-format
msgid "'N' must be an integer"
msgstr ""

#: frollapply.R:216 frollapply.R:227 frollapply.R:241
#, c-format
msgid "'N' must be non-negative integer values (>= 0)"
msgstr ""

#: frollapply.R:220
#, c-format
msgid ""
"adaptive rolling function can only process 'X' having equal length of "
"elements; If you want to call rolling function on list having variable "
"length of elements call it for each field separately"
msgstr ""

#: frollapply.R:223 frollapply.R:233
#, c-format
msgid ""
"length of integer vector(s) provided as list to 'N' argument must be equal "
"to number of observations provided in 'X'"
msgstr ""

#: frollapply.R:235
#, c-format
msgid "adaptive windows provided in 'N' must not to have different lengths"
msgstr ""

#: frollapply.R:237 frollapply.R:245
#, c-format
msgid "'N' must be an integer vector or list of integer vectors"
msgstr ""

#: frollapply.R:257
#, c-format
msgid "using adaptive TRUE and align 'center' is not implemented"
msgstr ""

#: frollapply.R:262
msgid ""
"frollapply: adaptive=TRUE && align='left' pre-processing for align='right'"
msgstr ""

#: frollapply.R:319
msgid ""
"frollapply calling parallel::mccollect to collect results from forked "
"processes raised an error.\n"
"%s"
msgstr ""

#: frollapply.R:320
msgid ""
"frollapply internal call to parallel::mccollect raised a warning, FUN "
"warnings should have been suppressed by parallel.\n"
"%s"
msgstr ""

#: frollapply.R:322
msgid ""
"frollapply completed successfully but raised an error when attempting to "
"simplify results using user specified function in 'simplify' argument. Be "
"sure to provide 'fill' argument matching the type and shape of results "
"returned by the your function. Use simplify=FALSE to obtain a list instead.\n"
"%s"
msgstr ""

#: frollapply.R:323
msgid ""
"frollapply completed successfully but raised a warning when attempting to "
"simplify results using user specified function in 'simplify' argument. Be "
"sure to provide 'fill' argument matching the type and shape of results "
"returned by the your function. Use simplify=FALSE to obtain a list instead.\n"
"%s"
msgstr ""

#: frollapply.R:325
msgid ""
"frollapply completed successfully but raised an error when attempting to "
"simplify results using our internal 'simplifylist' function. Be sure to "
"provide 'fill' argument matching the type and shape of results returned by "
"the your function. Use simplify=FALSE to obtain a list instead. If you "
"believe your results could be automatically simplified please submit your "
"use case as new issue in our issue tracker.\n"
"%s"
msgstr ""

#: frollapply.R:326
msgid ""
"frollapply completed successfully but raised a warning when attempting to "
"simplify results using our internal 'simplifylist' function. Be sure to "
"provide 'fill' argument matching the type and shape of results returned by "
"the your function. Use simplify=FALSE to obtain a list instead. If you "
"believe your results could be automatically simplified please submit your "
"use case as new issue in our issue tracker.\n"
"%s"
msgstr ""

#: frollapply.R:332
msgid "frollapply running on single CPU thread"
msgstr ""

#: frollapply.R:348
msgid ""
"frollapply run on %d CPU threads throttled to %d threads, input length %d"
msgstr ""

#: frollapply.R:350
msgid "frollapply running on %d CPU threads"
msgstr ""

#: frollapply.R:409 frollapply.R:433
#, c-format
msgid ""
"frollapply received an error(s) when evaluating FUN:\n"
"%s"
msgstr ""

#: fwrite.R:20
#, c-format
msgid "Argument 'encoding' must be '', 'UTF-8' or 'native'."
msgstr ""

#: fwrite.R:33
#, c-format
msgid "x being coerced from class: matrix to data.table"
msgstr ""

#: fwrite.R:67
msgid "Appending to existing file so setting bom=FALSE and yaml=FALSE"
msgstr ""

#: fwrite.R:80
#, c-format
msgid ""
"If you intended to overwrite the file at %s with an empty one, please use "
"file.remove first."
msgstr ""

#: fwrite.R:81
#, c-format
msgid "Input has no columns; doing nothing.%s"
msgstr ""

#: fwrite.R:84
#, c-format
msgid "Input has no columns; creating an empty file at '%s' and exiting."
msgstr ""

#: fwrite.R:92
#, c-format
msgid ""
"'data.table' relies on the package 'yaml' to write the file header; please "
"add this to your library with install.packages('yaml') and try again."
msgstr ""

#: groupingsets.R:7 groupingsets.R:25 groupingsets.R:47
#, c-format
msgid "Argument 'x' must be a data.table object"
msgstr ""

#: groupingsets.R:9 groupingsets.R:27 groupingsets.R:53
#, c-format
msgid ""
"Argument 'by' must be a character vector of column names used in grouping."
msgstr ""

#: groupingsets.R:11 groupingsets.R:29 groupingsets.R:59
#, c-format
msgid "Argument 'id' must be a logical scalar."
msgstr ""

#: groupingsets.R:31
#, c-format
msgid "Argument 'j' is required"
msgstr ""

#: groupingsets.R:49
#, c-format
msgid ""
"Argument 'x' is a 0-column data.table; no measure to apply grouping over."
msgstr ""

#: groupingsets.R:51
#, c-format
msgid "Input data.table must not contain duplicate column names."
msgstr ""

#: groupingsets.R:55
#, c-format
msgid "Argument 'by' must have unique column names for grouping."
msgstr ""

#: groupingsets.R:57
#, c-format
msgid "Argument 'sets' must be a list of character vectors."
msgstr ""

#: groupingsets.R:63
#, c-format
msgid ""
"Argument 'label', if not NULL, must be a scalar or a named list of scalars."
msgstr ""

#: groupingsets.R:65
#, c-format
msgid ""
"When argument 'label' is a list, all of the list elements must be named."
msgstr ""

#: groupingsets.R:67
#, c-format
msgid ""
"When argument 'label' is a list, the element names must not contain "
"duplicates."
msgstr ""

#: groupingsets.R:70
#, c-format
msgid ""
"All columns used in 'sets' argument must be in 'by' too. Columns used in "
"'sets' but not present in 'by': %s"
msgstr ""

#: groupingsets.R:72
#, c-format
msgid ""
"When using `id=TRUE` the 'x' data.table must not have a column named "
"'grouping'."
msgstr ""

#: groupingsets.R:74
#, c-format
msgid ""
"Character vectors in 'sets' list must not have duplicated column names "
"within a single grouping set."
msgstr ""

#: groupingsets.R:76
#, c-format
msgid ""
"'sets' contains a duplicate (i.e., equivalent up to sorting) element at "
"index %d; as such, there will be duplicate rows in the output -- note that "
"grouping by A,B and B,A will produce the same aggregations. Use "
"`sets=unique(lapply(sets, sort))` to eliminate duplicates."
msgstr ""

#: groupingsets.R:82
#, c-format
msgid ""
"When argument 'label' is a list, all element names must be (1) in 'by', or "
"(2) the first element of the class in the data.table 'x' of a variable in "
"'by', or (3) one of %s. Element names not satisfying this condition: %s"
msgstr ""

#: groupingsets.R:92
#, c-format
msgid "%s (label: %s; data: %s)"
msgstr ""

#: groupingsets.R:96
#, c-format
msgid ""
"When argument 'label' is a list, the class of each 'label' element with name "
"in 'by' must match the class of the corresponding column of the data.table "
"'x'. Class mismatch for: %s"
msgstr ""

#: groupingsets.R:100
#, c-format
msgid "(label name: %s; label class[1]: %s)"
msgstr ""

#: groupingsets.R:103
#, c-format
msgid ""
"When argument 'label' is a list, the name of each element of 'label' not in "
"'by' must match the first element of the class of the element value. "
"Mismatches: %s"
msgstr ""

#: groupingsets.R:110
#, c-format
msgid ""
"Expression passed to grouping sets function must not update by reference. "
"Use ':=' on results of your grouping function."
msgstr ""

#: groupingsets.R:121
#, c-format
msgid ""
"When using `id=TRUE` the 'j' expression must not evaluate to a column named "
"'grouping'."
msgstr ""

#: groupingsets.R:123
#, c-format
msgid ""
"There exists duplicated column names in the results, ensure the column "
"passed/evaluated in `j` and those in `by` are not overlapping."
msgstr ""

#: groupingsets.R:146
#, c-format
msgid "%s (label: %s)"
msgstr ""

#: groupingsets.R:147
#, c-format
msgid ""
"For the following variables, the 'label' value was already in the data: %s"
msgstr ""

#: groupingsets.R:154
#, c-format
msgid ""
"Using integer64 class columns require to have 'bit64' package installed."
msgstr ""

#: helpers.R:6
#, c-format
msgid "argument 'sort' must be TRUE or FALSE"
msgstr ""

#: helpers.R:8
#, c-format
msgid "argument 'rev' must be TRUE or FALSE"
msgstr ""

#: helpers.R:17
#, c-format
msgid ".selfref.ok expects data.table class object."
msgstr ""

#: last.R:11 last.R:16 last.R:24 last.R:29 last.R:33 last.R:41 last.R:52 last.R:57 last.R:65 last.R:70 last.R:74 last.R:82
msgid "%s: using %s: %s"
msgstr ""

#: last.R:39 last.R:80
#, c-format
msgid ""
"'xts' class passed to %s function but 'xts' is not available, you should "
"have 'xts' installed already"
msgstr ""

#: merge.R:4
#, c-format
msgid "Argument 'sort' should be logical TRUE/FALSE"
msgstr ""

#: merge.R:6
#, c-format
msgid "Argument 'no.dups' should be logical TRUE/FALSE"
msgstr ""

#: merge.R:18
#, c-format
msgid "Neither of the input data.tables to join have columns."
msgstr ""

#: merge.R:20 merge.R:22
#, c-format
msgid "Input data.table '%s' has no columns."
msgstr ""

#: merge.R:32
#, c-format
msgid "`by.x` and `by.y` must be of same length."
msgstr ""

#: merge.R:34
#, c-format
msgid "Supplied both `by` and `by.x`/`by.y`. `by` argument will be ignored."
msgstr ""

#: merge.R:37
#, c-format
msgid "A non-empty vector of column names is required for `by.x` and `by.y`."
msgstr ""

#: merge.R:39 merge.R:42 merge.R:56 merge.R:59
#, c-format
msgid "The following columns listed in `%s` are missing from %s: %s"
msgstr ""

#: merge.R:54
#, c-format
msgid "A non-empty vector of column names for `by` is required."
msgstr ""

#: merge.R:116
#, c-format
msgid "column names %s are duplicated in the result"
msgstr ""

#: merge.R:146
#, c-format
msgid "merge.data.table() received %s and %s, all of which will be ignored: %s"
msgstr ""

#: mergelist.R:52
#, c-format
msgid "'x' must be data.table"
msgstr ""

#: mergelist.R:54
#, c-format
msgid "'on' must be character column names of 'x' argument"
msgstr ""

#: mergelist.R:59
#, c-format
msgid ""
"'cols' must be non-zero length, non-NA, integer or character columns of 'x' "
"argument"
msgstr ""

#: mergelist.R:98
#, c-format
msgid "cross join must be used with zero-length on, mult='all', join.many=TRUE"
msgstr ""

#: mergelist.R:104
#, c-format
msgid "'on' must be non-zero length character vector"
msgstr ""

#: mergelist.R:106
#, c-format
msgid "semi and anti joins must be used with mult!='all'"
msgstr ""

#: mergelist.R:157
#, c-format
msgid "'on' is missing and necessary key is not present"
msgstr ""

#: mergelist.R:160 mergelist.R:162
#, c-format
msgid ""
"'on' argument specifies columns to join %s that are not present in %s table "
"%s"
msgstr ""

#: mergelist.R:206
#, c-format
msgid ""
"merge result has duplicated column names %s, use 'cols' argument or rename "
"columns in 'l' tables"
msgstr ""

#: mergelist.R:266 mergelist.R:304
#, c-format
msgid "'%s' must be a list"
msgstr ""

#: mergelist.R:268
#, c-format
msgid "Every element of 'l' list must be data.table objects"
msgstr ""

#: mergelist.R:270
#, c-format
msgid "Tables in 'l' must all have columns, but these entries have 0: %s"
msgstr ""

#: mergelist.R:272
#, c-format
msgid ""
"Column names in individual 'l' entries must be unique, but these have some "
"duplicates: %s"
msgstr ""

#: mergelist.R:279
msgid "mergelist: merging %d table(s), took %.3fs"
msgstr ""

#: mergelist.R:286
#, c-format
msgid ""
"'join.many' must be TRUE or FALSE, or a list of such whose length must be "
"length(l)-1L"
msgstr ""

#: mergelist.R:293
#, c-format
msgid ""
"'mult' must be one of [error, all, first, last] or NULL, or a list of such "
"whose length must be length(l)-1L"
msgstr ""

#: mergelist.R:298
#, c-format
msgid ""
"'how' must be one of [left, inner, full, right, semi, anti, cross], or a "
"list of such whose length must be length(l)-1L"
msgstr ""

#: mergelist.R:306
#, c-format
msgid "'cols' must be same length as 'l' (%d != %d)"
msgstr ""

#: mergelist.R:309
#, c-format
msgid ""
"'cols' must be a list of non-zero length, non-NA, non-duplicated, character "
"vectors, or eventually NULLs (all columns)"
msgstr ""

#: mergelist.R:311
#, c-format
msgid "'cols' specify columns not present in corresponding table"
msgstr ""

#: mergelist.R:320
#, c-format
msgid ""
"'on' must be non-NA, non-duplicated, character vector, or a list of such "
"which length must be length(l)-1L"
msgstr ""

#: mergelist.R:343
msgid "mergelist: merging %d tables, took %.3fs"
msgstr ""

#: onAttach.R:23
#, c-format
msgid ""
"data.table %s IN DEVELOPMENT built %s%s using %d threads (see ?getDTthreads)."
msgstr ""

#: onAttach.R:25
#, c-format
msgid "data.table %s using %d threads (see ?getDTthreads)."
msgstr ""

#: onAttach.R:26
#, c-format
msgid "Latest news: r-datatable.com"
msgstr ""

#: onAttach.R:27
msgid "TRANSLATION CHECK"
msgstr ""

#: onAttach.R:29
#, c-format
msgid ""
"**********\n"
"Running data.table in English; package support is available in English only. "
"When searching for online help, be sure to also check for the English error "
"message. This can be obtained by looking at the po/R-<locale>.po and po/"
"<locale>.po files in the package source, where the native language and "
"English error messages can be found side-by-side.%s\n"
"**********"
msgstr ""

#: onAttach.R:30
msgid ""
"You can also try calling Sys.setLanguage('en') prior to reproducing the "
"error message."
msgstr ""

#: onAttach.R:34
#, c-format
msgid ""
"**********\n"
"This development version of data.table was built more than 4 weeks ago. "
"Please update: data.table::update_dev_pkg()\n"
"**********"
msgstr ""

#: onAttach.R:36
#, c-format
msgid ""
"**********\n"
"This installation of data.table has not detected OpenMP support. It should "
"still work but in single-threaded mode."
msgstr ""

#: onAttach.R:38
#, c-format
msgid ""
"This is a Mac. Please read https://mac.r-project.org/openmp/. Please engage "
"with Apple and ask them for support. Check r-datatable.com for updates, and "
"our Mac instructions here: https://github.com/Rdatatable/data.table/wiki/"
"Installation. After several years of many reports of installation problems "
"on Mac, it's time to gingerly point out that there have been no similar "
"problems on Windows or Linux.\n"
"**********"
msgstr ""

#: onAttach.R:40
#, c-format
msgid ""
"This is %s. This warning should not normally occur on Windows or Linux where "
"OpenMP is turned on by data.table's configure script by passing -fopenmp to "
"the compiler. If you see this warning on Windows or Linux, please file a "
"GitHub issue.\n"
"**********"
msgstr ""

#: onLoad.R:5
#, c-format
msgid ""
"Option 'datatable.nomatch' is defined but is now ignored. Please see note 11 "
"in v1.12.4 NEWS (Oct 2019), and note 14 in v1.14.2."
msgstr ""

#: onLoad.R:21
#, c-format
msgid ""
"The data_table.%s version (%s) does not match the package (%s). Please close "
"all R sessions to release the old %s and reinstall data.table in a fresh R "
"session. Prior to R version 3.6.0 patched, R's package installer could leave "
"a package in an apparently functional state where new R code was calling old "
"C code silently: https://bugs.r-project.org/bugzilla/show_bug.cgi?id=17478. "
"Once a package is in this mismatch state it may produce wrong results "
"silently until you next upgrade the package. This mismatch between R and C "
"code can happen with any package not just data.table. It is just that data."
"table has added this check."
msgstr ""

#: onLoad.R:25
#, c-format
msgid ""
"This is R %s but data.table has been installed using R %s. The major version "
"must match. Please reinstall data.table."
msgstr ""

#: onLoad.R:103
#, c-format
msgid "Unexpected base R behaviour: list(x) has copied x"
msgstr ""

#: onLoad.R:111
#, c-format
msgid "Unexpected base R behaviour: names<- has copied column contents"
msgstr ""

#: onLoad.R:121
#, c-format
msgid ""
"Unexpected base R behaviour: DF[2,2]<- did not copy column 2 which was "
"assigned to"
msgstr ""

#: onLoad.R:122
#, c-format
msgid ""
"Unexpected base R behaviour: DF[2,2]<- copied the first column which was not "
"assigned to, too"
msgstr ""

#: onLoad.R:124
#, c-format
msgid "Unexpected base R behaviour: DF[2,2]<- has not copied address(DF)"
msgstr ""

#: openmp-utils.R:3
#, c-format
msgid "Provide either threads= or percent= but not both"
msgstr ""

#: openmp-utils.R:4
#, c-format
msgid "percent= is provided but is length %d"
msgstr ""

#: openmp-utils.R:6
#, c-format
msgid "percent==%d but should be a number between 2 and 100"
msgstr ""

#: print.data.table.R:19
#, c-format
msgid "Valid options for col.names are 'auto', 'top', and 'none'"
msgstr ""

#: print.data.table.R:21
#, c-format
msgid "Valid options for trunc.cols are TRUE and FALSE"
msgstr ""

#: print.data.table.R:24
#, c-format
msgid "Column classes will be suppressed when col.names is 'none'"
msgstr ""

#: print.data.table.R:48
msgid "Key: <%s>"
msgstr ""

#: print.data.table.R:58
msgid "Null %s (0 rows and 0 cols)"
msgstr ""

#: print.data.table.R:60
msgid "Empty %s (%d rows and %d cols)"
msgstr ""

#: print.data.table.R:161
#, c-format
msgid ""
"Internal structure doesn't seem to be a list. Possibly corrupt data.table."
msgstr ""

#: programming.R:14 programming.R:40
#, c-format
msgid "'x' must be a list"
msgstr ""

#: programming.R:22
#, c-format
msgid ""
"Character objects provided in the input are not scalar objects, if you need "
"them as character vector rather than a name, then wrap each into 'I' call: %s"
msgstr ""

#: programming.R:50
#, c-format
msgid "'env' must not be missing"
msgstr ""

#: programming.R:56
#, c-format
msgid "'env' must be a list or an environment"
msgstr ""

#: programming.R:63
#, c-format
msgid "'env' argument does not have names"
msgstr ""

#: programming.R:65
#, c-format
msgid "'env' argument has zero char names"
msgstr ""

#: programming.R:67
#, c-format
msgid "'env' argument has NA names"
msgstr ""

#: programming.R:69
#, c-format
msgid "'env' argument has duplicated names"
msgstr ""

#: rowwiseDT.R:4
#, c-format
msgid ""
"Must provide at least one column (use `name=`). See ?rowwiseDT for details"
msgstr ""

#: rowwiseDT.R:7
#, c-format
msgid "Named arguments must be empty"
msgstr ""

#: rowwiseDT.R:9
#, c-format
msgid "Header must be the first N arguments"
msgstr ""

#: rowwiseDT.R:15
#, c-format
msgid ""
"There are %d columns but the number of cells is %d, which is not an integer "
"multiple of the columns"
msgstr ""

#: setkey.R:3
#, c-format
msgid ""
"x may no longer be the character name of the data.table. The possibility was "
"undocumented and has been removed."
msgstr ""

#: setkey.R:34
#, c-format
msgid "x is not a data.table"
msgstr ""

#: setkey.R:35
#, c-format
msgid ""
"cols is not a character vector. Please see further information in ?setkey."
msgstr ""

#: setkey.R:36
#, c-format
msgid ""
"Setting a physical key on .SD is reserved for possible future use; to modify "
"the original data's order by group. Try setindex() instead. Or, set*(copy(."
"SD)) as a (slow) last resort."
msgstr ""

#: setkey.R:38
#, c-format
msgid ""
"cols is a character vector of zero length. Removed the key, but use NULL "
"instead, or wrap with suppressWarnings() to avoid this warning."
msgstr ""

#: setkey.R:42
#, c-format
msgid "cols is the empty string. Use NULL to remove the key."
msgstr ""

#: setkey.R:43 setkey.R:265
#, c-format
msgid "cols contains some blanks."
msgstr ""

#: setkey.R:46 setkey.R:269
#, c-format
msgid "some columns are not in the data.table: %s"
msgstr ""

#: setkey.R:54 setkey.R:270
#, c-format
msgid ""
"x contains a column called '.xi'. Conflicts with internal use by data.table."
msgstr ""

#: setkey.R:57
#, c-format
msgid ""
"Column '%s' is type '%s' which is not supported as a key column type, "
"currently."
msgstr ""

#: setkey.R:65
msgid "forder took %.03f sec"
msgstr ""

#: setkey.R:77
msgid "reorder took %s"
msgstr ""

#: setkey.R:79
msgid "x is already ordered by these columns, no need to call reorder"
msgstr ""

#: setkey.R:132
#, c-format
msgid "x is vector but 'by' is supplied"
msgstr ""

#: setkey.R:148
#, c-format
msgid "x is a single vector, non-NULL 'by' doesn't make sense"
msgstr ""

#: setkey.R:160
#, c-format
msgid ""
"data.table has no support for sorting by method='%s'. Use base::order(), not "
"order(), if you really need this."
msgstr ""

#: setkey.R:181
#, c-format
msgid "Attempting to order a 0-column data.table or data.frame."
msgstr ""

#: setkey.R:186
#, c-format
msgid ""
"The first item passed to [f]order is a plain list but there are more items. "
"It should be a data.table or data.frame."
msgstr ""

#: setkey.R:194
#, c-format
msgid "Mixing '-' with vector decreasing= is not supported."
msgstr ""

#: setkey.R:195
#, c-format
msgid "decreasing= has length %d applied to sorting %d columns."
msgstr ""

#: setkey.R:211
#, c-format
msgid "Internal code should not be being called on type double"
msgstr ""

#: setkey.R:218
#, c-format
msgid ""
"Input is not a vector of type double. New parallel sort has only been done "
"for double vectors so far. Using one thread."
msgstr ""

#: setkey.R:219
#, c-format
msgid ""
"New parallel sort has not been implemented for decreasing=TRUE so far. Using "
"one thread."
msgstr ""

#: setkey.R:220
#, c-format
msgid ""
"New parallel sort has not been implemented for vectors containing NA values "
"so far. Using one thread."
msgstr ""

#: setkey.R:231 setkey.R:257
#, c-format
msgid "x must be a data.frame or data.table"
msgstr ""

#: setkey.R:259
#, c-format
msgid "na.last must be logical TRUE/FALSE"
msgstr ""

#: setkey.R:260
#, c-format
msgid ""
"cols is not a character vector. Please see further information in ?setorder."
msgstr ""

#: setkey.R:262
#, c-format
msgid ""
"cols is a character vector of zero length. Use NULL instead, or wrap with "
"suppressWarnings() to avoid this warning."
msgstr ""

#: setkey.R:273
#, c-format
msgid "Column '%s' is type '%s' which is not supported for ordering currently."
msgstr ""

#: setkey.R:317
#, c-format
msgid ""
"'sorted' is TRUE but element %d is non-atomic, which can't be sorted; try "
"setting sorted = FALSE"
msgstr ""

#: setkey.R:332
#, c-format
msgid ""
"Cross product of elements provided to CJ() would result in %.0f rows which "
"exceeds .Machine$integer.max == %d"
msgstr ""

#: setops.R:3 setops.R:40
#, c-format
msgid "x and y must both be data.tables"
msgstr ""

#: setops.R:17
#, c-format
msgid ""
"When x's column ('%s') is character, the corresponding column in y ('%s') "
"should be factor or character, but found incompatible type '%s'."
msgstr ""

#: setops.R:19
#, c-format
msgid ""
"When x's column ('%s') is factor, the corresponding column in y ('%s') "
"should be character or factor, but found incompatible type '%s'."
msgstr ""

#: setops.R:21
#, c-format
msgid ""
"When x's column ('%s') is integer or numeric, the corresponding column in y ("
"'%s') can not be character or logical types, but found incompatible type "
"'%s'."
msgstr ""

#: setops.R:39
#, c-format
msgid "argument 'all' should be logical of length one"
msgstr ""

#: setops.R:41
#, c-format
msgid "x and y must have the same column names"
msgstr ""

#: setops.R:42
#, c-format
msgid "x and y must have the same column order"
msgstr ""

#: setops.R:55
#, c-format
msgid "Item %d of x is '%s' but the corresponding item of y is '%s'."
msgstr ""

#: setops.R:57
#, c-format
msgid "None of the datasets should contain a column named '.seqn'"
msgstr ""

#: setops.R:162
msgid "Datasets have different keys"
msgstr ""

#: setops.R:163 setops.R:164
msgid "has no key"
msgstr ""

#: setops.R:173
msgid "Datasets have different indices"
msgstr ""

#: setops.R:174 setops.R:175
msgid "has no index"
msgstr ""

#: setops.R:192
#, c-format
msgid "None of the datasets to compare should contain a column named '.seqn'"
msgstr ""

#: setops.R:195
#, c-format
msgid ""
"Datasets to compare with 'ignore.row.order' must not have unsupported column "
"types: %s"
msgstr ""

#: setops.R:197
#, c-format
msgid ""
"Argument 'tolerance' was forced to lowest accepted value `sqrt(."
"Machine$double.eps)` from provided %s"
msgstr ""

#: setops.R:210
#, c-format
msgid ""
"Duplicate rows in datasets, numeric columns and ignore.row.order cannot be "
"used with non 0 tolerance argument"
msgstr ""

#: setops.R:224
#, c-format
msgid ""
"Factor columns and ignore.row.order cannot be used with non 0 tolerance "
"argument"
msgstr ""

#: shift.R:3
#, c-format
msgid "Provided argument fill=%s will be ignored since type='cyclic'."
msgstr ""

#: tables.R:31
msgid "No objects of class data.table exist in %s"
msgstr ""

#: tables.R:46
#, c-format
msgid "order.col='%s' not a column name of info"
msgstr ""

#: tables.R:59
msgid "Total: %sMB using %s"
msgstr ""

#: test.data.table.R:23
#, c-format
msgid "data.table package is loaded. Unload or start a fresh R session."
msgstr ""

#: test.data.table.R:39
#, c-format
msgid ""
"script must end with '.Rraw'. If a file ending '.Rraw.bz2' exists, that will "
"be found and used."
msgstr ""

#: test.data.table.R:69
#, c-format
msgid "Neither %s nor %s exist in %s"
msgstr ""

#: test.data.table.R:121
msgid "test.data.table() running: %s"
msgstr ""

#: test.data.table.R:125
msgid "object '%s' not found"
msgstr ""

#: test.data.table.R:128
msgid ""
"**** This R session's language is not English. Each test will still check "
"that the correct number of errors and/or\n"
"**** warnings are produced. However, to test the text of each error/warning "
"too, please restart R with LANGUAGE=en"
msgstr ""

#: test.data.table.R:149
msgid ""
"***\n"
"*** memtest=%d. This should be the first call in a fresh R_GC_MEM_GROW=0 R "
"session for best results. Ctrl-C now if not.\n"
"***"
msgstr ""

#: test.data.table.R:150
#, c-format
msgid ""
"memtest intended for Linux. Step through data.table:::rss() to see what went "
"wrong."
msgstr ""

#: test.data.table.R:204
#, c-format
msgid "Attempt to subset to %d tests matching '%s' failed, running full suite."
msgstr ""

#: test.data.table.R:209
msgid "Running %d of %d tests matching '%s'"
msgstr ""

#: test.data.table.R:279
#, c-format
msgid "Failed in %s after test %s before the next test() call in %s"
msgstr ""

#: test.data.table.R:308
#, c-format
msgid ""
"Tests succeeded, but non-test code caused warnings. Search %s for tests "
"shown above."
msgstr ""

#: test.data.table.R:318
#, c-format
msgid "Timings count mismatch: %d vs %d"
msgstr ""

#: test.data.table.R:320
msgid "10 longest running tests took %ds (%d%% of %ds)"
msgstr ""

#: test.data.table.R:326
msgid "10 largest RAM increases (MiB); see plot for cumulative effect (if any)"
msgstr ""

#: test.data.table.R:336
msgid "Skipped %d tests for translated messages."
msgstr ""

#: test.data.table.R:337
msgid "All %d tests (last %.8g) in %s completed ok in %s"
msgstr ""

#: test.data.table.R:434
msgid "Running test id %s"
msgstr ""

#: test.data.table.R:452
#, c-format
msgid ""
"Test %s is invalid: when error= is provided it does not make sense to pass y "
"as well"
msgstr ""

#: test.data.table.R:506
msgid "Test id %s is not in increasing order"
msgstr ""

#: test.data.table.R:523
msgid ""
"Test %s produced %d %ss but expected %d\n"
"%s\n"
"%s"
msgstr ""

#: test.data.table.R:531
msgid ""
"Test %s didn't produce the correct %s:\n"
"Expected: %s\n"
"Observed: %s"
msgstr ""

#: test.data.table.R:540
msgid "Output captured before unexpected warning/error/message:"
msgstr ""

#: test.data.table.R:551
msgid "Test %s did not produce correct output:"
msgstr ""

#: test.data.table.R:552
msgid "Expected: <<%s>>"
msgstr ""

#: test.data.table.R:553 test.data.table.R:565
msgid "Observed: <<%s>>"
msgstr ""

#: test.data.table.R:555
msgid "Expected (raw): <<%s>>"
msgstr ""

#: test.data.table.R:556 test.data.table.R:568
msgid "Observed (raw): <<%s>>"
msgstr ""

#: test.data.table.R:563
msgid "Test %s produced output but should not have:"
msgstr ""

#: test.data.table.R:564
msgid "Expected absent (case insensitive): <<%s>>"
msgstr ""

#: test.data.table.R:567
msgid "Expected absent (raw): <<%s>>"
msgstr ""

#: test.data.table.R:583
msgid "Test %s ran without errors but selfrefok(%s) is FALSE"
msgstr ""

#: test.data.table.R:608
msgid "Test %s ran without errors but failed check that x equals y:"
msgstr ""

#: test.data.table.R:613
msgid "First %d of %d (type '%s'):"
msgstr ""

#: test.data.table.R:618
msgid "Non-ASCII string detected, raw representation:"
msgstr ""

#: timetaken.R:3
#, c-format
msgid "Use started.at=proc.time() not Sys.time() (POSIXt and slow)"
msgstr ""

#: transpose.R:7
#, c-format
msgid "make.names='%s' not found in names of input"
msgstr ""

#: transpose.R:12
#, c-format
msgid "make.names=%d is out of range [1,ncol=%d]"
msgstr ""

#: transpose.R:28
#, c-format
msgid "'names' must be TRUE/FALSE or a character vector."
msgstr ""

#: transpose.R:34
#, c-format
msgid "'keep' should contain integer values between %d and %d."
msgstr ""

#: transpose.R:51
#, c-format
msgid "The argument 'type.convert' does not support empty list."
msgstr ""

#: transpose.R:57
#, c-format
msgid ""
"When the argument 'type.convert' contains an unnamed element, it is expected "
"to be the last element and should be a function. More than one unnamed "
"element is not allowed unless all elements are functions with length equal "
"to %d (the length of the transpose list or 'keep' argument if it is "
"specified)."
msgstr ""

#: transpose.R:66
#, c-format
msgid ""
"When the argument 'type.convert' contains transpose list indices, it should "
"be a named list of non-missing integer values (with no duplicate) except the "
"last element that should be unnamed if it is a function."
msgstr ""

#: transpose.R:68
#, c-format
msgid ""
"When the argument 'type.convert' contains transpose list indices, they "
"should be integer values contained in the argument 'keep' (if it is "
"specified) or be between %d and %d (if it is not). But '%s' is/are not "
"contained in '%s'."
msgstr ""

#: transpose.R:74
#, c-format
msgid ""
"In the argument 'type.convert', '%s' was ignored because all elements in the "
"transpose list or elements corresponding to indices specified in the 'keep' "
"argument have already been converted."
msgstr ""

#: transpose.R:83
#, c-format
msgid ""
"The argument 'type.convert' should be TRUE/FALSE, a function, a list of "
"functions, or a named list of pairs 'fun=indices' with optionally one "
"unnamed element (a function) but an object of type '%s' was provided."
msgstr ""

#: transpose.R:88
#, c-format
msgid "length(names) (= %d) is not equal to length(%s) (= %d)."
msgstr ""

#: uniqlist.R:11
#, c-format
msgid "l not type list"
msgstr ""

#: utils.R:19
#, c-format
msgid "Argument 'nan' must be length 1"
msgstr ""

#: utils.R:22
#, c-format
msgid "Argument 'nan' must be NA or NaN"
msgstr ""

#: utils.R:32
msgid "Internal error in"
msgstr ""

#: utils.R:35
msgid "Please report to the data.table issues tracker."
msgstr ""

#: utils.R:79 utils.R:88
#, c-format
msgid "x not boolean"
msgstr ""

#: utils.R:99
#, c-format
msgid ""
"Some columns are type 'integer64' but package bit64 is not installed. Those "
"columns will print as strange looking floating point data. There is no need "
"to reload the data. Simply install.packages('bit64') to obtain the integer64 "
"print method and print the data again."
msgstr ""

#: xts.R:4
#, c-format
msgid "keep.rownames must be length 1"
msgstr ""

#: xts.R:5
#, c-format
msgid "keep.rownames must not be NA"
msgstr ""

#: xts.R:11
#, c-format
msgid ""
"Input xts object should not have '%s' column because it would result in "
"duplicate column names. Rename '%s' column in xts or use `keep.rownames` to "
"change the index column name."
msgstr ""

#: xts.R:21
#, c-format
msgid ""
"data.table must have a time based column in first position, use "
"`setcolorder` function to change the order, or see ?timeBased for supported "
"types"
msgstr ""

#: xts.R:25
#, c-format
msgid "Following columns are not numeric and will be omitted: %s"
msgstr ""

#: bmerge.R:219
msgid "  Found %d non-equi group ...\n"
msgid_plural "  Found %d non-equi groups ...\n"
msgstr[0] ""
msgstr[1] ""

#: data.table.R:745
msgid "column not removed because not found: %s"
msgid_plural "columns not removed because not found: %s"
msgstr[0] ""
msgstr[1] ""

#: data.table.R:760
msgid "column not found: %s"
msgid_plural "columns not found: %s"
msgstr[0] ""
msgstr[1] ""

#: data.table.R:928
msgid "The item in the 'by' or 'keyby' list is length %s. Each must be length %d; the same length as there are rows in x (after subsetting if i is provided)."
msgid_plural "The items in the 'by' or 'keyby' list have lengths %s. Each must be length %d; the same length as there are rows in x (after subsetting if i is provided)."
msgstr[0] ""
msgstr[1] ""

#: fmelt.R:27
msgid "Pattern not found: [%s]"
msgid_plural "Patterns not found: [%s]"
msgstr[0] ""
msgstr[1] ""

#: fread.R:354
msgid "stringsAsFactors=%s converted %d column: %s\n"
msgid_plural "stringsAsFactors=%s converted %d columns: %s\n"
msgstr[0] ""
msgstr[1] ""

#: merge.R:131
msgid "merge.data.table() received %d unnamed argument in '...' which will be ignored."
msgid_plural "merge.data.table() received %d unnamed arguments in '...' which will be ignored."
msgstr[0] ""
msgstr[1] ""

#: merge.R:138
msgid "merge.data.table() received %d unknown keyword argument which will be ignored: %s"
msgid_plural "merge.data.table() received %d unknown keyword arguments which will be ignored: %s"
msgstr[0] ""
msgstr[1] ""

#: merge.R:144
msgid "%d unnamed argument in '...'"
msgid_plural "%d unnamed arguments in '...'"
msgstr[0] ""
msgstr[1] ""

#: merge.R:145
msgid "%d unknown keyword argument"
msgid_plural "%d unknown keyword arguments"
msgstr[0] ""
msgstr[1] ""

#: print.data.table.R:51
msgid "Index: %s\n"
msgid_plural "Indices: %s\n"
msgstr[0] ""
msgstr[1] ""

#: print.data.table.R:290
msgid "%d variable not shown: %s\n"
msgid_plural "%d variables not shown: %s\n"
msgstr[0] ""
msgstr[1] ""

#: setops.R:46
msgid "unsupported column type found in x or y: %s"
msgid_plural "unsupported column types found in x or y: %s"
msgstr[0] ""
msgstr[1] ""

#: test.data.table.R:290
msgid "%d error out of %d. Search %s for test number %s. Duration: %s."
msgid_plural "%d errors out of %d. Search %s for test numbers %s. Duration: %s."
msgstr[0] ""
msgstr[1] ""

#: test.data.table.R:300
msgid "Caught %d warning outside the test() calls:\n"
msgid_plural "Caught %d warnings outside the test() calls:\n"
msgstr[0] ""
msgstr[1] ""

#: utils.R:43
msgid "%s has duplicated column name %s. Please remove or rename the duplicate and try again."
msgid_plural "%s has duplicated column names %s. Please remove or rename the duplicates and try again."
msgstr[0] ""
msgstr[1] ""
