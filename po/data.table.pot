msgid ""
msgstr ""
"Project-Id-Version: data.table 1.17.99\n"
"POT-Creation-Date: 2025-12-23 12:03-0700\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: assign.c:67
msgid ""
"The data.table internal attributes of this table are invalid. This is "
"expected and normal for a data.table loaded from disk. Please remember to "
"always setDT() immediately after loading to prevent unexpected behavior. If "
"this table was not loaded from disk or you've already run setDT(), please "
"report to the data.table issue tracker.\n"
msgstr ""

#: assign.c:138
#, c-format
msgid ""
"Some columns are a multi-column type (such as a matrix column), for example "
"column %d. setDT will retain these columns as-is but subsequent operations "
"like grouping and joining may fail. Please consider as.data.table() instead "
"which will create a new column for each embedded column."
msgstr ""

#: assign.c:155
#, c-format
msgid ""
"Column %d has class 'POSIXlt'. Please convert it to POSIXct (using as."
"POSIXct) and run setDT() again. We do not recommend the use of POSIXlt at "
"all because it uses 40 bytes to store one date."
msgstr ""

#: assign.c:172
#, c-format
msgid ""
"All elements in argument 'x' to 'setDT' must be of equal length, but input "
"%d has length %d whereas the first non-empty input had length %d"
msgstr ""

#: assign.c:182
msgid "alloccol has been passed a NULL dt"
msgstr ""

#: assign.c:183
msgid "dt passed to alloccol isn't type VECSXP"
msgstr ""

#: assign.c:185
msgid ""
"dt passed to alloccol has no class attribute. Please report result of "
"traceback() to data.table issue tracker."
msgstr ""

#: assign.c:202
#, c-format
msgid ""
"tl (%d) is greater than 10,000 items over-allocated (l = %d). If you didn't "
"set the datatable.alloccol option to be very large, please report to data."
"table issue tracker including the result of sessionInfo()."
msgstr ""

#: assign.c:204
#, c-format
msgid ""
"Attempt to reduce allocation from %d to %d ignored. Can only increase "
"allocation via shallow copy. Please do not use DT[...]<- or DT$someCol<-. "
"Use := inside DT[...] instead."
msgstr ""

#: assign.c:212
msgid ""
"Has getOption('datatable.alloccol') somehow become unset? It should be a "
"number, by default 1024."
msgstr ""

#: assign.c:214
#, c-format
msgid ""
"getOption('datatable.alloccol') should be a number, by default 1024. But its "
"type is '%s'."
msgstr ""

#: assign.c:216
#, c-format
msgid ""
"getOption('datatable.alloccol') is a numeric vector ok but its length is %d. "
"Its length should be 1."
msgstr ""

#: assign.c:219
#, c-format
msgid "getOption('datatable.alloccol')==%d.  It must be >=0 and not NA."
msgstr ""

#: assign.c:225 between.c:22 between.c:28 frollR.c:97 frollR.c:112 fsort.c:117 gsumm.c:351 gsumm.c:587 gsumm.c:733 gsumm.c:871 gsumm.c:1026 gsumm.c:1118 nafill.c:108 openmp-utils.c:97 uniqlist.c:358 utils.c:122 utils.c:124
#, c-format
msgid "%s must be TRUE or FALSE"
msgstr ""

#: assign.c:273
msgid "assign has been passed a NULL dt"
msgstr ""

#: assign.c:274
msgid "dt passed to assign isn't type VECSXP"
msgstr ""

#: assign.c:276
msgid ""
".SD is locked. Updating .SD by reference using := or set are reserved for "
"future use. Use := in j directly. Or use copy(.SD) as a (slow) last resort, "
"until shallow() is exported."
msgstr ""

#: assign.c:288
msgid "dt passed to assign has no names"
msgstr ""

#: assign.c:298
#, c-format
msgid "Assigning to all %d rows\n"
msgstr ""

#: assign.c:304 assign.c:358
#, c-format
msgid ""
"Coerced %s from numeric to integer. Passing integer directly may be more "
"efficient, e.g., 2L rather than 2"
msgstr ""

#: assign.c:307
#, c-format
msgid ""
"i is type '%s'. Must be integer, or numeric is coerced with warning. If i is "
"a logical subset, simply wrap with which(), and take the which() outside the "
"loop if possible for efficiency."
msgstr ""

#: assign.c:313 subset.c:170
#, c-format
msgid "i[%d] is %d which is out of range [1,nrow=%d]"
msgstr ""

#: assign.c:316
#, c-format
msgid "Assigning to %d row subset of %d rows\n"
msgstr ""

#: assign.c:332
msgid "length(LHS)==0; no columns to delete or assign RHS to."
msgstr ""

#: assign.c:346
msgid ""
"set() on a data.frame is for changing existing columns, not adding new ones. "
"Please use a data.table for that. data.table's are over-allocated and don't "
"shallow copy."
msgstr ""

#: assign.c:361
#, c-format
msgid ""
"j is type '%s'. Must be integer, character, or numeric is coerced with "
"warning."
msgstr ""

#: assign.c:363
msgid ""
"Can't assign to the same column twice in the same query (duplicates "
"detected)."
msgstr ""

#: assign.c:364
msgid "newcolnames is supplied but isn't a character vector"
msgstr ""

#: assign.c:366
msgid ""
"Values of type POSIXlt detected and converted to POSIXct. We do not "
"recommend the use of POSIXlt at all because it typically takes more than 6 "
"times the storage as an equivalent POSIXct column. Use as.POSIXct() to avoid "
"this warning."
msgstr ""

#: assign.c:376
#, c-format
msgid ""
"RHS_list_of_columns revised to true because RHS list has 1 item which is "
"NULL, or whose length %d is either 1 or targetlen (%d). Please unwrap RHS.\n"
msgstr ""

#: assign.c:381
#, c-format
msgid ""
"Supplied %d columns to be assigned an empty list (which may be an empty data."
"table or data.frame since they are lists too). To delete multiple columns "
"use NULL instead. To add multiple empty list columns, use list(list())."
msgstr ""

#: assign.c:386
#, c-format
msgid "Recycling single RHS list item across %d columns. Please unwrap RHS.\n"
msgstr ""

#: assign.c:388
#, c-format
msgid ""
"Supplied %d columns to be assigned %d items. Please see NEWS for v1.12.2."
msgstr ""

#: assign.c:396
#, c-format
msgid ""
"Item %d of column numbers in j is %d which is outside range [1,ncol=%d]. "
"set() on a data.frame is for changing existing columns, not adding new ones. "
"Please use a data.table for that."
msgstr ""

#: assign.c:397
#, c-format
msgid ""
"Item %d of column numbers in j is %d which is outside range [1,ncol=%d]. Use "
"column names instead in j to add new columns."
msgstr ""

#: assign.c:403
msgid ""
"Doubly-invalid attempt to delete a non-existent column while also providing i"
msgstr ""

#: assign.c:405
msgid ""
"Invalid attempt to delete a list column while also providing i; did you "
"intend to add NULL to those rows instead? If so, use list_col := "
"list(list(NULL))."
msgstr ""

#: assign.c:406
msgid "When deleting columns, i should not be provided"
msgstr ""

#: assign.c:414
#, c-format
msgid ""
"RHS of assignment to existing column '%s' is zero length but not NULL. If "
"you intend to delete the column use NULL. Otherwise, the RHS must have "
"length > 0; e.g., NA_integer_. If you are trying to change the column type "
"to be an empty list column then, as with all column type changes, provide a "
"full length RHS vector such as vector('list',nrow(DT)); i.e., 'plonk' in the "
"new column."
msgstr ""

#: assign.c:421
#, c-format
msgid ""
"Tried to assign NULL to column '%s', but this column does not exist to remove"
msgstr ""

#: assign.c:429
#, c-format
msgid "%d column matrix RHS of := will be treated as one vector"
msgstr ""

#: assign.c:434
#, c-format
msgid ""
"Can't assign to column '%s' (type 'factor') a value of type '%s' (not "
"character, factor, integer or numeric)"
msgstr ""

#: assign.c:440
#, c-format
msgid ""
"Supplied %d items to be assigned to %d items of column '%s'. If you wish to "
"'recycle' the RHS please use rep() to make this intent clear to readers of "
"your code."
msgstr ""

#: assign.c:447
msgid ""
"This data.table has either been loaded from disk (e.g. using readRDS()/"
"load()) or constructed manually (e.g. using structure()). Please run setDT() "
"or setalloccol() on it first (to pre-allocate space for new columns) before "
"assigning by reference to it."
msgstr ""

#: assign.c:453
#, c-format
msgid ""
"truelength (%d) is greater than 10,000 items over-allocated (length = %d). "
"See ?truelength. If you didn't set the datatable.alloccol option very large, "
"please report to data.table issue tracker including the result of "
"sessionInfo()."
msgstr ""

#: assign.c:457
msgid ""
"It appears that at some earlier point, names of this data.table have been "
"reassigned. Please ensure to use setnames() rather than names<- or "
"colnames<-. Otherwise, please report to data.table issue tracker."
msgstr ""

#: assign.c:464
msgid ""
"It appears that at some earlier point, attributes of this data.table have "
"been reassigned. Please use setattr(DT, name, value) rather than attr(DT, "
"name) <- value. If that doesn't apply to you, please report your case to the "
"data.table issue tracker."
msgstr ""

#: assign.c:496
#, c-format
msgid ""
"RHS for item %d has been duplicated because MAYBE_REFERENCED==%d "
"MAYBE_SHARED==%d ALTREP==%d, but then is being plonked. length(values)==%d; "
"length(cols)==%d\n"
msgstr ""

#: assign.c:501
#, c-format
msgid ""
"Direct plonk of unnamed RHS, no copy. MAYBE_REFERENCED==%d, MAYBE_SHARED=="
"%d\n"
msgstr ""

#: assign.c:570
#, c-format
msgid ""
"Dropping index '%s' as it doesn't have '__' at the beginning of its name. It "
"was very likely created by v1.9.4 of data.table.\n"
msgstr ""

#: assign.c:615 assign.c:631
#, c-format
msgid "Dropping index '%s' due to an update on a key column\n"
msgstr ""

#: assign.c:624
#, c-format
msgid "Shortening index '%s' to '%s' due to an update on a key column\n"
msgstr ""

#: assign.c:682
#, c-format
msgid "(column %d named '%s')"
msgstr ""

#: assign.c:716
#, c-format
msgid ""
"Cannot assign 'factor' to '%s'. Factors can only be assigned to factor, "
"character or list columns."
msgstr ""

#: assign.c:731
#, c-format
msgid ""
"Assigning factor numbers to target vector. But %d is outside the level range "
"[1,%d]"
msgstr ""

#: assign.c:733
#, c-format
msgid ""
"Assigning factor numbers to column %d named '%s'. But %d is outside the "
"level range [1,%d]"
msgstr ""

#: assign.c:743
#, c-format
msgid ""
"Assigning factor numbers to target vector. But %f is outside the level range "
"[1,%d], or is not a whole number."
msgstr ""

#: assign.c:745
#, c-format
msgid ""
"Assigning factor numbers to column %d named '%s'. But %f is outside the "
"level range [1,%d], or is not a whole number."
msgstr ""

#: assign.c:751
#, c-format
msgid ""
"Cannot assign '%s' to 'factor'. Factor columns can be assigned factor, "
"character, NA in any type, or level numbers."
msgstr ""

#: assign.c:822
#, c-format
msgid "Coercing 'character' RHS to '%s' to match the type of target vector."
msgstr ""

#: assign.c:824
#, c-format
msgid ""
"Coercing 'character' RHS to '%s' to match the type of column %d named '%s'."
msgstr ""

#: assign.c:832
msgid ""
"Cannot coerce 'list' RHS to 'integer64' to match the type of target vector."
msgstr ""

#: assign.c:834
#, c-format
msgid ""
"Cannot coerce 'list' RHS to 'integer64' to match the type of column %d named "
"'%s'."
msgstr ""

#: assign.c:840
#, c-format
msgid "Coercing 'list' RHS to '%s' to match the type of target vector."
msgstr ""

#: assign.c:842
#, c-format
msgid "Coercing 'list' RHS to '%s' to match the type of column %d named '%s'."
msgstr ""

#: assign.c:850
#, c-format
msgid "Zero-copy coerce when assigning '%s' to '%s' target vector.\n"
msgstr ""

#: assign.c:852
#, c-format
msgid ""
"Zero-copy coerce when assigning '%s' to column %d named '%s' which is '%s'.\n"
msgstr ""

#: assign.c:868
#, c-format
msgid "(target vector)"
msgstr ""

#: assign.c:878 assign.c:879
#, c-format
msgid ""
"%d (type '%s') at RHS position %d taken as TRUE when assigning to type '%s' "
"%s"
msgstr ""

#: assign.c:881
#, c-format
msgid ""
"%<PRId64> (type '%s') at RHS position %d taken as TRUE when assigning to "
"type '%s' %s"
msgstr ""

#: assign.c:882
#, c-format
msgid ""
"%f (type '%s') at RHS position %d taken as TRUE when assigning to type '%s' "
"%s"
msgstr ""

#: assign.c:886
#, c-format
msgid ""
"%d (type '%s') at RHS position %d taken as 0 when assigning to type '%s' %s"
msgstr ""

#: assign.c:888
#, c-format
msgid ""
"%<PRId64> (type '%s') at RHS position %d taken as 0 when assigning to type "
"'%s' %s"
msgstr ""

#: assign.c:889
#, c-format
msgid ""
"%f (type '%s') at RHS position %d either truncated (precision lost) or taken "
"as 0 when assigning to type '%s' %s"
msgstr ""

#: assign.c:894
#, c-format
msgid ""
"%<PRId64> (type '%s') at RHS position %d out-of-range (NA) when assigning to "
"type '%s' %s"
msgstr ""

#: assign.c:895 assign.c:902
#, c-format
msgid ""
"%f (type '%s') at RHS position %d out-of-range(NA) or truncated (precision "
"lost) when assigning to type '%s' %s"
msgstr ""

#: assign.c:897 assign.c:906
#, c-format
msgid ""
"%f (type '%s') at RHS position %d either imaginary part discarded or real "
"part truncated (precision lost) when assigning to type '%s' %s"
msgstr ""

#: assign.c:907
#, c-format
msgid ""
"%f (type '%s') at RHS position %d imaginary part discarded when assigning to "
"type '%s' %s"
msgstr ""

#: assign.c:952
#, c-format
msgid "type '%s' cannot be coerced to '%s'"
msgstr ""

#: assign.c:1110
#, c-format
msgid "Unsupported column type in assign.c:memrecycle '%s'"
msgstr ""

#: assign.c:1193
msgid "x must be a character vector"
msgstr ""

#: assign.c:1194
msgid "'which' must be an integer vector"
msgstr ""

#: assign.c:1195
msgid "'new' must be a character vector"
msgstr ""

#: assign.c:1196
#, c-format
msgid "'new' is length %d. Should be the same as length of 'which' (%d)"
msgstr ""

#: assign.c:1199
#, c-format
msgid ""
"Item %d of 'which' is %d which is outside range of the length %d character "
"vector"
msgstr ""

#: between.c:18
#, c-format
msgid ""
"Incompatible vector lengths: length(x)==%d length(lower)==%d length(upper)=="
"%d. Each should be either length 1 or the length of the longest."
msgstr ""

#: between.c:25
msgid "NAbounds must be TRUE or NA"
msgstr ""

#: between.c:35 between.c:37
#, c-format
msgid "x is integer64 but %s is not. Please align classes."
msgstr ""

#: between.c:40 between.c:42
#, c-format
msgid "x is not integer64 but %s is. Please align classes."
msgstr ""

#: between.c:83
#, c-format
msgid "Item %d of lower (%d) is greater than item %d of upper (%d)"
msgstr ""

#: between.c:101
#, c-format
msgid "between parallel processing of integer took %8.3fs\n"
msgstr ""

#: between.c:112
#, c-format
msgid ""
"Item %d of lower (%<PRId64>) is greater than item %d of upper (%<PRId64>)"
msgstr ""

#: between.c:129
#, c-format
msgid "between parallel processing of integer64 took %8.3fs\n"
msgstr ""

#: between.c:137
#, c-format
msgid "Item %d of lower (%f) is greater than item %d of upper (%f)"
msgstr ""

#: between.c:155
#, c-format
msgid "between parallel processing of double with open bounds took %8.3fs\n"
msgstr ""

#: between.c:172
#, c-format
msgid "between parallel processing of double with closed bounds took %8.3fs\n"
msgstr ""

#: between.c:187
#, c-format
msgid "Item %d of lower ('%s') is greater than item %d of upper ('%s')"
msgstr ""

#: between.c:202
#, c-format
msgid "between non-parallel processing of character took %8.3fs\n"
msgstr ""

#: bmerge.c:78
#, c-format
msgid "Type '%s' is not supported for joining/merging"
msgstr ""

#: bmerge.c:87
msgid "roll='nearest' can't be applied to a character column, yet."
msgstr ""

#: bmerge.c:96
msgid "rollends must be a length 2 logical vector"
msgstr ""

#: bmerge.c:131
msgid "Only '==' operator is supported for columns of type character."
msgstr ""

#: bmerge.c:209
#, c-format
msgid "bmerge: looping bmerge_r took %.3fs\n"
msgstr ""

#: bmerge.c:241
#, c-format
msgid "bmerge: took %.3fs\n"
msgstr ""

#: bmerge.c:417
msgid "mult='error' and multiple matches during merge"
msgstr ""

#: chmatch.c:5
#, c-format
msgid "table is type '%s' (must be 'character' or NULL)"
msgstr ""

#: chmatch.c:19
#, c-format
msgid "x is type '%s' (must be 'character' or NULL)"
msgstr ""

#: cj.c:95
#, c-format
msgid "Type '%s' is not supported by CJ."
msgstr ""

#: coalesce.c:22
msgid ""
"The first argument is a list, data.table or data.frame. In this case there "
"should be no other arguments provided."
msgstr ""

#: coalesce.c:38
#, c-format
msgid ""
"Item 1 is a factor but item %d is not a factor. When factors are involved, "
"all items must be factor."
msgstr ""

#: coalesce.c:40
#, c-format
msgid ""
"Item %d is a factor but its levels are not identical to the first item's "
"levels."
msgstr ""

#: coalesce.c:44
#, c-format
msgid ""
"Item %d is a factor but item 1 is not a factor. When factors are involved, "
"all items must be factor."
msgstr ""

#: coalesce.c:47
#, c-format
msgid ""
"Item %d is type %s but the first item is type %s. Please coerce before "
"coalescing."
msgstr ""

#: coalesce.c:49
#, c-format
msgid "Item %d has a different class than item 1."
msgstr ""

#: coalesce.c:52
#, c-format
msgid ""
"Item %d is length %d but the first item is length %d. Only singletons are "
"recycled."
msgstr ""

#: coalesce.c:56
msgid "coalesce copied first item (inplace=FALSE)\n"
msgstr ""

#: coalesce.c:193 fifelse.c:199 shift.c:177 uniqlist.c:98 uniqlist.c:130 uniqlist.c:215 uniqlist.c:252 uniqlist.c:325
#, c-format
msgid "Type '%s' is not supported"
msgstr ""

#: dogroups.c:82 gsumm.c:48
msgid "env is not an environment"
msgstr ""

#: dogroups.c:136
msgid "row.names attribute of .SD not found"
msgstr ""

#: dogroups.c:138
#, c-format
msgid ""
"row.names of .SD isn't integer length 2 with NA as first item; i.e., ."
"set_row_names(). [%s %d %d]"
msgstr ""

#: dogroups.c:169
#, c-format
msgid "length(iSD)[%d] != length(jiscols)[%d]"
msgstr ""

#: dogroups.c:170
#, c-format
msgid "length(xSD)[%d] != length(xjiscols)[%d]"
msgstr ""

#: dogroups.c:282
#, c-format
msgid "j evaluates to type '%s'. Must evaluate to atomic vector or list."
msgstr ""

#: dogroups.c:291
#, c-format
msgid ""
"Entry %d for group %d in j=list(...) should be atomic vector or list. If you "
"are trying something like j=list(.SD,newcol=mean(colA)) then use := by group "
"instead (much quicker), or cbind or merge afterwards."
msgstr ""

#: dogroups.c:298
#, c-format
msgid ""
"Entry %d for group %d in j=list(...) is an array with %d dimensions > 1, "
"which is disallowed. \"Break\" the array yourself with c() or as.vector() if "
"that is intentional."
msgstr ""

#: dogroups.c:308
msgid ""
"RHS of := is NULL during grouped assignment, but it's not possible to delete "
"parts of a column."
msgstr ""

#: dogroups.c:312
#, c-format
msgid ""
"Supplied %d items to be assigned to group %d of size %d in column '%s'. The "
"RHS length must either be 1 (single values are ok) or match the LHS length "
"exactly. If you wish to 'recycle' the RHS please use rep() explicitly to "
"make this intent clear to readers of your code."
msgstr ""

#: dogroups.c:345
#, c-format
msgid "Group %d column '%s': %s"
msgstr ""

#: dogroups.c:352
msgid "j doesn't evaluate to the same number of columns for each group"
msgstr ""

#: dogroups.c:386
#, c-format
msgid ""
"Column %d of j's result for the first group is NULL. We rely on the column "
"types of the first result to decide the type expected for the remaining "
"groups (and require consistency). NULL columns are acceptable for later "
"groups (and those are replaced with NA of appropriate type and recycled) but "
"not for the first. Please use a typed empty vector instead, such as "
"integer() or numeric()."
msgstr ""

#: dogroups.c:389
msgid ""
"j appears to be a named vector. The same names will likely be created over "
"and over again for each group and slow things down. Try and pass a named "
"list (which data.table optimizes) or an unnamed list() instead.\n"
msgstr ""

#: dogroups.c:391
#, c-format
msgid ""
"Column %d of j is a named vector (each item down the rows is named, "
"somehow). Please remove those names for efficiency (to save creating them "
"over and over for each group). They are ignored anyway.\n"
msgstr ""

#: dogroups.c:399
msgid ""
"The result of j is a named list. It's very inefficient to create the same "
"names over and over again for each group. When j=list(...), any names are "
"detected, removed and put back after grouping has completed, for efficiency. "
"Using j=transform(), for example, prevents that speedup (consider changing "
"to :=). This message may be upgraded to warning in future.\n"
msgstr ""

#: dogroups.c:411
#, c-format
msgid "dogroups: growing from %d to %d rows\n"
msgstr ""

#: dogroups.c:431
#, c-format
msgid ""
"Item %d of j's result for group %d is zero length. This will be filled with "
"%d NAs to match the longest column in this result. Later groups may have a "
"similar problem but only the first is reported to save filling the warning "
"buffer."
msgstr ""

#: dogroups.c:438
#, c-format
msgid ""
"Column %d of result for group %d is type '%s' but expecting type '%s'. "
"Column types must be consistent for each group."
msgstr ""

#: dogroups.c:440
#, c-format
msgid ""
"Supplied %d items for column %d of group %d which has %d rows. The RHS "
"length must either be 1 (single values are ok) or match the LHS length "
"exactly. If you wish to 'recycle' the RHS please use rep() explicitly to "
"make this intent clear to readers of your code."
msgstr ""

#: dogroups.c:459 fsort.c:264 fwrite.c:749
msgid "\n"
msgstr ""

#: dogroups.c:461 dogroups.c:478
#, c-format
msgid ""
"Processed %d groups out of %d. %.0f%% done. Time elapsed: %ds. ETA: %ds."
msgstr ""

#: dogroups.c:484
#, c-format
msgid "Wrote less rows (%d) than allocated (%d).\n"
msgstr ""

#: dogroups.c:493
#, c-format
msgid ""
"\n"
"  collecting discontiguous groups took %.3fs for %d groups\n"
msgstr ""

#: dogroups.c:494
#, c-format
msgid ""
"\n"
"  memcpy contiguous groups took %.3fs for %d groups\n"
msgstr ""

#: dogroups.c:496
#, c-format
msgid "  eval(j) took %.3fs for %d calls\n"
msgstr ""

#: dogroups.c:510
msgid "growVector passed NULL"
msgstr ""

#: fastmean.c:39 rbindlist.c:8 rbindlist.c:12
#, c-format
msgid "%s should be TRUE or FALSE"
msgstr ""

#: fastmean.c:45
#, c-format
msgid "fastmean was passed type %s, not numeric or logical"
msgstr ""

#: fcast.c:101
#, c-format
msgid "Unsupported column type in fcast val: '%s'"
msgstr ""

#: fifelse.c:11
msgid "Argument 'test' must be logical."
msgstr ""

#: fifelse.c:15
msgid "S4 class objects (except nanotime) are not supported."
msgstr ""

#: fifelse.c:30
#, c-format
msgid ""
"Length of 'yes' is %<PRId64> but must be 1 or length of 'test' (%<PRId64>)."
msgstr ""

#: fifelse.c:32
#, c-format
msgid ""
"Length of 'no' is %<PRId64> but must be 1 or length of 'test' (%<PRId64>)."
msgstr ""

#: fifelse.c:34
#, c-format
msgid ""
"Length of 'na' is %<PRId64> but must be 1 or length of 'test' (%<PRId64>)."
msgstr ""

#: fifelse.c:52
#, c-format
msgid ""
"'no' is of type %s but '%s' is %s. Please make all arguments have the same "
"type."
msgstr ""

#: fifelse.c:58
#, c-format
msgid ""
"'na' is of type %s but '%s' is %s. Please make all arguments have the same "
"type."
msgstr ""

#: fifelse.c:63
msgid ""
"'yes' has different class than 'no'. Please make sure that both arguments "
"have the same class."
msgstr ""

#: fifelse.c:68
msgid ""
"'yes' has different class than 'na'. Please make sure that both arguments "
"have the same class."
msgstr ""

#: fifelse.c:73
msgid ""
"'no' has different class than 'na'. Please make sure that both arguments "
"have the same class."
msgstr ""

#: fifelse.c:80
msgid "'yes' and 'no' are both type factor but their levels are different."
msgstr ""

#: fifelse.c:85
msgid "'yes' and 'na' are both type factor but their levels are different."
msgstr ""

#: fifelse.c:90
msgid "'no' and 'na' are both type factor but their levels are different."
msgstr ""

#: fifelse.c:213
#, c-format
msgid ""
"Received %d inputs; please supply an even number of arguments in ..., "
"consisting of logical condition, resulting value pairs (in that order). Note "
"that the default argument must be named explicitly, e.g., default=0"
msgstr ""

#: fifelse.c:235
msgid ""
"S4 class objects (except nanotime) are not supported. Please see https://"
"github.com/Rdatatable/data.table/issues/4131."
msgstr ""

#: fifelse.c:238
#, c-format
msgid "Argument #%d must be logical but was of type %s."
msgstr ""

#: fifelse.c:260
#, c-format
msgid ""
"Argument #%d has length %lld which differs from that of argument #1 (%lld). "
"Please make sure all logical conditions have the same length."
msgstr ""

#: fifelse.c:266
#, c-format
msgid ""
"Resulting value is of type %s but 'default' is of type %s. Please make sure "
"that both arguments have the same type."
msgstr ""

#: fifelse.c:269
#, c-format
msgid ""
"Argument #%d is of type %s, however argument #2 is of type %s. Please make "
"sure all output values have the same type."
msgstr ""

#: fifelse.c:277
msgid ""
"Resulting value has different class than 'default'. Please make sure that "
"both arguments have the same class."
msgstr ""

#: fifelse.c:280
#, c-format
msgid ""
"Argument #%d has different class than argument #2, Please make sure all "
"output values have the same class."
msgstr ""

#: fifelse.c:289
msgid ""
"Resulting value and 'default' are both type factor but their levels are "
"different."
msgstr ""

#: fifelse.c:291
#, c-format
msgid ""
"Argument #2 and argument #%d are both factor but their levels are different."
msgstr ""

#: fifelse.c:300
#, c-format
msgid "Length of 'default' must be 1 or %lld."
msgstr ""

#: fifelse.c:302
#, c-format
msgid ""
"Length of output value #%d (%lld) must either be 1 or match the length of "
"the logical condition (%lld)."
msgstr ""

#: fifelse.c:407
#, c-format
msgid "Type '%s' is not supported."
msgstr ""

#: fmelt.c:18
msgid "'x' must be an integer"
msgstr ""

#: fmelt.c:19
msgid "'n' must be a positive integer"
msgstr ""

#: fmelt.c:41
msgid "Argument to 'which' must be logical"
msgstr ""

#: fmelt.c:65
msgid "concat: 'vec' must be a character vector"
msgstr ""

#: fmelt.c:67
msgid "concat: 'idx' must be an integer vector"
msgstr ""

#: fmelt.c:137
#, c-format
msgid "Unknown 'measure.vars' type %s at index %d of list"
msgstr ""

#: fmelt.c:190
msgid "One or more values in 'measure.vars' is invalid."
msgstr ""

#: fmelt.c:192
msgid "One or more values in 'id.vars' is invalid."
msgstr ""

#: fmelt.c:216
#, c-format
msgid ""
"Unknown 'measure.vars' type %s, must be character or integer vector/list"
msgstr ""

#: fmelt.c:218
#, c-format
msgid "Unknown 'id.vars' type %s, must be character or integer vector"
msgstr ""

#: fmelt.c:243
#, c-format
msgid ""
"id.vars and measure.vars are internally guessed when both are 'NULL'. All "
"non-numeric/integer/logical type columns are considered id.vars, which in "
"this case are columns [%s]. Consider providing at least one of 'id' or "
"'measure' vars in future."
msgstr ""

#: fmelt.c:249
msgid ""
"'measure.vars' is missing. Assigning all columns other than 'id.vars' "
"columns as 'measure.vars'.\n"
msgstr ""

#: fmelt.c:251
#, c-format
msgid "Assigned 'measure.vars' are [%s].\n"
msgstr ""

#: fmelt.c:262
msgid ""
"'id.vars' is missing. Assigning all columns other than 'measure.vars' "
"columns as 'id.vars'.\n"
msgstr ""

#: fmelt.c:263
#, c-format
msgid "Assigned 'id.vars' are [%s].\n"
msgstr ""

#: fmelt.c:317
msgid ""
"When 'measure.vars' is a list, 'value.name' must be a character vector of "
"length =1 or =length(measure.vars)."
msgstr ""

#: fmelt.c:318
msgid ""
"When 'measure.vars' is either not specified or a character/integer vector, "
"'value.name' must be a character vector of length =1."
msgstr ""

#: fmelt.c:321
msgid "'variable.name' must be a character/integer vector of length 1."
msgstr ""

#: fmelt.c:374
msgid ""
"variable_table attribute of measure.vars should be a data table with at "
"least one column"
msgstr ""

#: fmelt.c:379
#, c-format
msgid ""
"variable_table attribute of measure.vars should be a data table with same "
"number of rows as max length of measure.vars vectors =%d"
msgstr ""

#: fmelt.c:383
msgid ""
"variable_table attribute of measure.vars should be either NULL or a data "
"table"
msgstr ""

#: fmelt.c:465
#, c-format
msgid ""
"'measure.vars' [%s] are not all of the same type. By order of hierarchy, the "
"molten data value column will be of type '%s'. All measure variables not of "
"type '%s' will be coerced too. Check DETAILS in ?melt.data.table for more on "
"coercion.\n"
msgstr ""

#: fmelt.c:577
#, c-format
msgid "Unknown column type '%s' for column '%s'."
msgstr ""

#: fmelt.c:684
#, c-format
msgid "variable_table does not support column type '%s' for column '%s'."
msgstr ""

#: fmelt.c:778
#, c-format
msgid "Unknown column type '%s' for column '%s' in 'data'"
msgstr ""

#: fmelt.c:789
msgid "Input is not of type VECSXP, expected a data.table, data.frame or list"
msgstr ""

#: fmelt.c:790
msgid "Argument 'value.factor' should be logical TRUE/FALSE"
msgstr ""

#: fmelt.c:791
msgid "Argument 'variable.factor' should be logical TRUE/FALSE"
msgstr ""

#: fmelt.c:792
msgid "Argument 'na.rm' should be logical TRUE/FALSE."
msgstr ""

#: fmelt.c:793
msgid "Argument 'variable.name' must be a character vector"
msgstr ""

#: fmelt.c:794
msgid "Argument 'value.name' must be a character vector"
msgstr ""

#: fmelt.c:795
msgid "Argument 'verbose' should be logical TRUE/FALSE"
msgstr ""

#: fmelt.c:799
msgid "ncol(data) is 0. Nothing to melt. Returning original data.table."
msgstr ""

#: forder.c:108 utils.c:652
msgid "Internal error in"
msgstr ""

#: forder.c:108 utils.c:652
msgid "Please report to the data.table issues tracker."
msgstr ""

#: forder.c:119
#, c-format
msgid "Failed to realloc thread private group size buffer to %d*4bytes"
msgstr ""

#: forder.c:135
#, c-format
msgid "Failed to realloc group size result to %d*4bytes"
msgstr ""

#: forder.c:270
#, c-format
msgid ""
"Logical error. counts[0]=%d in cradix but should have been decremented to 0. "
"radix=%d"
msgstr ""

#: forder.c:290
msgid "Failed to alloc cradix_counts and/or cradix_tmp"
msgstr ""

#: forder.c:322
#, c-format
msgid "Unable to realloc %d * %d bytes in range_str"
msgstr ""

#: forder.c:404
msgid "Must an integer or numeric vector length 1"
msgstr ""

#: forder.c:405
msgid "Must be 2, 1 or 0"
msgstr ""

#: forder.c:440
msgid "Unknown non-finite value; not NA, NaN, -Inf or +Inf"
msgstr ""

#: forder.c:479
msgid ""
"Input is an atomic vector (not a list of columns) but order= is not a length "
"1 integer"
msgstr ""

#: forder.c:481
#, c-format
msgid "forder.c received a vector type '%s' length %d\n"
msgstr ""

#: forder.c:489
#, c-format
msgid "forder.c received %d rows and %d columns\n"
msgstr ""

#: forder.c:499
#, c-format
msgid "'order' length (%d) is different to by='s length (%d)"
msgstr ""

#: forder.c:512
#, c-format
msgid ""
"Column %d is length %d which differs from length of column 1 (%d), are you "
"attempting to order by a list column?\n"
msgstr ""

#: forder.c:516 forder.c:1688
msgid "retGrp must be TRUE or FALSE"
msgstr ""

#: forder.c:519 forder.c:1691
msgid "retStats must be TRUE or FALSE"
msgstr ""

#: forder.c:522 forder.c:1694
msgid "retStats must be TRUE whenever retGrp is TRUE"
msgstr ""

#: forder.c:524 forder.c:1696
msgid "sort must be TRUE or FALSE"
msgstr ""

#: forder.c:527
msgid "At least one of retGrp= or sort= must be TRUE"
msgstr ""

#: forder.c:529 forder.c:1699
msgid "na.last must be logical TRUE, FALSE or NA of length 1"
msgstr ""

#: forder.c:562 forder.c:680
#, c-format
msgid "Unable to allocate %<PRIu64> bytes of working memory"
msgstr ""

#: forder.c:580
#, c-format
msgid "Item %d of order (ascending/descending) is %d. Must be +1 or -1."
msgstr ""

#: forder.c:611
#, c-format
msgid ""
"\n"
"*** Column %d passed to forder is a date stored as an 8 byte double but no "
"fractions are present. Please consider a 4 byte integer date such as IDate "
"to save space and time.\n"
msgstr ""

#: forder.c:625
#, c-format
msgid "Column %d passed to [f]order is type '%s', not yet supported."
msgstr ""

#: forder.c:804
#, c-format
msgid ""
"Failed to allocate TMP or UGRP or they weren't cache line aligned: nth=%d"
msgstr ""

#: forder.c:813
msgid "Could not allocate (very tiny) group size thread buffers"
msgstr ""

#: forder.c:881
#, c-format
msgid "Timing block %2d%s = %8.3f   %8d\n"
msgstr ""

#: forder.c:932 forder.c:1002 forder.c:1024 forder.c:1131 forder.c:1267 forder.c:1323
#, c-format
msgid "Failed to allocate %d bytes for '%s'."
msgstr ""

#: forder.c:1167
#, c-format
msgid "Failed to allocate parallel counts. my_n=%d, nBatch=%d"
msgstr ""

#: forder.c:1179
#, c-format
msgid "Failed to allocate 'my_otmp' and/or 'my_ktmp' arrays (%d bytes)."
msgstr ""

#: forder.c:1284
#, c-format
msgid "Unable to allocate TMP for my_n=%d items in parallel batch counting"
msgstr ""

#: forder.c:1410 forder.c:1461
#, c-format
msgid "issorted 'by' [%d] out of range [1,%d]"
msgstr ""

#: forder.c:1415
msgid "is.sorted does not work on list columns"
msgstr ""

#: forder.c:1448 forder.c:1478 forder.c:1512
#, c-format
msgid "type '%s' is not yet supported"
msgstr ""

#: forder.c:1525
msgid "x must be either NULL or an integer vector"
msgstr ""

#: forder.c:1527
msgid "nrow must be integer vector length 1"
msgstr ""

#: forder.c:1529
#, c-format
msgid "nrow==%d but must be >=0"
msgstr ""

#: forder.c:1546
msgid "x must be type 'double'"
msgstr ""

#: forder.c:1656
msgid "'datatable.use.index' option must be TRUE or FALSE"
msgstr ""

#: forder.c:1669
msgid "'datatable.forder.auto.index' option must be TRUE or FALSE"
msgstr ""

#: forder.c:1686
msgid "DT is NULL"
msgstr ""

#: forder.c:1702
msgid "order must be integer"
msgstr ""

#: forder.c:1704
msgid "reuseSorting must be logical TRUE, FALSE or NA of length 1"
msgstr ""

#: forder.c:1716
#, c-format
msgid ""
"forderReuseSorting: opt not possible: is.data.table(DT)=%d, sortGroups=%d, "
"all1(ascArg)=%d\n"
msgstr ""

#: forder.c:1735
#, c-format
msgid "forderReuseSorting: using key: %s\n"
msgstr ""

#: forder.c:1770
#, c-format
msgid "forderReuseSorting: index found but not for retGrp and retStats: %s\n"
msgstr ""

#: forder.c:1773
#, c-format
msgid "forderReuseSorting: index found but not for retGrp: %s\n"
msgstr ""

#: forder.c:1776
#, c-format
msgid "forderReuseSorting: index found but not for retStats: %s\n"
msgstr ""

#: forder.c:1783
#, c-format
msgid ""
"forderReuseSorting: index found but na.last=TRUE and no stats available: %s\n"
msgstr ""

#: forder.c:1786
#, c-format
msgid "forderReuseSorting: index found but na.last=TRUE and NAs present: %s\n"
msgstr ""

#: forder.c:1794
#, c-format
msgid "forderReuseSorting: using existing index: %s\n"
msgstr ""

#: forder.c:1806
#, c-format
msgid "forderReuseSorting: setting index (retGrp=%d, retStats=%d) on DT: %s\n"
msgstr ""

#: forder.c:1810
#, c-format
msgid "forderReuseSorting: opt=%d, took %.3fs\n"
msgstr ""

#: frank.c:17 frank.c:196
#, c-format
msgid "Item %d of 'cols' is %d which is outside 1-based range [1,ncol(x)=%d]"
msgstr ""

#: frank.c:28 frank.c:204
#, c-format
msgid ""
"Column %d of input list x is length %d, inconsistent with first column of "
"that item which is length %d."
msgstr ""

#: frank.c:105 frank.c:238 transpose.c:97
#, c-format
msgid "Unsupported column type '%s'"
msgstr ""

#: fread.c:180
#, c-format
msgid "System error %lu unmapping view of file\n"
msgstr ""

#: fread.c:183
#, c-format
msgid "System errno %d unmapping file: %s\n"
msgstr ""

#: fread.c:1407
msgid ""
"Previous fread() session was not cleaned up properly. Cleaned up ok at the "
"beginning of this fread() call.\n"
msgstr ""

#: fread.c:1410
msgid "[01] Check arguments\n"
msgstr ""

#: fread.c:1417
#, c-format
msgid "  Using %d threads (omp_get_max_threads()=%d, nth=%d)\n"
msgstr ""

#: fread.c:1439
#, c-format
msgid "freadMain: NAstring <<%s>> has whitespace at the beginning or end"
msgstr ""

#: fread.c:1443
#, c-format
msgid ""
"freadMain: NAstring <<%s>> is recognized as type boolean, this is not "
"permitted."
msgstr ""

#: fread.c:1445 fread.c:1447
#, c-format
msgid "freadMain: NAstring <<%s>> and %s=TRUE, this is not permitted."
msgstr ""

#: fread.c:1462
msgid "  No NAstrings provided.\n"
msgstr ""

#: fread.c:1469
msgid "  One or more of the NAstrings looks like a number.\n"
msgstr ""

#: fread.c:1471
msgid "  None of the NAstrings look like numbers.\n"
msgstr ""

#: fread.c:1473
#, c-format
msgid "  skip num lines = %<PRId64>\n"
msgstr ""

#: fread.c:1474
#, c-format
msgid "  skip to string = <<%s>>\n"
msgstr ""

#: fread.c:1475
#, c-format
msgid "  show progress = %d\n"
msgstr ""

#: fread.c:1476
#, c-format
msgid "  0/1 column will be read as %s\n"
msgstr ""

#: fread.c:1477
#, c-format
msgid "  Y/N column will be read as %s\n"
msgstr ""

#: fread.c:1490
#, c-format
msgid "sep == quote ('%c') is not allowed"
msgstr ""

#: fread.c:1491
#, c-format
msgid "sep == dec ('%c') is not allowed"
msgstr ""

#: fread.c:1492
#, c-format
msgid "quote == dec ('%c') is not allowed"
msgstr ""

#: fread.c:1509
msgid "[02] Opening the file\n"
msgstr ""

#: fread.c:1512
msgid ""
"  `input` argument is provided rather than a file name, interpreting as raw "
"text to read\n"
msgstr ""

#: fread.c:1519
#, c-format
msgid "  Opening file %s\n"
msgstr ""

#: fread.c:1523
#, c-format
msgid "Couldn't open file %s: %s"
msgstr ""

#: fread.c:1527
#, c-format
msgid "Opened file ok but couldn't obtain its size: %s"
msgstr ""

#: fread.c:1531 fread.c:1567
#, c-format
msgid "File size [%s] exceeds the address space: %s"
msgstr ""

#: fread.c:1534 fread.c:1570
#, c-format
msgid "File is empty: %s"
msgstr ""

#: fread.c:1535 fread.c:1571
#, c-format
msgid "  File opened, size = %s.\n"
msgstr ""

#: fread.c:1556
#, c-format
msgid "File not found: %s"
msgstr ""

#: fread.c:1562
#, c-format
msgid "Unable to open file after %d attempts (error %lu): %s"
msgstr ""

#: fread.c:1564
#, c-format
msgid "GetFileSizeEx failed (returned 0) on file: %s"
msgstr ""

#: fread.c:1573
#, c-format
msgid "This is Windows, CreateFileMapping returned error %lu for file %s"
msgstr ""

#: fread.c:1580
#, c-format
msgid ""
"Opened %s file ok but could not memory map it. This is a %dbit process. %s."
msgstr ""

#: fread.c:1581
msgid "Please upgrade to 64bit"
msgstr ""

#: fread.c:1581
msgid "There is probably not enough contiguous virtual memory available"
msgstr ""

#: fread.c:1584
msgid "  Memory mapped ok\n"
msgstr ""

#: fread.c:1603
msgid "[03] Detect and skip BOM\n"
msgstr ""

#: fread.c:1607
msgid ""
"  UTF-8 byte order mark EF BB BF found at the start of the file and skipped."
"\n"
msgstr ""

#: fread.c:1612
msgid ""
"GB-18030 encoding detected, however fread() is unable to decode it. Some "
"character fields may be garbled.\n"
msgstr ""

#: fread.c:1615
msgid ""
"File is encoded in UTF-16, this encoding is not supported by fread(). Please "
"recode the file to UTF-8."
msgstr ""

#: fread.c:1620
#, c-format
msgid "  Last byte(s) of input found to be %s and removed.\n"
msgstr ""

#: fread.c:1623
msgid "Input is empty or only contains BOM or terminal control characters"
msgstr ""

#: fread.c:1629
msgid "[04] Arrange mmap to be \\0 terminated\n"
msgstr ""

#: fread.c:1658
#, c-format
msgid ""
"  An \\r by itself will be taken as one line ending (counts: %d \\r by "
"themselves vs %d [\\r]*\\n). This happens with old Mac CSV or when there is "
"no \\r at all.\n"
msgstr ""

#: fread.c:1659
#, c-format
msgid ""
"  \\n has been found in the input (counts: %d \\r by themselves vs %d "
"[\\r]*\\n) and different lines can end with different line endings (e.g. "
"mixed \\n and \\r\\n in one file). This is common and ideal.\n"
msgstr ""

#: fread.c:1684
#, c-format
msgid ""
"  File ends abruptly with '%c'. Final end-of-line is missing. Using cow page "
"to write 0 to the last byte.\n"
msgstr ""

#: fread.c:1690
msgid ""
"This file is very unusual: it ends abruptly without a final newline, and "
"also its size is a multiple of 4096 bytes. Please properly end the last row "
"with a newline using for example 'echo >> file'"
msgstr ""

#: fread.c:1692
#, c-format
msgid ""
"  File ends abruptly with '%c'. Final end-of-line is missing. Copying file "
"in RAM. %s.\n"
msgstr ""

#: fread.c:1698 fread.c:2002
#, c-format
msgid "%s. Attempt to copy file in RAM failed."
msgstr ""

#: fread.c:1699 fread.c:2003
#, c-format
msgid "Unable to allocate %s of contiguous virtual RAM."
msgstr ""

#: fread.c:1703 fread.c:2007
#, c-format
msgid "  File copy in RAM took %.3f seconds.\n"
msgstr ""

#: fread.c:1705 fread.c:2009
#, c-format
msgid "Avoidable file copy in RAM took %.3f seconds. %s.\n"
msgstr ""

#: fread.c:1737
msgid "[05] Skipping initial rows if needed\n"
msgstr ""

#: fread.c:1743
#, c-format
msgid ""
"skip='%s' not found in input (it is case sensitive and literal; i.e., no "
"patterns, wildcards or regex)"
msgstr ""

#: fread.c:1749
#, c-format
msgid ""
"Found skip='%s' on line %d. Taking this to be header row or first row of "
"data.\n"
msgstr ""

#: fread.c:1763
#, c-format
msgid "  Skipped to line %d in the file"
msgstr ""

#: fread.c:1777
msgid ""
"Input is either empty, fully whitespace, or skip has been set after the last "
"non-whitespace."
msgstr ""

#: fread.c:1779
#, c-format
msgid "  Moved forward to first non-blank line (%d)\n"
msgstr ""

#: fread.c:1780
#, c-format
msgid "  Positioned on line %d starting: <<%s>>\n"
msgstr ""

#: fread.c:1803
msgid "[06] Detect separator, quoting rule, and ncolumns\n"
msgstr ""

#: fread.c:1807
msgid ""
"  sep='\\n' passed in meaning read lines as single character column\n"
msgstr ""

#: fread.c:1826
msgid "  Detecting sep automatically ...\n"
msgstr ""

#: fread.c:1833
#, c-format
msgid "  Using supplied sep '%s'\n"
msgstr ""

#: fread.c:1867
#, c-format
msgid "  sep=%#02x  with %d fields using quote rule %d\n"
msgstr ""

#: fread.c:1868
#, c-format
msgid "  sep='%c'  with %d fields using quote rule %d\n"
msgstr ""

#: fread.c:1934
#, c-format
msgid "  sep=%#02x  with %d lines of %d fields using quote rule %d\n"
msgstr ""

#: fread.c:1935
#, c-format
msgid "  sep='%c'  with %d lines of %d fields using quote rule %d\n"
msgstr ""

#: fread.c:1943
msgid ""
"  No sep and quote rule found a block of 2x2 or greater. Single column input."
"\n"
msgstr ""

#: fread.c:1959
msgid ""
"Single column input contains invalid quotes. Self healing only effective "
"when ncol>1"
msgstr ""

#: fread.c:1964
#, c-format
msgid ""
"Found and resolved improper quoting in first %d rows. If the fields are not "
"quoted (e.g. field separator does not appear within any field), try quote=\""
"\" to avoid this warning."
msgstr ""

#: fread.c:1985
#, c-format
msgid ""
"  Detected %d columns on line %d. This line is either column names or first "
"data row. Line starts as: <<%s>>\n"
msgstr ""

#: fread.c:1987
#, c-format
msgid "  Quote rule picked = %d\n"
msgstr ""

#: fread.c:1988
#, c-format
msgid "  fill=%s and the most number of columns found is %d\n"
msgstr ""

#: fread.c:1994
msgid ""
"This file is very unusual: it's one single column, ends with 2 or more end-"
"of-line (representing several NA at the end), and the file size is a "
"multiple of 4096, too"
msgstr ""

#: fread.c:1996
#, c-format
msgid "  Copying file in RAM. %s\n"
msgstr ""

#: fread.c:2013
msgid ""
"  1-column file ends with 2 or more end-of-line. Restoring last eol using "
"extra byte in cow page.\n"
msgstr ""

#: fread.c:2032
msgid ""
"[07] Detect column types, dec, good nrow estimate and whether first row is "
"column names\n"
msgstr ""

#: fread.c:2033
#, c-format
msgid "  'header' changed by user from 'auto' to %s\n"
msgstr ""

#: fread.c:2039
#, c-format
msgid "Failed to allocate 2 x %d bytes for type and tmpType: %s"
msgstr ""

#: fread.c:2044
msgid "  sep=',' so dec set to '.'\n"
msgstr ""

#: fread.c:2069
#, c-format
msgid ""
"  Number of sampling jump points = %d because nrow limit (%<PRId64>) "
"supplied\n"
msgstr ""

#: fread.c:2071
#, c-format
msgid "  Number of sampling jump points = %d because jump0size==0\n"
msgstr ""

#: fread.c:2073
#, c-format
msgid ""
"  Number of sampling jump points = %d because (%td bytes from row 1 to "
"eof) / (2 * %td jump0size) == %td\n"
msgstr ""

#: fread.c:2129
#, c-format
msgid ""
"  A line with too-few fields (%d/%d) was found on line %d of sample jump %d. "
"%s\n"
msgstr ""

#: fread.c:2130
#, c-format
msgid ""
"  A line with too-many fields (%d/%d) was found on line %d of sample jump "
"%d. %s\n"
msgstr ""

#: fread.c:2131
msgid ""
"Most likely this jump landed awkwardly so type bumps here will be skipped."
msgstr ""

#: fread.c:2154 fread.c:2180
#, c-format
msgid "  dec='%c' detected based on a balance of %d parsed fields\n"
msgstr ""

#: fread.c:2164
#, c-format
msgid "  Type codes (jump %03d)    : %s  Quote rule %d\n"
msgstr ""

#: fread.c:2186
#, c-format
msgid ""
"  'header' determined to be true due to column %d containing a string on row "
"1 and a lower type (%s) in the rest of the %<PRId64> sample rows\n"
msgstr ""

#: fread.c:2200
#, c-format
msgid ""
"Types in 1st data row match types in 2nd data row but previous row has %d "
"fields. Taking previous row as column names."
msgstr ""

#: fread.c:2204
#, c-format
msgid ""
"Detected %d column names but the data has %d columns (i.e. invalid file). "
"Added an extra default column name for the first column which is guessed to "
"be row names or an index. Use setnames() afterwards if this guess is not "
"correct, or fix the file write command that created the file to create a "
"valid file.\n"
msgstr ""

#: fread.c:2207
#, c-format
msgid ""
"Detected %d column names but the data has %d columns (i.e. invalid file). "
"Added %d extra default column names at the end.\n"
msgstr ""

#: fread.c:2211
#, c-format
msgid ""
"Detected %d column names but the data has %d columns. Filling rows "
"automatically. Set fill=TRUE explicitly to avoid this warning.\n"
msgstr ""

#: fread.c:2215
#, c-format
msgid "Failed to realloc 2 x %d bytes for type and tmpType: %s"
msgstr ""

#: fread.c:2236
msgid ""
"  'header' determined to be TRUE because there are no number fields in the "
"first and only row\n"
msgstr ""

#: fread.c:2238
msgid ""
"  'header' determined to be FALSE because there are number fields in the "
"first and only row\n"
msgstr ""

#: fread.c:2241
msgid ""
"  'header' determined to be true because all columns are type string and a "
"better guess is not possible\n"
msgstr ""

#: fread.c:2243
msgid ""
"  'header' determined to be false because there are some number columns and "
"those columns do not have a string field at the top of them\n"
msgstr ""

#: fread.c:2259
#, c-format
msgid "  Type codes (first row)   : %s  Quote rule %d\n"
msgstr ""

#: fread.c:2268
#, c-format
msgid ""
"  All rows were sampled since file is small so we know nrow=%<PRId64> "
"exactly\n"
msgstr ""

#: fread.c:2281
#, c-format
msgid ""
"  Sampled %<PRId64> rows (handled \\n inside quoted fields) at %d jump "
"points\n"
msgstr ""

#: fread.c:2282
#, c-format
msgid "  Bytes from first data row on line %d to the end of last row: %td\n"
msgstr ""

#: fread.c:2283
#, c-format
msgid "  Line length: mean=%.2f sd=%.2f min=%d max=%d\n"
msgstr ""

#: fread.c:2284
#, c-format
msgid "  Estimated number of rows: %td / %.2f = %<PRId64>\n"
msgstr ""

#: fread.c:2285
#, c-format
msgid ""
"  Initial alloc = %<PRId64> rows (%<PRId64> + %d%%) using bytes/max(mean-"
"2*sd,min) clamped between [1.1*estn, 2.0*estn]\n"
msgstr ""

#: fread.c:2292
#, c-format
msgid "  Alloc limited to lower nrows=%<PRId64> passed in.\n"
msgstr ""

#: fread.c:2304
msgid "[08] Assign column names\n"
msgstr ""

#: fread.c:2313
#, c-format
msgid "Unable to allocate %d*%d bytes for column name pointers: %s"
msgstr ""

#: fread.c:2361
msgid "[09] Apply user overrides on column types\n"
msgstr ""

#: fread.c:2365
msgid "  Cancelled by user: userOverride() returned false."
msgstr ""

#: fread.c:2376
#, c-format
msgid "Failed to allocate %zu bytes for '%s': %s"
msgstr ""

#: fread.c:2383
#, c-format
msgid ""
"Attempt to override column %d%s%.*s%s of inherent type '%s' down to '%s' "
"ignored. Only overrides to a higher type are currently supported. If this "
"was intended, please coerce to the lower type afterwards."
msgstr ""

#: fread.c:2398
#, c-format
msgid "  After %d type and %d drop user overrides : %s\n"
msgstr ""

#: fread.c:2406
msgid "[10] Allocate memory for the datatable\n"
msgstr ""

#: fread.c:2407
#, c-format
msgid "  Allocating %d column slots (%d - %d dropped) with %<PRId64> rows\n"
msgstr ""

#: fread.c:2462
#, c-format
msgid "Buffer size %<PRId64> is too large\n"
msgstr ""

#: fread.c:2465
msgid "[11] Read the data\n"
msgstr ""

#: fread.c:2713
#, c-format
msgid ""
"Column %d%s%.*s%s bumped from '%s' to '%s' due to <<%.*s>> on row %<PRId64>\n"
msgstr ""

#: fread.c:2839
#, c-format
msgid "  Provided number of fill columns: %d but only found %d\n"
msgstr ""

#: fread.c:2840
#, c-format
msgid "  Dropping %d overallocated columns\n"
msgstr ""

#: fread.c:2844
#, c-format
msgid "Failed to allocate %zu bytes for '%s'."
msgstr ""

#: fread.c:2857
#, c-format
msgid ""
"Internal error in %s: %s. Please report to the data.table issues tracker"
msgstr ""

#: fread.c:2864
#, c-format
msgid ""
"  Too few rows allocated. Allocating additional %<PRId64> rows (now nrows="
"%<PRId64>) and continue reading from jump %d\n"
msgstr ""

#: fread.c:2871
#, c-format
msgid "  Restarting team from jump %d. nSwept==%d quoteRule==%d\n"
msgstr ""

#: fread.c:2891
#, c-format
msgid "  %d out-of-sample type bumps: %s\n"
msgstr ""

#: fread.c:2928
#, c-format
msgid ""
"Read %<PRIu64> rows x %d columns from %s file in %02d:%06.3f wall clock "
"time\n"
msgstr ""

#: fread.c:2935
msgid "[12] Finalizing the datatable\n"
msgstr ""

#: fread.c:2936
msgid "  Type counts:\n"
msgstr ""

#: fread.c:2938
#, c-format
msgid "%10d : %-9s '%c'\n"
msgstr ""

#: fread.c:2954
#, c-format
msgid "Discarded single-line footer: <<%s>>"
msgstr ""

#: fread.c:2960
#, c-format
msgid ""
"Stopped early on line %<PRId64>. Expected %d fields but found %d. Consider "
"fill=%d or even more based on your knowledge of the input file. Use fill=Inf "
"for reading the whole file for detecting the number of fields. First "
"discarded non-empty line: <<%s>>"
msgstr ""

#: fread.c:2963
#, c-format
msgid ""
"Stopped early on line %<PRId64>. Expected %d fields but found %d. Consider "
"fill=TRUE. First discarded non-empty line: <<%s>>"
msgstr ""

#: fread.c:2976
#, c-format
msgid "%8.3fs (%3.0f%%) Memory map %.3fGiB file\n"
msgstr ""

#: fread.c:2979
#, c-format
msgid " ncol=%d and header detection\n"
msgstr ""

#: fread.c:2980
#, c-format
msgid "%8.3fs (%3.0f%%) Column type detection using %<PRId64> sample rows\n"
msgstr ""

#: fread.c:2982
#, c-format
msgid ""
"%8.3fs (%3.0f%%) Allocation of %<PRId64> rows x %d cols (%.3fGiB) of which "
"%<PRId64> (%3.0f%%) rows used\n"
msgstr ""

#: fread.c:2986
#, c-format
msgid ""
"%8.3fs (%3.0f%%) Reading %d chunks (%d swept) of %.3fMiB (each chunk "
"%<PRId64> rows) using %d threads\n"
msgstr ""

#: fread.c:2988
#, c-format
msgid ""
"   + %8.3fs (%3.0f%%) Parse to row-major thread buffers (grown %d times)\n"
msgstr ""

#: fread.c:2989
#, c-format
msgid "   + %8.3fs (%3.0f%%) Transpose\n"
msgstr ""

#: fread.c:2990
#, c-format
msgid "   + %8.3fs (%3.0f%%) Waiting\n"
msgstr ""

#: fread.c:2991
#, c-format
msgid ""
"%8.3fs (%3.0f%%) Rereading %d columns due to out-of-sample type exceptions\n"
msgstr ""

#: fread.c:2993
#, c-format
msgid "%8.3fs        Total\n"
msgstr ""

#: freadR.c:96
#, c-format
msgid "freadR.c has been passed a filename: %s\n"
msgstr ""

#: freadR.c:100
msgid "freadR.c has been passed the data as text input (not a filename)\n"
msgstr ""

#: freadR.c:118
msgid "quote= must be a single character, blank \"\", or FALSE"
msgstr ""

#: freadR.c:175
msgid "'integer64' must be a single character string"
msgstr ""

#: freadR.c:183
#, c-format
msgid ""
"Invalid value integer64='%s'. Must be 'integer64', 'character', 'double' or "
"'numeric'"
msgstr ""

#: freadR.c:193
msgid "Use either select= or drop= but not both."
msgstr ""

#: freadR.c:196
msgid ""
"select= is type list for specifying types in select=, but colClasses= has "
"been provided as well. Please remove colClasses=."
msgstr ""

#: freadR.c:198
msgid ""
"select= is type list but has no names; expecting list(type1=cols1, "
"type2=cols2, ...)"
msgstr ""

#: freadR.c:205
msgid ""
"select= is a named vector specifying the columns to select and their types, "
"but colClasses= has been provided as well. Please remove colClasses=."
msgstr ""

#: freadR.c:213 freadR.c:379
msgid "colClasses is type list but has no names"
msgstr ""

#: freadR.c:223
#, c-format
msgid "encoding='%s' invalid. Must be 'unknown', 'Latin-1' or 'UTF-8'"
msgstr ""

#: freadR.c:248
#, c-format
msgid "Column name '%s' (%s) not found"
msgstr ""

#: freadR.c:250
#, c-format
msgid "%s is NA"
msgstr ""

#: freadR.c:252
#, c-format
msgid "%s is %d which is out of range [1,ncol=%d]"
msgstr ""

#: freadR.c:299
#, c-format
msgid ""
"Column name '%s' not found in column name header (case sensitive), skipping."
msgstr ""

#: freadR.c:309
#, c-format
msgid ""
"Column number %d (select[%d]) is negative but should be in the range [1,ncol="
"%d]. Consider drop= for column exclusion."
msgstr ""

#: freadR.c:310
#, c-format
msgid ""
"select = 0 (select[%d]) has no meaning. All values of select should be in "
"the range [1,ncol=%d]."
msgstr ""

#: freadR.c:311
#, c-format
msgid ""
"Column number %d (select[%d]) is too large for this table, which only has %d "
"columns."
msgstr ""

#: freadR.c:312
#, c-format
msgid "Column number %d ('%s') has been selected twice by select="
msgstr ""

#: freadR.c:335
#, c-format
msgid ""
"colClasses= is an unnamed vector of types, length %d, but there are %d "
"columns in the input. To specify types for a subset of columns, you can use "
"a named vector, list format, or specify types using select= instead of "
"colClasses=. Please see examples in ?fread."
msgstr ""

#: freadR.c:377
#, c-format
msgid "colClasses is type '%s' but should be list or character"
msgstr ""

#: freadR.c:401
#, c-format
msgid "Column name '%s' (colClasses[[%d]][%d]) not found"
msgstr ""

#: freadR.c:403
#, c-format
msgid "colClasses[[%d]][%d] is NA"
msgstr ""

#: freadR.c:407
#, c-format
msgid "Column number %d (colClasses[[%d]][%d]) is out of range [1,ncol=%d]"
msgstr ""

#: freadR.c:411
#, c-format
msgid ""
"Column %d ('%s') appears more than once in colClasses. The second time is "
"colClasses[[%d]][%d]."
msgstr ""

#: freadR.c:653
#, c-format
msgid "Field size is 1 but the field is of type %d\n"
msgstr ""

#: froll.c:28
#, c-format
msgid "%s: window width longer than input vector, returning all NA vector\n"
msgstr ""

#: froll.c:100
#, c-format
msgid "%s: align %d, shift answer by %d\n"
msgstr ""

#: froll.c:107 frolladaptive.c:75
#, c-format
msgid "%s: processing fun %d algo %u took %.3fs\n"
msgstr ""

#: froll.c:173 froll.c:363 froll.c:540 froll.c:747 froll.c:986 froll.c:1153 froll.c:1505
#, c-format
msgid "%s: running for input length %<PRIu64>, window %d, hasnf %d, narm %d\n"
msgstr ""

#: froll.c:176 froll.c:239
#, c-format
msgid "%s: window width of size 0, returning all NaN vector\n"
msgstr ""

#: froll.c:236 froll.c:424 froll.c:636 froll.c:840 froll.c:1072 froll.c:1767
#, c-format
msgid ""
"%s: running in parallel for input length %<PRIu64>, window %d, hasnf %d, "
"narm %d\n"
msgstr ""

#: froll.c:366 froll.c:427
#, c-format
msgid "%s: window width of size 0, returning all 0 vector\n"
msgstr ""

#: froll.c:543 froll.c:639
#, c-format
msgid "%s: window width of size 0, returning all -Inf vector\n"
msgstr ""

#: froll.c:626
#, c-format
msgid "%s: nested window max calculation called %<PRIu64> times\n"
msgstr ""

#: froll.c:750 froll.c:843
#, c-format
msgid "%s: window width of size 0, returning all +Inf vector\n"
msgstr ""

#: froll.c:833
#, c-format
msgid "%s: nested window min calculation called %<PRIu64> times\n"
msgstr ""

#: froll.c:989 froll.c:1075
#, c-format
msgid "%s: window width of size 0, returning all 1 vector\n"
msgstr ""

#: froll.c:1156 froll.c:1222
#, c-format
msgid "%s: window width of size %d, returning all NA vector\n"
msgstr ""

#: froll.c:1209
#, c-format
msgid ""
"%s: non-finite values are present in input, redirecting to frollvarExact "
"using has.nf=TRUE\n"
msgstr ""

#: froll.c:1219
#, c-format
msgid ""
"%s: running %s for input length %<PRIu64>, window %d, hasnf %d, narm %d\n"
msgstr ""

#: froll.c:1324
#, c-format
msgid "%s: calling sqrt(frollvarFast(...))\n"
msgstr ""

#: froll.c:1335
#, c-format
msgid "%s: calling sqrt(frollvarExact(...))\n"
msgstr ""

#: froll.c:1508 froll.c:1770
#, c-format
msgid "%s: window width of size 0, returning all NA vector\n"
msgstr ""

#: froll.c:1516
#, c-format
msgid "%s: window width of size %d, skip median and use simple loop\n"
msgstr ""

#: froll.c:1555
#, c-format
msgid "%s: NAs detected, fall back to frollmedianExact\n"
msgstr ""

#: froll.c:1567
#, c-format
msgid ""
"%s: nx=%<PRIu64> is not multiple of k=%d, padding with %d elements, new nx="
"%<PRIu64>\n"
msgstr ""

#: froll.c:1628
#, c-format
msgid ""
"%s: finding order and initializing links for %d blocks in parallel took %."
"3fs\n"
msgstr ""

#: froll.c:1629
#, c-format
msgid ""
"%s: finding order and initializing links for %d blocks sequentially took %."
"3fs\n"
msgstr ""

#: froll.c:1639
#, c-format
msgid ""
"%s: running implementation as described in the paper by Jukka Suomela, for "
"uneven window size, length of input a multiple of window size, no NAs in the "
"input data\n"
msgstr ""

#: froll.c:1689
#, c-format
msgid "%s: skip rolling for %d padded elements\n"
msgstr ""

#: froll.c:1722
#, c-format
msgid "%s: rolling took %.3f\n"
msgstr ""

#: froll.c:1819 frolladaptive.c:992
#, c-format
msgid "%s: no NAs detected, redirecting to itself using has.nf=FALSE\n"
msgstr ""

#: frollR.c:18
msgid ""
"'x' must be of type numeric or logical, or a list, data.frame or data.table "
"of such"
msgstr ""

#: frollR.c:31
msgid "'n' must be an integer, list is accepted for adaptive TRUE"
msgstr ""

#: frollR.c:37
msgid "'n' must be an integer"
msgstr ""

#: frollR.c:44 frollR.c:74
msgid "'n' must be non-negative integer values (>= 0)"
msgstr ""

#: frollR.c:53 frollR.c:64
msgid "'n' must be an integer vector or list of integer vectors"
msgstr ""

#: frollR.c:94
msgid "n must be non 0 length"
msgstr ""

#: frollR.c:115
msgid "has.nf must be TRUE, FALSE or NA"
msgstr ""

#: frollR.c:117
msgid ""
"using has.nf FALSE and na.rm TRUE does not make sense, if you know there are "
"non-finite values then use has.nf TRUE, otherwise leave it as default NA"
msgstr ""

#: frollR.c:130
msgid "using adaptive TRUE and align 'center' is not implemented"
msgstr ""

#: frollR.c:134
#, c-format
msgid "%s: allocating memory for results %dx%d\n"
msgstr ""

#: frollR.c:143
msgid ""
"adaptive rolling function can only process 'x' having equal length of "
"elements, like data.table or data.frame; If you want to call rolling "
"function on list having variable length of elements call it for each field "
"separately"
msgstr ""

#: frollR.c:145
msgid ""
"length of integer vector(s) provided as list to 'n' argument must be equal "
"to number of observations provided in 'x'"
msgstr ""

#: frollR.c:175 gsumm.c:1204 shift.c:21
msgid "fill must be a vector of length 1"
msgstr ""

#: frollR.c:177
msgid "fill must be numeric or logical"
msgstr ""

#: frollR.c:199
#, c-format
msgid "%s: computing %d column(s) and %d window(s) in parallel\n"
msgstr ""

#: frollR.c:201
#, c-format
msgid ""
"%s: computing %d column(s) and %d window(s) sequentially because "
"algo='exact' is already parallelised within each rolling computation\n"
msgstr ""

#: frollR.c:203
#, c-format
msgid ""
"%s: computing %d column(s) and %d window(s) sequentially because "
"adaptive=TRUE is already parallelised within each rolling computation\n"
msgstr ""

#: frollR.c:205
#, c-format
msgid ""
"%s: computing %d column(s) and %d window(s) sequentially as there is only "
"single rolling computation\n"
msgstr ""

#: frollR.c:222
#, c-format
msgid "%s: processing of %d column(s) and %d window(s) took %.3fs\n"
msgstr ""

#: frollR.c:234
msgid "'n' must not have NAs"
msgstr ""

#: frollR.c:236
msgid "'n' must be positive integer values (>= 1)"
msgstr ""

#: frollR.c:241 frollR.c:244
msgid "index provided to 'x' must: be sorted, have no duplicates, have no NAs"
msgstr ""

#: frolladaptive.c:32 frolladaptive.c:39 frolladaptive.c:46 frolladaptive.c:53 frolladaptive.c:60 frolladaptive.c:67
#, c-format
msgid "%s: algo %u not implemented, fall back to %u\n"
msgstr ""

#: frolladaptive.c:118 frolladaptive.c:341
#, c-format
msgid "%s: running for input length %<PRIu64>, hasnf %d, narm %d\n"
msgstr ""

#: frolladaptive.c:216 frolladaptive.c:437 frolladaptive.c:512 frolladaptive.c:587 frolladaptive.c:673 frolladaptive.c:747 frolladaptive.c:929
#, c-format
msgid "%s: running in parallel for input length %<PRIu64>, hasnf %d, narm %d\n"
msgstr ""

#: frolladaptive.c:851
#, c-format
msgid "%s: calling sqrt(frolladaptivevarExact(...))\n"
msgstr ""

#: frolladaptive.c:937
#, c-format
msgid "%s: adaptive window width of size 0, returning all NA vector\n"
msgstr ""

#: fsort.c:104
msgid "Reduced MSBsize from %zu to %zu by excluding 0 and 1 counts\n"
msgstr ""

#: fsort.c:119
msgid "x must be a vector of type double currently"
msgstr ""

#: fsort.c:145
#, c-format
msgid "Failed to allocate %d bytes in fsort()."
msgstr ""

#: fsort.c:171
#, c-format
msgid "Range = [%g,%g]\n"
msgstr ""

#: fsort.c:172
msgid "Cannot yet handle negatives."
msgstr ""

#: fsort.c:194
#, c-format
msgid ""
"counts is %dMiB (%d pages per nBatch=%d, batchSize=%<PRIu64>, lastBatchSize="
"%<PRIu64>)\n"
msgstr ""

#: fsort.c:264
msgid "Top 20 MSB counts: "
msgstr ""

#: fsort.c:264
#, c-format
msgid "%<PRId64> "
msgstr ""

#: fsort.c:331
#, c-format
msgid ""
"OpenMP %d did not assign threads to iterations monotonically. Please search "
"Stack Overflow for this message."
msgstr ""

#: fsort.c:333
msgid "Unable to allocate working memory"
msgstr ""

#: fsort.c:343
#, c-format
msgid "%d: %.3f (%4.1f%%)\n"
msgstr ""

#: fwrite.c:641
msgid ""
"Compression in fwrite uses zlib library. Its header files were not found at "
"the time data.table was compiled. To enable fwrite compression, please "
"reinstall data.table and study the output for further guidance."
msgstr ""

#: fwrite.c:657
#, c-format
msgid ""
"eol must be 1 or more bytes (usually either \\n or \\r\\n) but is length %d"
msgstr ""

#: fwrite.c:660
msgid "Column writers: "
msgstr ""

#: fwrite.c:706
#, c-format
msgid "type %d has no max length method implemented"
msgstr ""

#: fwrite.c:718
#, c-format
msgid "maxLineLen=%<PRIu64>. Found in %.3fs\n"
msgstr ""

#: fwrite.c:737
#, c-format
msgid ""
"%s: '%s'. Failed to open existing file for writing. Do you have write "
"permission to it? Is this Windows and does another process such as Excel "
"have it open?"
msgstr ""

#: fwrite.c:738
#, c-format
msgid ""
"%s: '%s'. Unable to create new file for writing (it does not exist already). "
"Do you have permission to write here, is there space on the disk and does "
"the path exist?"
msgstr ""

#: fwrite.c:746
#, c-format
msgid "Writing bom (%s), yaml (%d characters) and column names (%s)\n"
msgstr ""

#: fwrite.c:798
#, c-format
msgid ""
"Writing %<PRId64> rows in %d batches of %d rows, each buffer size %zu bytes ("
"%zu MiB), showProgress=%d, nth=%d\n"
msgstr ""

#: fwrite.c:806
msgid "Allocate %zu bytes (%zu MiB) for buffPool\n"
msgstr ""

#: fwrite.c:810
#, c-format
msgid ""
"Unable to allocate %zu MiB * %d thread buffers; '%d: %s'. Please read ?"
"fwrite for nThread, buffMB and verbose options."
msgstr ""

#: fwrite.c:826
msgid "Can't init stream structure for deflateBound"
msgstr ""

#: fwrite.c:831
#, c-format
msgid "zbuffSize=%d returned from deflateBound\n"
msgstr ""

#: fwrite.c:837
msgid "Allocate %zu bytes (%zu MiB) for zbuffPool\n"
msgstr ""

#: fwrite.c:844
#, c-format
msgid ""
"Unable to allocate %zu MiB * %d thread compressed buffers; '%d: %s'. Please "
"read ?fwrite for nThread, buffMB and verbose options."
msgstr ""

#: fwrite.c:864
#, c-format
msgid "Failed to write gzip header. Write returned %d"
msgstr ""

#: fwrite.c:939
#, c-format
msgid "Failed to compress gzip. compressbuff() returned %d"
msgstr ""

#: fwrite.c:940 fwrite.c:963
#, c-format
msgid "%s: '%s'"
msgstr ""

#: fwrite.c:952
#, c-format
msgid "Initialization done in %.3fs\n"
msgstr ""

#: fwrite.c:957
msgid "No data rows present (nrow==0)\n"
msgstr ""

#: fwrite.c:1132
msgid "Failed to write gzip trailer"
msgstr ""

#: fwrite.c:1151
#, c-format
msgid ""
"zlib: uncompressed length=%zu (%zu MiB), compressed length=%zu (%zu MiB), "
"ratio=%.1f%%, crc=%x\n"
msgstr ""

#: fwrite.c:1172
#, c-format
msgid ""
"zlib %s (zlib.h %s) deflate() returned error %d Z_FINISH=%d Z_BLOCK=%d. %s"
msgstr ""

#: fwrite.c:1174
msgid ""
"Please include the full output above and below this message in your data."
"table bug report."
msgstr ""

#: fwrite.c:1175
msgid ""
"Please retry fwrite() with verbose=TRUE and include the full output with "
"your data.table bug report."
msgstr ""

#: fwriteR.c:103
#, c-format
msgid ""
"Row %<PRId64> of list column is type '%s' - not yet implemented. fwrite() "
"can write list columns containing items which are atomic vectors of type "
"logical, integer, integer64, double, complex and character."
msgstr ""

#: fwriteR.c:179
msgid ""
"fwrite must be passed an object of type list; e.g. data.frame, data.table"
msgstr ""

#: fwriteR.c:191
msgid "fwrite was passed an empty list of no columns. Nothing to write."
msgstr ""

#: fwriteR.c:245
#, c-format
msgid ""
"Column %d's length (%d) is not the same as column 1's length (%<PRId64>)"
msgstr ""

#: fwriteR.c:249
#, c-format
msgid "Column %d's type is '%s' - not yet implemented in fwrite."
msgstr ""

#: fwriteR.c:272
#, c-format
msgid ""
"input has specific integer rownames but their length (%lld) != nrow ("
"%<PRId64>)"
msgstr ""

#: fwriteR.c:287
msgid ""
"No list columns are present. Setting sep2='' otherwise quote='auto' would "
"quote fields containing sep2.\n"
msgstr ""

#: fwriteR.c:291
#, c-format
msgid ""
"If quote='auto', fields will be quoted if the field contains either sep ("
"'%c') or sep2 ('%c') because column %d is a list column.\n"
msgstr ""

#: fwriteR.c:295
#, c-format
msgid ""
"sep ('%c'), sep2 ('%c') and dec ('%c') must all be different. Column %d is a "
"list column."
msgstr ""

#: gsumm.c:50 gsumm.c:51 gsumm.c:52
#, c-format
msgid "%s is not an integer vector"
msgstr ""

#: gsumm.c:61
msgid "irowsArg is neither an integer vector nor NULL"
msgstr ""

#: gsumm.c:72
#, c-format
msgid "o has length %d but sum(l)=%d"
msgstr ""

#: gsumm.c:104
#, c-format
msgid "gforce initial population of grp took %.3f\n"
msgstr ""

#: gsumm.c:124
msgid "Failed to allocate counts or TMP when assigning g in gforce"
msgstr ""

#: gsumm.c:203
#, c-format
msgid "gforce assign high and low took %.3f\n"
msgstr ""

#: gsumm.c:209
#, c-format
msgid "gforce eval took %.3f\n"
msgstr ""

#: gsumm.c:342
#, c-format
msgid "gather implemented for INTSXP, REALSXP, and CPLXSXP but not '%s'"
msgstr ""

#: gsumm.c:344
#, c-format
msgid "gather took %.3fs\n"
msgstr ""

#: gsumm.c:354 gsumm.c:585 gsumm.c:736 gsumm.c:874 gsumm.c:1029 gsumm.c:1123
#, c-format
msgid "%s is not meaningful for factors."
msgstr ""

#: gsumm.c:358
#, c-format
msgid "This gsum (narm=%s) took ... "
msgstr ""

#: gsumm.c:359 gsumm.c:593 gsumm.c:741 gsumm.c:877 gsumm.c:929 gsumm.c:1031 gsumm.c:1127
#, c-format
msgid "nrow [%d] != length(x) [%d] in %s"
msgstr ""

#: gsumm.c:413
msgid ""
"The sum of an integer column for a group was more than type 'integer' can "
"hold so the result has been coerced to 'numeric' automatically for "
"convenience."
msgstr ""

#: gsumm.c:574 gsumm.c:849 gsumm.c:915 gsumm.c:1100 gsumm.c:1172
#, c-format
msgid ""
"Type '%s' is not supported by GForce %s. Either add the prefix %s or turn "
"off GForce optimization using options(datatable.optimize=1)"
msgstr ""

#: gsumm.c:577 gsumm.c:725
#, c-format
msgid "%.3fs\n"
msgstr ""

#: gsumm.c:592
#, c-format
msgid "This gmean took (narm=%s) ... "
msgstr ""

#: gsumm.c:630 gsumm.c:686
#, c-format
msgid "Unable to allocate %d * %zu bytes for non-NA counts in gmean na.rm=TRUE"
msgstr ""

#: gsumm.c:722
#, c-format
msgid ""
"Type '%s' not supported by GForce mean (gmean). Either add the prefix base::"
"mean(.) or turn off GForce optimization using options(datatable.optimize=1)"
msgstr ""

#: gsumm.c:734
msgid ""
"GForce min/max can only be applied to columns, not .SD or similar. To find "
"min/max of all items in a list such as .SD, either add the prefix base::min(."
"SD) or turn off GForce optimization using options(datatable.optimize=1). "
"More likely, you may be looking for 'DT[,lapply(.SD,min),by=,.SDcols=]'"
msgstr ""

#: gsumm.c:846
msgid "Type 'complex' has no well-defined min/max"
msgstr ""

#: gsumm.c:872
msgid ""
"GForce median can only be applied to columns, not .SD or similar. To find "
"median of all items in a list such as .SD, either add the prefix stats::"
"median(.SD) or turn off GForce optimization using options(datatable."
"optimize=1). More likely, you may be looking for 'DT[,lapply(.SD,median),"
"by=,.SDcols=]'"
msgstr ""

#: gsumm.c:989
#, c-format
msgid ""
"Type '%s' is not supported by GForce head/tail/first/last/`[`. Either add "
"the namespace prefix (e.g. utils::head(.)) or turn off GForce optimization "
"using options(datatable.optimize=1)"
msgstr ""

#: gsumm.c:1027
msgid ""
"GForce var/sd can only be applied to columns, not .SD or similar. For the "
"full covariance matrix of all items in a list such as .SD, either add the "
"prefix stats::var(.SD) (or stats::sd(.SD)) or turn off GForce optimization "
"using options(datatable.optimize=1). Alternatively, if you only need the "
"diagonal elements, 'DT[,lapply(.SD,var),by=,.SDcols=]' is the optimized way "
"to do this."
msgstr ""

#: gsumm.c:1121
msgid ""
"GForce prod can only be applied to columns, not .SD or similar. To multiply "
"all items in a list such as .SD, either add the prefix base::prod(.SD) or "
"turn off GForce optimization using options(datatable.optimize=1). More "
"likely, you may be looking for 'DT[,lapply(.SD,prod),by=,.SDcols=]'"
msgstr ""

#: gsumm.c:1130
#, c-format
msgid "Unable to allocate %d * %zu bytes for gprod"
msgstr ""

#: gsumm.c:1221 shift.c:34
#, c-format
msgid "Item %d of n is NA"
msgstr ""

#: gsumm.c:1278
#, c-format
msgid ""
"Type '%s' is not supported by GForce gshift. Either add the namespace prefix "
"(e.g. data.table::shift(.)) or turn off GForce optimization using "
"options(datatable.optimize=1)"
msgstr ""

#: idatetime.c:124 vecseq.c:14
msgid "x must be an integer vector"
msgstr ""

#: idatetime.c:170
msgid ""
"The default behavior of week() is changing. Previously ('legacy' mode), week "
"numbers advanced every 7th day of the year. The new 'sequential' mode "
"ensures the first week always has 7 days. For example, as.IDate('2023-01-"
"07') returns week 2 in legacy mode but week 1 in sequential mode (week 2 "
"starts on '2023-01-08'). To adopt the new behavior now, set "
"options(datatable.week = 'sequential'). To keep the old results and silence "
"this warning, set options(datatable.week = 'legacy'). See https://github.com/"
"Rdatatable/data.table/issues/2611"
msgstr ""

#: ijoin.c:128
#, c-format
msgid "First pass on calculating lengths in lookup ... done in %8.3f seconds\n"
msgstr ""

#: ijoin.c:141
#, c-format
msgid "Second pass on allocation in lookup ... done in %8.3f seconds\n"
msgstr ""

#: ijoin.c:220
#, c-format
msgid "Final step in generating lookup ... done in %8.3f seconds\n"
msgstr ""

#: ijoin.c:330
#, c-format
msgid ""
"First pass on calculating lengths in overlaps ... done in %8.3f seconds\n"
msgstr ""

#: ijoin.c:729
#, c-format
msgid "Final step, fetching indices in overlaps ... done in %8.3f seconds\n"
msgstr ""

#: init.c:183
msgid ""
"Pointers are %zu bytes, greater than 8. We have not tested on any "
"architecture greater than 64bit yet."
msgstr ""

#: init.c:197
msgid "... failed. Please forward this message to maintainer('data.table')."
msgstr ""

#: init.c:198
#, c-format
msgid "Checking NA_INTEGER [%d] == INT_MIN [%d] %s"
msgstr ""

#: init.c:199
#, c-format
msgid "Checking NA_INTEGER [%d] == NA_LOGICAL [%d] %s"
msgstr ""

#: init.c:200 init.c:201 init.c:203 init.c:206 init.c:207 init.c:208 init.c:209 init.c:210 init.c:211 init.c:212
#, c-format
msgid "Checking sizeof(%s) [%zu] is %d %s"
msgstr ""

#: init.c:204
#, c-format
msgid "Checking sizeof(pointer) [%zu] is 4 or 8 %s"
msgstr ""

#: init.c:205
#, c-format
msgid "Checking sizeof(SEXP) [%zu] == sizeof(pointer) [%zu] %s"
msgstr ""

#: init.c:215
#, c-format
msgid "Checking LENGTH(allocVector(INTSXP,2)) [%d] is 2 %s"
msgstr ""

#: init.c:222
#, c-format
msgid "Checking memset(&i,0,sizeof(int)); i == (int)0 %s"
msgstr ""

#: init.c:225
#, c-format
msgid "Checking memset(&ui, 0, sizeof(unsigned int)); ui == (unsigned int)0 %s"
msgstr ""

#: init.c:228
#, c-format
msgid "Checking memset(&d, 0, sizeof(double)); d == (double)0.0 %s"
msgstr ""

#: init.c:231
#, c-format
msgid "Checking memset(&ld, 0, sizeof(long double)); ld == (long double)0.0 %s"
msgstr ""

#: init.c:234
msgid ""
"Unlike the very common case, e.g. ASCII, the character '/' is not just "
"before '0'."
msgstr ""

#: init.c:235
msgid "The C expression (uint_fast8_t)('/'-'0')<10 is true. Should be false."
msgstr ""

#: init.c:236
msgid ""
"Unlike the very common case, e.g. ASCII, the character ':' is not just after "
"'9'."
msgstr ""

#: init.c:237
msgid "The C expression (uint_fast8_t)('9'-':')<10 is true. Should be false."
msgstr ""

#: init.c:242
#, c-format
msgid "Conversion of NA_INT64 via double failed %<PRId64>!=%<PRId64>"
msgstr ""

#: init.c:246
msgid "NA_INT64_D (negative -0.0) is not == 0.0."
msgstr ""

#: init.c:247
msgid "NA_INT64_D (negative -0.0) is not ==-0.0."
msgstr ""

#: init.c:248
msgid "ISNAN(NA_INT64_D) is TRUE but should not be"
msgstr ""

#: init.c:249
msgid "isnan(NA_INT64_D) is TRUE but should not be"
msgstr ""

#: init.c:283
#, c-format
msgid "PRINTNAME(install(\"integer64\")) has returned %s not %s"
msgstr ""

#: init.c:342
msgid "verbose option must be length 1 non-NA logical or integer"
msgstr ""

#: init.c:367
msgid ".Last.updated in namespace is not a length 1 integer"
msgstr ""

#: mergelist.c:36
#, c-format
msgid "'%s' must be a list"
msgstr ""

#: mergelist.c:47
#, c-format
msgid "Element %d of 'l' list is not a data.table."
msgstr ""

#: mergelist.c:56
#, c-format
msgid ""
"For copy=FALSE all non-empty tables in 'l' have to have the same number of "
"rows, but l[[%d]] has %d rows which differs from the previous non-zero "
"number of rows (%d)."
msgstr ""

#: mergelist.c:62
msgid "Recycling rows is not yet implemented."
msgstr ""

#: mergelist.c:92
#, c-format
msgid "cbindlist: took %.3fs\n"
msgstr ""

#: nafill.c:43 nafill.c:65 nafill.c:87
#, c-format
msgid "%s: took %.3fs\n"
msgstr ""

#: nafill.c:115
msgid ""
"'x' argument is atomic vector, in-place update is supported only for list/"
"data.table"
msgstr ""

#: nafill.c:117 nafill.c:128
msgid "'x' argument must be numeric type, or list/data.table of numeric types"
msgstr ""

#: nafill.c:185
msgid ""
"fill must be a vector of length 1 or a list of length of x. Consider "
"fcoalesce() to specify element-wise replacements."
msgstr ""

#: nafill.c:187
msgid "fill must be a vector of length 1 or a list of length of x."
msgstr ""

#: negate.c:6
msgid "not logical or integer vector"
msgstr ""

#: openmp-utils.c:23
#, c-format
msgid ""
"Ignoring invalid %s==\"%s\". Not an integer >= 1. Please remove any "
"characters that are not a digit [0-9]. See ?data.table::setDTthreads."
msgstr ""

#: openmp-utils.c:56
#, c-format
msgid ""
"Ignoring invalid R_DATATABLE_NUM_PROCS_PERCENT==%d. If used it must be an "
"integer between 2 and 100. Default is 50. See ?setDTtheads."
msgstr ""

#: openmp-utils.c:100
msgid ""
"This installation of data.table has not been compiled with OpenMP support.\n"
msgstr ""

#: openmp-utils.c:102
#, c-format
msgid "  OpenMP version (_OPENMP)       %d\n"
msgstr ""

#: openmp-utils.c:118
#, c-format
msgid ""
"  data.table is using %d threads with throttle==%d. See ?setDTthreads.\n"
msgstr ""

#: openmp-utils.c:127
msgid ""
"restore_after_fork= must be TRUE, FALSE, or NULL (default). "
"getDTthreads(verbose=TRUE) reports the current setting.\n"
msgstr ""

#: openmp-utils.c:133
msgid "'throttle' must be a single number, non-NA, and >=1"
msgstr ""

#: openmp-utils.c:147
msgid ""
"threads= must be either NULL or a single number >= 0. See ?setDTthreads."
msgstr ""

#: programming.c:18
#, c-format
msgid ""
"Attempting to substitute '%s' element with object of type '%s' but it has to "
"be 'symbol' type when substituting name of the call argument, functions 'as."
"name' and 'I' can be used to work out proper substitution, see ?substitute2 "
"examples."
msgstr ""

#: rbindlist.c:10
msgid "use.names= should be TRUE, FALSE, or not used (\"check\" by default)"
msgstr ""

#: rbindlist.c:14
msgid ""
"Input to rbindlist must be a list. This list can contain data.tables, data."
"frames or plain lists."
msgstr ""

#: rbindlist.c:33
#, c-format
msgid "Item %d of input is not a data.frame, data.table or list"
msgstr ""

#: rbindlist.c:41
#, c-format
msgid ""
"Item %d has %d columns, inconsistent with item %d which has %d columns. To "
"fill missing columns use fill=TRUE."
msgstr ""

#: rbindlist.c:44
#, c-format
msgid "Item %d has %d columns but %d column names. Invalid object."
msgstr ""

#: rbindlist.c:51
#, c-format
msgid ""
"Column %d of item %d is length %d inconsistent with column %d which is "
"length %d. Only length-1 columns are recycled."
msgstr ""

#: rbindlist.c:66
#, c-format
msgid ""
"Total rows in the list is %<PRId64> which is larger than the maximum number "
"of rows, currently %d"
msgstr ""

#: rbindlist.c:67
msgid "use.names=TRUE but no item of input list has any names"
msgstr ""

#: rbindlist.c:106
#, c-format
msgid "Failed to allocate nuniq=%d items working memory in rbindlist.c"
msgstr ""

#: rbindlist.c:139
#, c-format
msgid "Failed to allocate ncol=%d items working memory in rbindlist.c"
msgstr ""

#: rbindlist.c:199
msgid ""
" use.names='check' (default from v1.12.2) emits this message and proceeds as "
"if use.names=FALSE for  backwards compatibility. See news item 5 in v1.12.2 "
"for options to control this message."
msgstr ""

#: rbindlist.c:213
#, c-format
msgid ""
"Column %d ['%s'] of item %d is missing in item %d. Use fill=TRUE to fill "
"with NA (NULL for list columns), or use.names=FALSE to ignore column names.%s"
msgstr ""

#: rbindlist.c:222
#, c-format
msgid ""
"Column %d ['%s'] of item %d appears in position %d in item %d. Set use."
"names=TRUE to match by column name, or use.names=FALSE to ignore column "
"names.%s"
msgstr ""

#: rbindlist.c:231
msgid ""
"options()$datatable.rbindlist.check is set but is not a single string. See "
"news item 5 in v1.12.2."
msgstr ""

#: rbindlist.c:238
#, c-format
msgid ""
"options()$datatable.rbindlist.check=='%s' which is not 'message'|'warning'|"
"'error'|'none'. See news item 5 in v1.12.2."
msgstr ""

#: rbindlist.c:301
#, c-format
msgid ""
"Column %d of item %d has type 'factor' but has no levels; i.e. malformed."
msgstr ""

#: rbindlist.c:330
#, c-format
msgid ""
"Class attribute on column %d of item %d does not match with column %d of "
"item %d. You can deactivate this safety-check by using ignore.attr=TRUE"
msgstr ""

#: rbindlist.c:380 rbindlist.c:389
#, c-format
msgid ""
"Failed to allocate working memory for %d ordered factor levels of result "
"column %d"
msgstr ""

#: rbindlist.c:408
#, c-format
msgid ""
"Column %d of item %d is an ordered factor but level %d ['%s'] is missing "
"from the ordered levels from column %d of item %d. Each set of ordered "
"factor levels should be an ordered subset of the first longest. A regular "
"factor will be created for this column."
msgstr ""

#: rbindlist.c:413
#, c-format
msgid ""
"Column %d of item %d is an ordered factor with '%s'<'%s' in its levels. But "
"'%s'<'%s' in the ordered levels from column %d of item %d. A regular factor "
"will be created for this column due to this ambiguity."
msgstr ""

#: rbindlist.c:456 rbindlist.c:465
#, c-format
msgid ""
"Failed to allocate working memory for %d factor levels of result column %d "
"when reading item %d of item %d"
msgstr ""

#: rbindlist.c:553 rbindlist.c:556
#, c-format
msgid "Column %d of item %d: %s"
msgstr ""

#: reorder.c:22
#, c-format
msgid ""
"Item %d of list is type '%s' which isn't yet supported (RTYPE_SIZEOF=%zu)"
msgstr ""

#: reorder.c:24
#, c-format
msgid ""
"Column %d is length %d which differs from length of column 1 (%d). Invalid "
"data.table."
msgstr ""

#: reorder.c:32
#, c-format
msgid ""
"reorder accepts vectors but this non-VECSXP is type '%s' which isn't yet "
"supported (RTYPE_SIZEOF=%zu)"
msgstr ""

#: reorder.c:39
msgid "order must be an integer vector"
msgstr ""

#: reorder.c:58
#, c-format
msgid ""
"Item %d of order (%d) is either NA, out of range [1,%d], or is duplicated. "
"The new order must be a strict permutation of 1:n"
msgstr ""

#: reorder.c:130
msgid "dt passed to setcolorder has no names"
msgstr ""

#: shift.c:12
msgid ""
"shift input must not be matrix or array, consider wrapping it into data."
"table() or c()"
msgstr ""

#: shift.c:17
#, c-format
msgid ""
"type '%s' passed to shift(). Must be a vector, list, data.frame or data.table"
msgstr ""

#: shift.c:46
#, c-format
msgid ""
"Filling %s with %s using shift() is unsupported. Please convert fill to %s "
"first."
msgstr ""

#: snprintf.c:193 snprintf.c:196 snprintf.c:199 snprintf.c:202 snprintf.c:205 snprintf.c:208 snprintf.c:211 snprintf.c:214 snprintf.c:217 snprintf.c:221 snprintf.c:224 snprintf.c:227 snprintf.c:230 snprintf.c:233 snprintf.c:236 snprintf.c:239 snprintf.c:242 snprintf.c:245
#, c-format
msgid "dt_win_snprintf test %d failed: %s"
msgstr ""

#: snprintf.c:218
#, c-format
msgid "dt_win_snprintf test %d failed: %d"
msgstr ""

#: subset.c:182
#, c-format
msgid ""
"Item %d of i is %d and item %d is %d. Cannot mix positives and negatives."
msgstr ""

#: subset.c:192
#, c-format
msgid "Item %d of i is %d and item %d is NA. Cannot mix negatives and NA."
msgstr ""

#: subset.c:239
#, c-format
msgid ""
"Item %d of i is %d but there are only %d rows. Ignoring this and %d more "
"like it out of %d."
msgstr ""

#: subset.c:241
#, c-format
msgid ""
"Item %d of i is %d which removes that item but that has occurred before. "
"Ignoring this dup and %d other dups."
msgstr ""

#: subset.c:255
#, c-format
msgid "Column %d is NULL; malformed data.table."
msgstr ""

#: subset.c:258
#, c-format
msgid "Column %d ['%s'] is a data.frame or data.table; malformed data.table."
msgstr ""

#: subset.c:263
#, c-format
msgid ""
"Column %d ['%s'] is length %d but column 1 is length %d; malformed data."
"table."
msgstr ""

#: subset.c:296
#, c-format
msgid "Item %d of cols is %d which is outside the range [1,ncol(x)=%d]"
msgstr ""

#: transpose.c:9
msgid "l must be a list."
msgstr ""

#: transpose.c:13
msgid "ignore.empty should be logical TRUE/FALSE."
msgstr ""

#: transpose.c:16
msgid ""
"keep.names should be either NULL, or the name of the first column of the "
"result in which to place the names of the input"
msgstr ""

#: transpose.c:19
msgid "fill must be a length 1 vector, such as the default NA"
msgstr ""

#: transpose.c:22
msgid "list.cols should be logical TRUE/FALSE."
msgstr ""

#: transpose.c:31
#, c-format
msgid "Item %d of list input is not either an atomic vector, or a list"
msgstr ""

#: uniqlist.c:151
msgid "Input argument 'x' to 'uniqlengths' must be an integer vector"
msgstr ""

#: uniqlist.c:152
msgid ""
"Input argument 'n' to 'uniqlengths' must be an integer vector of length 1"
msgstr ""

#: uniqlist.c:174 uniqlist.c:271
msgid "cols must be an integer vector with length >= 1"
msgstr ""

#: uniqlist.c:178
#, c-format
msgid "Item %d of cols is %d which is outside the range [1,length(l)=%d]"
msgstr ""

#: uniqlist.c:181
#, c-format
msgid ""
"All elements to input list must be of same length. Element [%d] has length "
"%<PRIu64> != length of first element = %<PRIu64>."
msgstr ""

#: uniqlist.c:356
msgid "x is not a logical vector"
msgstr ""

#: utils.c:100
#, c-format
msgid "Unsupported type '%s' passed to allNA()"
msgstr ""

#: utils.c:120
msgid "'x' argument must be data.table compatible"
msgstr ""

#: utils.c:144
msgid ""
"argument specifying columns is type 'double' and one or more items in it are "
"not whole integers"
msgstr ""

#: utils.c:150
#, c-format
msgid ""
"argument specifying columns received non-existing column(s): cols[%d]=%d"
msgstr ""

#: utils.c:157
msgid "'x' argument data.table has no names"
msgstr ""

#: utils.c:163
#, c-format
msgid ""
"argument specifying columns received non-existing column(s): cols[%d]='%s'"
msgstr ""

#: utils.c:167
msgid "argument specifying columns must be character or numeric"
msgstr ""

#: utils.c:170
msgid "argument specifying columns received duplicate column(s)"
msgstr ""

#: utils.c:381
msgid "'x' is not atomic"
msgstr ""

#: utils.c:383
msgid "'x' must not be matrix or array"
msgstr ""

#: utils.c:385
msgid "input must not be matrix or array"
msgstr ""

#: utils.c:389
#, c-format
msgid "copy=false and input already of expected type and class %s[%s]\n"
msgstr ""

#: utils.c:396
#, c-format
msgid "Coercing %s[%s] into %s[%s]\n"
msgstr ""

#: utils.c:412
#, c-format
msgid "zlib header files were not found when data.table was compiled"
msgstr ""

#: utils.c:538
msgid "'x' should not be data.frame or data.table."
msgstr ""

#: utils.c:540
#, c-format
msgid "%s must be TRUE or FALSE."
msgstr ""

#: utils.c:621
#, c-format
msgid "Type '%s' is not supported by frev"
msgstr ""

#: vecseq.c:16
msgid "len must be an integer vector"
msgstr ""

#: vecseq.c:18
msgid "x and len must be the same length"
msgstr ""

#: vecseq.c:24
msgid ""
"Join results in more than 2^31 rows (internal vecseq reached physical "
"limit). Very likely misspecified join. Check for duplicate key values in i "
"each of which join to the same group in x over and over again. If that's ok, "
"try by=.EACHI to run j for each group to avoid the large allocation. "
"Otherwise, please search for this error message in the FAQ, Wiki, Stack "
"Overflow and data.table issue tracker for advice."
msgstr ""

#: vecseq.c:29
msgid "clamp must be a double vector length 1"
msgstr ""

#: vecseq.c:32
msgid "clamp must be positive"
msgstr ""

#: vecseq.c:34
#, c-format
msgid ""
"Join results in %d rows; more than %d = nrow(x)+nrow(i). Check for duplicate "
"key values in i each of which join to the same group in x over and over "
"again. If that's ok, try by=.EACHI to run j for each group to avoid the "
"large allocation. If you are sure you wish to proceed, rerun with allow."
"cartesian=TRUE. Otherwise, please search for this error message in the FAQ, "
"Wiki, Stack Overflow and data.table issue tracker for advice."
msgstr ""

#: wrappers.c:11
msgid "Attribute name must be a character vector of length 1"
msgstr ""

#: wrappers.c:16
msgid ""
"Internal structure doesn't seem to be a list. Can't set class to be 'data."
"table' or 'data.frame'. Use 'as.data.table()' or 'as.data.frame()' methods "
"instead."
msgstr ""

#: wrappers.c:68
#, c-format
msgid "i (%d) is outside the range of items [1,%d]"
msgstr ""

#: wrappers.c:99
msgid "x isn't a VECSXP"
msgstr ""

#: wrappers.c:114
#, c-format
msgid ""
"dim.data.table expects a data.table as input (which is a list), but seems to "
"be of type %s"
msgstr ""
