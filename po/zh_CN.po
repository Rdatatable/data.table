msgid ""
msgstr ""
"Project-Id-Version: data.table 1.12.5\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-08-28 21:08+0000\n"
"PO-Revision-Date: 2020-10-18 20:39-0400\n"
"Last-Translator: Yuhang Chen <yuhangchen0802@gmail.com>\n"
"Language-Team: Mandarin\n"
"Language: Mandarin\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: assign.c:121
msgid ""
".internal.selfref ptr is NULL. This is expected and normal for a data.table "
"loaded from disk. Please remember to always setDT() immediately after "
"loading to prevent unexpected behavior. If this table was not loaded from "
"disk or you've already run setDT(), please report to data.table issue "
"tracker.\n"
msgstr ""
".internal.selfref ptr为空。 这是从磁盘加载data.table的正常现象请在装载结束后"
"立刻运行setDT()操作避免发生异常行为。 如果该data.table不是从磁盘读取或已经运"
"行了setDT(), 请报告data.table异常行为到问题跟踪器(issue tracker)\n"

#: assign.c:202
#, c-format
msgid ""
"Some columns are a multi-column type (such as a matrix column), for example "
"column %d. setDT will retain these columns as-is but subsequent operations "
"like grouping and joining may fail. Please consider as.data.table() instead "
"which will create a new column for each embedded column."
msgstr ""
"某些列为包含多列的类型（如矩阵列）：%d。setDT 会保留这些列，但后续的操作如分"
"组（grouping）和联接（joining）等操作可能会失败。请考虑使用 as.data.table() "
"因为它会为每个内嵌列建立一个新列。"

#: assign.c:219
#, c-format
msgid ""
"Column %d has class 'POSIXlt'. Please convert it to POSIXct (using as."
"POSIXct) and run setDT() again. We do not recommend the use of POSIXlt at "
"all because it uses 40 bytes to store one date."
msgstr ""
"第 %d 列属于 POSIXlt 类型。请使用 as.POSIXct 将其转换为 POSIXct 类型并再次运"
"行setDT。我们非常不推荐使用 POSIXlt 类型，因为它需使用 40 个字节来存储一个日"
"期。"

#: assign.c:239
#, c-format
msgid ""
"All elements in argument 'x' to 'setDT' must be of equal length, but input "
"%d has length %d whereas the first non-empty input had length %d"
msgstr ""
"'setDT' 参数 'x' 中所有的元素均须为同一长度，但输入 %d 的长度为 %d 而第一个非"
"空输入的长度为 %d"

#: assign.c:249
msgid "alloccol has been passed a NULL dt"
msgstr "alloccol被传递给了一个空的(NULL)dt"

#: assign.c:250
msgid "dt passed to alloccol isn't type VECSXP"
msgstr "传递给alloccol的dt类型不为VECSXP"

#: assign.c:252
msgid ""
"dt passed to alloccol has no class attribute. Please report result of "
"traceback() to data.table issue tracker."
msgstr ""
"传递给alloccol的dt没有类型属性，请报告traceback()的运行结果给data.table的问题"
"跟踪器issue tracker"

#: assign.c:269
#, c-format
msgid ""
"tl (%d) is greater than 10,000 items over-allocated (l = %d). If you didn't "
"set the datatable.alloccol option to be very large, please report to data."
"table issue tracker including the result of sessionInfo()."
msgstr ""
"tl (%d)超过了10,000，过度预分配(l = %d)如果用户没有设置datatable.alloccol很"
"大，请请汇报错误到data.table的问题跟踪器issue tracker， 并包含sessionInfo()信"
"息"

#: assign.c:271
#, c-format
msgid ""
"Attempt to reduce allocation from %d to %d ignored. Can only increase "
"allocation via shallow copy. Please do not use DT[...]<- or DT$someCol<-. "
"Use := inside DT[...] instead."
msgstr ""
"忽视降低预分配从%d到%d的操作。 只能使用浅拷贝(shallow copy)增加预分配考虑在"
"DT[...]中使用 :=， 而不是使用DT[...]<-或DT$someCol<-"

#: assign.c:279
msgid ""
"Has getOption('datatable.alloccol') somehow become unset? It should be a "
"number, by default 1024."
msgstr ""
"getOption('datatable.alloccol')结果是否返回为未设置，返回应该为数字， 默认值"
"为1024"

#: assign.c:281
#, c-format
msgid ""
"getOption('datatable.alloccol') should be a number, by default 1024. But its "
"type is '%s'."
msgstr "getOption('datatable.alloc')应该返回数字，默认为1024但其类型为'%s'"

#: assign.c:283
#, c-format
msgid ""
"getOption('datatable.alloc') is a numeric vector ok but its length is %d. "
"Its length should be 1."
msgstr "getOption('datatable.alloc')结果为长度%d的数值向量其长度应该为1"

#: assign.c:286
#, c-format
msgid "getOption('datatable.alloc')==%d.  It must be >=0 and not NA."
msgstr "getOption('datatable.alloc')值为%d, 其必须大于等于零且不能为NA"

#: assign.c:292 between.c:16 between.c:22 frollR.c:41 frollR.c:95 fsort.c:105
#: gsumm.c:346 gsumm.c:582 gsumm.c:728 gsumm.c:865 gsumm.c:1020 gsumm.c:1112
#: nafill.c:103 openmp-utils.c:79 uniqlist.c:354 utils.c:107 utils.c:109
#, c-format
msgid "%s must be TRUE or FALSE"
msgstr "%s 的参数是逻辑值，必须是 TRUE 或 FALSE"

#: assign.c:340
msgid "assign has been passed a NULL dt"
msgstr "赋值已经被传递给一个空的(NULL)dt"

#: assign.c:341
msgid "dt passed to assign isn't type VECSXP"
msgstr "传递给赋值操作的dt不是VECSXP类型"

#: assign.c:343
msgid ""
".SD is locked. Updating .SD by reference using := or set are reserved for "
"future use. Use := in j directly. Or use copy(.SD) as a (slow) last resort, "
"until shallow() is exported."
msgstr ""
".SD被锁定。 使用':='更新.SD操作保留将来使用对'j'直接使用':=', 或可以使用"
"copy(.SD)， 直到导出shallow()"

#: assign.c:355
msgid "dt passed to assign has no names"
msgstr "传递给赋值操作的dt没有命名"

#: assign.c:359
msgid ""
"data.table is NULL; malformed. A null data.table should be an empty list. "
"typeof() should always return 'list' for data.table."
msgstr ""
"data.table为空， 格式错误，一个null的data.table应该为空的列表list即对data."
"table使用typeof()函数应该返回'list'类型"

#: assign.c:369
#, c-format
msgid "Assigning to all %d rows\n"
msgstr "为所有的%d行赋值\n"

#: assign.c:374
msgid ""
"Coerced i from numeric to integer. Please pass integer for efficiency; e.g., "
"2L rather than 2"
msgstr "将i由数值型强制转换为整数型。请直接传入整数以提高效率，如传入2L而非2"

#: assign.c:377
#, c-format
msgid ""
"i is type '%s'. Must be integer, or numeric is coerced with warning. If i is "
"a logical subset, simply wrap with which(), and take the which() outside the "
"loop if possible for efficiency."
msgstr ""
"i 为 '%s' 类型。i 必须为整（integer）型，或数值（numeric）型（将被自动转换成"
"整型并发出警告）。如果 i 为一个用于筛选的逻辑（logical）向量，请直接将它传给 "
"which()，且如果可能的话将 which() 放置于循环之外以保持高效。"

#: assign.c:383 subset.c:170
#, c-format
msgid "i[%d] is %d which is out of range [1,nrow=%d]"
msgstr "i[%d] 是 %d ，超出 [1,nrow=%d] 的范围"

#: assign.c:386
#, c-format
msgid "Assigning to %d row subset of %d rows\n"
msgstr "正在为 %d 行（总数为 %d 行）进行赋值\n"

#: assign.c:395
#, c-format
msgid "Added %d new column%s initialized with all-NA\n"
msgstr "添加了 %d 个新列 %s 并全部初始化为 NA\n"

#: assign.c:400
msgid "length(LHS)==0; no columns to delete or assign RHS to."
msgstr "左手侧长度为0（length(LHS)==0）；没有列可供删除或赋值给右手侧（RHS）。"

#: assign.c:414
msgid ""
"set() on a data.frame is for changing existing columns, not adding new ones. "
"Please use a data.table for that. data.table's are over-allocated and don't "
"shallow copy."
msgstr ""
"数据框（data.frame）的 set() 是用于修改现有列，而非添加新列。请使用 data."
"table 来添加新列。data.table 的操作是超额分配的（over-allocated）并且不进行浅"
"拷贝（shallow copy）。"

#: assign.c:425
msgid ""
"Coerced j from numeric to integer. Please pass integer for efficiency; e.g., "
"2L rather than 2"
msgstr ""
"将 j 从数值（numeric）型自动转换为整（integer）型。为了保持高效请直接传入整"
"型，如2L 而非 2"

#: assign.c:428
#, c-format
msgid ""
"j is type '%s'. Must be integer, character, or numeric is coerced with "
"warning."
msgstr ""
"j 为 '%s' 型。j 必须为整（integer）型、字符（character）型，或数值（numeric）"
"型（将被自动转换成整型并发出警告）。"

#: assign.c:430
msgid ""
"Can't assign to the same column twice in the same query (duplicates "
"detected)."
msgstr "在一次查询中无法对同一列赋值两次（检测出重复项）。"

#: assign.c:431
msgid "newcolnames is supplied but isn't a character vector"
msgstr "指定了 newcolnames 但其并非一字符串向量"

#: assign.c:433
msgid ""
"Values of type POSIXlt detected and converted to POSIXct. We do not "
"recommend the use of POSIXlt at all because it typically takes more than 6 "
"times the storage as an equivalent POSIXct column. Use as.POSIXct() to avoid "
"this warning."
msgstr ""

#: assign.c:437
#, c-format
msgid "RHS_list_of_columns == %s\n"
msgstr "RHS_list_of_columns == %s\n"

#: assign.c:442
#, c-format
msgid ""
"RHS_list_of_columns revised to true because RHS list has 1 item which is "
"NULL, or whose length %d is either 1 or targetlen (%d). Please unwrap RHS.\n"
msgstr ""
"RHS_list_of_columns 改为真（True），因为右手侧列表（RHS list）有一子项为空值"
"（NULL）或长度 %d 为 1 或 targetlen（%d）。请拆开右手侧。\n"

#: assign.c:447
#, c-format
msgid ""
"Supplied %d columns to be assigned an empty list (which may be an empty data."
"table or data.frame since they are lists too). To delete multiple columns "
"use NULL instead. To add multiple empty list columns, use list(list())."
msgstr ""
"试图将 %d 列赋值为空列表（可能为空数据、表（table）或数据框（data.frame），因"
"后两者也是列表的一种）。删除多个列时请使用空值（NULL）。添加多个空列表列"
"（list columns）时，请使用 list(list())。"

#: assign.c:452
#, c-format
msgid "Recycling single RHS list item across %d columns. Please unwrap RHS.\n"
msgstr ""
"回收重用（Recycling）单个右手侧（RHS）列表子项于 %d 列。请拆开右手侧。\n"

#: assign.c:454
#, c-format
msgid ""
"Supplied %d columns to be assigned %d items. Please see NEWS for v1.12.2."
msgstr "试图将 %2$d 项赋值给 %1$d 列。请阅读 v1.12.2 的更新信息（NEWS）。"

#: assign.c:462
#, c-format
msgid ""
"Item %d of column numbers in j is %d which is outside range [1,ncol=%d]. "
"set() on a data.frame is for changing existing columns, not adding new ones. "
"Please use a data.table for that."
msgstr ""
"j 中的列编号里第 %d 项是 %d，超出了有效范围 [1,ncol=%d]。数据框（data.frame）"
"的 set() 是用于修改现有列，而非添加新列。请使用 data.table 来添加新列。"

#: assign.c:463
#, c-format
msgid ""
"Item %d of column numbers in j is %d which is outside range [1,ncol=%d]. Use "
"column names instead in j to add new columns."
msgstr ""
"j 中的列编号里第 %d 项是 %d，超出了有效范围 [1,ncol=%d]。请在 j 中使用列名来"
"添加新列。"

#: assign.c:468
msgid "When deleting columns, i should not be provided"
msgstr "当删除列时，不应指定 i"

#: assign.c:474
#, c-format
msgid ""
"RHS of assignment to existing column '%s' is zero length but not NULL. If "
"you intend to delete the column use NULL. Otherwise, the RHS must have "
"length > 0; e.g., NA_integer_. If you are trying to change the column type "
"to be an empty list column then, as with all column type changes, provide a "
"full length RHS vector such as vector('list',nrow(DT)); i.e., 'plonk' in the "
"new column."
msgstr ""
"对已有列 '%s' 的赋值其右手侧（RHS）长度为零但并非空值（NULL）。如果想要删除列"
"请使用空值（NULL）。否则，右手侧必须长度 > 0，如 NA_integer_。如果想将该列类"
"型修改为空列表列（list column），正如所有修改列类型的操作一样，请在右手侧提供"
"一个与该列原数据等长的向量，如 vector('list',nrow(DT))，即，用新数据替换"
"（plonk）重新生成该列。"

#: assign.c:481
#, c-format
msgid ""
"Tried to assign NULL to column '%s', but this column does not exist to remove"
msgstr "要删除的列 '%s' 不存在"

#: assign.c:489
#, c-format
msgid "%d column matrix RHS of := will be treated as one vector"
msgstr "':=' 右手侧（RHS）%d 列矩阵将被视为一维向量"

#: assign.c:494
#, c-format
msgid ""
"Can't assign to column '%s' (type 'factor') a value of type '%s' (not "
"character, factor, integer or numeric)"
msgstr ""
"无法给因子（factor）类型列 '%s' 赋类型为 '%s' 的值（不是字符（character）、因"
"子（factor）、整数（integer）或数值（numeric）类中的一种）"

#: assign.c:500
#, c-format
msgid ""
"Supplied %d items to be assigned to %d items of column '%s'. If you wish to "
"'recycle' the RHS please use rep() to make this intent clear to readers of "
"your code."
msgstr ""
"试图将 %d 项赋值给 %d 项（列 '%s'）。如果想'回收重用'（'recycle'）右手侧，请"
"使用 rep() 以将该意图清晰地表述给阅读代码的人。"

#: assign.c:510
msgid ""
"This data.table has either been loaded from disk (e.g. using readRDS()/"
"load()) or constructed manually (e.g. using structure()). Please run setDT() "
"or setalloccol() on it first (to pre-allocate space for new columns) before "
"assigning by reference to it."
msgstr ""
"此 data.table 是从硬盘导入(例如 readRDS()/load() )或者手动创建(例如 "
"structure() )。在通过引用的方式进行赋值前，请先运行 setDT() 或 setalloccol() "
"来为增加的列预先分配空间"

#: assign.c:513
#, c-format
msgid ""
"truelength (%d) is greater than 10,000 items over-allocated (length = %d). "
"See ?truelength. If you didn't set the datatable.alloccol option very large, "
"please report to data.table issue tracker including the result of "
"sessionInfo()."
msgstr ""
"truelength (%d) 的值大于超额分配的 10000 项 (length = %d)。请查看 ?"
"truelength。如果你没有将 datatable.alloccol 设置为非常大的数值，请将此问题汇"
"报给 data.table 问题追踪器，包含 sessionInfo() 的信息"

#: assign.c:517
msgid ""
"It appears that at some earlier point, names of this data.table have been "
"reassigned. Please ensure to use setnames() rather than names<- or "
"colnames<-. Otherwise, please report to data.table issue tracker."
msgstr ""
"此 data.table 的名称在早先已经被重新赋值。请确保使用 setnames() 而不是 "
"names<- 或 colnames<- 进行赋值。如果该办法无效，请将此问题汇报给 data.table "
"问题追踪器，包含 sessionInfo() 的信息"

#: assign.c:552
#, fuzzy, c-format
#| msgid ""
#| "RHS for item %d has been duplicated because NAMED==%d MAYBE_SHARED==%d, "
#| "but then is being plonked. length(values)==%d; length(cols)==%d)\n"
msgid ""
"RHS for item %d has been duplicated because MAYBE_REFERENCED==%d "
"MAYBE_SHARED==%d, but then is being plonked. length(values)==%d; "
"length(cols)==%d)\n"
msgstr ""
"因为 NAMED==%d MAYBE_SHARED==%d， 所以条目 %d 的 RHS 已经被复制，但是接下来又"
"要被替换了。length(values)==%d; length(cols)==%d)\n"

#: assign.c:557
#, fuzzy, c-format
#| msgid "Direct plonk of unnamed RHS, no copy. NAMED==%d, MAYBE_SHARED==%d\n"
msgid ""
"Direct plonk of unnamed RHS, no copy. MAYBE_REFERENCED==%d, "
"MAYBE_SHARED==%d\n"
msgstr "直接替换没有名字的 RHS，并没有复制。 NAMED==%d, MAYBE_SHARED==%d\n"

#: assign.c:626
#, c-format
msgid ""
"Dropping index '%s' as it doesn't have '__' at the beginning of its name. It "
"was very likely created by v1.9.4 of data.table.\n"
msgstr ""
"丢掉索引(index) '%s' 因为它的名字前面没有 '__' 。这个很可能由data.table "
"v1.9.4 创建\n"

#: assign.c:671 assign.c:687
#, c-format
msgid "Dropping index '%s' due to an update on a key column\n"
msgstr " 因为一个键(key)列的更新，丢掉索引(index) '%s'\n"

#: assign.c:680
#, c-format
msgid "Shortening index '%s' to '%s' due to an update on a key column\n"
msgstr "因为一个键(key)列的更新，缩短索引(index) '%s' 到 '%s'\n"

#: assign.c:738
#, c-format
msgid "target vector"
msgstr "目标向量"

#: assign.c:738
#, c-format
msgid "column %d named '%s'"
msgstr "第 %d 列名为 '%s'"

#: assign.c:772
#, c-format
msgid ""
"Cannot assign 'factor' to '%s'. Factors can only be assigned to factor, "
"character or list columns."
msgstr ""
"不能将 'factor' 赋值为 '%s' 。因子类型只能赋值为因子，字符或者列表其中的列"

#: assign.c:786
#, c-format
msgid ""
"Assigning factor numbers to %s. But %d is outside the level range [1,%d]"
msgstr "%s 赋值为因子。但是 %d 在层次范围[1,%d]之外"

#: assign.c:795
#, c-format
msgid ""
"Assigning factor numbers to %s. But %f is outside the level range [1,%d], or "
"is not a whole number."
msgstr "%s 赋值为因子。但是 %f 在层次范围[1,%d]之外，或者不是一个完整的数字"

#: assign.c:801
#, c-format
msgid ""
"Cannot assign '%s' to 'factor'. Factor columns can be assigned factor, "
"character, NA in any type, or level numbers."
msgstr ""
"不能将 'factor' 赋值为 '%s' 。 因子列可被赋值为因子，字符 ，NA 或者 层次数值"

#: assign.c:861
msgid "Unable to allocate working memory of %zu bytes to combine factor levels"
msgstr "不能分配 %zu 字节的工作内存来组合因子层次"

#: assign.c:887
#, c-format
msgid "Coercing 'character' RHS to '%s' to match the type of %s."
msgstr "将'character' RHS 强制转换成 '%s' 来匹配目标列 %s 的类型"

#: assign.c:894
#, c-format
msgid "Cannot coerce 'list' RHS to 'integer64' to match the type of %s."
msgstr "不能将'list' RHS 强制转换成 'integer64' 来匹配目 %s 的类型"

#: assign.c:899
#, c-format
msgid "Coercing 'list' RHS to '%s' to match the type of %s."
msgstr "将'list' RHS 强制转换成 '%s' 来匹配目 %s 的类型"

#: assign.c:904
#, c-format
msgid "Zero-copy coerce when assigning '%s' to '%s' %s.\n"
msgstr "在 %s 中将 '%s' 赋值成 '%s' 时发生了零拷贝强制转换。\n"

#: assign.c:1006
#, c-format
msgid "type '%s' cannot be coerced to '%s'"
msgstr "类型 '%s' 不能强制转换成 '%s'"

#: assign.c:1164
#, c-format
msgid "Unsupported column type in assign.c:memrecycle '%s'"
msgstr "assign.c:memrecycle '%s' 里有不支持的列的类型"

#: assign.c:1249
#, c-format
msgid "savetl_init checks failed (%d %d %p %p)"
msgstr ""

#: assign.c:1258
#, c-format
msgid "Failed to allocate initial %d items in savetl_init"
msgstr "不能为 savetl_init 最开始的 %d 个项分配空间"

#: assign.c:1274
#, c-format
msgid "Failed to realloc saveds to %d items in savetl"
msgstr "不能给 savetl 里的 %d 个项重新分配 saveds"

#: assign.c:1280
#, c-format
msgid "Failed to realloc savedtl to %d items in savetl"
msgstr "不能给savetl里的 %d 个项提供 savetl"

#: assign.c:1303
msgid "x must be a character vector"
msgstr "x 必须是一个字符向量"

#: assign.c:1304
msgid "'which' must be an integer vector"
msgstr "'which' 必须是一个整数向量"

#: assign.c:1305
msgid "'new' must be a character vector"
msgstr "'new' 必须是一个字符向量"

#: assign.c:1306
#, c-format
msgid "'new' is length %d. Should be the same as length of 'which' (%d)"
msgstr "'new' 的长度是 %d。 它的长度必须和'which' (%d)的长度一致。"

#: assign.c:1309
#, c-format
msgid ""
"Item %d of 'which' is %d which is outside range of the length %d character "
"vector"
msgstr "'which' 的 %d 项是 %d，这超出了 %d 字符的长度范围"

#: between.c:12
#, c-format
msgid ""
"Incompatible vector lengths: length(x)==%d length(lower)==%d "
"length(upper)==%d. Each should be either length 1 or the length of the "
"longest."
msgstr ""
"向量长度不一致：length(x)==%d length(lower)==%d length(upper)==%d。每一个向量"
"要么是长度为一或者是等于最长向量的长度。"

#: between.c:19
msgid "NAbounds must be TRUE or NA"
msgstr "NAbounds 必须是 TRUE (真) 或者是 FALSE (假)"

#: between.c:64
#, c-format
msgid "Item %d of lower (%d) is greater than item %d of upper (%d)"
msgstr "lower (%2$d) 的 %1$d 项大于 upper (%3$d)的 %4$d 项"

#: between.c:82
#, c-format
msgid "between parallel processing of integer took %8.3fs\n"
msgstr "整数的并行运行时间一共花费了 %8.3fs\n"

#: between.c:88
msgid "x is integer64 but lower and/or upper are not."
msgstr "x 是一个64位整数但是至少在 lower 和 upper 其中有一个不是。"

#: between.c:95
#, c-format
msgid ""
"Item %d of lower (%<PRId64>) is greater than item %d of upper (%<PRId64>)"
msgstr "lower (%2$<PRId64>) 的 %1$d 项大于 upper (%4$<PRId64>)的 %3$d 项"

#: between.c:112
#, c-format
msgid "between parallel processing of integer64 took %8.3fs\n"
msgstr "64位整数的并行运行时间一共花费了 %8.3fs\n"

#: between.c:115
msgid ""
"x is not integer64 but lower and/or upper is integer64. Please align classes."
msgstr ""
"x 不是一个64位整数但是 lower 和 upper 中至少有一个是64位整数，请保证所有的变"
"量类型一致。"

#: between.c:122
#, c-format
msgid "Item %d of lower (%f) is greater than item %d of upper (%f)"
msgstr "lower (%2$f) 的 %1$d 项大于 upper (%4$f)的 %3$d 项"

#: between.c:140
#, c-format
msgid "between parallel processing of double with open bounds took %8.3fs\n"
msgstr "不设界的双精度浮点数的并行运行时间一共花费了 %8.3fs\n"

#: between.c:157
#, c-format
msgid "between parallel processing of double with closed bounds took %8.3fs\n"
msgstr "设界的双精度浮点数的并行运行时间一共花费了 %8.3fs\n"

#: between.c:172
#, c-format
msgid "Item %d of lower ('%s') is greater than item %d of upper ('%s')"
msgstr "lower (%2$s) 的 %1$d 项大于 upper (%4$s)的 %3$d 项"

#: between.c:187
#, c-format
msgid "between non-parallel processing of character took %8.3fs\n"
msgstr "字符的并行运行时间一共花费了 %8.3fs\n"

#: bmerge.c:65
#, c-format
msgid "icols[%d]=%d outside range [1,length(i)=%d]"
msgstr "icols[%1$d]=%2$d 造成了空间溢出，当前范围是[1,length(i)=%3$d]"

#: bmerge.c:66
#, c-format
msgid "xcols[%d]=%d outside range [1,length(x)=%d]"
msgstr "xcols[%1$d]=%2$d 造成了空间溢出，当前范围是[1,length(i)=%3$d]"

#: bmerge.c:69
#, c-format
msgid "typeof x.%s (%s) != typeof i.%s (%s)"
msgstr "x.%1$s (%2$s) 的数据类型和 i.%3$s (%4$s) 的数据类型并不一致"

#: bmerge.c:71 bmerge.c:383
#, c-format
msgid "Type '%s' is not supported for joining/merging"
msgstr "'%s' 类型不支持联结/归并"

#: bmerge.c:77
msgid "roll is character but not 'nearest'"
msgstr "roll 是字符但并不是最近的"

#: bmerge.c:78
msgid "roll='nearest' can't be applied to a character column, yet."
msgstr "roll='最近的'的功能当前并不能被使用在字符列。"

#: bmerge.c:86
msgid "rollends must be a length 2 logical vector"
msgstr "rollends 必须是一个长度为2的逻辑向量"

#: bmerge.c:115
msgid "Only '==' operator is supported for columns of type character."
msgstr "字符类型的列仅支持 '==' 操作符。"

#: chmatch.c:5
#, c-format
msgid "table is type '%s' (must be 'character' or NULL)"
msgstr "table 类型为 '%s' （必须为 'character' 或 NULL）"

#: chmatch.c:19
#, c-format
msgid "x is type '%s' (must be 'character' or NULL)"
msgstr "x 类型为 '%s' （必须为'character'或 NULL）"

#: chmatch.c:105
#, c-format
msgid ""
"Failed to allocate %<PRIu64> bytes working memory in chmatchdup: "
"length(table)=%d length(unique(table))=%d"
msgstr ""
"无法为 chmatchdup: length(table)=%2$d length(unique(table))=%3$d 分配 "
"%1$<PRIu64> 字节的内存空间"

#: cj.c:89
#, c-format
msgid "Type '%s' is not supported by CJ."
msgstr "CJ 不支持 '%s' 类型"

#: coalesce.c:14
msgid ""
"The first argument is a list, data.table or data.frame. In this case there "
"should be no other arguments provided."
msgstr ""
"第一个参数是一个 list, data.table 或 data.frame。当前不应该提供其他参数。"

#: coalesce.c:30
#, c-format
msgid ""
"Item 1 is a factor but item %d is not a factor. When factors are involved, "
"all items must be factor."
msgstr "元素1是一个因子，但元素 %d 不是。当涉及因子时，所有元素必须都为因子。"

#: coalesce.c:32
#, c-format
msgid ""
"Item %d is a factor but its levels are not identical to the first item's "
"levels."
msgstr "元素 %d 是一个因子，但因子水平与第一个元素因子水平不同。"

#: coalesce.c:36
#, c-format
msgid ""
"Item %d is a factor but item 1 is not a factor. When factors are involved, "
"all items must be factor."
msgstr "元素 %d 是一个因子，但元素1不是。当涉及因子时，所有元素必须都为因子。"

#: coalesce.c:39
#, c-format
msgid ""
"Item %d is type %s but the first item is type %s. Please coerce before "
"coalescing."
msgstr ""
"元素 %d 类型为 %s，但是第一个元素类型为 %s。请在 coalescing 之前强制转换类"
"型。"

#: coalesce.c:41
#, c-format
msgid "Item %d has a different class than item 1."
msgstr "元素 %d 与元素1类型不同。"

#: coalesce.c:44
#, c-format
msgid ""
"Item %d is length %d but the first item is length %d. Only singletons are "
"recycled."
msgstr ""
"元素 %d 长度为 %d，但第一个元素长度为 %d。只有长度为1的元素才会进行循环补齐。"

#: coalesce.c:48
msgid "coalesce copied first item (inplace=FALSE)\n"
msgstr "coalesce 复制了第一项 (inplace=FALSE)\n"

#: coalesce.c:164 fifelse.c:193 shift.c:171 uniqlist.c:98 uniqlist.c:130
#: uniqlist.c:211 uniqlist.c:248 uniqlist.c:321
#, c-format
msgid "Type '%s' is not supported"
msgstr "不支持类型 '%s'"

#: dogroups.c:85 gsumm.c:43
msgid "env is not an environment"
msgstr "env不是环境"

#: dogroups.c:109
#, c-format
msgid "!length(bynames)[%d]==length(groups)[%d]==length(grpcols)[%d]"
msgstr "!length(bynames)[%d]==length(groups)[%d]==length(grpcols)[%d]"

#: dogroups.c:131
msgid "row.names attribute of .SD not found"
msgstr ".SD 的行名属性不存在"

#: dogroups.c:133
#, c-format
msgid ""
"row.names of .SD isn't integer length 2 with NA as first item; i.e., ."
"set_row_names(). [%s %d %d]"
msgstr ""
".SD 的行名不是长度为2且首个元素为 NA 的整型；例如：set_row_names(). [%s %d "
"%d]"

#: dogroups.c:138
msgid "length(names)!=length(SD)"
msgstr "length(names)!=length(SD)"

#: dogroups.c:154
msgid "length(xknames)!=length(xSD)"
msgstr "length(xknames)!=length(xSD)"

#: dogroups.c:162
#, c-format
msgid "length(iSD)[%d] != length(jiscols)[%d]"
msgstr "length(iSD)[%d] != length(jiscols)[%d]"

#: dogroups.c:163
#, c-format
msgid "length(xSD)[%d] != length(xjiscols)[%d]"
msgstr "length(xSD)[%d] != length(xjiscols)[%d]"

#: dogroups.c:274
#, c-format
msgid "j evaluates to type '%s'. Must evaluate to atomic vector or list."
msgstr "j的运算结果为'%s'类型。其运算结果必须为原子向量或列表。"

#: dogroups.c:283
#, c-format
msgid ""
"Entry %d for group %d in j=list(...) should be atomic vector or list. If you "
"are trying something like j=list(.SD,newcol=mean(colA)) then use := by group "
"instead (much quicker), or cbind or merge afterwards."
msgstr ""
"j=list(...) 里的 %d 组的第 %d 项目本该是原子向量或列表。如果您在试图进行 "
"j=list(.SD,newcol=mean(colA)) 之类的操作请使用 := by group 代替(更快速)，或事"
"后使用 cbind()、merge()"

#: dogroups.c:290
#, c-format
msgid ""
"Entry %d for group %d in j=list(...) is an array with %d dimensions > 1, "
"which is disallowed. \"Break\" the array yourself with c() or as.vector() if "
"that is intentional."
msgstr ""
"j=list(...) 里的 %d 组的第 %d 项目本是一个 %d 维度 > 1 的排列，这是不允许的。"
"如果这是故意的话请使用 c() 或 as.vector() 来分裂该数组"

#: dogroups.c:300
msgid ""
"RHS of := is NULL during grouped assignment, but it's not possible to delete "
"parts of a column."
msgstr "用 := 分组时 RHS 为 NULL但無法刪除部分列"

#: dogroups.c:304
#, c-format
msgid ""
"Supplied %d items to be assigned to group %d of size %d in column '%s'. The "
"RHS length must either be 1 (single values are ok) or match the LHS length "
"exactly. If you wish to 'recycle' the RHS please use rep() explicitly to "
"make this intent clear to readers of your code."
msgstr ""
"提供 %1$d 个项分配给第 '%4$s' 列中的第 %2$d 组，组的大小为 %3$d RHS 的长度必"
"须是 1(可以是单个值) 或完全符合 LHS 的长度如果您想回收(recycle) RHS，请使用 "
"rep() 向你的代码读者明确表达你的意图"

#: dogroups.c:336
#, c-format
msgid "Group %d column '%s': %s"
msgstr "列 '%2$s' 第 %1$d 组 : %3$s"

#: dogroups.c:343
msgid "j doesn't evaluate to the same number of columns for each group"
msgstr "j 估算出的每组的列数不同"

#: dogroups.c:377
#, c-format
msgid ""
"Column %d of j's result for the first group is NULL. We rely on the column "
"types of the first result to decide the type expected for the remaining "
"groups (and require consistency). NULL columns are acceptable for later "
"groups (and those are replaced with NA of appropriate type and recycled) but "
"not for the first. Please use a typed empty vector instead, such as "
"integer() or numeric()."
msgstr ""
"j 的结果中第 %d 列在第 1 组中为 NULL我们依赖第 1 组的列类型去决定剩余组的类型"
"(需要一致性)空 (NULL) 列可以出现在后面的组(适当的以 NA 取代并回收)但不能是第 "
"1 组请输入空向量代替，例如 integer() 或 numeric()"

#: dogroups.c:380
msgid ""
"j appears to be a named vector. The same names will likely be created over "
"and over again for each group and slow things down. Try and pass a named "
"list (which data.table optimizes) or an unnamed list() instead.\n"
msgstr ""
"j 是名称向量，这可能使相同的名称不停重复创建导致速度变慢请尝试输入名称列表(较"
"适合 data.table)或是非名称列表代替\n"

#: dogroups.c:382
#, c-format
msgid ""
"Column %d of j is a named vector (each item down the rows is named, "
"somehow). Please remove those names for efficiency (to save creating them "
"over and over for each group). They are ignored anyway.\n"
msgstr ""
"j 的第 %d 列是名称向量(整行的项都是名称)为了效率请移除这些名称(避免在每组重复"
"创建这些名称)总之他们被忽略了\n"

#: dogroups.c:390
msgid ""
"The result of j is a named list. It's very inefficient to create the same "
"names over and over again for each group. When j=list(...), any names are "
"detected, removed and put back after grouping has completed, for efficiency. "
"Using j=transform(), for example, prevents that speedup (consider changing "
"to :=). This message may be upgraded to warning in future.\n"
msgstr ""
"j 的结果是名称列表，在每组不停重复创建相同的名称很没效率为了提高效率，当 "
"j=list(...) 时侦测到的所有名称会被移出，待分组完成后再放回来可以使用 "
"j=transform() 避免这种加速此讯息可能会在未来升级为警告\n"

#: dogroups.c:402
#, c-format
msgid "dogroups: growing from %d to %d rows\n"
msgstr "dogroups: 从 %d 列增加至 %d 列\n"

#: dogroups.c:403
#, c-format
msgid "dogroups: length(ans)[%d]!=ngrpcols[%d]+njval[%d]"
msgstr "dogroups: length(ans)[%d]!=ngrpcols[%d]+njval[%d]"

#: dogroups.c:421
#, c-format
msgid ""
"Item %d of j's result for group %d is zero length. This will be filled with "
"%d NAs to match the longest column in this result. Later groups may have a "
"similar problem but only the first is reported to save filling the warning "
"buffer."
msgstr ""
"j 的结果第 %d 项在第 %d 组中为零长度(zero length)将使用 %d 个 NA 填入以符合结"
"果中最长列的长度后面的分组也有相同问题，但只回报第一组以避免过多警告"

#: dogroups.c:428
#, c-format
msgid ""
"Column %d of result for group %d is type '%s' but expecting type '%s'. "
"Column types must be consistent for each group."
msgstr ""
"结果的第 %d 列在第 %d 组中是 '%s' 类别而非预期的 '%s' 类别所有组的列类别必须"
"一致"

#: dogroups.c:430
#, c-format
msgid ""
"Supplied %d items for column %d of group %d which has %d rows. The RHS "
"length must either be 1 (single values are ok) or match the LHS length "
"exactly. If you wish to 'recycle' the RHS please use rep() explicitly to "
"make this intent clear to readers of your code."
msgstr ""
"提供 %1$d 项给第 %3$d 組的第 %2$d 列，这组有 %4$d 行RHS長度必須為 1 (可以使用"
"單個值) 或與 LHS 長度完全匹配如果您想回收(recycle) RHS，请使用 rep() 向你的代"
"码读者明确表达你的意图"

#: dogroups.c:448 fsort.c:250 fwrite.c:707
msgid "\n"
msgstr "\n"

#: dogroups.c:449
#, c-format
msgid ""
"\rProcessed %d groups out of %d. %.0f%% done. Time elapsed: %ds. ETA: %ds."
msgstr ""

#: dogroups.c:462
#, c-format
msgid ""
"\rProcessed %d groups out of %d. %.0f%% done. Time elapsed: %ds. ETA: %ds.\n"
msgstr ""

#: dogroups.c:465
#, c-format
msgid "Wrote less rows (%d) than allocated (%d).\n"
msgstr "写入的行 (%d) 少于分配的 (%d)\n"

#: dogroups.c:489
#, c-format
msgid ""
"\n"
"  %s took %.3fs for %d groups\n"
msgstr ""
"\n"
"  %s 花了 %.3fs 在 %d 个组\n"

#: dogroups.c:491
#, c-format
msgid "  eval(j) took %.3fs for %d calls\n"
msgstr "  eval(j)取%.3fs给 %d 调用\n"

#: dogroups.c:520
msgid "growVector passed NULL"
msgstr "growVector通过NULL"

#: fastmean.c:39 rbindlist.c:8 rbindlist.c:12
#, c-format
msgid "%s should be TRUE or FALSE"
msgstr "%s 必须是TRUE或FALSE"

#: fastmean.c:45
#, c-format
msgid "fastmean was passed type %s, not numeric or logical"
msgstr "传递给 fastmean 的是 %s 类型，而不是数值或逻辑类型"

#: fcast.c:101
#, c-format
msgid "Unsupported column type in fcast val: '%s'"
msgstr "fcast val不支持的列类型：'%s'"

#: fifelse.c:5
msgid "Argument 'test' must be logical."
msgstr "参数'test'必须是逻辑类型。"

#: fifelse.c:9
msgid "S4 class objects (except nanotime) are not supported."
msgstr "不支持的S4 类对象（nanotime 除外）。"

#: fifelse.c:24
#, c-format
msgid ""
"Length of 'yes' is %<PRId64> but must be 1 or length of 'test' (%<PRId64>)."
msgstr "'yes'长度是%<PRId64>但长度必须是1或者等于'test'的长度 (%<PRId64>)。"

#: fifelse.c:26
#, c-format
msgid ""
"Length of 'no' is %<PRId64> but must be 1 or length of 'test' (%<PRId64>)."
msgstr "'no'长度是%<PRId64>但长度必须是1或者等于'test'的长度 (%<PRId64>)。"

#: fifelse.c:28
#, c-format
msgid ""
"Length of 'na' is %<PRId64> but must be 1 or length of 'test' (%<PRId64>)."
msgstr "'na'长度是%<PRId64>但长度必须是1或者等于'test'的长度 (%<PRId64>)。"

#: fifelse.c:46
#, c-format
msgid ""
"'no' is of type %s but '%s' is %s. Please make all arguments have the same "
"type."
msgstr "'no' 是 %s 类型，但 '%s' 是 %s 类型。请确保所有参数为同一类型。"

#: fifelse.c:52
#, c-format
msgid ""
"'na' is of type %s but '%s' is %s. Please make all arguments have the same "
"type."
msgstr "'na' 是 %s 类型，但 '%s' 是 %s 类型。请确保所有参数为同一类型。"

#: fifelse.c:57
msgid ""
"'yes' has different class than 'no'. Please make sure that both arguments "
"have the same class."
msgstr "'yes'的类型与'no'不同。请确认两个参数是同一类型。"

#: fifelse.c:62
msgid ""
"'yes' has different class than 'na'. Please make sure that both arguments "
"have the same class."
msgstr "'yes'的类型与'na'不同。请确认两个参数是同一类型。"

#: fifelse.c:67
msgid ""
"'no' has different class than 'na'. Please make sure that both arguments "
"have the same class."
msgstr "'no'的类型与'na'不同。请确认两个参数是同一类型。"

#: fifelse.c:74
msgid "'yes' and 'no' are both type factor but their levels are different."
msgstr "'yes'和'no'都是因子类型但他们的因子水平不同。"

#: fifelse.c:79
msgid "'yes' and 'na' are both type factor but their levels are different."
msgstr "'yes'和'na'都是因子类型但他们的因子水平不同"

#: fifelse.c:84
msgid "'no' and 'na' are both type factor but their levels are different."
msgstr "'no'和'na'都是因子类型但他们的因子水平不同"

#: fifelse.c:207
#, c-format
msgid ""
"Received %d inputs; please supply an even number of arguments in ..., "
"consisting of logical condition, resulting value pairs (in that order). Note "
"that the default argument must be named explicitly, e.g., default=0"
msgstr ""
"接收到 %d 个输入。请向 ... 中提供偶数个参数。每一参数需包含逻辑条件判断，以及"
"对应顺序的结果值对。请注意默认参数须明确给出名字，如 default=0"

#: fifelse.c:227
msgid ""
"S4 class objects (except nanotime) are not supported. Please see https://"
"github.com/Rdatatable/data.table/issues/4131."
msgstr ""
"不支持的S4 类对象（nanotime 除外）。详见 https://github.com/Rdatatable/data."
"table/issues/4131。"

#: fifelse.c:230
#, fuzzy, c-format
#| msgid "Argument #%d must be logical."
msgid "Argument #%d must be logical but was of type %s."
msgstr "参数 #%d 必须为逻辑类型。"

#: fifelse.c:248
#, fuzzy, c-format
#| msgid ""
#| "Argument #%d has a different length than argument #1. Please make sure "
#| "all logical conditions have the same length."
msgid ""
"Argument #%d has length %lld which differs from that of argument #1 (%lld). "
"Please make sure all logical conditions have the same length."
msgstr "参数 #%d 与参数 #1 长度不同。请确认所有逻辑条件的长度相等。"

#: fifelse.c:254
#, c-format
msgid ""
"Resulting value is of type %s but 'default' is of type %s. Please make sure "
"that both arguments have the same type."
msgstr "结果为 %s 类型，然而 'default' 却为 %s 类型。请确认二者为同一类型。"

#: fifelse.c:257
#, c-format
msgid ""
"Argument #%d is of type %s, however argument #2 is of type %s. Please make "
"sure all output values have the same type."
msgstr ""
"参数 #%d 为 %s 类型，但参数 #2 为 %s 类型。请确认所有输出均为同一类型。"

#: fifelse.c:265
msgid ""
"Resulting value has different class than 'default'. Please make sure that "
"both arguments have the same class."
msgstr "结果的类型与 'default' 的类型不同。请确认二者为同一类型。"

#: fifelse.c:268
#, c-format
msgid ""
"Argument #%d has different class than argument #2, Please make sure all "
"output values have the same class."
msgstr "参数 #2 的类型与参数 #%d 的不同。请确认所有输出均为同一类型。"

#: fifelse.c:277
msgid ""
"Resulting value and 'default' are both type factor but their levels are "
"different."
msgstr "结果和 'default' 均为因子类型，但其因子水平不同。"

#: fifelse.c:279
#, c-format
msgid ""
"Argument #2 and argument #%d are both factor but their levels are different."
msgstr "参数 #2 和参数 #%d 均为因子类型，但其因子水平不同。"

#: fifelse.c:288
#, fuzzy, c-format
#| msgid "Length of 'default' must be 1."
msgid "Length of 'default' must be 1 or %lld."
msgstr "'default' 长度必须是 1。"

#: fifelse.c:290
#, fuzzy, c-format
#| msgid ""
#| "Length of output value #%d must either be 1 or length of logical "
#| "condition."
msgid ""
"Length of output value #%d (%lld) must either be 1 or match the length of "
"the logical condition (%lld)."
msgstr "#%d 输出的长度必须为 1 或与逻辑判断条件的长度相同。"

#: fifelse.c:395
#, fuzzy, c-format
#| msgid "Type '%s' is not supported"
msgid "Type '%s' is not supported."
msgstr "不支持类型 '%s'"

#: fmelt.c:18
msgid "'x' must be an integer"
msgstr "'x'必须是整数"

#: fmelt.c:19
msgid "'n' must be a positive integer"
msgstr "'n'必须是正整数"

#: fmelt.c:41
msgid "Argument to 'which' must be logical"
msgstr "'which'的参数必须是逻辑值"

#: fmelt.c:65
msgid "concat: 'vec' must be a character vector"
msgstr "concat：'vec' 必须是一个字符向量"

#: fmelt.c:66
msgid "concat: 'idx' must be an integer vector of length >= 0"
msgstr "concat：'idx' 必须为一个长度>= 0的整数向量"

#: fmelt.c:134
#, c-format
msgid "Unknown 'measure.vars' type %s at index %d of list"
msgstr "未知'measure.vars'类型 %s，位于列表中 %d"

#: fmelt.c:187
msgid "One or more values in 'measure.vars' is invalid."
msgstr "'measure.vars'里，一或多个数值无效"

#: fmelt.c:189
msgid "One or more values in 'id.vars' is invalid."
msgstr "'id.vars'里，一或多个数值无效"

#: fmelt.c:213
#, c-format
msgid ""
"Unknown 'measure.vars' type %s, must be character or integer vector/list"
msgstr "未知'measure.vars'类型 %s，必须是字符或者整数向量(vector)/列表(list)"

#: fmelt.c:215
#, c-format
msgid "Unknown 'id.vars' type %s, must be character or integer vector"
msgstr "未知'id.vars'类型 %s，必须是字符或者整数向量(vector)"

#: fmelt.c:240
#, c-format
msgid ""
"id.vars and measure.vars are internally guessed when both are 'NULL'. All "
"non-numeric/integer/logical type columns are considered id.vars, which in "
"this case are columns [%s]. Consider providing at least one of 'id' or "
"'measure' vars in future."
msgstr ""
"当'id.vars'和'measure.vars'都是NULL时，data.table会自动猜测适当值。所有非数"
"值/整数/逻辑类型列会作为'id.vars'，即以下列 [%s]。以后请考虑择一指定'id."
"vars'或'measure.vars'。"

#: fmelt.c:246
msgid ""
"'measure.vars' is missing. Assigning all columns other than 'id.vars' "
"columns as 'measure.vars'.\n"
msgstr ""
"找不到'measure.vars'。将指定所有'id.vars'以外的所有列为'measure.vars'。\n"

#: fmelt.c:248
#, c-format
msgid "Assigned 'measure.vars' are [%s].\n"
msgstr "指定'measure.vars'为[%s]。\n"

#: fmelt.c:259
msgid ""
"'id.vars' is missing. Assigning all columns other than 'measure.vars' "
"columns as 'id.vars'.\n"
msgstr "找不到'id.vars'。将指定所有'measure.vars'以外的所有列为'id.vars'。\n"

#: fmelt.c:260
#, c-format
msgid "Assigned 'id.vars' are [%s].\n"
msgstr "指定的 'id.vars' 是 [%s].\n"

#: fmelt.c:314
msgid ""
"When 'measure.vars' is a list, 'value.name' must be a character vector of "
"length =1 or =length(measure.vars)."
msgstr ""
"当'measure.vars'是一个列表(list), 'value.name' 必须是一个长度为1或者等于"
"length(measure.vars)的字符向量"

#: fmelt.c:315
msgid ""
"When 'measure.vars' is either not specified or a character/integer vector, "
"'value.name' must be a character vector of length =1."
msgstr ""
"当'measure.vars'未被指定或者是一个字符/整数向量时，'value.name'必须是一个长度"
"1的字符/整数向量"

#: fmelt.c:318
msgid "'variable.name' must be a character/integer vector of length 1."
msgstr "'variable.name' 必须是长度1的字符/整数向量。"

#: fmelt.c:371
msgid ""
"variable_table attribute of measure.vars should be a data table with at "
"least one column"
msgstr "measure.vars 的 variable_table 属性应为一个至少有一列的 data.table"

#: fmelt.c:376
#, c-format
msgid ""
"variable_table attribute of measure.vars should be a data table with same "
"number of rows as max length of measure.vars vectors =%d"
msgstr ""
"measure.vars 的 variable_table 属性应为一个 data.table，且该 data.table 的行"
"应与 measure.vars 向量中的最大长度（=%d）一致"

#: fmelt.c:380
msgid ""
"variable_table attribute of measure.vars should be either NULL or a data "
"table"
msgstr "measure.vars 的 variable_table 属性应为 NULL 或一个 data.table"

#: fmelt.c:463
#, c-format
msgid ""
"'measure.vars' [%s] are not all of the same type. By order of hierarchy, the "
"molten data value column will be of type '%s'. All measure variables not of "
"type '%s' will be coerced too. Check DETAILS in ?melt.data.table for more on "
"coercion.\n"
msgstr ""
"'measure.vars'[%1$s] 的数据类型不完全相同。由于融合后的数据将是'%2$s'类型，所"
"以变量中不是'%3$s'类型的数将被强制转换为'%2$s'类型，更多关于强制转换的信息请"
"查看 ?melt.data.table.\n"

#: fmelt.c:575
#, c-format
msgid "Unknown column type '%s' for column '%s'."
msgstr "'%s'列是未知的纵列类型: '%s'"

#: fmelt.c:685
#, c-format
msgid "variable_table does not support column type '%s' for column '%s'."
msgstr "variable_table 不支持列 '%2$s' 所包含的数据类型 '%1$s'。"

#: fmelt.c:779
#, c-format
msgid "Unknown column type '%s' for column '%s' in 'data'"
msgstr "'data' 中的'%s'列是未知列类型:'%s'"

#: fmelt.c:790
msgid "Input is not of type VECSXP, expected a data.table, data.frame or list"
msgstr "输入类型不是 VECSXP，输入类型应该是 data.table,data.frame 或 list。"

#: fmelt.c:791
msgid "Argument 'value.factor' should be logical TRUE/FALSE"
msgstr "'value.factor' 的参数是逻辑值，必须是 TRUE 或FALSE"

#: fmelt.c:792
msgid "Argument 'variable.factor' should be logical TRUE/FALSE"
msgstr "'variable.factor' 的参数是逻辑值，必须是 TRUE 或FALSE"

#: fmelt.c:793
msgid "Argument 'na.rm' should be logical TRUE/FALSE."
msgstr "'na.rm' 的参数是逻辑值，必须是 TRUE 或 FALSE"

#: fmelt.c:794
msgid "Argument 'variable.name' must be a character vector"
msgstr "'variable.name' 必须是字符串类型"

#: fmelt.c:795
msgid "Argument 'value.name' must be a character vector"
msgstr "'value.name' 必须是字符串类型"

#: fmelt.c:796
msgid "Argument 'verbose' should be logical TRUE/FALSE"
msgstr "'verbose' 的参数是逻辑值，必须是 TRUE 或 FALSE"

#: fmelt.c:800
msgid "ncol(data) is 0. Nothing to melt. Returning original data.table."
msgstr "ncol(data)为0，返回原 data.table"

#: fmelt.c:805
msgid "names(data) is NULL. Please report to data.table-help"
msgstr "names(data)为NULL，请向 data.table-help 报告"

#: forder.c:111 fread.c:2587 utils.c:446
msgid "Internal error in"
msgstr "内部错误"

#: forder.c:111 utils.c:446
msgid "Please report to the data.table issues tracker."
msgstr "请将此问题汇报给 data.table 问题追踪器。"

#: forder.c:121
#, c-format
msgid "Failed to realloc thread private group size buffer to %d*4bytes"
msgstr "无法将线程私有的组大小缓冲区重新分配为%d*4字节"

#: forder.c:135
#, c-format
msgid "Failed to realloc group size result to %d*4bytes"
msgstr "分配%d*4字节内存时失败。"

#: forder.c:269
#, c-format
msgid ""
"Logical error. counts[0]=%d in cradix but should have been decremented to 0. "
"radix=%d"
msgstr "逻辑错误：在 cradix 中的 counts[0] 应该为0，而不是%dradix=%d"

#: forder.c:287
#, fuzzy
#| msgid "Failed to alloc cradix_counts"
msgid "Failed to alloc cradix_counts and/or cradix_tmp"
msgstr "分配 cradix_counts 失败"

#: forder.c:320
#, c-format
msgid "Unable to realloc %d * %d bytes in range_str"
msgstr "在 range_str 中，无法重新分配%d * %d字节"

#: forder.c:347
msgid "Failed to alloc ustr3 when converting strings to UTF8"
msgstr "将字符串转换为 UTF8 格式时，无法分配ustr3"

#: forder.c:366
msgid "Failed to alloc tl when converting strings to UTF8"
msgstr "将字符串转换为 UTF8 格式时，无法分配 tl"

#: forder.c:395
msgid "Must an integer or numeric vector length 1"
msgstr "必须是长度为1的整数或数字向量"

#: forder.c:396
msgid "Must be 2, 1 or 0"
msgstr "必须是2、1或者0"

#: forder.c:431
msgid "Unknown non-finite value; not NA, NaN, -Inf or +Inf"
msgstr "未知的取值范围，不属于 NA, NaN, -Inf 或 +Inf"

#: forder.c:457
msgid ""
"Input is an atomic vector (not a list of columns) but order= is not a length "
"1 integer"
msgstr ""
"输入值是一个原子向量(而不是列表中的一列)，但参数 order不是长度为1的整数"

#: forder.c:459
#, c-format
msgid "forder.c received a vector type '%s' length %d\n"
msgstr "forder.c 接收到一个类型为'%s'长度为%d的向量\n"

#: forder.c:467
#, c-format
msgid "forder.c received %d rows and %d columns\n"
msgstr "forder.c 接收到%d行和%d列\n"

#: forder.c:477
#, fuzzy, c-format
#| msgid ""
#| "Either order= is not integer or its length (%d) is different to by='s "
#| "length (%d)"
msgid "'order' length (%d) is different to by='s length (%d)"
msgstr "参数 order 不是整数，或者它的长度(%d)与参数 'by' 指定的长度(%d)不同"

#: forder.c:491
#, c-format
msgid ""
"Column %d is length %d which differs from length of column 1 (%d), are you "
"attempting to order by a list column?\n"
msgstr ""
"第 %d 列的长度是 %d，与第 1 列的长度(%d)不同。你是在尝试通过一个列表类型的列"
"来排序吗？\n"

#: forder.c:495
msgid "retGrp must be TRUE or FALSE"
msgstr "retGrp 的参数是逻辑值，必须是 TRUE 或 FALSE"

#: forder.c:498
msgid "retStats must be TRUE or FALSE"
msgstr "retStats 的参数是逻辑值，必须是 TRUE 或 FALSE"

#: forder.c:503
msgid "sort must be TRUE or FALSE"
msgstr "sort 的参数是逻辑值，必须是 TRUE 或 FALSE"

#: forder.c:506
msgid "At least one of retGrp= or sort= must be TRUE"
msgstr "retGrp 和sort 的参数中，至少一个必须是 TRUE"

#: forder.c:508
msgid "na.last must be logical TRUE, FALSE or NA of length 1"
msgstr "na.last 的参数必须是逻辑值 TRUE, FALSE 或 NA "

#: forder.c:542 forder.c:656
#, c-format
msgid "Unable to allocate %<PRIu64> bytes of working memory"
msgstr "无法分配%<PRIu64>字节的工作内存"

#: forder.c:560
#, c-format
msgid "Item %d of order (ascending/descending) is %d. Must be +1 or -1."
msgstr "排序(ascending/descending)选项%d是%d，必须是+1 or -1"

#: forder.c:586
#, c-format
msgid ""
"\n"
"*** Column %d passed to forder is a date stored as an 8 byte double but no "
"fractions are present. Please consider a 4 byte integer date such as IDate "
"to save space and time.\n"
msgstr ""
"\n"
"***传递给 forder 的%d列是一个没有小数的8字节 double 类型的日期数据，请考虑使"
"用4字节的整数日期（例如IDate）以节省空间和时间\n"

#: forder.c:602
#, c-format
msgid "Column %d passed to [f]order is type '%s', not yet supported."
msgstr "传递给 [f]order 的第%d列为 '%s'类型，目前尚不支持。"

#: forder.c:771
#, c-format
msgid "nradix=%d\n"
msgstr "nradix=%d\n"

#: forder.c:780
#, c-format
msgid ""
"Failed to allocate TMP or UGRP or they weren't cache line aligned: nth=%d"
msgstr "分配TMP或UGRP失败或缓存行不一致： nth=%d"

#: forder.c:789
msgid "Could not allocate (very tiny) group size thread buffers"
msgstr "无法分配（极小）块组大小的线程缓冲区"

#: forder.c:857
#, c-format
msgid "Timing block %2d%s = %8.3f   %8d\n"
msgstr "定时块 %2d%s = %8.3f   %8d\n"

#: forder.c:860
#, c-format
msgid "stat[%03d]==%20<PRIu64>\n"
msgstr "stat[%03d]==%20<PRIu64>\n"

#: forder.c:908 forder.c:978 forder.c:1000 forder.c:1102 forder.c:1233
#: forder.c:1289 fread.c:2573
#, fuzzy, c-format
#| msgid "Failed to allocate %d bytes for size array: %s"
msgid "Failed to allocate %d bytes for '%s'."
msgstr "无法分配 %d 字节给 size 数组：%s"

#: forder.c:1133
#, c-format
msgid "Failed to allocate parallel counts. my_n=%d, nBatch=%d"
msgstr "分配并行计算失败，my_n=%d, nBatch=%d"

#: forder.c:1145
#, fuzzy, c-format
#| msgid "Failed to allocate %d bytes for size array: %s"
msgid "Failed to allocate 'my_otmp' and/or 'my_ktmp' arrays (%d bytes)."
msgstr "无法分配 %d 字节给 size 数组：%s"

#: forder.c:1250
#, c-format
msgid "Unable to allocate TMP for my_n=%d items in parallel batch counting"
msgstr "无法分配TMP给并行批处理计算的 my_n=%d 项"

#: forder.c:1365 forder.c:1416
#, c-format
msgid "issorted 'by' [%d] out of range [1,%d]"
msgstr "issorted 参数 'by' 的值%d超出[1，%d]的范围"

#: forder.c:1370
msgid "is.sorted does not work on list columns"
msgstr "is.sorted 不支持列表（list）列"

#: forder.c:1403 forder.c:1433 forder.c:1467
#, c-format
msgid "type '%s' is not yet supported"
msgstr "类型 '%s' 目前不支持"

#: forder.c:1480
msgid "x must be either NULL or an integer vector"
msgstr "x 必须为空值或整型向量"

#: forder.c:1482
msgid "nrow must be integer vector length 1"
msgstr "nrow 必须为长度为1的整型向量"

#: forder.c:1484
#, c-format
msgid "nrow==%d but must be >=0"
msgstr "nrow==%d 但是必须 >=0"

#: forder.c:1501
msgid "x must be type 'double'"
msgstr "x 必须为浮点数类型"

#: frank.c:14 frank.c:192
#, c-format
msgid "Item %d of 'cols' is %d which is outside 1-based range [1,ncol(x)=%d]"
msgstr "'cols' 的 %d 项为 %d ，超出1的范围 [1,ncol(x)=%d]"

#: frank.c:24 frank.c:200
#, c-format
msgid ""
"Column %d of input list x is length %d, inconsistent with first column of "
"that item which is length %d."
msgstr "输入列表x的列 %d 长度为 %d，不同于第一列的该项长度为 %d"

#: frank.c:101 frank.c:234 transpose.c:97
#, c-format
msgid "Unsupported column type '%s'"
msgstr "不支持的列类型 '%s'"

#: fread.c:154
#, c-format
msgid "System error %lu unmapping view of file\n"
msgstr "系统错误 %lu 取消映射文件视图\n"

#: fread.c:157
#, c-format
msgid "System errno %d unmapping file: %s\n"
msgstr "系统错误 %d 取消映射文件： %s\n"

#: fread.c:446
#, c-format
msgid "Unable to allocate %s of contiguous virtual RAM. %s allocation."
msgstr "无法分配 %s 的连续虚拟内存。 %s 已分配。"

#: fread.c:451
#, c-format
msgid "Avoidable %.3f seconds. %s time to copy.\n"
msgstr "可避免的 %.3f 秒。 %s 复制用时\n"

#: fread.c:452
#, c-format
msgid "  File copy in RAM took %.3f seconds.\n"
msgstr "  内存上的文件复制耗时 %.3f 秒\n"

#: fread.c:1283
msgid ""
"Previous fread() session was not cleaned up properly. Cleaned up ok at the "
"beginning of this fread() call.\n"
msgstr "之前的会话fread()未正确清理。在当前 fread() 会话开始前清理好\n"

#: fread.c:1286
msgid "[01] Check arguments\n"
msgstr "[01] 参数检查\n"

#: fread.c:1293
#, c-format
msgid "  Using %d threads (omp_get_max_threads()=%d, nth=%d)\n"
msgstr "  使用 %d 线程 (omp_get_max_threads()=%d, nth=%d)\n"

#: fread.c:1315
#, c-format
msgid "freadMain: NAstring <<%s>> has whitespace at the beginning or end"
msgstr "freadMain: NAstring <<%s>> 在开始或者结束处有空白"

#: fread.c:1319
#, c-format
msgid ""
"freadMain: NAstring <<%s>> is recognized as type boolean, this is not "
"permitted."
msgstr "freadMain: NAstring <<%s>> 被识别为布尔型，这是不允许"

#: fread.c:1321
#, c-format
msgid "freadMain: NAstring <<%s>> and logical01=TRUE, this is not permitted."
msgstr "freadMain: NAstring 为 <<%s>> 同时 logical01=TRUE，不允许这种情况。"

#: fread.c:1333
msgid "  No NAstrings provided.\n"
msgstr "  未提供 NAstrings \n"

#: fread.c:1335
msgid "  NAstrings = ["
msgstr "  NAstrings = ["

#: fread.c:1338
msgid "]\n"
msgstr "]\n"

#: fread.c:1340
msgid "  One or more of the NAstrings looks like a number.\n"
msgstr "  一个或多个 NAstrings 类似数值\n"

#: fread.c:1342
msgid "  None of the NAstrings look like numbers.\n"
msgstr "  没有 NAstrings 为数值\n"

#: fread.c:1344
#, c-format
msgid "  skip num lines = %<PRId64>\n"
msgstr "  跳过行数为 %<PRId64>\n"

#: fread.c:1345
#, c-format
msgid "  skip to string = <<%s>>\n"
msgstr "  跳转至 string = <<%s>>\n"

#: fread.c:1346
#, c-format
msgid "  show progress = %d\n"
msgstr "  显示进程 %d\n"

#: fread.c:1347
#, c-format
msgid "  0/1 column will be read as %s\n"
msgstr "  0/1 列被读取为 %s\n"

#: fread.c:1359
#, c-format
msgid "sep == quote ('%c') is not allowed"
msgstr "sep == quote ('%c') 不被允许"

#: fread.c:1360
#, c-format
msgid "sep == dec ('%c') is not allowed"
msgstr "sep == dec ('%c') 不允许"

#: fread.c:1361
#, c-format
msgid "quote == dec ('%c') is not allowed"
msgstr "quote == dec ('%c') 不允许"

#: fread.c:1378
msgid "[02] Opening the file\n"
msgstr "[02] 打开文件\n"

#: fread.c:1381
msgid ""
"  `input` argument is provided rather than a file name, interpreting as raw "
"text to read\n"
msgstr "提供 `input` 参数而非文件名，理解为原始的文本读取\n"

#: fread.c:1388
#, c-format
msgid "  Opening file %s\n"
msgstr "  打开文件 %s\n"

#: fread.c:1392 fread.c:1421
#, c-format
msgid "File not found: %s"
msgstr "文件没有找到：%s"

#: fread.c:1396
#, c-format
msgid "Opened file ok but couldn't obtain its size: %s"
msgstr "文件能够打开但无法获知其大小：%s"

#: fread.c:1399 fread.c:1431
#, c-format
msgid "File is empty: %s"
msgstr "文件是空的：%s"

#: fread.c:1400 fread.c:1432
#, c-format
msgid "  File opened, size = %s.\n"
msgstr "  文件已打开，大小为 %s.\n"

#: fread.c:1427
#, c-format
msgid "Unable to open file after %d attempts (error %lu): %s"
msgstr "经过 %d 次尝试后仍无法打开文件（错误 %lu）：%s"

#: fread.c:1429
#, c-format
msgid "GetFileSizeEx failed (returned 0) on file: %s"
msgstr "GetFileSizeEx 未能成功执行（返回值为0）于文件：%s"

#: fread.c:1434
#, c-format
msgid "This is Windows, CreateFileMapping returned error %lu for file %s"
msgstr "现在在Windows下，CreateFileMapping 返回错误 %lu 于文件 %s"

#: fread.c:1441
#, c-format
msgid ""
"Opened %s file ok but could not memory map it. This is a %dbit process. %s."
msgstr "能够打开文件 %s 但不能创建内存映射。这是一个 %d 位进程。 %s."

#: fread.c:1442
msgid "Please upgrade to 64bit"
msgstr "请升级到64位"

#: fread.c:1442
msgid "There is probably not enough contiguous virtual memory available"
msgstr "多半没有足够的连续虚拟内存"

#: fread.c:1445
msgid "  Memory mapped ok\n"
msgstr "  内存映射正常\n"

#: fread.c:1464
msgid "[03] Detect and skip BOM\n"
msgstr "[03] 检测并跳过字节顺序标记（BOM）\n"

#: fread.c:1468
msgid ""
"  UTF-8 byte order mark EF BB BF found at the start of the file and "
"skipped.\n"
msgstr "在文件头发现了UTF-8 字节顺序标记（BOM）EF BB BF 并已跳过。\n"

#: fread.c:1473
msgid ""
"GB-18030 encoding detected, however fread() is unable to decode it. Some "
"character fields may be garbled.\n"
msgstr "检测到GB-18030 编码，但fread() 未能解码。某些 字符字段可能有乱码。\n"

#: fread.c:1476
msgid ""
"File is encoded in UTF-16, this encoding is not supported by fread(). Please "
"recode the file to UTF-8."
msgstr "文件编码是UTF-16，fread()不支持此编码。请 将文件转换为UTF-8。"

#: fread.c:1481
#, c-format
msgid "  Last byte(s) of input found to be %s and removed.\n"
msgstr "  发现输入的最后字节是 %s 并已去除。\n"

#: fread.c:1484
msgid "Input is empty or only contains BOM or terminal control characters"
msgstr "输入是空的或只有字节顺序标记（BOM）或终端控制字符"

#: fread.c:1491
msgid "[04] Arrange mmap to be \\0 terminated\n"
msgstr "[04] 设定mmap为 \\0 终止\n"

#: fread.c:1498
msgid ""
"  No \\n exists in the file at all, so single \\r (if any) will be taken as "
"one line ending. This is unusual but will happen normally when there is no "
"\\r either; e.g. a single line missing its end of line.\n"
msgstr ""
"  文件中完全没有换行符\\n，所以单个 \\r（如果有的话）将被当成一行的结束。这不"
"太常见但如果没有\\r 的话属于正常；例如单个行没有行尾结束符。\n"

#: fread.c:1499
msgid ""
"  \\n has been found in the input and different lines can end with different "
"line endings (e.g. mixed \\n and \\r\\n in one file). This is common and "
"ideal.\n"
msgstr ""
"  输入中有\\n 并且不同行可以有不同的 行尾结束符（如在一个文件中混合使用 \\n "
"和\\r\\n）。这很常见也是理想情况。\n"

#: fread.c:1523
#, c-format
msgid ""
"  File ends abruptly with '%c'. Final end-of-line is missing. Using cow page "
"to write 0 to the last byte.\n"
msgstr ""
"  文件突然中止于 '%c'。没有最后一个行尾结束符。正使用写时复制页（cow, copy-"
"on-write）写入 0 到最后一个字节。\n"

#: fread.c:1529
msgid ""
"This file is very unusual: it ends abruptly without a final newline, and "
"also its size is a multiple of 4096 bytes. Please properly end the last row "
"with a newline using for example 'echo >> file' to avoid this "
msgstr ""
"这个文件非常不正常：它突然中止而没有最后的换行，并且其大小是4096 字节的整数"
"倍。请用一个换行（例如 'echo >> file'）来恰当地结束最后一行以避免此错误"

#: fread.c:1530
#, c-format
msgid "  File ends abruptly with '%c'. Copying file in RAM. %s copy.\n"
msgstr "  文件突然中止于 '%c'。正在从内存中复制文件。%s 复制。\n"

#: fread.c:1564
msgid "[05] Skipping initial rows if needed\n"
msgstr "[05] 如需要的话跳过起始行\n"

#: fread.c:1570
#, c-format
msgid ""
"skip='%s' not found in input (it is case sensitive and literal; i.e., no "
"patterns, wildcards or regex)"
msgstr ""
"在输入中没有发现 skip='%s' （这里大小写敏感并需要是字面形式，也就是说不能使用"
"模式，适配符或正则表达式）"

#: fread.c:1576
#, c-format
msgid ""
"Found skip='%s' on line %<PRIu64>. Taking this to be header row or first row "
"of data.\n"
msgstr "在行 %2$<PRIu64> 发现了 skip='%1$s'。将此当做表头或数据的第一行。\n"

#: fread.c:1589
#, c-format
msgid "  Skipped to line %<PRIu64> in the file"
msgstr "  跳到文件的第 %<PRIu64> 行"

#: fread.c:1590
#, c-format
msgid "skip=%<PRIu64> but the input only has %<PRIu64> line%s"
msgstr "skip=%<PRIu64> 但输入只有 %<PRIu64> 行 %s"

#: fread.c:1599
msgid ""
"Input is either empty, fully whitespace, or skip has been set after the last "
"non-whitespace."
msgstr "输入是空，或全部为空白，或跳过设置是在最后一个非空白字符之后。"

#: fread.c:1601
#, c-format
msgid "  Moved forward to first non-blank line (%d)\n"
msgstr "  前移到第一个非空行 (%d)\n"

#: fread.c:1602
#, c-format
msgid "  Positioned on line %d starting: <<%s>>\n"
msgstr "  定位到行 %d 开始于： <<%s>>\n"

#: fread.c:1624
msgid "[06] Detect separator, quoting rule, and ncolumns\n"
msgstr "[06] 检测分隔符，引用规则，以及列数\n"

#: fread.c:1628
msgid "  sep='\\n' passed in meaning read lines as single character column\n"
msgstr "  sep='\\n' 设定意味着将把所有行读作一个字符列\n"

#: fread.c:1647
msgid "  Detecting sep automatically ...\n"
msgstr "  自动检测分隔符中 ...\n"

#: fread.c:1654
#, c-format
msgid "  Using supplied sep '%s'\n"
msgstr "  使用提供的分隔符 '%s'\n"

#: fread.c:1688
#, c-format
msgid "  with %d fields using quote rule %d\n"
msgstr "  对 %d 个字段使用引用规则 %d\n"

#: fread.c:1738
#, c-format
msgid "  with %d lines of %d fields using quote rule %d\n"
msgstr "  对 %d 行的 %d 字段使用引用规则 %d\n"

#: fread.c:1745
msgid ""
"  No sep and quote rule found a block of 2x2 or greater. Single column "
"input.\n"
msgstr "  没有分隔符并且引用规则发现了一个大于或等于2x2的区块。输入是单列。\n"

#: fread.c:1761
msgid ""
"Single column input contains invalid quotes. Self healing only effective "
"when ncol>1"
msgstr "单列输入包含了不合法的引用。自我修正只有在列数大于1（ncol>1）时才有效"

#: fread.c:1766
#, c-format
msgid ""
"Found and resolved improper quoting in first %d rows. If the fields are not "
"quoted (e.g. field separator does not appear within any field), try "
"quote=\"\" to avoid this warning."
msgstr ""
"在前 %d 行中发现并修正了不合适的引号用法。如果字段没有加引号（例如字段间隔符"
"没有在任何字段内出现），可以尝试使用 quote=\"\" 来避免此警告。"

#: fread.c:1787
#, c-format
msgid ""
"  Detected %d columns on line %d. This line is either column names or first "
"data row. Line starts as: <<%s>>\n"
msgstr "检测到第%2$d行有%1$d列。该行为列名或数据集首行。该行以<<%3$s>>开始\n"

#: fread.c:1789
#, c-format
msgid "  Quote rule picked = %d\n"
msgstr "标点符号规则 = %d\n"

#: fread.c:1790
#, c-format
msgid "  fill=%s and the most number of columns found is %d\n"
msgstr "fill=%s 且找到的最大列数为 %d\n"

#: fread.c:1796
msgid ""
"This file is very unusual: it's one single column, ends with 2 or more end-"
"of-line (representing several NA at the end), and is a multiple of 4096, too."
msgstr ""
"该文件极为特殊，仅有一列数据，在结尾处包含多个行结束标记（表示多个空值），且"
"长度为4096的整数倍。"

#: fread.c:1797
#, c-format
msgid "  Copying file in RAM. %s\n"
msgstr "正在将文件拷贝到RAM。%s\n"

#: fread.c:1803
msgid ""
"  1-column file ends with 2 or more end-of-line. Restoring last eol using "
"extra byte in cow page.\n"
msgstr ""
"该文件包含一列数据，存在多个行结束标记（表示多个空值）。正在使用写时复制页"
"(cow, copy-on-write)额外的字节恢复最后一个标记.\n"

#: fread.c:1822
msgid ""
"[07] Detect column types, dec, good nrow estimate and whether first row is "
"column names\n"
msgstr "[07] 检测列类型，小数点分隔，良好的行数估计以及首行是否为列名\n"

#: fread.c:1823
#, c-format
msgid "  'header' changed by user from 'auto' to %s\n"
msgstr " 用户已将'header'（列名）从 'auto' 改为 %s\n"

#: fread.c:1829
#, c-format
msgid "Failed to allocate 2 x %d bytes for type and tmpType: %s"
msgstr "为 %2$s 类型分配 2 x %1$d bytes失败"

#: fread.c:1834
msgid "  sep=',' so dec set to '.'\n"
msgstr "  sep=',' 所以 dec 被设成 '.'\n"

#: fread.c:1858
#, c-format
msgid "  Number of sampling jump points = %d because "
msgstr "采样跳点数 = %d 因为"

#: fread.c:1859
#, c-format
msgid "nrow limit (%<PRIu64>) supplied\n"
msgstr "指定了nrow 的最大值 (%<PRIu64>) \n"

#: fread.c:1860
msgid "jump0size==0\n"
msgstr "jump0size==0\n"

#: fread.c:1861
#, c-format
msgid ""
"(%<PRIu64> bytes from row 1 to eof) / (2 * %<PRIu64> jump0size) == "
"%<PRIu64>\n"
msgstr ""
"(从首行到结束共 %<PRIu64> bytes) / (2 * %<PRIu64> jump0size) == %<PRIu64>\n"

#: fread.c:1900
#, c-format
msgid ""
"  A line with too-%s fields (%d/%d) was found on line %d of sample jump %d. "
"%s\n"
msgstr "第%5$d个跳点所找到的第%4$d行，该行字段过于%1$s(%2$d/%3$d). %6$s\n"

#: fread.c:1901
msgid "few"
msgstr "少"

#: fread.c:1901
msgid "many"
msgstr "多"

#: fread.c:1901
msgid ""
"Most likely this jump landed awkwardly so type bumps here will be skipped."
msgstr "很有可能这一跳点的位置并不合适，因此此处的类型转换将被跳过。"

#: fread.c:1924 fread.c:1950
#, c-format
msgid "  dec='%c' detected based on a balance of %d parsed fields\n"
msgstr "  dec='%c' 因为 %d 个解析字段的余额被检测到\n"

#: fread.c:1934
#, c-format
msgid "  Type codes (jump %03d)    : %s  Quote rule %d\n"
msgstr " 类型码（跳点 %03d）   : %s  引用规则 %d\n"

#: fread.c:1956
#, c-format
msgid ""
"  'header' determined to be true due to column %d containing a string on row "
"1 and a lower type (%s) in the rest of the %<PRId64> sample rows\n"
msgstr ""
" 'header' 参数设为真，原因是第%1$d列首行包含字符串，并且在样本中的另"
"外%3$<PRId64>行包含有较底层的数据类型(%2$s)\n"

#: fread.c:1970
#, c-format
msgid ""
"Types in 1st data row match types in 2nd data row but previous row has %d "
"fields. Taking previous row as column names."
msgstr ""
"数据第一行的类型与第二行相匹配，但是之前的行有 %d 个字段。故将第一行数据的前"
"一行作为列名"

#: fread.c:1973
#, c-format
msgid ""
"Detected %d column names but the data has %d columns (i.e. invalid file). "
"Added %d extra default column name%s\n"
msgstr ""
"检测到 %d 个列名，然而数据共有 %d 列（文件不合法）。添加了 %d 个额外列名%s\n"

#: fread.c:1974
msgid ""
" for the first column which is guessed to be row names or an index. Use "
"setnames() afterwards if this guess is not correct, or fix the file write "
"command that created the file to create a valid file."
msgstr ""
"作为第一列，并被用于猜测行名或索引。若上述猜测不正确，可在后续使用setnames()"
"进行修改，或修复用于生成该文件的文件写入命令以生成有效的文件。"

#: fread.c:1974
msgid "s at the end."
msgstr "到结尾处"

#: fread.c:1977
#, c-format
msgid ""
"Detected %d column names but the data has %d columns. Filling rows "
"automatically. Set fill=TRUE explicitly to avoid this warning.\n"
msgstr ""
"检测到%d个列名，但数据共有%d列。已经自动填充。设置参数fill=TRUE以屏蔽此警"
"告。\n"

#: fread.c:1981
#, c-format
msgid "Failed to realloc 2 x %d bytes for type and tmpType: %s"
msgstr "为 %2$s 类型重新分配 2 x %1$d bytes失败"

#: fread.c:2001
#, c-format
msgid ""
"  'header' determined to be %s because there are%s number fields in the "
"first and only row\n"
msgstr " 参数'header' 被设置为%s， 因为唯一的一行包含 %s 个字段\n"

#: fread.c:2001
msgid " no"
msgstr "0"

#: fread.c:2004
msgid ""
"  'header' determined to be true because all columns are type string and a "
"better guess is not possible\n"
msgstr "参数 'header' 被设置为true，因为所有列类型均为字符串\n"

#: fread.c:2006
msgid ""
"  'header' determined to be false because there are some number columns and "
"those columns do not have a string field at the top of them\n"
msgstr "参数 'header' 被设置为false，因为部分字段的首行不为字符串\n"

#: fread.c:2022
#, c-format
msgid "  Type codes (first row)   : %s  Quote rule %d\n"
msgstr " 类型码（第一行）   : %s  引用规则 %d\n"

#: fread.c:2031
#, c-format
msgid ""
"  All rows were sampled since file is small so we know nrow=%<PRIu64> "
"exactly\n"
msgstr " 文件太小，全部行均被采样到，所以 nrow=%<PRIu64>\n"

#: fread.c:2043 fread.c:2050
msgid "  =====\n"
msgstr " =====\n"

#: fread.c:2044
#, c-format
msgid ""
"  Sampled %<PRIu64> rows (handled \\n inside quoted fields) at %d jump "
"points\n"
msgstr "  已使用了 %2$d个跳点抽样 %1$<PRIu64> 行(处理了字段间的分隔符\\n)\n"

#: fread.c:2045
#, c-format
msgid ""
"  Bytes from first data row on line %d to the end of last row: %<PRIu64>\n"
msgstr " 从第一个数据行(%d)到最后一行的字节: %<PRIu64>\n"

#: fread.c:2046
#, c-format
msgid "  Line length: mean=%.2f sd=%.2f min=%d max=%d\n"
msgstr "文件每行长度的统计量：均值=%.2f，标准差=%.2f，最小值=%d ，最大值=%d\n"

#: fread.c:2047
#, c-format
msgid "  Estimated number of rows: %<PRIu64> / %.2f = %<PRIu64>\n"
msgstr "估计数据共有 %<PRIu64> / %.2f = %<PRIu64> 行\n"

#: fread.c:2048
#, c-format
msgid ""
"  Initial alloc = %<PRIu64> rows (%<PRIu64> + %d%%) using bytes/"
"max(mean-2*sd,min) clamped between [1.1*estn, 2.0*estn]\n"
msgstr ""
"为 %<PRIu64> 行 (%<PRIu64> + %d%%)分配初始内存，大小为字节数/max(mean-2*sd,"
"min)，并确保该数值落于区间[1.1*estn, 2.0*estn]中\n"

#: fread.c:2056
#, c-format
msgid "  Alloc limited to lower nrows=%<PRIu64> passed in.\n"
msgstr "  分配被限制在输入的更小的 nrows=%<PRIu64> 值上。\n"

#: fread.c:2068
msgid "[08] Assign column names\n"
msgstr "[08] 指定列名\n"

#: fread.c:2077
#, c-format
msgid "Unable to allocate %d*%d bytes for column name pointers: %s"
msgstr "无法分配 %d*%d 字节给列名指针: %s"

#: fread.c:2117
msgid "[09] Apply user overrides on column types\n"
msgstr "[09] 使用用户指定的列类型\n"

#: fread.c:2121
msgid "  Cancelled by user: userOverride() returned false."
msgstr "  用户已取消：userOverride() 返回 false。"

#: fread.c:2132
#, fuzzy, c-format
#| msgid "Failed to allocate %d bytes for size array: %s"
msgid "Failed to allocate %d bytes for '%s': %s"
msgstr "无法分配 %d 字节给 size 数组：%s"

#: fread.c:2139
#, c-format
msgid ""
"Attempt to override column %d%s%.*s%s of inherent type '%s' down to '%s' "
"ignored. Only overrides to a higher type are currently supported. If this "
"was intended, please coerce to the lower type afterwards."
msgstr ""
"试图覆盖第 %d 列 %s%.*s%s，将内部类型 '%s' 降级为 '%s' 的操作被忽略。只支持将"
"列类型升为更高阶的类型。如果确定此操作，请完成之后再转换类型。"

#: fread.c:2154
#, c-format
msgid "  After %d type and %d drop user overrides : %s\n"
msgstr "  经过 %d 类型和 %d 丢弃用户覆盖：%s\n"

#: fread.c:2162
msgid "[10] Allocate memory for the datatable\n"
msgstr "[10] 分配内存给 datatable\n"

#: fread.c:2163
#, c-format
msgid "  Allocating %d column slots (%d - %d dropped) with %<PRIu64> rows\n"
msgstr "  正在分配 %d 列位置（%d - %d 已丢弃），%<PRIu64> 行\n"

#: fread.c:2218
#, c-format
msgid "Buffer size %<PRId64> is too large\n"
msgstr "缓冲长度 %<PRId64> 过大\n"

#: fread.c:2221
msgid "[11] Read the data\n"
msgstr "[11] 读取数据\n"

#: fread.c:2224
#, c-format
msgid "  jumps=[%d..%d), chunk_size=%<PRIu64>, total_size=%<PRIu64>\n"
msgstr "  jumps=[%d..%d)，chunk_size=%<PRIu64>，total_size=%<PRIu64>\n"

#: fread.c:2450
#, c-format
msgid ""
"Column %d%s%.*s%s bumped from '%s' to '%s' due to <<%.*s>> on row %<PRIu64>\n"
msgstr ""
"第 %d 列 %s%.*s%s 发生了从 '%s' 到 '%s' 的类型转换，原因是由于 <<%.*s>> 出现"
"在第 %<PRIu64> 行\n"

#: fread.c:2568
#, c-format
msgid "  Provided number of fill columns: %d but only found %d\n"
msgstr "提供的填充列数: %d 但只找到 %d\n"

#: fread.c:2569
#, c-format
msgid "  Dropping %d overallocated columns\n"
msgstr "  删除 %d 个过度分配的列\n"

#: fread.c:2587
msgid "Please report to the data.table issues tracker"
msgstr "请将此问题汇报给 data.table 问题追踪器。"

#: fread.c:2594
#, c-format
msgid ""
"  Too few rows allocated. Allocating additional %<PRIu64> rows (now "
"nrows=%<PRIu64>) and continue reading from jump %d\n"
msgstr ""
"  分配的行数太少。正在分配额外的 %<PRIu64> 行（当前 nrows=%<PRIu64>），并从跳"
"跃 %d 继续读取\n"

#: fread.c:2601
#, c-format
msgid "  Restarting team from jump %d. nSwept==%d quoteRule==%d\n"
msgstr "  从跳跃 %d 重启组。nSwept==%d quoteRule==%d\n"

#: fread.c:2621
#, c-format
msgid "  %d out-of-sample type bumps: %s\n"
msgstr "  %d 样本外类型变更：%s\n"

#: fread.c:2656
#, c-format
msgid ""
"Read %<PRIu64> rows x %d columns from %s file in %02d:%06.3f wall clock "
"time\n"
msgstr "读取 %<PRIu64> 行 x %d 列，从 %s 文件（时钟时间 %02d:%06.3f）\n"

#: fread.c:2663
msgid "[12] Finalizing the datatable\n"
msgstr "[12] 最后定型 datatable\n"

#: fread.c:2664
msgid "  Type counts:\n"
msgstr " 类型数量：\n"

#: fread.c:2666
#, c-format
msgid "%10d : %-9s '%c'\n"
msgstr "%10d : %-9s '%c'\n"

#: fread.c:2682
#, c-format
msgid "Discarded single-line footer: <<%s>>"
msgstr "丢弃末尾行：<<%s>>"

#: fread.c:2688
#, fuzzy, c-format
#| msgid ""
#| "Stopped early on line %<PRIu64>. Expected %d fields but found %d. "
#| "Consider fill=%d or even more based on your knowledge of the input file. "
#| "First discarded non-empty line: <<%s>>"
msgid ""
"Stopped early on line %<PRIu64>. Expected %d fields but found %d. Consider "
"fill=%d or even more based on your knowledge of the input file. Use fill=Inf "
"for reading the whole file for detecting the number of fields. First "
"discarded non-empty line: <<%s>>"
msgstr ""
"在第 %<PRIu64> 行提前终止。预期有 %d 个字段但只找到 %d 个。可以考虑设置 "
"fill=%d 甚至更多，基于您对输入文件的了解。 首个丢弃的非空行：<<%s>>"

#: fread.c:2691
#, c-format
msgid ""
"Stopped early on line %<PRIu64>. Expected %d fields but found %d. Consider "
"fill=TRUE and comment.char=. First discarded non-empty line: <<%s>>"
msgstr ""
"在第 %<PRIu64> 行提前终止。预期有 %d 个字段但只找到 %d 个。可以考虑设置 "
"fill=TRUE 和 comment.char=。 首个丢弃的非空行：<<%s>>"

#: fread.c:2698
#, c-format
msgid ""
"Found and resolved improper quoting out-of-sample. First healed line "
"%<PRIu64>: <<%s>>. If the fields are not quoted (e.g. field separator does "
"not appear within any field), try quote=\"\" to avoid this warning."
msgstr ""
"发现并修复了样本外的错误引号。首次在第 %<PRIu64> 行修复：<<%s>>。如果这些字段"
"不在引号内（例如：字段间隔符没有在任何一个字段中出现），尝试用 quote=\"\" 来"
"避免该警告。"

#: fread.c:2702
msgid "=============================\n"
msgstr "=============================\n"

#: fread.c:2704
#, c-format
msgid "%8.3fs (%3.0f%%) Memory map %.3fGB file\n"
msgstr "%8.3fs (%3.0f%%) 内存映射 %.3fGB 文件\n"

#: fread.c:2705
#, c-format
msgid "%8.3fs (%3.0f%%) sep="
msgstr "%8.3fs (%3.0f%%) sep="

#: fread.c:2707
#, c-format
msgid " ncol=%d and header detection\n"
msgstr " ncol=%d 和表头检测\n"

#: fread.c:2708
#, c-format
msgid "%8.3fs (%3.0f%%) Column type detection using %<PRIu64> sample rows\n"
msgstr "%8.3fs (%3.0f%%) 列类型检测基于 %<PRIu64> 个样本行\n"

#: fread.c:2710
#, c-format
msgid ""
"%8.3fs (%3.0f%%) Allocation of %<PRIu64> rows x %d cols (%.3fGB) of which "
"%<PRIu64> (%3.0f%%) rows used\n"
msgstr ""
"%8.3fs (%3.0f%%) %<PRIu64> 行 x %d 列 (%.3fGB) 的分配中已使用 %<PRIu64> "
"(%3.0f%%) 行\n"

#: fread.c:2714
#, c-format
msgid ""
"%8.3fs (%3.0f%%) Reading %d chunks (%d swept) of %.3fMB (each chunk %d rows) "
"using %d threads\n"
msgstr ""
"%8.3fs (%3.0f%%) 正在读取 %d 个块 (%d 已扫描) of %.3fMB (每个块 %d 行) 使用 "
"%d 个线程\n"

#: fread.c:2716
#, c-format
msgid ""
"   + %8.3fs (%3.0f%%) Parse to row-major thread buffers (grown %d times)\n"
msgstr "   + %8.3fs (%3.0f%%) 解析到行处理线程的缓冲区（已增长 %d 次）\n"

#: fread.c:2717
#, c-format
msgid "   + %8.3fs (%3.0f%%) Transpose\n"
msgstr "   + %8.3fs (%3.0f%%) 转置\n"

#: fread.c:2718
#, c-format
msgid "   + %8.3fs (%3.0f%%) Waiting\n"
msgstr "   + %8.3fs (%3.0f%%) 正在等待\n"

#: fread.c:2719
#, c-format
msgid ""
"%8.3fs (%3.0f%%) Rereading %d columns due to out-of-sample type exceptions\n"
msgstr "%8.3fs (%3.0f%%) 正在重读 %d 列，由于样本外类型异常\n"

#: fread.c:2721
#, c-format
msgid "%8.3fs        Total\n"
msgstr "%8.3fs        总计\n"

#: freadR.c:92
#, c-format
msgid "freadR.c has been passed a filename: %s\n"
msgstr "freadR.c 接收到了一个文件名：%s\n"

#: freadR.c:96
msgid "freadR.c has been passed the data as text input (not a filename)\n"
msgstr "freadR.c 接收到了文字输入（非文件名）\n"

#: freadR.c:114
msgid "quote= must be a single character, blank \"\", or FALSE"
msgstr "quote= 必须是单个字符，空白 \"\"，或者 FALSE"

#: freadR.c:158
#, c-format
msgid "nThread(%d)<1"
msgstr "nThread(%1$d)<1（线程数（%1$d）小于1）"

#: freadR.c:166
msgid "'integer64' must be a single character string"
msgstr "'64整数型'必须是单个字符串"

#: freadR.c:174
#, c-format
msgid ""
"Invalid value integer64='%s'. Must be 'integer64', 'character', 'double' or "
"'numeric'"
msgstr ""
"64位整数型有效值='%s'.必须是'64位整数型'，'字符串'，'双精度浮点型'或者'数值"
"型'"

#: freadR.c:182
msgid "Use either select= or drop= but not both."
msgstr "select=和drop=不可同时使用"

#: freadR.c:185
msgid ""
"select= is type list for specifying types in select=, but colClasses= has "
"been provided as well. Please remove colClasses=."
msgstr ""
"select=是用于在select=中指定类型的类型列表，但是还提供了colClasses=。请删除"
"colClasses=。"

#: freadR.c:187
msgid ""
"select= is type list but has no names; expecting list(type1=cols1, "
"type2=cols2, ...)"
msgstr ""
"select =是类型列表，但没有名称； 期望列表（type1 = cols1，type2 = "
"cols2，...）"

#: freadR.c:194
msgid ""
"select= is a named vector specifying the columns to select and their types, "
"but colClasses= has been provided as well. Please remove colClasses=."
msgstr ""
"select =是一个命名向量，用于指定要选择的列及其类型，但是还提供了colClasses "
"=。 请删除colClasses =。"

#: freadR.c:202 freadR.c:368
msgid "colClasses is type list but has no names"
msgstr "colClasses是类型列表，但没有名称"

#: freadR.c:212
#, c-format
msgid "encoding='%s' invalid. Must be 'unknown', 'Latin-1' or 'UTF-8'"
msgstr "encoding ='%s'无效。 必须为'未知'，'Latin-1'或'UTF-8'"

#: freadR.c:235
#, c-format
msgid "Column name '%s' (%s) not found"
msgstr "找不到列名'%s'（%s）"

#: freadR.c:237
#, c-format
msgid "%s is NA"
msgstr "%s是缺失值"

#: freadR.c:239
#, c-format
msgid "%s is %d which is out of range [1,ncol=%d]"
msgstr "%s是%d，超出范围[1，ncol =%d]"

#: freadR.c:288
#, c-format
msgid ""
"Column name '%s' not found in column name header (case sensitive), skipping."
msgstr "在列名标题中找不到列名'%s'（区分大小写），正在跳过。"

#: freadR.c:298
#, c-format
msgid ""
"Column number %d (select[%d]) is negative but should be in the range [1,"
"ncol=%d]. Consider drop= for column exclusion."
msgstr ""
"列号%d（select [%d]）为负，但应在[1，ncol =%d]范围内。考虑drop=用于排除列。"

#: freadR.c:299
#, c-format
msgid ""
"select = 0 (select[%d]) has no meaning. All values of select should be in "
"the range [1,ncol=%d]."
msgstr ""
"select=0（select[%d]）没有意义。select的所有值都应在[1，ncol=%d]范围内。"

#: freadR.c:300
#, c-format
msgid ""
"Column number %d (select[%d]) is too large for this table, which only has %d "
"columns."
msgstr "对于此表（仅包含%d列，）列号%d（select [%d]）太大。"

#: freadR.c:301
#, c-format
msgid "Column number %d ('%s') has been selected twice by select="
msgstr "列号%d（'%s'）已由select =选择两次"

#: freadR.c:324
#, c-format
msgid ""
"colClasses= is an unnamed vector of types, length %d, but there are %d "
"columns in the input. To specify types for a subset of columns, you can use "
"a named vector, list format, or specify types using select= instead of "
"colClasses=. Please see examples in ?fread."
msgstr ""
"colClasses =是类型为%d的类型的未命名向量，但是有%d输入中的列。要为列的子集指"
"定类型，可以使用命名向量，列表格式或使用select=而不是colClasses=。请参阅'?"
"fread'中的示例。"

#: freadR.c:366
#, c-format
msgid "colClasses is type '%s' but should be list or character"
msgstr "colClasses是类型'%s'，但应该是列表或字符"

#: freadR.c:390
#, c-format
msgid "Column name '%s' (colClasses[[%d]][%d]) not found"
msgstr "找不到列名'%s'（colClasses[[%d]][%d]）"

#: freadR.c:392
#, c-format
msgid "colClasses[[%d]][%d] is NA"
msgstr "colClasses[[%d]][%d]是NA"

#: freadR.c:396
#, c-format
msgid "Column number %d (colClasses[[%d]][%d]) is out of range [1,ncol=%d]"
msgstr "列号%d(colClasses[[%d]][%d])超出范围[1,ncol=%d]"

#: freadR.c:400
#, c-format
msgid ""
"Column %d ('%s') appears more than once in colClasses. The second time is "
"colClasses[[%d]][%d]."
msgstr ""
"Column %d ('%s')在colClasses中出现了多次。第二次是colClasses[[%d]][%d]."

#: freadR.c:640
#, c-format
msgid "Field size is 1 but the field is of type %d\n"
msgstr "字段大小为1，但字段类型为%d \n"

#: freadR.c:717 utils.c:387
#, c-format
msgid "%s"
msgstr "%s"

#: froll.c:14 froll.c:223 froll.c:407
#, c-format
msgid "%s: window width longer than input vector, returning all NA vector\n"
msgstr "%s：窗口宽度比输入向量长，返回所有NA向量\n"

#: froll.c:32 froll.c:240 froll.c:456
#, c-format
msgid "%s: align %d, shift answer by %d\n"
msgstr "%s：对齐%d，将答案移位%d\n"

#: froll.c:39 froll.c:247 frolladaptive.c:19 frolladaptive.c:214
#, c-format
msgid "%s: processing algo %u took %.3fs\n"
msgstr "%s: 处理算法%u用了%.3fs\n"

#: froll.c:48 froll.c:251
#, c-format
msgid "%s: running for input length %<PRIu64>, window %d, hasna %d, narm %d\n"
msgstr ""
"%s: 正在并行运行, 输入长度 (input length) %<PRIu64>, 窗口 (window) %d, hasna "
"%d, narm %d\n"

#: froll.c:68 froll.c:78 froll.c:169 froll.c:271 froll.c:281 froll.c:362
#: frolladaptive.c:58 frolladaptive.c:147 frolladaptive.c:247
#: frolladaptive.c:326
#, c-format
msgid ""
"%s: hasNA=FALSE used but NA (or other non-finite) value(s) are present in "
"input, use default hasNA=NA to avoid this warning"
msgstr ""
"%s：使用了hasNA = FALSE，但输入中存在NA（或其他非限定性）值，请使用默认的"
"hasNA=NA以避免此警告"

#: froll.c:71 froll.c:173 froll.c:274 froll.c:366 frolladaptive.c:61
#: frolladaptive.c:151 frolladaptive.c:250 frolladaptive.c:330
#, c-format
msgid ""
"%s: NA (or other non-finite) value(s) are present in input, re-running with "
"extra care for NAs\n"
msgstr "%s：输入中存在NA（或非限定值），请格外注意NA值并重新运行\n"

#: froll.c:81 froll.c:284
#, c-format
msgid ""
"%s: NA (or other non-finite) value(s) are present in input, skip non-NA "
"attempt and run with extra care for NAs\n"
msgstr "%s: NA (或其他非有限长度值) 出现在输入中, 跳过非NA的输入并当心NA值\n"

#: froll.c:137 froll.c:335
#, c-format
msgid ""
"%s: running in parallel for input length %<PRIu64>, window %d, hasna %d, "
"narm %d\n"
msgstr ""
"%s: 正在并行运行, 输入长度 (input length) %<PRIu64>, 窗口 (window) %d, hasna "
"%d, narm %d\n"

#: froll.c:175 froll.c:368 frolladaptive.c:153 frolladaptive.c:332
#, c-format
msgid ""
"%s: NA (or other non-finite) value(s) are present in input, na.rm was FALSE "
"so in 'exact' implementation NAs were handled already, no need to re-run\n"
msgstr ""
"%s: NA (或其他非有限长度值) 出现在输入中, na.rm 为 FALSE 因此在'exact'实现"
"中, NA值已经被处理, 不需要重新运行\n"

#: froll.c:424
#, c-format
msgid "%s: results from provided FUN are not length 1"
msgstr "%s: 所提供的函数 (FUN) 的结果长度不为1"

#: froll.c:431
#, c-format
msgid ""
"%s: results from provided FUN are not of type double, coercion from integer "
"or logical will be applied on each iteration\n"
msgstr ""
"%s: 所提供的函数 (FUN) 的结果不是双精度 (double) 类型, 对整数或逻辑值的类型转"
"换会在每个循环中执行\n"

#: froll.c:434
#, c-format
msgid "%s: results from provided FUN are not of type double"
msgstr "%s: 所提供的函数 (FUN) 的结果不是双精度 (double) 类型"

#: froll.c:463 nafill.c:87
#, c-format
msgid "%s: took %.3fs\n"
msgstr "%s: 使用了 %.3fs\n"

#: frollR.c:17
msgid ""
"x must be of type numeric or logical, or a list, data.frame or data.table of "
"such"
msgstr "x 须为数值型或逻辑型，或由这两种类型组成的列表、数据框或 data.table。"

#: frollR.c:38 frollR.c:244
msgid "n must be non 0 length"
msgstr "n 必须不是0长度"

#: frollR.c:49
msgid "n must be integer, list is accepted for adaptive TRUE"
msgstr "n 必须是整数, 或者当adaptive TRUE时也可以是列表"

#: frollR.c:56 frollR.c:236 frollR.c:239
msgid "n must be integer"
msgstr "n 必须是整数"

#: frollR.c:63
msgid "n must be positive integer values (> 0)"
msgstr "n 必须是正整数 (> 0)"

#: frollR.c:72 frollR.c:84
msgid "n must be integer vector or list of integer vectors"
msgstr "n 必须是整数向量 或者由整数向量组成的列表"

#: frollR.c:98
msgid "hasNA must be TRUE, FALSE or NA"
msgstr "hasNA 必须是 TRUE, FALSE 或者 NA"

#: frollR.c:100
msgid ""
"using hasNA FALSE and na.rm TRUE does not make sense, if you know there are "
"NA values use hasNA TRUE, otherwise leave it as default NA"
msgstr ""
"同时使用 hasNA FALSE 和 na.rm TRUE 没有意义, 如果明确有NA值, 那就用 hasNA "
"TRUE, 在其他情况可以让它保留默认值NA"

#: frollR.c:113
msgid ""
"using adaptive TRUE and align argument different than 'right' is not "
"implemented"
msgstr "同时使用 adaptive TRUE 和不是 'right' 的align参数还未能实现"

#: frollR.c:117 frollR.c:267 types.c:64
#, c-format
msgid "%s: allocating memory for results %dx%d\n"
msgstr "%s: 正在为结果 %dx%d 分配内存\n"

#: frollR.c:126
msgid ""
"adaptive rolling function can only process 'x' having equal length of "
"elements, like data.table or data.frame; If you want to call rolling "
"function on list having variable length of elements call it for each field "
"separately"
msgstr ""
"adaptive rolling 函数只能处理长度同为的 'x', 比如 data.table 或数据框; 如果想"
"在含有不同长度元素的列表上执行 rolling函数, 需要分开单独地在每一项上面执行."

#: frollR.c:128
msgid ""
"length of integer vector(s) provided as list to 'n' argument must be equal "
"to number of observations provided in 'x'"
msgstr "'n' 列表中整数向量的长度必须等于 'x' 中的观察数量"

#: frollR.c:146 frollR.c:259 gsumm.c:1198 shift.c:21
msgid "fill must be a vector of length 1"
msgstr "fill 必须是长度为1的向量"

#: frollR.c:148 frollR.c:261
msgid "fill must be numeric or logical"
msgstr "fill 必须是数值或者逻辑类型"

#: frollR.c:178
#, c-format
msgid ""
"%s: %d column(s) and %d window(s), if product > 1 then entering parallel "
"execution\n"
msgstr "%s: %d column(s) 和 %d window(s), 如果 product > 1 则进入并行执行\n"

#: frollR.c:180
#, c-format
msgid ""
"%s: %d column(s) and %d window(s), not entering parallel execution here "
"because algo='exact' will compute results in parallel\n"
msgstr ""
"%s: %d column(s) 和 %d window(s), 未能进入并行执行,因为 algo='exact' 会并行计"
"算结果\n"

#: frollR.c:207 frollR.c:299
#, c-format
msgid "%s: processing of %d column(s) and %d window(s) took %.3fs\n"
msgstr "%s: 处理 %d column(s), 和 %d window(s) 用掉 %.3fs\n"

#: frolladaptive.c:29 frolladaptive.c:218
#, c-format
msgid "%s: running for input length %<PRIu64>, hasna %d, narm %d\n"
msgstr "%s: 正在运行, 输入长度 %<PRIu64>, hasna %d, narm %d\n"

#: frolladaptive.c:35 frolladaptive.c:224
#, c-format
msgid "%s: Unable to allocate memory for cumsum"
msgstr "%s: 无法为 cumsum 分配内存"

#: frolladaptive.c:71 frolladaptive.c:260
#, c-format
msgid "%s: Unable to allocate memory for cum NA counter"
msgstr "%s: 无法为 cum NA counter 分配内存"

#: frolladaptive.c:114 frolladaptive.c:298
#, c-format
msgid "%s: running in parallel for input length %<PRIu64>, hasna %d, narm %d\n"
msgstr "%s: 正在并行运行, 输入长度 %<PRIu64>, hasna %d, narm %d\n"

#: fsort.c:107
msgid "x must be a vector of type double currently"
msgstr "x 目前必须是双精度 (double) 类型的向量"

#: fsort.c:118
#, c-format
msgid "nth=%d, nBatch=%d\n"
msgstr "nth=%d, nBatch=%d\n"

#: fsort.c:132
#, fuzzy, c-format
#| msgid "Failed to allocate %d bytes for size array: %s"
msgid "Failed to allocate %d bytes in fsort()."
msgstr "无法分配 %d 字节给 size 数组：%s"

#: fsort.c:158
#, c-format
msgid "Range = [%g,%g]\n"
msgstr "Range = [%g,%g]\n"

#: fsort.c:159
msgid "Cannot yet handle negatives."
msgstr "目前无法处理负值。"

#: fsort.c:174
#, c-format
msgid "maxBit=%d; MSBNbits=%d; shift=%d; MSBsize=%zu\n"
msgstr "maxBit=%d; MSBNbits=%d; shift=%d; MSBsize=%zu\n"

#: fsort.c:180
#, c-format
msgid ""
"counts is %dMB (%d pages per nBatch=%d, batchSize=%<PRIu64>, "
"lastBatchSize=%<PRIu64>)\n"
msgstr ""
"counts为%dMB (每个nBatch中的%d页=%d, batchSize=%<PRIu64>, "
"lastBatchSize=%<PRIu64>)\n"

#: fsort.c:250
msgid "Top 20 MSB counts: "
msgstr "前20个MSB counts："

#: fsort.c:250
#, c-format
msgid "%<PRId64> "
msgstr "%<PRId64> "

#: fsort.c:251
msgid "Reduced MSBsize from %zu to "
msgstr "MSBsize 从 %zu 减少到"

#: fsort.c:255
msgid "%zu by excluding 0 and 1 counts\n"
msgstr "%zu 通过排除0和1的counts\n"

#: fsort.c:321
#, c-format
msgid ""
"OpenMP %d did not assign threads to iterations monotonically. Please search "
"Stack Overflow for this message."
msgstr ""
"OpenMP %d 没有按照顺序分配线程进行迭代。请在 Stack Overflow 上搜索此消息。"

#: fsort.c:323
msgid "Unable to allocate working memory"
msgstr "无法分配工作内存"

#: fsort.c:333
#, c-format
msgid "%d: %.3f (%4.1f%%)\n"
msgstr "%d: %.3f (%4.1f%%)\n"

#: fwrite.c:612
#, c-format
msgid "buffMB=%d outside [1,1024]"
msgstr "buffMB=%d 在[1,1024]之外"

#: fwrite.c:619
#, c-format
msgid ""
"eol must be 1 or more bytes (usually either \\n or \\r\\n) but is length %d"
msgstr "eol必须是1或更多的字节（通常是either\\n 或 \\r\\n）但是长度为%d"

#: fwrite.c:622
msgid "Column writers: "
msgstr "数据写入： "

#: fwrite.c:624 fwrite.c:626 fwrite.c:628
#, c-format
msgid "%d "
msgstr "%d "

#: fwrite.c:627
msgid "... "
msgstr "... "

#: fwrite.c:630
#, c-format
msgid ""
"\n"
"args.doRowNames=%d args.rowNames=%p args.rowNameFun=%d doQuote=%d args."
"nrow=%<PRId64> args.ncol=%d eolLen=%d\n"
msgstr ""
"\n"
"args.doRowNames=%d args.rowNames=%p args.rowNameFun=%d doQuote=%d args."
"nrow=%<PRId64> args.ncol=%d eolLen=%d\n"

#: fwrite.c:672
#, c-format
msgid "maxLineLen=%<PRIu64>. Found in %.3fs\n"
msgstr "maxLineLen=%<PRIu64>. 在%.3fs中发现\n"

#: fwrite.c:692
#, c-format
msgid ""
"%s: '%s'. Failed to open existing file for writing. Do you have write "
"permission to it? Is this Windows and does another process such as Excel "
"have it open?"
msgstr ""
"%s: '%s'. 无法打开一斤存在的文件进行写入.你是否对该文件有写入权限？这是"
"Windows系统？是否有Excel之类的进程已经打开了该文件？"

#: fwrite.c:693
#, c-format
msgid ""
"%s: '%s'. Unable to create new file for writing (it does not exist already). "
"Do you have permission to write here, is there space on the disk and does "
"the path exist?"
msgstr ""
"%s: '%s'. 无法创建新的文件进行写入（文件不存在）你是否对此有写入权限？磁盘上"
"是否有空间以及路径是否存在？"

#: fwrite.c:700
msgid ""
"Compression in fwrite uses zlib library. Its header files were not found at "
"the time data.table was compiled. To enable fwrite compression, please "
"reinstall data.table and study the output for further guidance."
msgstr ""
"fwrite 中的压缩功能使用了 zlib 库。并未在 data.table 编译时找到它的头文件。若"
"想启用 fwrite 的压缩功能，请重新安装 data.table 并查看输出以获得进一步的指"
"导。"

#: fwrite.c:705
#, c-format
msgid "Writing bom (%s), yaml (%d characters) and column names (%s) ... "
msgstr "正在写入bom (%s), yaml (%d characters) 和 column names (%s) ..."

#: fwrite.c:719
#, c-format
msgid "Unable to allocate %zu MiB for header: %s"
msgstr "无法为header: %2$s分配%1$zu MiB"

#: fwrite.c:753 fwrite.c:817
msgid "Can't allocate gzip stream structure"
msgstr "无法分配gzip的流结构"

#: fwrite.c:761
#, c-format
msgid "Unable to allocate %zu MiB for zbuffer: %s"
msgstr "无法为zbuffer: %2$s分配%1$zu MiB"

#: fwrite.c:777
#, c-format
msgid "Compress gzip error: %d"
msgstr "解压gzip错误: %d"

#: fwrite.c:778 fwrite.c:786
#, c-format
msgid "%s: '%s'"
msgstr "%s: '%s'"

#: fwrite.c:783
#, c-format
msgid "done in %.3fs\n"
msgstr "%.3fs完成\n"

#: fwrite.c:785
msgid "No data rows present (nrow==0)\n"
msgstr "当前没有数据行(nrow==0)\n"

#: fwrite.c:803
#, c-format
msgid ""
"Writing %<PRId64> rows in %d batches of %d rows (each buffer size %dMB, "
"showProgress=%d, nth=%d)\n"
msgstr ""
"正在%3$d行的%2$d批处理中写入%1$<PRId64>行(每个缓存的大小为%4$dMB，"
"showProgress=%5$d, nth=%6$d)\n"
")\n"

#: fwrite.c:819
#, c-format
msgid "zbuffSize=%d returned from deflateBound\n"
msgstr "zbuffSize=%d 从 deflateBound 返回\n"

#: fwrite.c:828
#, c-format
msgid ""
"Unable to allocate %zu MB * %d thread buffers; '%d: %s'. Please read ?fwrite "
"for nThread, buffMB and verbose options."
msgstr ""
"无法分配 %zu MB * %d 的线程缓存；'%d: %s'。请阅读 ?fwrite 中对 nThread、"
"buffMB 和 verbose 选项的说明。"

#: fwrite.c:839
#, c-format
msgid ""
"Unable to allocate %zu MB * %d thread compressed buffers; '%d: %s'. Please "
"read ?fwrite for nThread, buffMB and verbose options."
msgstr ""
"无法分配 %zu MB * %d 的线程压缩缓存；'%d: %s'。请阅读 ?fwrite 中对 nThread、"
"buffMB 和 verbose 选项的说明。"

#: fwrite.c:853
#, fuzzy, c-format
#| msgid "Failed to allocate %d bytes for size array: %s"
msgid "Failed to allocated %d bytes for '%s'."
msgstr "无法分配 %d 字节给 size 数组：%s"

#: fwrite.c:1019
#, c-format
msgid ""
"zlib %s (zlib.h %s) deflate() returned error %d with z_stream->msg==\"%s\" "
"Z_FINISH=%d Z_BLOCK=%d. %s"
msgstr ""
"zlib %s (zlib.h %s) deflate() 返回了错误%d跟错误 z_stream->msg==\"%s\" "
"Z_FINISH=%d Z_BLOCK=%d . %s"

#: fwrite.c:1021
msgid ""
"Please include the full output above and below this message in your data."
"table bug report."
msgstr "请将此消息上方和下方的全部输出结果一起提交到data.table的bug report中"

#: fwrite.c:1022
msgid ""
"Please retry fwrite() with verbose=TRUE and include the full output with "
"your data.table bug report."
msgstr ""
"请使用verbose=TRUE重试fwrite()，并将完整的输出提交到data.table的bug report中"

#: fwriteR.c:103
#, c-format
msgid ""
"Row %<PRId64> of list column is type '%s' - not yet implemented. fwrite() "
"can write list columns containing items which are atomic vectors of type "
"logical, integer, integer64, double, complex and character."
msgstr ""
"列表页行%<PRId64>的类型是'%s' - 尚未实施. fwrite()可以写入包含逻辑类型原子向"
"量项目的列表页，整数，整数64，双精度，复数和字符"

#: fwriteR.c:176
msgid ""
"fwrite must be passed an object of type list; e.g. data.frame, data.table"
msgstr "fwrite必须传递一个类型为列表的对象；比如data.frame, data.table"

#: fwriteR.c:186
msgid "fwrite was passed an empty list of no columns. Nothing to write."
msgstr "fwrite传递了一个没有列的空列表. 没有对象可以写入"

#: fwriteR.c:240
#, c-format
msgid ""
"Column %d's length (%d) is not the same as column 1's length (%<PRId64>)"
msgstr "列%d的长度(%d)和列1的长度(%<PRId64>)不一致"

#: fwriteR.c:244
#, c-format
msgid "Column %d's type is '%s' - not yet implemented in fwrite."
msgstr "列%d的类型是'%s' - 尚未在fwrite中实施"

#: fwriteR.c:267
#, c-format
msgid ""
"input has specific integer rownames but their length (%lld) != nrow "
"(%<PRId64>)"
msgstr "输入具有特定的整数行名但是他们的长度(%lld) != nrow (%<PRId64>)"

#: fwriteR.c:282
msgid ""
"No list columns are present. Setting sep2='' otherwise quote='auto' would "
"quote fields containing sep2.\n"
msgstr ""
"当前没有列表页. 设置sep2=''否则quote='auto'会自动为所有包含sep2的字段加上引"
"号.\n"

#: fwriteR.c:286
#, c-format
msgid ""
"If quote='auto', fields will be quoted if the field contains either sep "
"('%c') or sep2 ('%c') because column %d is a list column.\n"
msgstr ""
"如果参数设定quote = 'auto'，由于%3$d列是列表页 (list-column is a data frame "
"that host lists)，所有包含sep('%1$c') 或 sep2 ('%2$c')的字段将会被自动加上引"
"号。\n"

#: fwriteR.c:290
#, c-format
msgid ""
"sep ('%c'), sep2 ('%c') and dec ('%c') must all be different. Column %d is a "
"list column."
msgstr "sep ('%c'), sep2 ('%c') 和 dec ('%c') 必须都不相同. 列 %d 是一个空列表"

#: gsumm.c:45 gsumm.c:46 gsumm.c:47
#, c-format
msgid "%s is not an integer vector"
msgstr "%s不是整数向量"

#: gsumm.c:56
msgid "irowsArg is neither an integer vector nor NULL"
msgstr "irowsArg 既不是整数向量也不是 NULL"

#: gsumm.c:58
#, c-format
msgid "length(f)=%d != length(l)=%d"
msgstr "length(f)=%d != length(l)=%d"

#: gsumm.c:66
#, c-format
msgid "o has length %d but sum(l)=%d"
msgstr "o 的长度为 %d，但 sum(l) = %d"

#: gsumm.c:98
#, c-format
msgid "gforce initial population of grp took %.3f\n"
msgstr "grp 的 gforce 初始群体数占了 %.3f\n"

#: gsumm.c:118
msgid "Failed to allocate counts or TMP when assigning g in gforce"
msgstr "在 gforce 中为 g 赋值时，未能成功为 counts 或者 TMP 分配空间"

#: gsumm.c:197
#, c-format
msgid "gforce assign high and low took %.3f\n"
msgstr "gforce 分配 high 和 low 用了 %.3f\n"

#: gsumm.c:203
#, c-format
msgid "gforce eval took %.3f\n"
msgstr "gforce eval 用了 %.3f\n"

#: gsumm.c:219
msgid "gather took ... "
msgstr "gather 用了 ..."

#: gsumm.c:337
#, c-format
msgid "gather implemented for INTSXP, REALSXP, and CPLXSXP but not '%s'"
msgstr "gather 已支持 INTSXP，REALSXP 和 CPLXSXP，但不支持 '%s'"

#: gsumm.c:339 gsumm.c:572 gsumm.c:720
#, c-format
msgid "%.3fs\n"
msgstr "%.3fs\n"

#: gsumm.c:349 gsumm.c:580 gsumm.c:731 gsumm.c:868 gsumm.c:1023 gsumm.c:1117
#, c-format
msgid "%s is not meaningful for factors."
msgstr "对因子的 %s 没有意义。"

#: gsumm.c:353
#, c-format
msgid "This gsum (narm=%s) took ... "
msgstr "gsum 占用了 (narm=%s) ..."

#: gsumm.c:354 gsumm.c:588 gsumm.c:736 gsumm.c:871 gsumm.c:923 gsumm.c:1025
#: gsumm.c:1121
#, c-format
msgid "nrow [%d] != length(x) [%d] in %s"
msgstr "%3$s 中 nrow [%1$d] != length(x) [%2$d]"

#: gsumm.c:408
msgid ""
"The sum of an integer column for a group was more than type 'integer' can "
"hold so the result has been coerced to 'numeric' automatically for "
"convenience."
msgstr ""
"某整数列分组求和的结果中，出现了超过了整型（integer）数值所允许最大值的情况，"
"故结果被自动转换为数值类型（numeric）"

#: gsumm.c:569 gsumm.c:843 gsumm.c:909 gsumm.c:1094 gsumm.c:1166
#, c-format
msgid ""
"Type '%s' is not supported by GForce %s. Either add the prefix %s or turn "
"off GForce optimization using options(datatable.optimize=1)"
msgstr ""
"GForce %s 不支持类型'%s'，要么添加前缀 %s，要么使用选项datatable.optimize=1来"
"关闭GForce优化。"

#: gsumm.c:587
#, c-format
msgid "This gmean took (narm=%s) ... "
msgstr "gsum 占用了 (narm=%s) ..."

#: gsumm.c:625 gsumm.c:681
#, c-format
msgid "Unable to allocate %d * %zu bytes for non-NA counts in gmean na.rm=TRUE"
msgstr "无法为 gmean na.rm=TRUE 的不 NA 计数（counts）分配 %d * %zu 字节空间"

#: gsumm.c:717
#, c-format
msgid ""
"Type '%s' not supported by GForce mean (gmean). Either add the prefix base::"
"mean(.) or turn off GForce optimization using options(datatable.optimize=1)"
msgstr ""
"类型 '%s' 不支持应用 GForce mean（gmin） 优化。你可以添加前缀 base::mean(.) "
"或者使用 options(datatable.optimize=1) 关闭 GForce 优化"

#: gsumm.c:729
msgid ""
"GForce min/max can only be applied to columns, not .SD or similar. To find "
"min/max of all items in a list such as .SD, either add the prefix base::min(."
"SD) or turn off GForce optimization using options(datatable.optimize=1). "
"More likely, you may be looking for 'DT[,lapply(.SD,min),by=,.SDcols=]'"
msgstr ""
"GForce 的 min/max 函数只能在应用在数据列上，无法应用于 .SD 或者其他对象上。为"
"了找到某个 list，如 .SD 里所有元素的最大值/最大值，请使用 base::min(.SD) 或者"
"通过设置 options(datatable.optimize=1) 来关闭 GForce 优化。更有可能的是，你真"
"正想要使用的命令是 'DT[,lapply(.SD,median),by=,.SDcols=]'"

#: gsumm.c:840
msgid "Type 'complex' has no well-defined min/max"
msgstr "'complex' 类型没有明确定义的最小值/最大值"

#: gsumm.c:866
msgid ""
"GForce median can only be applied to columns, not .SD or similar. To find "
"median of all items in a list such as .SD, either add the prefix stats::"
"median(.SD) or turn off GForce optimization using options(datatable."
"optimize=1). More likely, you may be looking for 'DT[,lapply(.SD,median),"
"by=,.SDcols=]'"
msgstr ""
"GForce的median函数只能在应用在数据列上，而不能在.SD或者其他对象上。为了找到某"
"个list（如.SD）里所有元素的最大值，请使用 stats::median(.SD) 或者通过设置 "
"options(datatable.optimize=1) 来关掉GForce优化。更有可能的是，你真正想要使用"
"的命令是 'DT[,lapply(.SD,median),by=,.SDcols=]'"

#: gsumm.c:983
#, c-format
msgid ""
"Type '%s' is not supported by GForce head/tail/first/last/`[`. Either add "
"the namespace prefix (e.g. utils::head(.)) or turn off GForce optimization "
"using options(datatable.optimize=1)"
msgstr ""
"类型 '%s' 不支持应用 GForce head/tail/first/last/`[` 优化。你可以添加命名空间"
"前缀（如 utils::head(.)）或者使用 options(datatable.optimize=1) 关闭 GForce "
"优化"

#: gsumm.c:1021
msgid ""
"GForce var/sd can only be applied to columns, not .SD or similar. For the "
"full covariance matrix of all items in a list such as .SD, either add the "
"prefix stats::var(.SD) (or stats::sd(.SD)) or turn off GForce optimization "
"using options(datatable.optimize=1). Alternatively, if you only need the "
"diagonal elements, 'DT[,lapply(.SD,var),by=,.SDcols=]' is the optimized way "
"to do this."
msgstr ""
"GForce var/sd 仅能应用于列，而非.SD或其他。若要求取某一列表，如.SD，所有元素"
"的全协方差矩阵，请添加前缀stats::var(.SD)（或stats::sd(.SD)），或使用"
"options(datatable.optimize=1) 关闭 GForce优化。另外，若仅需获得对角线元素，最"
"佳的方式是使用'DT[,lapply(.SD,var),by=,.SDcols=]'。"

#: gsumm.c:1115
msgid ""
"GForce prod can only be applied to columns, not .SD or similar. To multiply "
"all items in a list such as .SD, either add the prefix base::prod(.SD) or "
"turn off GForce optimization using options(datatable.optimize=1). More "
"likely, you may be looking for 'DT[,lapply(.SD,prod),by=,.SDcols=]'"
msgstr ""
"GForce prod只能应用于列，而不能应用于.SD或其他类似格式的。为了在列表如.SD相乘"
"所有的元素，要么添加前缀base::prod(.SD), 要么使用选项datatable.optimize=1来关"
"闭GForce优化。你可以试试'DT[,lapply(.SD,prod),by=,.SDcols=]'"

#: gsumm.c:1124
#, c-format
msgid "Unable to allocate %d * %zu bytes for gprod"
msgstr "无法给gprod分配%d * %zu 字节"

#: gsumm.c:1215 shift.c:34
#, c-format
msgid "Item %d of n is NA"
msgstr "n 的第 %d 项是NA"

#: gsumm.c:1272
#, c-format
msgid ""
"Type '%s' is not supported by GForce gshift. Either add the namespace prefix "
"(e.g. data.table::shift(.)) or turn off GForce optimization using "
"options(datatable.optimize=1)"
msgstr ""
"类型 '%s' 不支持应用 GForce gshift 优化。你可以添加命名空间前缀（如 data."
"table::shift(.)）或者使用 options(datatable.optimize=1) 关闭 GForce优化"

#: idatetime.c:126 vecseq.c:13
msgid "x must be an integer vector"
msgstr "x必须为一个整数向量"

#: ijoin.c:128
#, c-format
msgid "First pass on calculating lengths in lookup ... done in %8.3f seconds\n"
msgstr "查找的第一步：长度计算...在%8.3f秒内完成\n"

#: ijoin.c:141
#, c-format
msgid "Second pass on allocation in lookup ... done in %8.3f seconds\n"
msgstr "查找的第二步：分配...在%8.3f秒内完成\n"

#: ijoin.c:220
#, c-format
msgid "Final step in generating lookup ... done in %8.3f seconds\n"
msgstr "查找的最后一步：生成结果...在在%8.3f秒内完成\n"

#: ijoin.c:330
#, c-format
msgid ""
"First pass on calculating lengths in overlaps ... done in %8.3f seconds\n"
msgstr "重叠的第一步：长度计算...在%8.3f秒内完成\n"

#: ijoin.c:729
#, c-format
msgid "Final step, fetching indices in overlaps ... done in %8.3f seconds\n"
msgstr "重叠的最后一步：获取索引...在%8.3f秒内完成\n"

#: init.c:172
msgid ""
"Pointers are %zu bytes, greater than 8. We have not tested on any "
"architecture greater than 64bit yet."
msgstr "指针是%zu个字节，大于8。我们尚未在大于64位的任何体系结构上进行测试。"

#: init.c:186
msgid "... failed. Please forward this message to maintainer('data.table')."
msgstr "... 失败。请将此消息转发给 maintainer('data.table')。"

#: init.c:187
#, c-format
msgid "Checking NA_INTEGER [%d] == INT_MIN [%d] %s"
msgstr "检查NA_INTEGER [%d] == INT_MIN [%d] %s"

#: init.c:188
#, c-format
msgid "Checking NA_INTEGER [%d] == NA_LOGICAL [%d] %s"
msgstr "检查Checking NA_INTEGER [%d] == NA_LOGICAL [%d] %s"

#: init.c:189 init.c:190 init.c:192 init.c:195 init.c:196 init.c:197 init.c:198
#: init.c:199 init.c:200 init.c:201
#, c-format
msgid "Checking sizeof(%s) [%zu] is %d %s"
msgstr "检查sizeof（%s）[%zu]是否为%d %s"

#: init.c:193
#, c-format
msgid "Checking sizeof(pointer) [%zu] is 4 or 8 %s"
msgstr "检查sizeof(pointer) [%zu]是否为4 或者 8 %s"

#: init.c:194
#, c-format
msgid "Checking sizeof(SEXP) [%zu] == sizeof(pointer) [%zu] %s"
msgstr "检查sizeof(SEXP) [%zu] == sizeof(pointer) [%zu] %s"

#: init.c:204
#, c-format
msgid "Checking LENGTH(allocVector(INTSXP,2)) [%d] is 2 %s"
msgstr "检查LENGTH(allocVector(INTSXP,2)) [%d]是否为2 %s"

#: init.c:206
#, c-format
msgid "Checking TRUELENGTH(allocVector(INTSXP,2)) [%lld] is 0 %s"
msgstr "检查TRUELENGTH(allocVector(INTSXP,2)) [%lld]是否为0 %s"

#: init.c:213
#, c-format
msgid "Checking memset(&i,0,sizeof(int)); i == (int)0 %s"
msgstr "检查memset(&i,0,sizeof(int)); i == (int)0 %s"

#: init.c:216
#, c-format
msgid "Checking memset(&ui, 0, sizeof(unsigned int)); ui == (unsigned int)0 %s"
msgstr "检查memset(&ui, 0, sizeof(unsigned int)); ui == (unsigned int)0 %s"

#: init.c:219
#, c-format
msgid "Checking memset(&d, 0, sizeof(double)); d == (double)0.0 %s"
msgstr "检查memset(&d, 0, sizeof(double)); d == (double)0.0 %s"

#: init.c:222
#, c-format
msgid "Checking memset(&ld, 0, sizeof(long double)); ld == (long double)0.0 %s"
msgstr "检查memset(&ld, 0, sizeof(long double)); ld == (long double)0.0 %s"

#: init.c:225
msgid "The ascii character '/' is not just before '0'"
msgstr "ASCII 字符 '/' 后一个字符并非字符 '0'"

#: init.c:226
msgid "The C expression (uint_fast8_t)('/'-'0')<10 is true. Should be false."
msgstr "C表达式 (uint_fast8_t)('/'-'0') <10  为 true. 应该是 false."

#: init.c:227
msgid "The ascii character ':' is not just after '9'"
msgstr "ascii字符':'不是在'9'后"

#: init.c:228
msgid "The C expression (uint_fast8_t)('9'-':')<10 is true. Should be false."
msgstr "C表达式(uint_fast8_t)('9'-':') < 10  为 true. 应该是 false."

#: init.c:233
#, c-format
msgid "Conversion of NA_INT64 via double failed %<PRId64>!=%<PRId64>"
msgstr "double类型转化为NA_INT64失败，%<PRId64>!=%<PRId64>"

#: init.c:237
msgid "NA_INT64_D (negative -0.0) is not == 0.0."
msgstr "NA_INT64_D (negative -0.0) 不是 == 0.0."

#: init.c:238
msgid "NA_INT64_D (negative -0.0) is not ==-0.0."
msgstr "NA_INT64_D (negative -0.0) 不是 ==-0.0."

#: init.c:239
msgid "ISNAN(NA_INT64_D) is TRUE but should not be"
msgstr "ISNAN(NA_INT64_D) 不应该是TRUE"

#: init.c:240
msgid "isnan(NA_INT64_D) is TRUE but should not be"
msgstr "isnan(NA_INT64_D) 不应该是 TRUE"

#: init.c:274
#, c-format
msgid "PRINTNAME(install(\"integer64\")) has returned %s not %s"
msgstr "PRINTNAME(install(\"integer64\")) 返回了 %s , 而不是 %s"

#: init.c:333
msgid "verbose option must be length 1 non-NA logical or integer"
msgstr "verbose 选项必须为一个长度为 1 的非 NA 逻辑值或整数"

#: init.c:367
msgid ".Last.value in namespace is not a length 1 integer"
msgstr "命名空间中，.Last.value 不是一个长度为 1 的整型"

#: nafill.c:110
msgid ""
"'x' argument is atomic vector, in-place update is supported only for list/"
"data.table"
msgstr "参数'x'是一个原子型矢量，原位的更新只为list 或 data.table提供"

#: nafill.c:112 nafill.c:123
msgid "'x' argument must be numeric type, or list/data.table of numeric types"
msgstr "参数'x'必须是数字类型，或者是数字类型的list/data.table"

#: nafill.c:179
msgid "fill must be a vector of length 1 or a list of length of x"
msgstr "fill 必须是一个长度为 1 的向量或长度为 x 的列表"

#: nafill.c:226
#, c-format
msgid "%s: parallel processing of %d column(s) took %.3fs\n"
msgstr "%s : 并行处理 %d 列， 用时 %.3fs\n"

#: openmp-utils.c:23
#, c-format
msgid ""
"Ignoring invalid %s==\"%s\". Not an integer >= 1. Please remove any "
"characters that are not a digit [0-9]. See ?data.table::setDTthreads."
msgstr ""
"忽略无效的 %s==\"%s\". 不是一个 >= 1 的整型. 请去除任何不是[0-9]数字的字符。 "
"查看?data.table::setDTthreads."

#: openmp-utils.c:44
#, c-format
msgid ""
"Ignoring invalid R_DATATABLE_NUM_PROCS_PERCENT==%d. If used it must be an "
"integer between 2 and 100. Default is 50. See ?setDTtheads."
msgstr ""
"忽略无效的R_DATATABLE_NUM_PROCS_PERCENT==%d. 如需使用，它必须是一个2-100的整"
"型，默认值为50查看?setDTtheads."

#: openmp-utils.c:82
msgid ""
"This installation of data.table has not been compiled with OpenMP support.\n"
msgstr "安装的data.table并不是获得OpenMP支持的编译\n"

#: openmp-utils.c:84
#, c-format
msgid "  OpenMP version (_OPENMP)       %d\n"
msgstr "  OpenMP 版本 (_OPENMP)       %d\n"

#: openmp-utils.c:89
#, c-format
msgid "  omp_get_num_procs()            %d\n"
msgstr "  omp_get_num_procs()            %d\n"

#: openmp-utils.c:90
#, c-format
msgid "  R_DATATABLE_NUM_PROCS_PERCENT  %s\n"
msgstr "  R_DATATABLE_NUM_PROCS_PERCENT  %s\n"

#: openmp-utils.c:91
#, c-format
msgid "  R_DATATABLE_NUM_THREADS        %s\n"
msgstr "  R_DATATABLE_NUM_THREADS        %s\n"

#: openmp-utils.c:92
#, c-format
msgid "  R_DATATABLE_THROTTLE           %s\n"
msgstr "  R_DATATABLE_THROTTLE           %s\n"

#: openmp-utils.c:93
#, c-format
msgid "  omp_get_thread_limit()         %d\n"
msgstr "  omp_get_thread_limit()         %d\n"

#: openmp-utils.c:94
#, c-format
msgid "  omp_get_max_threads()          %d\n"
msgstr "  omp_get_max_threads()          %d\n"

#: openmp-utils.c:95
#, c-format
msgid "  OMP_THREAD_LIMIT               %s\n"
msgstr "  OMP_THREAD_LIMIT               %s\n"

#: openmp-utils.c:96
#, c-format
msgid "  OMP_NUM_THREADS                %s\n"
msgstr "  OMP_NUM_THREADS                %s\n"

#: openmp-utils.c:97
#, c-format
msgid "  RestoreAfterFork               %s\n"
msgstr "  RestoreAfterFork               %s\n"

#: openmp-utils.c:98
#, c-format
msgid ""
"  data.table is using %d threads with throttle==%d. See ?setDTthreads.\n"
msgstr "  data.table 正在使用 %d 线程, throttle==%d. 查看 ?setDTthreads.\n"

#: openmp-utils.c:106
msgid ""
"restore_after_fork= must be TRUE, FALSE, or NULL (default). "
"getDTthreads(verbose=TRUE) reports the current setting.\n"
msgstr ""
"restore_after_fork= 必须是 TRUE, FALSE, 或者 NULL (默认值). "
"getDTthreads(verbose=TRUE) 来查看当前设置.\n"

#: openmp-utils.c:112
msgid "'throttle' must be a single number, non-NA, and >=1"
msgstr "'throttle' 须为单个非 NA 且 >= 1 的数值"

#: openmp-utils.c:126
msgid ""
"threads= must be either NULL or a single number >= 0. See ?setDTthreads."
msgstr "threads= 必须是 NULL 或者一个>=0 的数值。 查看 ?setDTthreads."

#: programming.c:16
#, c-format
msgid ""
"Attempting to substitute '%s' element with object of type '%s' but it has to "
"be 'symbol' type when substituting name of the call argument, functions 'as."
"name' and 'I' can be used to work out proper substitution, see ?substitute2 "
"examples."
msgstr ""
"尝试用 '%s' 元素替换 '%s' 类型的对象，但当替换调用参数的名称时，它必须"
"是'symbol' 类型，函数 'as.name' 和 'I' 可以用来实现适当的替换，参见 ?"
"substitute2"

#: rbindlist.c:10
msgid "use.names= should be TRUE, FALSE, or not used (\"check\" by default)"
msgstr "use.names= 应该是 TRUE, FALSE, 或者默认不使用 (\"check\" )"

#: rbindlist.c:14
msgid ""
"Input to rbindlist must be a list. This list can contain data.tables, data."
"frames or plain lists."
msgstr ""
"rbindlist的输入必须是一个list. 该list可以包含data.table, data.frame 或者 普通"
"list."

#: rbindlist.c:33
#, c-format
msgid "Item %d of input is not a data.frame, data.table or list"
msgstr "输入项 %d 不是一个data.frame, data.table 或list"

#: rbindlist.c:41
#, c-format
msgid ""
"Item %d has %d columns, inconsistent with item %d which has %d columns. To "
"fill missing columns use fill=TRUE."
msgstr ""
"项%d有%d列, 与第%d项不一致， 它有%d列. 若要填补这些列, 请使用fill=TRUE."

#: rbindlist.c:44
#, c-format
msgid "Item %d has %d columns but %d column names. Invalid object."
msgstr "=====================第%d项有%d列, 却有列名 %d 个. 无效对象."

#: rbindlist.c:51
#, c-format
msgid ""
"Column %d of item %d is length %d inconsistent with column %d which is "
"length %d. Only length-1 columns are recycled."
msgstr ""
"第 %2$d 项的第 %1$d 列长度为 %3$d，与第 %4$d 列的长度 %5$d 不一致。只有长度"
"为 1 的列会被循环补齐。"

#: rbindlist.c:60
#, c-format
msgid ""
"Column %d ['%s'] of item %d is length 0. This (and %d other%s like it) has "
"been filled with NA (NULL for list columns) to make each item uniform."
msgstr ""
"第%d列['%s'](子项%d的)的长度为0，它(以及%d其他%s类似的)被填充为NA(等同与列表"
"列的NULL值)使得每一个子项统一。"

#: rbindlist.c:64
#, c-format
msgid ""
"Total rows in the list is %<PRId64> which is larger than the maximum number "
"of rows, currently %d"
msgstr "列表的总行数为 %<PRId64>，比当前行数的最大值 %d 大。"

#: rbindlist.c:65
msgid "use.names=TRUE but no item of input list has any names"
msgstr "use.names=TRUE，但是输入列表的各项均没有名字。"

#: rbindlist.c:74
#, c-format
msgid ""
"Failed to allocate upper bound of %<PRId64> unique column names "
"[sum(lapply(l,ncol))]"
msgstr "无法为 %<PRId64> 个独有列名 [sum(lapply(l,ncol))] 的上界分配内存。"

#: rbindlist.c:105
#, c-format
msgid "Failed to allocate nuniq=%d items working memory in rbindlist.c"
msgstr "错误发生于 rbindlist.c，无法分配 nuniq=%d 项工作内存。"

#: rbindlist.c:139
#, c-format
msgid "Failed to allocate ncol=%d items working memory in rbindlist.c"
msgstr "错误发生于 rbindlist.c，无法分配 ncol=%d 项工作内存。"

#: rbindlist.c:199
msgid ""
" use.names='check' (default from v1.12.2) emits this message and proceeds as "
"if use.names=FALSE for  backwards compatibility. See news item 5 in v1.12.2 "
"for options to control this message."
msgstr ""
"use.names='check'（从v1.12.2版本开始的默认值）发出该消息并为了向后兼容按照"
"use.names=FALSE执行。有关控制此消息的选项，请参见 v1.12.2 更新信息中的第 5 "
"项。"

#: rbindlist.c:213
#, c-format
msgid ""
"Column %d ['%s'] of item %d is missing in item %d. Use fill=TRUE to fill "
"with NA (NULL for list columns), or use.names=FALSE to ignore column names.%s"
msgstr ""
"第 %3$d 项的第 %1$d 列 ['%2$s'] 在第 %4$d 项中并不存在。请使用 fill=TRUE 以用"
"NA （或 NULL 若该列为列表（list））填充，或使用 use.names=FALSE 以忽略列"
"名。%5$s"

#: rbindlist.c:222
#, c-format
msgid ""
"Column %d ['%s'] of item %d appears in position %d in item %d. Set use."
"names=TRUE to match by column name, or use.names=FALSE to ignore column "
"names.%s"
msgstr ""
"第 %3$d 项的第 %1$d 列 ['%2$s'] 出现在第 %5$d 项的第 %4$d 列。设置use."
"names=TRUE 以按列名匹配，或使用 use.names=FALSE 以忽视列名。%6$s"

#: rbindlist.c:231
msgid ""
"options()$datatable.rbindlist.check is set but is not a single string. See "
"news item 5 in v1.12.2."
msgstr ""
"options()$datatable.rbindlist.check 已设置但并非单个字符串。参见 v1.12.2更新"
"信息中的第 5 项。"

#: rbindlist.c:238
#, c-format
msgid ""
"options()$datatable.rbindlist.check=='%s' which is not "
"'message'|'warning'|'error'|'none'. See news item 5 in v1.12.2."
msgstr ""
"options()$datatable.rbindlist.check=='%s' 不"
"是'message'|'warning'|'error'|'none'。参见 v1.12.2 更新信息中的第 5 项。"

#: rbindlist.c:301
#, c-format
msgid ""
"Column %d of item %d has type 'factor' but has no levels; i.e. malformed."
msgstr ""
"第%2$d 项的第 %1$d 列为因子（'factor'）类型却没有因子水平（levels），格式错"
"误。"

#: rbindlist.c:330
#, fuzzy, c-format
#| msgid ""
#| "Class attribute on column %d of item %d does not match with column %d of "
#| "item %d."
msgid ""
"Class attribute on column %d of item %d does not match with column %d of "
"item %d. You can deactivate this safety-check by using ignore.attr=TRUE"
msgstr "第 %2$d 项的第 %1$d 列的类属性与第 %4$d 项的第 %3$d列的不匹配。"

#: rbindlist.c:380
#, c-format
msgid ""
"Failed to allocate working memory for %d ordered factor levels of result "
"column %d"
msgstr "未能为结果中第 %d 列的 %d 个有序因子水平分配工作内存"

#: rbindlist.c:403
#, c-format
msgid ""
"Column %d of item %d is an ordered factor but level %d ['%s'] is missing "
"from the ordered levels from column %d of item %d. Each set of ordered "
"factor levels should be an ordered subset of the first longest. A regular "
"factor will be created for this column."
msgstr ""
"第 %2$d 项的第 %1$d 列为一有序因子（ordered factor），但第 %3$d 个水平"
"（level）['%4$s']在第 %6$d 项第 %5$d 列的有序因子水平中缺失。每组有序因子水平"
"应为其中最长有序因子水平的子集。该列将被创建为一非有序因子列。"

#: rbindlist.c:408
#, c-format
msgid ""
"Column %d of item %d is an ordered factor with '%s'<'%s' in its levels. But "
"'%s'<'%s' in the ordered levels from column %d of item %d. A regular factor "
"will be created for this column due to this ambiguity."
msgstr ""
"第 %2$d 项的第 %1$d 列中有序因子水平 '%3$s'<'%4$s'。但在第 %8$d 项第 %7$d 列"
"的有序因子水平中却 '%5$s'<'%6$s'。由于这种模糊性，该列将被创建为一非有序因子"
"列。"

#: rbindlist.c:453
#, c-format
msgid ""
"Failed to allocate working memory for %d factor levels of result column %d "
"when reading item %d of item %d"
msgstr ""
"当读取第%4$d项的第%3$d个子项时，无法为第%2$d列的%1$d个因素水平分配工作内存"

#: rbindlist.c:544 rbindlist.c:547
#, c-format
msgid "Column %d of item %d: %s"
msgstr "第 %2$d 项的第 %1$d 列: %3$s"

#: reorder.c:17
#, c-format
msgid "Item %d of list is type '%s' which isn't yet supported (SIZEOF=%zu)"
msgstr "列表的第 %d 项是 '%s' 类型，其尚不被支持 (SIZEOF=%zu)"

#: reorder.c:19
#, c-format
msgid ""
"Column %d is length %d which differs from length of column 1 (%d). Invalid "
"data.table."
msgstr "列 %d 的长度是 %d ，与列 1 (%d) 的长度不同。数据表无效。"

#: reorder.c:27
#, c-format
msgid ""
"reorder accepts vectors but this non-VECSXP is type '%s' which isn't yet "
"supported (SIZEOF=%zu)"
msgstr ""
"重新排序需要输入向量，但输入了 '%s' 类型的非向量对象，目前并不支持 "
"(SIZEOF=%zu)"

#: reorder.c:33
msgid "order must be an integer vector"
msgstr "排序必须是整数向量"

#: reorder.c:34
#, c-format
msgid "nrow(x)[%d]!=length(order)[%d]"
msgstr "nrow(x)[%d] 不等于 length(order)[%d]"

#: reorder.c:51
#, c-format
msgid ""
"Item %d of order (%d) is either NA, out of range [1,%d], or is duplicated. "
"The new order must be a strict permutation of 1:n"
msgstr ""
"排序（%2$d）的 %1$d 项为 NA，超出范围 [1,%3$d]，或与其他项重复。新的排序必须"
"为 1:n 的排列"

#: reorder.c:111
msgid "dt passed to setcolorder has no names"
msgstr "setcolorder读取到的dt并没有名字"

#: shift.c:12
msgid ""
"shift input must not be matrix or array, consider wrapping it into data."
"table() or c()"
msgstr "shift 的输入不能为矩阵或数组，考虑将其放入 data.table() 或 c() 中。"

#: shift.c:17
#, c-format
msgid ""
"type '%s' passed to shift(). Must be a vector, list, data.frame or data.table"
msgstr ""
"传递给 shift() 的 '%s' 类型，必须是向量、列表、data.frame 或 data.table"

#: snprintf.c:193 snprintf.c:196 snprintf.c:199 snprintf.c:202 snprintf.c:205
#: snprintf.c:208 snprintf.c:211 snprintf.c:214 snprintf.c:217 snprintf.c:221
#: snprintf.c:224 snprintf.c:227 snprintf.c:230 snprintf.c:233 snprintf.c:236
#: snprintf.c:239 snprintf.c:242 snprintf.c:245
#, c-format
msgid "dt_win_snprintf test %d failed: %s"
msgstr "dt_win_snprintf 测试 %d 失败了: %s"

#: snprintf.c:218
#, c-format
msgid "dt_win_snprintf test %d failed: %d"
msgstr "dt_win_snprintf 测试 %d 失败了: %d"

#: subset.c:182
#, c-format
msgid ""
"Item %d of i is %d and item %d is %d. Cannot mix positives and negatives."
msgstr "i 的第 %d 项是 %d ，第 %d 项是 %d 。正负不能混用。"

#: subset.c:192
#, c-format
msgid "Item %d of i is %d and item %d is NA. Cannot mix negatives and NA."
msgstr "i 的第 %d 项是 %d ，第 %d 项是 NA 。负值和 NA 不能混用。"

#: subset.c:239
#, c-format
msgid ""
"Item %d of i is %d but there are only %d rows. Ignoring this and %d more "
"like it out of %d."
msgstr ""
"i 的第 %d 项是 %d ，但只有 %d 行。忽略这项以及其他相似的 %d 项（共 %d 项）。"

#: subset.c:241
#, c-format
msgid ""
"Item %d of i is %d which removes that item but that has occurred before. "
"Ignoring this dup and %d other dups."
msgstr ""
"i 的第 %d 项是 %d ，它删除了这项但此操作之前发生过。忽略该重复以及其他 %d 个"
"重复。"

#: subset.c:255
#, c-format
msgid "Column %d is NULL; malformed data.table."
msgstr "%d 列为空（NULL）；data.table 格式错误。"

#: subset.c:258
#, c-format
msgid "Column %d ['%s'] is a data.frame or data.table; malformed data.table."
msgstr "%d ['%s'] 列是 data.frame 或 data.table; data.table 格式错误。"

#: subset.c:263
#, c-format
msgid ""
"Column %d ['%s'] is length %d but column 1 is length %d; malformed data."
"table."
msgstr "%d ['%s'] 长度为 %d ，而列 1 的长度为 %d ；data.table 格式错误。"

#: subset.c:295
#, c-format
msgid "Item %d of cols is %d which is outside the range [1,ncol(x)=%d]"
msgstr "'cols' 的 第 %d 项为 %d ，超出范围 [1,ncol(x)=%d]"

#: transpose.c:9
msgid "l must be a list."
msgstr "l 必须是列表"

#: transpose.c:13
msgid "ignore.empty should be logical TRUE/FALSE."
msgstr "ignore.empty 应该是逻辑类型 TRUE 或 FALSE。"

#: transpose.c:16
msgid ""
"keep.names should be either NULL, or the name of the first column of the "
"result in which to place the names of the input"
msgstr "keep.names 应该是空（NULL），或者为放置输入名称的结果中第一列的列名"

#: transpose.c:19
msgid "fill must be a length 1 vector, such as the default NA"
msgstr "fill 必须是长度为 1 的向量，例如默认值 NA"

#: transpose.c:22
msgid "list.cols should be logical TRUE/FALSE."
msgstr "list.cols 应该是逻辑类型 TRUE 或 FALSE。"

#: transpose.c:31
#, c-format
msgid "Item %d of list input is not either an atomic vector, or a list"
msgstr "列表输入的第 %d 项既不是原子(atomic)向量也不是列表"

#: uniqlist.c:151
msgid "Input argument 'x' to 'uniqlengths' must be an integer vector"
msgstr "输入到 'uniqlengths' 的参数 'x' 必须是整数向量"

#: uniqlist.c:152
msgid ""
"Input argument 'n' to 'uniqlengths' must be an integer vector of length 1"
msgstr "输入到 'uniqlengths' 的参数 'n' 必须是长度为 1 的整数向量"

#: uniqlist.c:170 uniqlist.c:267
msgid "cols must be an integer vector with length >= 1"
msgstr "cols必须是一个长度大于等于1的整数向量"

#: uniqlist.c:174
#, c-format
msgid "Item %d of cols is %d which is outside the range [1,length(l)=%d]"
msgstr "列的%d项是%d，它超出所在区间[1,length(l)=%d]"

#: uniqlist.c:177
#, c-format
msgid ""
"All elements to input list must be of same length. Element [%d] has length "
"%<PRIu64> != length of first element = %<PRIu64>."
msgstr ""
"列表的所有元素必须是同样的长度。元素[%d]的长度%<PRIu64>不等于第一个元素的长"
"度%<PRIu64>"

#: uniqlist.c:352
msgid "x is not a logical vector"
msgstr "x不是一个逻辑向量"

#: utils.c:85
#, c-format
msgid "Unsupported type '%s' passed to allNA()"
msgstr "allNA() 不支持'%s'类型"

#: utils.c:105
msgid "'x' argument must be data.table compatible"
msgstr "'x' 必须为data.table支持的类型"

#: utils.c:129
msgid ""
"argument specifying columns is type 'double' and one or more items in it are "
"not whole integers"
msgstr "指定列的参数是一个双精度类型而其中至少有一个元素不是整数"

#: utils.c:135
#, c-format
msgid ""
"argument specifying columns received non-existing column(s): cols[%d]=%d"
msgstr "指定列的参数受到了不存在的列: cols[%d]=%d"

#: utils.c:142
msgid "'x' argument data.table has no names"
msgstr "data.table的参数x并没有名字"

#: utils.c:148
#, c-format
msgid ""
"argument specifying columns received non-existing column(s): cols[%d]='%s'"
msgstr "指定列的参数受到了不存在的列: cols[%d]='%s'"

#: utils.c:152
msgid "argument specifying columns must be character or numeric"
msgstr "指定列的参数必须是字符或者是数值"

#: utils.c:155
msgid "argument specifying columns received duplicate column(s)"
msgstr "指定列的参数受到了重复的列"

#: utils.c:289
#, c-format
msgid "Found and copied %d column%s with a shared memory address\n"
msgstr "发现并拷贝了具有相同的内存地址的%d列%s\n"

#: utils.c:369
msgid "'x' is not atomic"
msgstr "x 不是一个原子向量"

#: utils.c:371
msgid "'x' must not be matrix or array"
msgstr "'x' 不能是矩阵或者数组"

#: utils.c:373
msgid "input must not be matrix or array"
msgstr "输入不能是矩阵或者数组"

#: utils.c:377
#, c-format
msgid "copy=false and input already of expected type and class %s[%s]\n"
msgstr "copy=false 并且输入已经是预期的类型和类 %s[%s]\n"

#: utils.c:384
#, c-format
msgid "Coercing %s[%s] into %s[%s]\n"
msgstr "强制转换 %s[%s] 为 %s[%s]\n"

#: utils.c:400
#, c-format
msgid "zlib header files were not found when data.table was compiled"
msgstr "zlib头文件在 data.table 编译时没有找到"

#: vecseq.c:14
msgid "len must be an integer vector"
msgstr "len必须为一个整数向量"

#: vecseq.c:15
msgid "x and len must be the same length"
msgstr "x和len必须长度一致"

#: vecseq.c:21
msgid ""
"Join results in more than 2^31 rows (internal vecseq reached physical "
"limit). Very likely misspecified join. Check for duplicate key values in i "
"each of which join to the same group in x over and over again. If that's ok, "
"try by=.EACHI to run j for each group to avoid the large allocation. "
"Otherwise, please search for this error message in the FAQ, Wiki, Stack "
"Overflow and data.table issue tracker for advice."
msgstr ""
"连接后将生成超过2^31行（已达内部的vecseq的物理极限）。这很可能是一个错误的连"
"接操作。请检查i中是否存在重复的键值（key values），导致x中对应的组反复连接。"
"若确定重复的连接可授受，可尝试 by=.EACHI 以使j中的语句仅在每个 i 中对应的组运"
"行以避免大量的内存分配。否则，请在常见问题（FAQ）、维基（Wiki）、Stack "
"Overflow 和 data.table GitHub Issue中寻求帮助。"

#: vecseq.c:25
msgid "clamp must be a double vector length 1"
msgstr "clamp 必须为一个长度为1的双精度向量"

#: vecseq.c:27
msgid "clamp must be positive"
msgstr "clamp必须为正数"

#: vecseq.c:28
#, c-format
msgid ""
"Join results in %d rows; more than %d = nrow(x)+nrow(i). Check for duplicate "
"key values in i each of which join to the same group in x over and over "
"again. If that's ok, try by=.EACHI to run j for each group to avoid the "
"large allocation. If you are sure you wish to proceed, rerun with allow."
"cartesian=TRUE. Otherwise, please search for this error message in the FAQ, "
"Wiki, Stack Overflow and data.table issue tracker for advice."
msgstr ""
"连接后生成%d行；多于%d = nrow(x)+nrow(i)。请检查i中是否存在重复的键值（key "
"values），导致x中对应的组反复连接。若确定重复的连接可授受，可尝试 by=.EACHI "
"以使j中的语句仅在每个 i 中对应的组运行以避免大量的内存分配。如果确认要继续，"
"请设置cartesian=TRUE 并重新运行。否则，请在常见问题（FAQ）、维基（Wiki）、"
"Stack Overflow 和 data.table GitHub Issue中寻求帮助。"

#: wrappers.c:11
msgid "Attribute name must be a character vector of length 1"
msgstr "属性的名字必须为一个长度为1的字符向量"

#: wrappers.c:16
msgid ""
"Internal structure doesn't seem to be a list. Can't set class to be 'data."
"table' or 'data.frame'. Use 'as.data.table()' or 'as.data.frame()' methods "
"instead."
msgstr ""
"内部结构并不非一个列表。无法将目标的类型设置为一个data.table或data.frame。请"
"使用'as.data.table()' 或 'as.data.frame()'."

#: wrappers.c:66
msgid "First argument to setlistelt must be a list()"
msgstr "setlistelt的第一个参数必须是一个列表"

#: wrappers.c:67
msgid "Second argument to setlistelt must a length 1 integer vector"
msgstr "setlistelt的第二个参数必须为一个长度为1的整数向量"

#: wrappers.c:69
#, c-format
msgid "i (%d) is outside the range of items [1,%d]"
msgstr "i (%d)超出了[1,%d]的范围"

#: wrappers.c:91
msgid "x isn't a VECSXP"
msgstr "x并非一个VECSXP"

#: wrappers.c:106
#, c-format
msgid ""
"dim.data.table expects a data.table as input (which is a list), but seems to "
"be of type %s"
msgstr ""
"dim.data.table的参数必须为一个data.table（实质为一个列表），但输入参数为%s类"
"型"
